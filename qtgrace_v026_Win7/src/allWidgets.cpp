/***************************************************************************
 *   Copyright (C) 2008-2017 by Andreas Winter                             *
 *   andreas.f.winter@web.de                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "allWidgets.h"
#include "MainWindow.h"
#include "events.h"
#include "device.h"
#include "globals.h"
#include "t1fonts.h"
#include "t1lib.h"
#include "ssdata.h"
#include "graphutils.h"
#include "events.h"
#include "parser.h"
#include "undo_module.h"
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <fcntl.h>
#include <QSvgRenderer>
#include <QProgressBar>
#include <QMessageBox>
#include "svgdrv.h"
#include "cmath.h"
#include "external_libs.h"

#ifdef _MSC_VER
#include "windows.h"
#endif

#define OPTYPE_COPY 0
#define OPTYPE_MOVE 1
#define OPTYPE_SWAP 2
#define OPTYPE_COPY_LEGEND 3

/* nonlprefs.load possible values */
#define LOAD_VALUES         0
#define LOAD_RESIDUALS      1
#define LOAD_FUNCTION       2

#define  WEIGHT_NONE    0
#define  WEIGHT_Y       1
#define  WEIGHT_Y2      2
#define  WEIGHT_DY      3
#define  WEIGHT_CUSTOM  4

struct komplex one={1.0,0.0};
struct komplex zero={0.0,0.0};
struct komplex i_one={0.0,1.0};
int new_set_no;
int * new_set_nos=NULL;
int * new_graph_nos=NULL;
#ifdef __cplusplus
extern "C" {
#endif
extern int current_origin_graph,current_origin_set;
extern int current_target_graph,current_target_set;
extern int error_count;
#ifdef __cplusplus
}
#endif
extern void clear_new_set_ids(void);
extern double rint_v2(double x);

//int replace_souce_sno,replace_souce_gno,replace_dest_sno,replace_dest_gno;
//int by_souce_sno,by_souce_gno,by_dest_sno,by_dest_gno;
extern int slider_status;
extern int lastPrintDevice;
extern bool useQtFonts;
extern bool symbol_font_is_special;
extern bool use_print_command;
extern bool activate_id_replacing;
extern CanvasAction action_flag;
extern int replace_o_set_ids,replace_n_set_ids;//number of set ids (original and new set ids - meaning right and left hand side of an equation)
//if set-id is '-1' a new set is to be allocated and the new id is writen in the id-arrays
//gnos always have to be real ids and no '-1'
extern int * replace_o_gnos;
extern int * replace_o_snos;
extern int * replace_n_gnos;
extern int * replace_n_snos;
bool ApplyError=false;
bool GlobalInhibitor=false;
bool immediateUpdate=false;
bool updateRunning=false;
extern bool printing_in_file;
extern int print_target;
int default_Print_Device=-1;//-1=last one
//extern bool use_new_print_dialog;
extern int rtiCheckTime;
extern int stdOutputFormat;//actually: last Output Format
extern char dummy[];
extern char last_formula[];
extern char saved_formula[];
extern double last_fit_falues[];
extern double saved_value;
extern int DefaultFont;
extern char default_grace_file[];

QStringList ListOfChanges;
QStringList ListOfOldStates;

extern CMap_entry *cmap_table;
extern CMap_entry cmap_init[16];
extern int dirtystate;
extern bool exchange_point_comma;
extern bool display_help_externally;
//extern long orig_page_w,orig_page_h;
extern double GeneralPageZoomFactor;
extern Device_entry *device_table;
extern MainWindow * mainWin;
extern frmCommands * FormCommands;
extern bool useQPrinter;
extern QPrinter * stdPrinter;
extern frmDeviceSetup * FormDeviceSetup;
extern frmUserDefaultGeometries * FormUserDefaultGeometries;
extern frmPlotAppearance * FormPlotAppearance;
extern frmTextProps * TextProps;
extern frmTextProps * EditTextProps;
extern frmLineProps * LineProps;
extern frmLineProps * EditLineProps;
extern frmEllipseProps * BoxProps;
extern frmEllipseProps * EditBoxProps;
extern frmEllipseProps * EllipseProps;
extern frmEllipseProps * EditEllipseProps;
extern frmEditColumnProp * EditColumn;
extern frmFontTool * FormFontTool;
extern frmIOForm * FormReadNetCDF;
extern QPixmap * GraceIcon;
extern QBitmap * patterns[MAXPATTERNS];
extern QBitmap * Qt_justifications[12];
extern frmIOForm * FormSelectOutputFile;
extern int number_of_opened_spreadsheets;
extern frmSpreadSheet ** FormSpreadSheets;
extern QPainter * GeneralPainter;
extern QImage * MainPixmap;
extern QBitmap * Qt_justifications[12];
extern QBitmap * Qt_matrixOrder[8];
extern frmIOForm * FormSelectHotLink;
extern frmConsole * FormConsole;
extern void HelpCB(char *data);
extern int get_cg(void);
extern frmSetOperations * FormSetOPS;
extern frmSetAppearance * FormSetAppearance;
extern frmGraphApp * FormGraphAppearance;
extern frmSetEditor * FormSetEditor;
extern frmAxisProp * FormAxisProperties;
extern frm_Preferences * Form_Preferences;
extern frmAgrInfos * Form_AgrInfo;
extern frmProgressWin * FormProgress;
extern frmQuestionDialog * FormQuestion;
extern frmSimpleListSelectionDialog * FormSimpleListSel;
extern frmUndoList * FormUndoList;

extern bool showhideworkaround;
extern bool use_new_icons;
extern QFont * GuiFont,*stdGuiFont;

extern int max_history;
extern int current_history;
extern QString history[MAX_HISTORY];
extern QList<QByteArray> avcod;
extern QTextCodec * FileCodec;

extern int nr_of_current_linestyles;
extern int * lenghts_of_linestyle_patterns;
extern char ** current_linestyle_patterns;
extern QIcon ** LineIcons;
extern QPixmap ** LinePixmaps;
extern QVector<qreal> ** PenDashPattern;

extern QLocale * comma_locale;//a setting where ',' is the decimal separator (we use the setting for Germany here)
extern QLocale * dot_locale;//a setting where '.' is the decimal separator (we use the setting for the USA here)

extern int current_language;
extern QTranslator translator[nr_of_translations];
extern char translator_files[nr_of_translations][64];
extern char translator_languages[nr_of_translations][64];
extern void change_language(int index);
extern void update_default_props(void);
extern char *next_token(char *s, char **token, int *quoted);
extern void exchangePointComma(char * token);
extern void convert_Grace_Strings(void);
extern void copy_LaTeX_to_Grace(void);
extern void convert_all_strings_from_encoding_to_UTF8(void);
extern void copy_Grace_to_LaTeX(void);
extern void check_external_lib_usability(void);
extern void setExportTypeDescription(const char * ext);
extern void read_bin_file_by_current_settings(bool halt_autoscale);
extern int interpolate(double *mesh, double *yint, int meshlen,double *x, double *y, int len, int method);
extern void parse_qtGrace_Additions(char * s);

static T1_TMATRIX UNITY_MATRIX = {1.0, 0.0, 0.0, 1.0};
extern QBitmap generate_Bitmap_form_Bits(unsigned char * bits,int length,int rows,int cols);
extern int max_node_nr;
extern region undo_region;
extern region undo_region2;
extern void UpdateAllWindowContents(void);

extern int maxboxes;
extern int maxlines;
extern int maxstr;
extern int maxellipses;

extern int nb_rt;
extern Input_buffer *ib_tbl;
extern int ib_tblsize;

int nr_of_set_concerned=0;
int * sets_concerned_g=NULL;
int * sets_concerned_s=NULL;

int nrOfUndoObjs;
int * undoObjs;
int fit_destination_graph,fit_destination_set;

extern int arrange_graphs(int *graphs, int ngraphs,
                          int nrows, int ncols, int order, int snake,
                          double loff, double roff, double toff, double boff,
                          double vgap, double hgap,
                          int hpack, int vpack, int move_legend, double legendX, double legendY);
extern void init_color_icons(int nr_of_cols,CMap_entry * entries,int & allocated_colors,QIcon *** ColorIcons,QPixmap *** ColorPixmaps,QString *** ColorNames);
extern void complete_LaTeX_to_Grace_Translator(QString & text);
extern void update_grace_string_from_UTF8_static(char * string);
extern void replace_set_ids_in_command(QString & commandString,int o_gno,int o_sno,int n_gno,int n_sno,int relative);//only replace-operations, no command execution
extern void copy_line_style_patterns_to_current(int n_length,int * n_style_lengths,char ** n_patterns);
extern void copy_line_style_patterns_to_target(int n_length,int * n_style_lengths,char ** n_patterns,int target);
extern void update_line_style_selectors(void);
extern void replaceSuffix(QString & fpath,QString n_suffix);
extern int guess_bin_format(QString filename,int & std_format_nr,bool & is_header);
extern int nr_of_std_bin_import_settings;
extern struct importSettings * std_bin_import_settings;
extern struct importSettings current_bin_import_settings;
extern void drawSimpleSymbol(QPainter & paint1,int x,int y,int w,int sym,char sym_c=65);

#ifdef __cplusplus
extern "C" {
#endif
extern int qtspecial_scanner(char * command, int * errors);
extern void prepare_strings_for_saving(void);
extern void resume_strings_after_load_or_save(void);
extern double rint_2(double v);
#ifdef __cplusplus
}
#endif

extern int regiontype;
extern bool wait_till_update;
extern int ReqUpdateColorSel;

int track_setno=-1;
int track_add_at;    /* where to begin inserting points in the set */
int track_move_dir;  /* direction on point movement */
extern int curformat;
extern int curdevice;
extern unsigned long page_scale;
extern double pixel_size;
extern float page_scalef;
extern int page_orientation;
extern int *psfont_status;
extern int ps_color;
extern int ps_pattern;
extern double ps_linew;
extern int ps_lines;
extern int ps_linecap;
extern int ps_linejoin;
extern int ps_grayscale;
extern int ps_level2;
extern int docdata;
extern int ps_setup_offset_x;
extern int ps_setup_offset_y;
extern int ps_setup_grayscale;
extern int ps_setup_level2;
extern int ps_setup_docdata;
extern int ps_setup_feed;
extern int ps_setup_hwres;
extern int eps_setup_grayscale;
extern int eps_setup_level2;
extern int eps_setup_tight_bb;
extern int eps_setup_docdata;
extern int tight_bb;
extern int pnm_setup_format;
extern int pnm_setup_rawbits;

extern graph * g;
extern int maxgraph;
extern char print_file[];
//extern char desired_hardcopy_filename[GR_MAXPATHLEN];
extern int png_setup_res;

extern defaults d_d;
extern defaults file_defaults;
extern defaults ini_defaults;
extern defaults tmp_defaults;

extern view d_v;
extern view file_view;
extern view ini_view;
extern view tmp_view;

int current_page_units = 0;
#if defined WITH_XMHTML || defined WITH_LIBHELP
extern int force_external_viewer;
#endif

extern void xdrawgraph(void);
extern void sort(int number,int * items);
extern const char *set_types(int it);
extern nonlparms nonl_parms[];
extern nonlopts nonl_opts;
extern char SystemsDecimalPoint;
extern char OldDecimalPoint;
extern char DecimalPointToUse;
extern QFile path_to_fftw3_lib,path_to_libharu;
extern int AAGrayLevelsOK;
extern QMap<unsigned char,ushort> key_for_greek;
extern QString Last_Dialog_Path[NR_OF_FILE_DIALOGS];
extern UserDeviceGeometry DefaultUserDeviceGeometry[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES];
extern UserDeviceGeometry DefaultSystemDeviceGeometry[NR_OF_QUICKSELECTOPTIONS];

extern struct ColumnFormat binaryImportFormat[NUMBER_OF_COLUMN_FORMATS];
extern char binaryImportFormatName[NUMBER_OF_COLUMN_FORMATS][32];
extern int ImportDestination[NUMBER_OF_IMPORT_DESTINATIONS];
extern char ImportDestinationName[NUMBER_OF_IMPORT_DESTINATIONS][32];
extern signed char ImportDestinationType[NUMBER_OF_IMPORT_DESTINATIONS];
extern void copy_bin_settings_to_current_bin_import(QString filename,bool is_header,importSettings * imp_set);
extern int openPipe(char * pname,int * fd);
extern void update_font_selectors(bool appearance);
extern int get_QtFontID_from_Grace_Name(const char * name,int whatlist);

extern void SetDecimalSeparatorToUserValue(char * str,bool remove_space=true);
extern void ReplaceDecimalSeparator(char * str,bool remove_space=true);
extern void RedisplayString(char * str);
extern void PrepareFormula(char * str);
extern void RedisplayFormula(char * str);

extern void create_one_line_pattern(int len,char * linestyle_pattern,QPixmap ** pm,QIcon ** ic,QVector<qreal> ** pendash);
extern void copy_std_line_style_patterns(int * length,int ** style_lengths,char *** patterns);
extern void update_one_line_style_selector(LineStyleSelector * selStyles,int len,QPixmap ** pix);
extern int find_import_destination(char * name,signed char type);
extern int find_import_format(char * name);

extern int n_linestyles_ini,n_linestyles_tmp,n_linestyles_file,nr_of_current_linestyles;
extern int *l_linestyle_pat_ini,*l_linestyle_pat_tmp,*l_linestyle_pat_file,*lenghts_of_linestyle_patterns;
extern char **linestyle_pat_ini,**linestyle_pat_tmp,**linestyle_pat_file,**current_linestyle_patterns;

QString regtypes[10];
int reg_order[10];

extern QSize LastSize_EllipseProps;
extern QSize LastSize_EditEllipseProps;
extern QSize LastSize_BoxProps;
extern QSize LastSize_EditBoxProps;
extern QSize LastSize_TextProps;
extern QSize LastSize_EditTextProps;
extern QSize LastSize_LineProps;
extern QSize LastSize_EditLineProps;
extern QSize LastSize_FormDrawObjects;
extern QSize LastSize_FormConsole;
extern QSize LastSize_FormEvalExpr;
extern QSize LastSize_FormSetAppearance;
extern QSize LastSize_FormGraphAppearance;
extern QSize LastSize_FormPlotAppearance;
extern QSize LastSize_FormLocatorProps;
extern QSize LastSize_FormAxisProperties;
extern QSize LastSize_FormPointExplorer;
extern QSize LastSize_FormNonlinCurveFit;
extern QSize LastSize_FormInterpolation;
extern QSize LastSize_FormSetOperations;
extern QSize LastSize_FormExplorer;
extern QSize LastSize_FormRTIManage;
extern QSize LastSize_FormCommands;
extern QSize LastSize_FormDeviceOptions;
extern QSize LastSize_FormDeviceSetup;
extern QSize LastSize_FormUserDefaultDevice;
extern QSize LastSize_FormArrangeGraphs;
extern QSize LastSize_FormOverlayGraphs;
extern QSize LastSize_FormAutoScaleGraphs;
extern QSize LastSize_FormDataSetProperties;
extern QSize LastSize_FormSetOPS;
extern QSize LastSize_FormFeatureExtraction;
extern QSize LastSize_FormHistograms;
extern QSize LastSize_FormFourier;
extern QSize LastSize_FormFourier2;
extern QSize LastSize_FormLoadAndEvaluate;
extern QSize LastSize_FormIntegration;
extern QSize LastSize_FormSeasonDiff;
extern QSize LastSize_FormDifferences;
extern QSize LastSize_FormAverages;
extern QSize LastSize_FormRegression;
extern QSize LastSize_FormCorrelation;
extern QSize LastSize_FormConvolution;
extern QSize LastSize_FormDigitalFilter;
extern QSize LastSize_FormPruneData;
extern QSize LastSize_FormSamplePoints;
extern QSize LastSize_FormGeometricTransform;
extern QSize LastSize_FormHotLinks;
extern QSize LastSize_FormRegionMaster;
extern QSize LastSize_FormRegionStatus;
extern QSize LastSize_FormReportRegion;
extern QSize LastSize_FormClearRegion;
extern QSize LastSize_FormDefineRegion;
extern QSize LastSize_FormNetCDF;
extern QSize LastSize_FormReadSets;
extern QSize LastSize_FormReadNetCDF;
extern QSize LastSize_FormWriteSets;
extern QSize LastSize_FormOpenProject;
extern QSize LastSize_FormSaveProject;
extern QSize LastSize_FormSelectHotLink;
extern QSize LastSize_FormReadParameters;
extern QSize LastSize_FormWriteParameters;
extern QSize LastSize_FormSelectOutputFile;
extern QSize LastSize_FormOpenFitPara;
extern QSize LastSize_FormSaveFitPara;
extern QSize LastSize_FormReadBinary;
extern QSize LastSize_FormWriteBinary;
extern QSize LastSize_FormCSVImport;
extern QSize LastSize_FormProgress;
extern QSize LastSize_FormQuestion;
extern QSize LastSize_FormSimpleListSel;
extern QSize LastSize_FormReportFitParameters;
extern QSize LastSize_FormGeometricEvaluation;
extern QSize LastSize_FormBinaryImportFilter;
extern QSize LastSize_FormEditBlockData;
extern QSize LastSize_FormFontTool;
extern QSize LastSize_FormAbout;
extern QSize LastSize_FormSetEditor;
extern QSize LastSize_FormUndoList;
extern QSize LastSize_DeviceActivator;
extern QSize LastSize_Form_Preferences;
extern QSize LastSize_Form_AgrInfo;
extern QSize LastSize_Form_SetupWizard;
extern QSize LastSize_Form_InitWizard;
extern QSize LastSize_FormIOForm;
extern QSize LastSize_EditColumnProp;
extern QSize LastSize_Spreadsheets;

//the following two lists are for the generation of new sets by commands lie G0.S5N
//for new sets allocated during command execution
/*extern QStringList NewGraphCommands;//commands used to create a new graph
extern QStringList NewGraphReplacement;//the replacement for the commands (i.e. the new graph id)
extern QStringList NewSetCommands;//commands used to create a new set
extern QStringList NewSetReplacement;//the replacement for the commands (i.e. the new set id)
extern QList<int> newSetIds;//new numbers of the new set-ids
extern QList<int> newGraphIds;//the graphs the new sets are allocated in
extern int current_target_graph;

//this function tries to find the "newCommand" like G0.S5N in "NewSetCommands"; if it does not exist, a new set will be generated and added to the list
QString find_new_set_command(QString newCommand)
{
QString ret;
ret.clear();
int index=NewSetCommands.indexOf(newCommand);
if (index==-1)//not present yet
{
    int d1,d2,d3,r2;
    char * dummy=new char[16+newCommand.length()];
    strcpy(dummy,newCommand.toLocal8Bit().constData());
    sscanf(dummy,"G%d.S%dN",&d1,&d2);
    d3=nextset(d1);
    r2=activateset(d1,d3);
    if (r2==RETURN_SUCCESS)
    {
    sprintf(dummy,"G%d.S%d",d1,d3);
    ret=QString(dummy);
    NewSetCommands << newCommand;
    NewSetReplacement << ret;
    }
    delete[] dummy;
}
else//found
{
ret=NewSetReplacement.at(index);
}
return ret;
}
*/

#ifdef __cplusplus
extern "C" {
#endif
extern void prepare_strings_for_saving(void);
extern void resume_strings_after_load_or_save(void);
#ifdef __cplusplus
}
#endif

/* prefs for non-linear fit */
typedef struct {
    int autoload;       /* do autoload */
    int load;           /* load to... */
    int npoints;        /* # of points to evaluate function at */
    double start;       /* start... */
    double stop;        /* stop ... */
} nonlprefs;

char buf[1024];
char command[1024];
nonlprefs nonl_prefs = {TRUE, LOAD_VALUES, 10, 0.0, 1.0};

int outputQuality=75;
bool outputGrayscale=false;
int init_null(void){return 0;}	    /* function to initialize device */
int parser_null(const char * v){(void)v;return 0;}  /* function to parse device-specific commands */
void setup_null(void){;}    /* function (GUI interface) to setup device */
void define_region(int nr, int rtype);

/*
void read_INI_header(struct importSettings & imp_set,struct importSettings & imp_schema);
void read_BINARY_Header(struct importSettings & imp_set,struct importSettings & imp_schema);
void read_ASCII_Header(struct importSettings & imp_set,struct importSettings & imp_schema);
int postprocess_bin_import_data(struct importSettings & imp_set,int & nr_of_new_sets,int ** n_gnos,int ** n_snos);
*/

static OptionItem fmt_option_items[NUM_FMT_OPTION_ITEMS] =
{
    {FORMAT_DECIMAL,        "Decimal"             },
    {FORMAT_EXPONENTIAL,    "Exponential"         },
    {FORMAT_GENERAL,        "General"             },
    {FORMAT_POWER,          "Power"               },
    {FORMAT_SCIENTIFIC,     "Scientific"          },
    {FORMAT_ENGINEERING,    "Engineering"         },
    {FORMAT_COMPUTING,      "Computing (K,M,G,...)"},
    {FORMAT_DDMMYY,         "DD-MM-YY"            },
    {FORMAT_MMDDYY,         "MM-DD-YY"            },
    {FORMAT_YYMMDD,         "YY-MM-DD"            },
    {FORMAT_MMYY,           "MM-YY"               },
    {FORMAT_MMDD,           "MM-DD"               },
    {FORMAT_MONTHDAY,       "Month-DD"            },
    {FORMAT_DAYMONTH,       "DD-Month"            },
    {FORMAT_MONTHS,         "Month (abrev.)"      },
    {FORMAT_MONTHSY,        "Month (abrev.)-YY"   },
    {FORMAT_MONTHL,         "Month"               },
    {FORMAT_DAYOFWEEKS,     "Day of week (abrev.)"},
    {FORMAT_DAYOFWEEKL,     "Day of week"         },
    {FORMAT_DAYOFYEAR,      "Day of year"         },
    {FORMAT_HMS,            "HH:MM:SS"            },
    {FORMAT_MMDDHMS,        "MM-DD HH:MM:SS"      },
    {FORMAT_MMDDYYHMS,      "MM-DD-YY HH:MM:SS"   },
    {FORMAT_YYMMDDHMS,      "YY-MM-DD HH:MM:SS"   },
    {FORMAT_DEGREESLON,     "Degrees (lon)"       },
    {FORMAT_DEGREESMMLON,   "DD MM' (lon)"        },
    {FORMAT_DEGREESMMSSLON, "DD MM' SS.s\" (lon)" },
    {FORMAT_MMSSLON,        "MM' SS.s\" (lon)"    },
    {FORMAT_DEGREESLAT,     "Degrees (lat)"       },
    {FORMAT_DEGREESMMLAT,   "DD MM' (lat)"        },
    {FORMAT_DEGREESMMSSLAT, "DD MM' SS.s\" (lat)" },
    {FORMAT_MMSSLAT,        "MM' SS.s\" (lat)"    },
    {FORMAT_YYYY,           "Year (YYYY)"         },
    {FORMAT_YYDYHMS,        "YY/YDAY/HH:MM:SS"    }
};

bool get_file_infos(QString file,bool & readable,bool & writeable,long & kB)//returns true if file exists, otherwise false
{
    if (file.isEmpty())
    {
    readable=writeable=false;
    kB=0;
    return false;
    }
QFileInfo fi(file);
readable=fi.isReadable();
writeable=fi.isWritable();
kB=fi.size()/1024;
return fi.exists();
}

void Replace_Dec_Sep_In_Single_String(QString & te)
{
    if (te.isEmpty()) return;
    if (OldDecimalPoint=='.')//.-->,
    {
    te.replace(QChar(','),QChar('|'));
    te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
    }
    else//,-->.
    {
    te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
    te.replace(QChar('|'),QChar(','));
    }
}

QString get_text_in_quotations(QString text)//returns only the text inside the quotation marks (the last(!) 2 quotations)
{
QString ret("");
QString tmp;
int st_op=text.lastIndexOf("\"");
if (st_op!=-1)
{
tmp=text.left(st_op);
st_op=tmp.lastIndexOf("\"");
    if (st_op!=-1)
    {
    ret=tmp.right(tmp.length()-st_op-1);
    }
}
return ret;
}

QString get_text_in_first_quotations(QString text)//returns only the text inside the quotation marks (the first(!) 2 quotations)
{
QString ret("");
QString tmp;
int st_op=text.indexOf("\"");
if (st_op!=-1)
{
tmp=text.right(text.length()-st_op-1);
st_op=tmp.indexOf("\"");
    if (st_op!=-1)
    {
    ret=tmp.left(st_op);
    }
}
return ret;
}

QList<int> get_text_positions(QString text,QString subtext)//get all starting positions of subtext in text
{
QList<int> pos;
int delta=subtext.length();
int cur_pos=0,next_pos=0;
pos.clear();
while ((next_pos=text.indexOf(subtext,cur_pos))>=0)
{
pos << next_pos;
cur_pos=next_pos+delta;
}
return pos;
}

void get_text_from_to(char * original,int f,int t,char * text)//gets the text between positions f and t (without f and t)
{
int len=t-f;
strncpy(text,original+f+1,len);
text[len-1]='\0';
}

QList<int> comments_from_set,comments_from_graph;
QStringList orig_saved_comment;
QStringList std_saved_comment;
QStringList orig_saved_legend;
QStringList std_saved_legend;

void save_set_comments(QList<int> & gnos,QList<int> & snos)
{
comments_from_set.clear();
comments_from_graph.clear();
orig_saved_comment.clear();
std_saved_comment.clear();
orig_saved_legend.clear();
std_saved_legend.clear();
    for (int i=0;i<gnos.length();i++)
    {
        if (is_set_active(gnos.at(i),snos.at(i)))
        {
        orig_saved_legend << g[gnos.at(i)].p[snos.at(i)].orig_lstr;
        std_saved_legend << g[gnos.at(i)].p[snos.at(i)].lstr;
        orig_saved_comment << g[gnos.at(i)].p[snos.at(i)].orig_comments;
        std_saved_comment << g[gnos.at(i)].p[snos.at(i)].comments;
        comments_from_set << snos.at(i);
        comments_from_graph << gnos.at(i);
        }
    }
}

void restore_set_comments(void)
{
    for (int i=0;i<comments_from_set.length();i++)
    {
        if (is_set_active(comments_from_graph.at(i),comments_from_set.at(i)))
        {
        strcpy(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].orig_comments,orig_saved_comment.at(i).toLocal8Bit().constData());
        strcpy(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].comments,std_saved_comment.at(i).toLocal8Bit().constData());
        strcpy(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].orig_lstr,orig_saved_legend.at(i).toLocal8Bit().constData());
        strcpy(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].lstr,std_saved_legend.at(i).toLocal8Bit().constData());
        //g[comments_from_graph.at(i)].p[comments_from_set.at(i)].orig_lstr=copy_string(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].orig_lstr,orig_saved_comment.at(i).toLocal8Bit().constData());
        //g[comments_from_graph.at(i)].p[comments_from_set.at(i)].lstr=copy_string(g[comments_from_graph.at(i)].p[comments_from_set.at(i)].lstr,std_saved_comment.at(i).toLocal8Bit().constData());
        }
    }
}

void initSettings(struct importSettings & iset,bool remove_old_settings=true)
{
    iset.valid_status=-1;//uninitialized
    if (remove_old_settings && iset.title)
        delete[] iset.title;
    if (remove_old_settings && iset.subtitle)
        delete[] iset.subtitle;
    if (remove_old_settings && iset.x_title)
        delete[] iset.x_title;
    if (remove_old_settings && iset.y_title)
        delete[] iset.y_title;
    if (remove_old_settings && iset.first_data)
        delete[] iset.first_data;
    if (remove_old_settings && iset.channel_format)
        delete[] iset.channel_format;
    if (remove_old_settings && iset.channel_size)
        delete[] iset.channel_size;
    if (remove_old_settings && iset.channel_target)
        delete[] iset.channel_target;
    if (remove_old_settings && iset.format_suggestion)
        delete[] iset.format_suggestion;
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
        if (remove_old_settings && iset.set_title[i])
            delete[] iset.set_title[i];
    }
    iset.format_suggestion=NULL;
    iset.channel_format=NULL;
    iset.channel_size=NULL;
    iset.channel_target=NULL;
    iset.first_data=NULL;
    iset.title=NULL;
    iset.subtitle=NULL;
    iset.x_title=NULL;
    iset.y_title=NULL;
    iset.first_data=NULL;
    iset.read_to_eof=false;
    iset.multiple_header_files=true;
    iset.string_end_char=0;
    iset.setorder=0;
    iset.x0set=iset.deltaxset=iset.fset=false;
    iset.contains_trigger=iset.keep_trigger=false;
    /*iset.title=new char[2];
    iset.subtitle=new char[2];*/
    iset.x0=-1.0;//negative values suggest, that this value has not been set
    iset.deltax=-1.0;
    iset.f=-1.0;
    iset.bytesize=-1;
    iset.bitsize=-1;
    iset.whole_size=-1;
    iset.single_size=-1;
    iset.channels=-1;
    iset.points=-1;
        for (int i=0;i<7;i++)//one for every column in a set
        iset.factors[i]=1.0;
        for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
        {
        iset.channel_factors[i]=1.0;//one for every set to be imported
        iset.channel_offsets[i]=0.0;
        iset.set_title[i]=NULL;
        }
    /*iset.x_title=new char[2];
    iset.y_title=new char[2];
    iset.title[0]=iset.subtitle[0]=iset.y_title[0]=iset.x_title[0]='\0';*/
    iset.target_gno=0;
    iset.set_type=0;

    iset.setorder=0;//tabDataInfo->selOrder->currentIndex();
    char dummy[8];
    strncpy(dummy,"\n",2);//tabHeader->lenEndChar->text().toLocal8Bit(),2);
    iset.string_end_char=dummy[0];
    iset.read_to_eof=false;//tabDataInfo->chkReadToEOF->isChecked();

    iset.nr_of_import_tokens=0;
    if (remove_old_settings && iset.token_target) delete[] iset.token_target;
    iset.token_target=NULL;
    iset.HeaderSuffix=QString("ini");
    iset.DataSuffix=QString("dat");

    iset.nr_of_header_values=0;
    if (remove_old_settings && iset.header_value_format) delete[] iset.header_value_format;
    if (remove_old_settings && iset.header_value_size) delete[] iset.header_value_size;
    if (remove_old_settings && iset.header_value_import) delete[] iset.header_value_import;
    iset.header_value_format=NULL;
    iset.header_value_size=NULL;
    iset.header_value_import=NULL;
}

void copy_import_settings(struct importSettings * from, struct importSettings * to)
{
to->name=from->name;
to->filename=from->filename;
to->valid_status=from->valid_status;
to->header_present=from->header_present;
to->header_format=from->header_format;
to->string_end_char=from->string_end_char;
    if (from->title!=NULL)
    {
        if (to->title!=NULL) delete[] to->title;
        to->title=new char[strlen(from->title)+2];
        strcpy(to->title,from->title);
    }
    else to->title=NULL;
    if (from->subtitle!=NULL)
    {
        if (to->subtitle!=NULL) delete[] to->subtitle;
        to->subtitle=new char[strlen(from->subtitle)+2];
        strcpy(to->subtitle,from->subtitle);
    }
    else to->subtitle=NULL;
to->x0set=from->x0set;
to->deltaxset=from->deltaxset;
to->fset=from->fset;
to->read_to_eof=from->read_to_eof;
to->contains_trigger=from->contains_trigger;
to->keep_trigger=from->keep_trigger;
to->multiple_header_files=from->multiple_header_files;
to->x0=from->x0;
to->deltax=from->deltax;
to->f=from->f;
to->triggervalue=from->triggervalue;
to->trigger_type=from->trigger_type;
to->bytesize=from->bytesize;
to->bitsize=from->bitsize;
to->whole_size=from->whole_size;
to->single_size=from->single_size;
to->channels=from->channels;
to->points=from->points;
to->autoscale=from->autoscale;
to->setorder=from->setorder;
    for (int i=0;i<7;i++)
    {
    to->factors[i]=from->factors[i];
    to->offsets[i]=from->offsets[i];
    }
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
    to->channel_factors[i]=from->channel_factors[i];
    to->channel_offsets[i]=from->channel_offsets[i];
    }
    if (from->x_title!=NULL)
    {
        if (to->x_title!=NULL) delete[] to->x_title;
        to->x_title=new char[strlen(from->x_title)+2];
        strcpy(to->x_title,from->x_title);
    }
    else to->x_title=NULL;
    if (from->y_title!=NULL)
    {
        if (to->y_title!=NULL) delete[] to->y_title;
        to->y_title=new char[strlen(from->y_title)+2];
        strcpy(to->y_title,from->y_title);
    }
    else to->y_title=NULL;
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
        if (from->set_title[i]!=NULL)
        {
        if (to->set_title[i]!=NULL) delete[] to->set_title[i];
        to->set_title[i]=new char[strlen(from->set_title[i])+2];
        strcpy(to->set_title[i],from->set_title[i]);
        }
        else
        {
        to->set_title[i]=NULL;
        }
    }
to->target_gno=from->target_gno;
to->set_type=from->set_type;
    if (from->first_data!=NULL)
    {
        if (to->first_data!=NULL) delete[] to->first_data;
        /*to->first_data=new double*[...];
            for (int i=0;i<...;i++)
            {
            to->first_data[i]=new double[...];
            memcpy(to->first_data[i],from->first_data[i],sizeof(double)*...);
            }
        */
    }
    else to->first_data=NULL;
    if (to->channels>0)
    {
        if (from->channel_format!=NULL)
        {
            if (to->channel_format!=NULL) delete[] to->channel_format;
            to->channel_format=new int[to->channels];
            memcpy(to->channel_format,from->channel_format,sizeof(int)*to->channels);
        }
        else to->channel_format=NULL;
        if (from->channel_size!=NULL)
        {
            if (to->channel_size!=NULL) delete[] to->channel_size;
            to->channel_size=new int[to->channels];
            memcpy(to->channel_size,from->channel_size,sizeof(int)*to->channels);
        }
        else to->channel_size=NULL;
        if (from->channel_target!=NULL)
        {
            if (to->channel_target!=NULL) delete[] to->channel_target;
            to->channel_target=new int[to->channels];
            memcpy(to->channel_target,from->channel_target,sizeof(int)*to->channels);
        }
        else to->channel_format=NULL;
    }
to->nr_of_header_values=from->nr_of_header_values;
if (to->nr_of_header_values>0)
{
if (from->header_value_format!=NULL)
{
    if (to->header_value_format!=NULL) delete[] to->header_value_format;
    to->header_value_format=new int[to->nr_of_header_values];
    memcpy(to->header_value_format,from->header_value_format,sizeof(int)*to->nr_of_header_values);
}
else
to->header_value_format=NULL;
if (from->header_value_size!=NULL)
{
    if (to->header_value_size!=NULL) delete[] to->header_value_size;
    to->header_value_size=new int[to->nr_of_header_values];
    memcpy(to->header_value_size,from->header_value_size,sizeof(int)*to->nr_of_header_values);
}
else
to->header_value_size=NULL;
if (from->header_value_import!=NULL)
{
    if (to->header_value_import!=NULL) delete[] to->header_value_import;
    to->header_value_import=new int[to->nr_of_header_values];
    memcpy(to->header_value_import,from->header_value_import,sizeof(int)*to->nr_of_header_values);
}
else
to->header_value_import=NULL;
}
else
{
to->header_value_format=NULL;
to->header_value_size=NULL;
to->header_value_import=NULL;
}
to->nr_of_import_tokens=from->nr_of_import_tokens;
/*cout << "nr_of_import_tokens=" << endl;
cout << "from:" << from->nr_of_import_tokens << endl;
cout << "to:  " << to->nr_of_import_tokens << endl;*/
        if (to->token_target!=NULL) delete[] to->token_target;
        to->token_target=new int[to->nr_of_import_tokens+2];
    for (int i=0;i<to->nr_of_import_tokens;i++)
    to->token_target[i]=from->token_target[i];
to->vals=from->vals;
to->keys=from->keys;
to->DataSuffix=from->DataSuffix;
to->HeaderSuffix=from->HeaderSuffix;
to->import_dest=from->import_dest;
to->import_channel_dest=from->import_channel_dest;
}

QString get_filename_with_extension(int device)//generates a filename from the name of the document, using the extension of the given device
{
    Device_entry dev = get_device_props(device);
    /*char printfile[GR_MAXPATHLEN];
strcpy(printfile,get_docname());*/

    QFileInfo fi(QString::fromLocal8Bit(get_docname()));

/*cout << endl;
//cout << "DocName = #" << printfile << "# abs=" << fi.isAbsolute() << endl;
cout << "AbsFilePath = #" << fi.absoluteFilePath().toLocal8Bit().constData() << "#" << endl;
cout << "FileNameOnly = #" << fi.fileName().toLocal8Bit().constData() << "#" << endl;
cout << "PathOnly = #" << fi.absolutePath().toLocal8Bit().constData() << "#" << endl;
cout << "ComplBaseName = #" << fi.completeBaseName().toLocal8Bit().constData() << "#" << endl;*/

    QString fwe;
    fwe=fi.absolutePath() + QDir::separator() + fi.completeBaseName() + QString(".") + QString(dev.fext);
    //cout << "newFileName = #" << fwe.toLocal8Bit().constData() << "#" << endl;

    fwe.replace(QString("/\\"),QDir::separator());
    return fwe;

    /*if (!fi.isAbsolute())
{
strcpy(printfile,fi.absoluteFilePath().toLocal8Bit().constData());
}

char * bufptr = strrchr(printfile, '.');//search for the last '.'
if (!strcmp(get_docname(),"Untitled") || bufptr==NULL)//no real document-name, just the default OR document-name does not contain a '.'
{
strcat(printfile,".");//add a '.' at the end
}
else if (bufptr)
{
*(bufptr + 1) = '\0';//remove extensions
}
strcat(printfile,dev.fext);//add the appropriate extension
return QString(printfile);*/
}

int nr_of_true_changes(QStringList & list)
{
    static int nr,len;
    static QString ref("with");
    nr=list.length();
    len=nr;
    for (int i=0;i<nr;i++)
    {
        if (list.at(i).indexOf(ref)==0)//contains with at the beginning
            len--;
    }
    return len;
}

void prependAllSetID(QString * text,int sno,int gno)
{
static const char * tosuppl[7]={"X","Y","Y0","Y1","Y2","Y3","Y4"};
    QString str(text->toLocal8Bit());
    QString l1;
    QString toinsert;
    QRegExp regex1("G\\d+.S\\d+.$");//what we search for as a regular expression
    QRegExp regex2("S\\d+.$");//I changed the expression to '+' from '*' because we want to find at least one digit (0 digits is not allowed)
    QRegExp regex3("G\\d+N{1}.S\\d+N{1}$");//generate a new graph and / or a set
    QRegExp regex4("G\\d+N{1}$");//generate just a new graph
    QRegExp regex5("S\\d+N{1}$");//generate just a new set
    //QString find_new_set_command(QString newCommand)

    char dummy1[128];
    char dummy2[128];
    sprintf(dummy1,"G%d.",gno);
    sprintf(dummy2,"G%d.S%d.",gno,sno);
    int pos=0,t_pos=0,inlen;//last=0
    int p1,pos_1,pos_2;
    char c1;
    pos_1=text->indexOf("\"");
    if (pos_1<0)//no quotation marks found
    {
    pos_2=pos_1;
    }
    else
    {
    pos_2=text->indexOf("\"",pos_1+1);
        if (pos_2<0)
        {
        errmsg(QObject::tr("Opening quotation mark without closing mark found in command.").toLocal8Bit().constData());
        errmsg(text->toLocal8Bit().constData());
        return;
        }
    }
//qDebug() << "prepend: start=" << str;
    for (int i=0;i<2;i++)//find replacements for all sus (Y0...Y4 are automatically replaced during the search for Y)
    {
        pos=0;
        while (pos<str.length())
        {
            //last=pos;//last is position at beginning of search
            //we search here for X,Y,Y0,Y1,...,Y4
            pos=str.indexOf(tosuppl[i],pos);//pos is now the position of the string we search for
//qDebug() << "str=" << str << " pos=" << pos;
            //we have to ingore values with '_' before or after, because these are commands not set-ids
            if (pos==0 && str.length()>1)
            {
                if (str.at(pos+1).toLatin1()=='_')//we have a '_' after it
                {
                pos++;
                continue;
                }
            }
            else if (pos>0 && pos<=str.length()-1)
            {
                if (pos<str.length()-1 && (str.at(pos+1).toLatin1()=='_' || str.at(pos-1).toLatin1()=='_'))//not the last character
                {
                    pos++;
                    continue;
                }
                else if (isalpha(str.at(pos-1).toLatin1()) || str.at(pos-1).toLatin1()=='.')//there is a character in front of it --> ignore it
                {
                    pos++;
                    continue;
                }
                else if (pos<=str.length()-2 && isalpha(str.at(pos+1).toLatin1()))//there is a character after it --> ignore it
                {
                    pos++;
                    continue;
                }
                else if (pos==str.length()-1)//the last character
                {
                    if (str.at(pos-1).toLatin1()=='_')
                    {
                    pos++;
                    continue;
                    }
                }
            }
            //cout << "pos=" << pos << endl;
            //ok, we ignored the ones with '_' in front or after
            if (pos==-1)//nothing found
            {
                //last=
                pos=str.length()+1;//nothing found-->set current position to the end of the string
            }
            else
            {
                l1=str.left(pos);
                p1=regex1.indexIn(l1);
                if (p1==-1)//expression not found --> id not complete
                {
                    p1=regex2.indexIn(l1);
                    t_pos=regex3.indexIn(l1);
                    //cout << "p1=" << p1 << " t_pos=" << t_pos << endl;
                        if (p1==t_pos && p1!=-1)//S0N and S0 are at the same position --> ignore this!
                        {
                        pos++;
                        continue;
                        }
                    if (p1==-1)//no usual set-id --> search for S$ and S_
                    {
                    p1=l1.indexOf("S$");
                        if (p1==-1)
                        p1=l1.indexOf("S_");
                    }
                    if (p1==-1)//expression not found --> no id at all
                    {
                    //cout << "expression found at#" << str.mid(pos).toLatin1().constData() << "#" << endl;
                        c1='\0';
                        if (pos>0)//there are characters in front
                        {
                            c1=str.at(pos-1).toLatin1();
                            if (!isalpha(c1))
                                c1='\0';
                        }
                        if (pos_1>=0)//there are some quotation-marks present
                        {
                            if (pos>=pos_1 && pos<=pos_2)//found index inside quotations
                            {
                            c1='\0';
                            }
                        }
                        if (c1=='\0')//do the replacement
                        {
                            toinsert=QString(dummy2);
                            inlen=toinsert.length();
                            //cout << "full: str=" << str.toAscii().constData() << " pos=" << pos << endl;
                            str.insert(pos,toinsert);
                            pos+=inlen+1;
                        }
                        else//no replacement --> go on searching, starting with the next character
                        {
                            pos++;
                        }
                    }
                    else//expression found --> id only simplified --> 'G0.' missing
                    {
                        toinsert=QString(dummy1);
                        inlen=toinsert.length();
                        //cout << "only G: str=" << str.toAscii().constData() << " pos=" << pos << endl;
                        str.insert(p1,toinsert);
                        pos+=inlen+1;
                    }
                }
                else//complete id found --> do nothing
                {
                    pos=pos+1;//search on from last position
                }
            }//end of if
        }//end while
    }//end of go throught all substrings
    *text=str;
}

void prependSetID_single(QString & text,int leftset,int leftgraph,int rightset,int rightgraph)
{
QString leftpart,rightpart,result;
int len,eq_pos;
    len=text.length();
    eq_pos=text.indexOf(QString("="));
        if (eq_pos==-1)
        {
        result=text;
        prependAllSetID(&result,leftset,leftgraph);
        }
        else
        {
        leftpart=text.left(eq_pos);
        rightpart=text.right(len-eq_pos-1);
//qDebug() << "Left:  G[" << leftgraph << "].S[" << leftset << "]";
//qDebug() << "Right: G[" << rightgraph << "].S[" << rightset << "]";
//qDebug() << "#" << leftpart.toLocal8Bit().constData() << "#=#" << rightpart.toLocal8Bit().constData() << "#";
        prependAllSetID(&leftpart,leftset,leftgraph);
        prependAllSetID(&rightpart,rightset,rightgraph);
        result=leftpart+QString("=")+rightpart;
        }
text=result;
}

void prependAllIDs_V2(QString & text,int n_gno,int n_sno)//just complete incomplete IDs (no replacement and no resolvement of S0N or S# or similar)
{
int f_ret,f_pos,g_no,s_no,st_len;
char control1,control2,col;
int st_pos=0;
QString newText,tmpText;
newText.clear();
qDebug() << "Make IDs complete: before=" << text;
while ( (f_ret=searchTextForFirstID(text,st_pos,f_pos,g_no,s_no,control1,control2,col,st_len))!=ID_NONE )//as long as we find something
{
qDebug() << "st_pos=" << st_pos << " type=" << f_ret << " found ID at " << f_pos << ": " << text.mid(f_pos,st_len) << " st_len=" << st_len;
tmpText=createCompleteID(f_ret,n_gno,n_sno,g_no,s_no,control1,control2,col);
qDebug() << "   new ID=" << tmpText;
qDebug() << "   text before=" << text.mid(st_pos,f_pos-st_pos);
newText+=text.mid(st_pos,f_pos-st_pos);
/*
if (st_pos==0 && f_pos>0)
newText+=text.mid(st_pos,f_pos);//add text before found ID
*/
    if (tmpText.isEmpty())//no replacement needed
    {
    newText+=text.mid(f_pos,st_len);
    qDebug() << "   adding=" << text.mid(f_pos,st_len);
    }
    else
    {
    newText+=tmpText;//insert new (complete ID)
    qDebug() << "   adding=" << tmpText;
    }
st_pos=f_pos+st_len;
qDebug() << "newText so far=" << newText;
qDebug() << "searching in  =" << text.mid(st_pos);
}
newText+=text.mid(st_pos,f_pos);//add text at the end
qDebug() << "   finally adding=" << text.mid(st_pos,f_pos);
text=newText;
qDebug() << "Make IDs complete: after=" << text;
}

void replaceAllIDs_V2(QString & text,int n_gno,int n_sno)//assumes all IDs are complete --> just replace the IDs and resolve things like S0N and S#
{
int f_ret,f_pos,g_no,s_no,st_len;
char control1,control2,col;
int st_pos=0;
QString newText,tmpText;
newText.clear();
qDebug() << "Replace IDs: before=" << text;
while ( (f_ret=searchTextForFirstID(text,st_pos,f_pos,g_no,s_no,control1,control2,col,st_len))!=ID_NONE )//as long as we find something
{
qDebug() << "st_pos=" << st_pos << " type=" << f_ret << " found ID at " << f_pos << ": " << text.mid(f_pos,st_len) << " st_len=" << st_len;
    tmpText=createReplacementID(f_ret,n_gno,n_sno,g_no,s_no,control1,control2,col);
qDebug() << "   new ID=" << tmpText;
qDebug() << "   text before=" << text.mid(st_pos,f_pos-st_pos);
    newText+=text.mid(st_pos,f_pos-st_pos);
        if (tmpText.isEmpty())//no replacement needed
        {
        newText+=text.mid(f_pos,st_len);
qDebug() << "   adding=" << text.mid(f_pos,st_len);
        }
        else
        {
        newText+=tmpText;//insert new (complete ID)
qDebug() << "   adding=" << tmpText;
        }
    st_pos=f_pos+st_len;
qDebug() << "newText so far=" << newText;
qDebug() << "searching in  =" << text.mid(st_pos);
    }
    newText+=text.mid(st_pos,f_pos);//add text at the end
qDebug() << "   finally adding=" << text.mid(st_pos,f_pos);
text=newText;
qDebug() << "Replace IDs: after=" << text;
}

void prependSetID(char * text,int leftset,int leftgraph,int rightset,int rightgraph);

void prependSetID(QString & text,int leftset,int leftgraph,int rightset,int rightgraph)
{
char * original=new char[text.length()*2+8];
strcpy(original,text.toLocal8Bit().constData());
prependSetID(original,leftset,leftgraph,rightset,rightgraph);
text=QString::fromLocal8Bit(original);
}

void prependSetID(char * text,int leftset,int leftgraph,int rightset,int rightgraph)
{
    //QString leftpart,rightpart
    QString result,final_result;
    QString before,inside,after;
    QList<int> quot_list;
    //int len,eq_pos
    int nr_of_quotations;
//left id is target id
//right id is source id
    QString original(text);
    original=original.toUpper();
    QStringList list1=original.split(";");
//qDebug() << "PrependSetID=" << original;
//qDebug() << "Left=G" << leftgraph << ".S" << leftset << " Right=G" << rightgraph << ".S" << rightset;
    final_result.clear();
    for (int i=0;i<list1.length();i++)//work through every commant in the list separately
    {
    original=list1.at(i);
    //first find quotations
    quot_list=get_text_positions(original,QString("\""));
    nr_of_quotations=quot_list.length();
//qDebug() << "nr_of_quotations=" << nr_of_quotations;
        if (nr_of_quotations % 2)//number of quotation marks does not match!
        {
        errmsg(QObject::tr("Opening quotation mark without closing mark found in command.").toLocal8Bit().constData());
        errmsg(original.toLocal8Bit().constData());
        //no replacing if quotations do not match! (because we cannot be sure what to do)
        result=original;
        }
        else if (nr_of_quotations==0)//no quotation-marks
        {
        result=original;
        prependSetID_single(result,leftset,leftgraph,rightset,rightgraph);
        }
        else//there are quotation-marks
        {
        before=original.left(quot_list.at(0));
        prependSetID_single(before,leftset,leftgraph,rightset,rightgraph);

        inside=get_text_in_first_quotations(original);
        prependSetID_single(inside,leftset,leftgraph,rightset,rightgraph);

        after=original.right(original.length()-1-quot_list.at(1));
        quot_list=get_text_positions(after,QString("\""));
            if (quot_list.length()==0)
            {
            prependSetID_single(after,leftset,leftgraph,rightset,rightgraph);
            }
            else
            {
            prependSetID(after,leftset,leftgraph,rightset,rightgraph);
            }
        result=before+QString("\"")+inside+QString("\"")+after;
        }
//qDebug() << i << ": " << list1.at(i);
/*
        result=original;
prependSetID_single(result,leftset,leftgraph,rightset,rightgraph);

    len=original.length();
    eq_pos=original.indexOf(QString("="));
        if (eq_pos==-1)
        {
        result=original;
        prependAllSetID(&result,leftset,leftgraph);
        }
        else
        {
        leftpart=original.left(eq_pos);
        rightpart=original.right(len-eq_pos-1);
//qDebug() << "Left:  G[" << leftgraph << "].S[" << leftset << "]";
//qDebug() << "Right: G[" << rightgraph << "].S[" << rightset << "]";
//qDebug() << "#" << leftpart.toLocal8Bit().constData() << "#=#" << rightpart.toLocal8Bit().constData() << "#";
        prependAllSetID(&leftpart,leftset,leftgraph);
        prependAllSetID(&rightpart,rightset,rightgraph);
        result=leftpart+QString("=")+rightpart;
        }
*/
    final_result+=result;
    if (i<list1.length()-1) final_result+=QString(";");
    }
    strcpy(text,final_result.toLocal8Bit().constData());
//qDebug() << "result=#" << text << "#";
}

/*int find_pos_of_inclomplete_setid(char * text,char * tofind,char ** pos)
{
int ret=-1;//-1=nothing found; 0=fully incomplete; 1=only GraphId missing; 2=found and complete
int pos2;
*pos=strstr(text,tofind);
while (pos!=NULL)//go on until suitable command found
{//we found a position
ret=*pos-text;
if (ret>0)
{
pos2=ret-1;
    if (text[pos2]!='.')//-->incomplete, ret is position of incomplete description
    {
    ret=0;
    break;
    }
    else//may be incomplete, but '.' before
    {
    pos2--;
    while (pos2>0 && isdigit(text[pos2])) pos2--;//try to find description before Column-Description
        if (pos2<=1)//incomplete
        {
        *pos=text;
        ret=0;
        }
        else//we presume: we have found a 'S'
        {
        pos2--;
        if (text[pos2]!='.')
        {
        ret=1;
        *pos=text+pos2+1;
        break;
        }
        else
        {
        ret=2;
        break;
        }
        }
    }
}
else
{
ret=0;
break;//found at first character --> not complete!
}
*pos=strstr(*pos+1,tofind);
}
return ret;
}

void include_str(char * text,char * pos,char * toinclude)
{
if (!pos) return;
char * dummy=new char[strlen(text)+strlen(toinclude)+2];
//cout << "include#" << text << "#" << pos << "#" << toinclude << "#" << endl;
strcpy(dummy,text);
strcpy(dummy+(pos-text),toinclude);
strcpy(dummy+(pos-text+strlen(toinclude)),pos);
strcpy(text,dummy);
delete[] dummy;
}

void correct_formula(char * text,int gno,int sno)//takes a formula and supplements all x,y,y1,y2,y3,y4 by 'G0.S0.' or something apropriate according to gno and sno
{
static char suppl[32], suppl2[16], temp[1024];
static char * tosuppl[7]={"X","Y","Y0","Y1","Y2","Y3","Y4"};
static char * n_pos,*n_pos2;
static unsigned int len;
static int pos,retu;
sprintf(suppl,"G%d.S%d.",gno,sno);
sprintf(suppl2,"G%d.",gno);
len=strlen(text);
char result[128+strlen(text)];
    for (unsigned int i=0;i<len;i++)
    result[i]=toupper(text[i]);
for (int i=0;i<7;i++)
{//supplement the entries
n_pos2=result;
while (n_pos2)
{
retu=find_pos_of_inclomplete_setid(n_pos2,tosuppl[i],&n_pos);
cout << "text=#" << result << "#retu=" << retu << endl;
    switch (retu)
    {
    case 0://0=fully incomplete
    include_str(result,n_pos,suppl);
        if (n_pos)
        n_pos+=strlen(suppl);
    break;
    case 1://1=only GraphId missing
    include_str(result,n_pos,suppl2);
        if (n_pos)
        n_pos+=strlen(suppl2);
    break;
    default:
    n_pos=NULL;
    break;
    }
cout << "text=#" << result << "#retu=" << retu << endl;
if (n_pos) cout << "npos=#" << n_pos << "#" << endl;
        if (n_pos)
        n_pos2=n_pos+1;
        else
        n_pos2=NULL;
}//end while loop

}//end supplements
strcpy(text,result);
}*/

int should_open_grace_file_dialog(void)
{//returns TRUE if the Grace-file-dialog is to be used and FALSE if the dialog of the operating system should be used directly
static int ret=TRUE;
Qt::KeyboardModifiers modif=Qt::NoModifier;
        #if QT_VERSION >= 0x050000
        modif=QApplication::queryKeyboardModifiers();
        #endif
    if (general_behavior==0)//Grace-behavior
    {
    ret=TRUE;
    }
    else//QtGrace-behavior
    {
    ret=FALSE;
    }
    if (modif & Qt::ControlModifier)
    {
    ret=!ret;
    }
return ret;
}

/* 'Legacy' FFT code from Grace v5.99*/
int bit_swap_v6(int i, int nu);
int ilog2_v6(int n);
int fft_v6(double *jr, double *ji, int n, int nu, int iflag);

int fourier_v6(double *jr, double *ji, int n, int iflag)
{
    int i2= ilog2(n);

    /*if ((i2 = ilog2(n)) > 0) {*/
    return fft_v6(jr, ji, n, i2, iflag);
    /*} else {
        return dft(jr, ji, n, iflag);
    }*/
}

/*
   real_data ... ptr. to real part of data to be transformed
   imag_data ... ptr. to imag  "   "   "   "  "      "
   inv ..... Switch to flag normal or inverse transform
   n_pts ... Number of real data points
   nu ...... logarithm in base 2 of n_pts e.g. nu = 5 if n_pts = 32.
*/
int fft_v6(double *real_data, double *imag_data, int n_pts, int nu, int inv)
{
    int n2, i, ib, mm, k;
    int sgn, tstep;
    double tr, ti, arg; /* intermediate values in calcs. */
    double c, s;        /* cosine & sine components of Fourier trans. */
    static double *sintab = NULL;
    static int last_n = 0;

    n2 = n_pts / 2;

    if (n_pts != last_n) { /* allocate new sin table */
        arg = 2*M_PI/n_pts;
        last_n = 0;
        sintab = (double *)xrealloc(sintab, n_pts*sizeof(double));
        if (sintab == NULL) {
            return RETURN_FAILURE;
        }
        for (i = 0; i < n_pts; i++) {
            sintab[i] = sin(arg*i);
        }
        last_n = n_pts;
    }

    /*
 * sign change for inverse transform
 */
    sgn = inv ? 1:-1;

    /* do bit reversal of data in advance */
    for (k = 0; k != n_pts; k++) {
        ib = bit_swap_v6(k, nu);
        if (ib > k) {
            fswap((real_data + k), (real_data + ib));
            fswap((imag_data + k), (imag_data + ib));
        }
    }
    /*
* Calculate the componets of the Fourier series of the function
*/
    tstep = n2;
    for (mm = 1; mm < n_pts; mm *= 2) {
        int sinidx = 0, cosidx = n_pts/4;
        for (k=0; k<mm; k++) {
            c = sintab[cosidx];
            s = sgn*sintab[sinidx];
            sinidx += tstep;
            cosidx += tstep;
            if (sinidx >= n_pts) {
                sinidx -= n_pts;
            }
            if (cosidx >= n_pts) {
                cosidx -= n_pts;
            }
            for (i = k; i < n_pts; i += mm*2) {
                double re1, re2, im1, im2;
                re1 = real_data[i];
                im1 = imag_data[i];
                re2 = real_data[i + mm];
                im2 = imag_data[i + mm];

                tr = re2*c + im2*s;
                ti = im2*c - re2*s;
                real_data[i+mm] = re1 - tr;
                imag_data[i+mm] = im1 - ti;
                real_data[i] = re1 + tr;
                imag_data[i] = im1 + ti;
            }
        }
        tstep /= 2;
    }

    return RETURN_SUCCESS;
}

/*
* Bit swapping routine in which the bit pattern of the integer i is reordered.
* See Brigham's book for details
*/
int bit_swap_v6(int i, int nu)
{
    int ib, i1, i2;

    ib = 0;

    for (i1 = 0; i1 != nu; i1++) {
        i2 = i/2;
        ib = ib*2 + i - 2*i2;
        i = i2;
    }
    return (ib);
}

/*
 * log base 2
 */
int ilog2_v6(int n)
{
    int i = 0;
    int n1 = n;

    while (n1 >>= 1) {
        i++;
    }
    if (1 << i != n) {
        return -1;
    } else {
        return i;
    }
}

int monospaced_v6(double *array, int len, double *space)
{
    int i;
    double eps;
    if (len < 2) {
        //errmsg(tr("Monospacing of an array of length < 2 is meaningless").toLocal8Bit().constData());
        return FALSE;
    }
    *space = array[1] - array[0];
    eps = fabs((array[len - 1] - array[0]))*1.0e-6; /* FIXME */
    for (i = 2; i < len; i++) {
        if (fabs(array[i] - array[i - 1] - *space) > eps) {
            return FALSE;
        }
    }
    return TRUE;
}

void remove_whitespaces(char * tar,char * ch)
{
    int len=strlen(ch),pos=0;
    int text_counter=0;
    tar[0]='\0';
    for (int i=0;i<len;i++)
    {
        if (ch[i]=='\"')
        {
        text_counter=!text_counter;
        continue;
        }
            if (!isspace(ch[i]) && text_counter==0)
            tar[pos++]=ch[i];
    }
    tar[pos++]='\0';
}

void remove_beginning_whitespaces(QString & text)
{
QString text2;
text2.clear();
bool first_non_space=false;
    for (int i=0;i<text.length();i++)
    {
        if (!text.at(i).isSpace() || first_non_space)
        {
        text2+=text.at(i);
        first_non_space=true;
        }
    }
text=text2;
}

void remove_beginning_whitespaces2(char * text)
{
QString str(text);
remove_beginning_whitespaces(str);
strcpy(text,str.toLatin1().constData());
}

void strToUpper(char * tar,const char * ch)
{
    int len=strlen(ch);
    for (int i=0;i<len;i++)
        tar[i]=toupper(ch[i]);
    tar[len]=ch[len];
}

int find_dev_nr(const char * dev_name)/*my own number of devices*/
{
    int nr=-1;
    if (!strcmp(dev_name,"JPEG"))
    {
        nr=DEVICE_JPEG;
    }
    else if (!strcmp(dev_name,"BMP"))
    {
        nr=DEVICE_BMP;
    }
    else if (!strcmp(dev_name,"EPS"))
    {
        nr=DEVICE_EPS;
    }
    else if ((!strcmp(dev_name,"PS")) || (!strcmp(dev_name,"PostScript")))
    {
        nr=DEVICE_PS;
    }
    else if (!strcmp(dev_name,"PNM"))
    {
        nr=DEVICE_PNM;
    }
    else if (!strcmp(dev_name,"PNG"))
    {
        nr=DEVICE_PNG;
    }
    else if ((!strcmp(dev_name,"X11")) || (!strcmp(dev_name,"SCREEN")))
    {
        nr=DEVICE_SCREEN;
    }
    else if (!strcmp(dev_name,"PDF"))
    {
        nr=DEVICE_PDF;
    }
    else if (!strcmp(dev_name,"TIFF"))
    {
        nr=DEVICE_TIFF;
    }
    return nr;
}

/*with QT the JPG and PNG and BMP file types are easily accessible, but only very few options are available*/
static Device_entry dev_jpg = {DEVICE_FILE,
                               "JPEG",
                               init_null,
                               parser_null,
                               setup_null,
                               "jpg",
                               FALSE,
                               TRUE,
                               {DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT, 72.0},
                               NULL,
                               1,
                               "JPG"
                              };

static Device_entry dev_png = {DEVICE_FILE,
                               "PNG",
                               init_null,
                               parser_null,
                               setup_null,
                               "png",
                               FALSE,
                               TRUE,
                               {DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT, 72.0},
                               NULL,
                               1,
                               ""
                              };

static Device_entry dev_bmp = {DEVICE_FILE,
                               "BMP",
                               init_null,
                               parser_null,
                               setup_null,
                               "bmp",
                               FALSE,
                               TRUE,
                               {DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT, 72.0},
                               NULL,
                               1,
                               ""
                              };

static Device_entry dev_tif = {DEVICE_FILE,
                               "TIFF",
                               init_null,
                               parser_null,
                               setup_null,
                               "tif",
                               FALSE,
                               TRUE,
                               {DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT, 72.0},
                               NULL,
                               1,
                               "TIF"
                              };

#define cg get_cg()

extern int register_high_png_drv(void);

void register_qt_devices(void)
{
    register_device(dev_jpg);
    register_device(dev_png);
    //register_high_png_drv();
    register_device(dev_bmp);
    register_device(dev_tif);//added in v0.26
}

frmEditColumnProp::frmEditColumnProp(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Edit set properties"));
    setWindowIcon(QIcon(*GraceIcon));
    int number;
    QString entr[8];
    number=6;
    entr[0]=QString("X");
    entr[1]=QString("Y");
    entr[2]=QString("Y1");
    entr[3]=QString("Y2");
    entr[4]=QString("Y3");
    entr[5]=QString("Y4");
    selColumn=new StdSelector(this,tr("Column:"),number,entr);
    number=4;
    entr[0]=tr("Decimal");
    entr[1]=tr("General");
    entr[2]=tr("Exponential");
    entr[3]=tr("Date/time");
    selFormat=new StdSelector(this,tr("Format:"),number,entr);
    selFormat->setCurrentIndex(SpreadsheetColumnFormat);
    selPrecision=new stdIntSelector(this,tr("Precision:"),0,20);
    selPrecision->setValue(SpreadsheetColumnPrecision);
    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(selColumn);
    layout->addWidget(selFormat);
    layout->addWidget(selPrecision);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_EditColumnProp);
    setModal(TRUE);
}

frmEditColumnProp::~frmEditColumnProp()
{
    LastSize_EditColumnProp=this->size();
}

void frmEditColumnProp::doApply(void)
{
    ApplyError=false;
    int col=selColumn->currentIndex();
    int format=selFormat->currentValue();
    int prec=selPrecision->value();
    col_format[col]=format;
    col_precision[col]=prec;
    emit(newColumnFormat(col,format,prec));
}

void frmEditColumnProp::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmEditColumnProp::doClose(void)
{
    hide();
}

void frmEditColumnProp::initToColumn(int i)
{
    selColumn->setCurrentIndex(i);
    selFormat->setCurrentIndex(col_format[i]);
    selPrecision->setValue(col_precision[i]);
}

frmSpreadSheet::frmSpreadSheet(QWidget * parent,int g_no,int s_no):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Spreadsheet dataset editor"));
    setWindowIcon(QIcon(*GraceIcon));
    CreateActions();
    gno=g_no;
    sno=s_no;
    parentList=NULL;
    EditColumn=new frmEditColumnProp(this);
    EditColumn->hide();
    connect(EditColumn,SIGNAL(newColumnFormat(int,int,int)),SLOT(setColumnFormat(int,int,int)));

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu(tr("&File"));
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actClose);
    mnuEdit=new QMenu(tr("&Edit"));
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actAddRow);
    mnuEdit->addAction(actDelSelRow);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actColumnFormat);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actSelectEven);
    mnuEdit->addAction(actSelectOdd);
    mnuEdit->addAction(actCopySelected);
    mnuHelp=new QMenu(tr("&Help"));
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnDataSetEditor);
    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    for (int i=0;i<6;i++)
    {
        col_format[i]=SpreadsheetColumnFormat;
        col_precision[i]=SpreadsheetColumnPrecision;
        EditColumn->col_format[i]=col_format[i];
        EditColumn->col_precision[i]=col_precision[i];
    }

    sprintf(dummy," G%d.S%d",gno,sno);
    fraDataset=new QGroupBox(tr("Dataset") + QString(dummy),this);

    int number=NUMBER_OF_SETTYPES;
    QString entr[NUMBER_OF_SETTYPES];
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(fraDataset,tr("Type:"),number,entr);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(changeDataSet(int)));

    ledComment=new stdLineEdit(fraDataset,tr("Comment:"),true);
    ledComment->lenText->setText(tr("Editor"));
    layout0=new QVBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(selType);
    layout0->addWidget(ledComment);
    fraDataset->setLayout(layout0);

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    //table=new SetTableView(gno,sno,col_format,col_precision,this);

    model=new SetTableModel(gno,sno,col_format,col_precision,this);
    table=new QTableView(this);
    table->setModel(model);
    table->setSelectionBehavior(QAbstractItemView::SelectRows);
    connect(model,SIGNAL(item_entry_changed(int,int,bool)),this,SLOT(itemChanged(int,int,bool)));
    connect(table->horizontalHeader(),SIGNAL(sectionClicked(int)),SLOT(HHeaderClicked(int)));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(0);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(fraDataset);
    layout->addWidget(table);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_Spreadsheets);
    update_entries();
}

frmSpreadSheet::~frmSpreadSheet()
{
    LastSize_Spreadsheets=this->size();
}

void frmSpreadSheet::HHeaderClicked(int i)
{
    EditColumn->initToColumn(i);
    EditColumn->show();
    EditColumn->raise();
}

void frmSpreadSheet::init(int g_no,int s_no)
{
    gno=g_no;
    sno=s_no;
    disconnect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)));
    selType->setCurrentIndex(dataset_type(g_no,s_no));
    for (int i=0;i<6;i++)
    {
        col_format[i]=SpreadsheetColumnFormat;
        col_precision[i]=SpreadsheetColumnPrecision;
        EditColumn->col_format[i]=col_format[i];
        EditColumn->col_precision[i]=col_precision[i];
    }
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(changeDataSet(int)));
    model->init(gno,sno);
    update_entries();
}

void frmSpreadSheet::CreateActions(void)
{
    actClose= new QAction(tr("&Close"), this);
    actClose->setShortcut(tr("Esc"));
    connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
    actAddRow= new QAction(tr("&Add row"), this);
    connect(actAddRow, SIGNAL(triggered()), this, SLOT(doAddRow()));
    actDelSelRow= new QAction(tr("&Delete selected rows"), this);
    connect(actDelSelRow, SIGNAL(triggered()), this, SLOT(doDelSelRow()));
    actColumnFormat= new QAction(tr("&Column format..."), this);
    connect(actColumnFormat, SIGNAL(triggered()), this, SLOT(doColumnFormat()));
    actHelpOnContext= new QAction(tr("On conte&xt"), this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext, SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnDataSetEditor= new QAction(tr("On datas&et editor"), this);
    connect(actHelpOnDataSetEditor, SIGNAL(triggered()), this, SLOT(doHelpOnDataSetEditor()));
    actSelectEven= new QAction(tr("Select even rows"), this);
    connect(actSelectEven, SIGNAL(triggered()), this, SLOT(doSelectEven()));
    actSelectOdd= new QAction(tr("Select odd rows"), this);
    connect(actSelectOdd, SIGNAL(triggered()), this, SLOT(doSelectOdd()));
    actCopySelected= new QAction(tr("Copy selection to clipboard"), this);
    connect(actCopySelected, SIGNAL(triggered()), this, SLOT(doCopySelected()));
}

void frmSpreadSheet::changeDataSet(int type)//to change the set-type
{
    if (!is_valid_setno(gno,sno)) return;//do nothing if set is invalid
    int nsets=1;
    int * gnos=new int[2],*snos=new int[2];
    SaveSetStatesPrevious(nsets,gnos,snos,UNDO_COMPLETE);
    set_dataset_type(this->gno, this->sno, type);
    gnos[0]=this->gno;
    snos[0]=this->sno;
    SetsModified(nsets,gnos,snos,UNDO_COMPLETE);
    sprintf(dummy," (G%d.S%d)",gnos[0],snos[0]);
    addAditionalDescriptionToLastNode(-1,QObject::tr("Data set type changed") + QString(dummy),QString());
    mainWin->mainArea->completeRedraw();
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet::itemChanged(int row,int col,bool really_new_value)
{
    (void)row;
    (void)col;
    /*static char setPrec[8];
    static char out_format[16];
    static char dummy[128];
    static int graphnr,setnr;*/
    if (!really_new_value || !is_valid_setno(gno,sno)) return;
    /*char dummy2[128];
    QModelIndex modind=model->index(row,col);*/
    gno=model->graphnr;
    sno=model->setnr;
    /*strcpy(dummy2,model->data(modind).toString().toLocal8Bit());
    sprintf(setPrec,"%%.%d",col_precision[col]);
    switch (col_format[col])
    {
    case 0://decimal
    sprintf(out_format,"%sf",setPrec);
    break;
    case 1://general
    sprintf(out_format,"%sg",setPrec);
    break;
    case 2://exponential
    sprintf(out_format,"%se",setPrec);
    break;
    case 3://Date/time
    sprintf(out_format,"%%t");///NOT CORRECT
    break;
    }
    sprintf(dummy,out_format,g[graphnr].p[setnr].data.ex[col][row]);*/
    ledComment->SetMemoryToText(g[gno].p[sno].comments,g[gno].p[sno].orig_comments);
    set_dirtystate();
    mainWin->mainArea->completeRedraw();
    if (parentList!=NULL)
    {
    parentList->set_new_selection(1,&sno);
    emit(parentList->new_selection());
    }
}

void frmSpreadSheet::setColumnFormat(int col,int format,int precision)
{
    col_format[col]=format;
    col_precision[col]=precision;
    update_entries();
}

void frmSpreadSheet::doApply(void)
{
    ApplyError=true;
    if (!is_valid_setno(gno,sno)) return;//do nothing if set is invalid
    ApplyError=false;
    ledComment->SetMemoryToText(g[model->graphnr].p[model->setnr].comments,g[model->graphnr].p[model->setnr].orig_comments);
    mainWin->mainArea->completeRedraw();
}

void frmSpreadSheet::doAccept(void)
{
    ApplyError=false;
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSpreadSheet::doClose(void)
{
    hide();
}

void frmSpreadSheet::doAddRow(void)
{
    int * sels;
    int nsels,gno,sno;
    int * gnos=new int[3];
    int * snos=new int[3];
    getSelection(&nsels,&sels);
    if (nsels<=0)
    {
        errmsg(tr("No rows selected!").toLocal8Bit().constData());
        delete[] gnos;
        delete[] snos;
        return;
    }
    gnos[0]=gno=model->graphnr;
    snos[0]=sno=model->setnr;
    SaveSetStatesPrevious(1,gnos,snos,UNDO_DATA);
    //for (int ii=0;ii<nsels;ii++)
    for (int ii=nsels-1;ii>=0;ii--)
    {
        int i=sels[ii], k;
        int nrows=getsetlength(gno,sno), ncols=dataset_cols(gno,sno);
        char **s;
        Datapoint dpoint;
        if (i > nrows || i < 0)
        {
            errmsg(tr("Selected row out of range!").toLocal8Bit().constData());
            delete[] gnos;
            delete[] snos;
            return;
        }
        zero_datapoint(&dpoint);
        if (i < nrows)
        {
            for (k = 0; k < ncols; k++)
            {
                dpoint.ex[k] = g[gno].p[sno].data.ex[k][i];//*(getcol(gno, sno, k) + i);
            }
            if ((s = get_set_strings(gno, sno)) != NULL)
            {
                dpoint.s = s[i];
            }
            add_point_at(gno, sno, i+1, &dpoint);
            //model->insertRow(i+1);
        }
        else
        {
            add_point_at(gno, sno, i, &dpoint);
            //model->insertRow(i);
        }
        update_set_lists(gno);
        /// init(gno, setno);
        update_entries();
        mainWin->mainArea->completeRedraw();
    }
    SetsModified(1,gnos,snos,UNDO_DATA);
    delete[] sels;
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet::doDelSelRow(void)
{
    int i;
    int * srows;
    int nsrows;
    int * gnos=new int[3];
    int * snos=new int[3];
    char buf[64];
    getSelection(&nsrows,&srows);
    gnos[0]=model->graphnr;
    snos[0]=model->setnr;
    if (srows[0] < 0 || srows[0] >= getsetlength(gnos[0],snos[0]) || nsrows<=0)
    {
        errmsg(tr("Nothing to delete").toLocal8Bit().constData());
        delete[] gnos;
        delete[] snos;
        return;
    }
    sprintf(buf, "Delete %d selected row(s)?", nsrows);
    if (yesno(buf, NULL, NULL, NULL))
    {
        SaveSetStatesPrevious(1,gnos,snos,UNDO_DATA);
        for (i = nsrows - 1; i >= 0; i--)
        {
            if (srows[i]>=0 && srows[i]<getsetlength(gnos[0],snos[0]))
            {
                del_point(gnos[0],snos[0],srows[i]);
                //model->removeRow(srows[i]);
            }
        }
        update_set_lists(gnos[0]);
        /// init(gno, setno);
        update_entries();
        mainWin->mainArea->completeRedraw();
        SetsModified(1,gnos,snos,UNDO_DATA);
    }
    delete[] srows;
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet::doColumnFormat(void)
{
    EditColumn->initToColumn(0);
    EditColumn->show();
    EditColumn->raise();
}

void frmSpreadSheet::doHelpOnContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmSpreadSheet::doHelpOnDataSetEditor(void)
{
    HelpCB("doc/UsersGuide.html#SSEditor");
}

void frmSpreadSheet::getSelection(int * n_of_sel,int ** sel)
{
    QModelIndexList list=table->selectionModel()->selectedIndexes();
    *sel=new int[list.length()];
    int counter=0;
    int current;
    bool found;
    for (int i=0;i<list.length();i++)
    {
        current=list.at(i).row();
        found=false;
        for (int j=0;j<counter;j++)
        {
            if ((*sel)[j]==current)
            {
                found=true;
                break;
            }
        }
        if (found==false)
            (*sel)[counter++]=current;
    }
    *n_of_sel=counter;
    sort(*n_of_sel,*sel);
}

void frmSpreadSheet::setSelection(int n_of_sel,int * sel)
{
    QModelIndex index;
    table->clearSelection();
    for (int i=0;i<n_of_sel;i++)
    {
        index=table->model()->index(sel[i],0);
        table->selectionModel()->select(index,QItemSelectionModel::Select|QItemSelectionModel::Rows);
    }
}

void frmSpreadSheet::update_entries(void)
{
    static int rows,cols;
    static char dum[64];
    if (is_valid_setno(gno,sno))
    {
        gno=model->graphnr;
        sno=model->setnr;
        rows=getsetlength(gno,sno);
        cols=dataset_cols(gno,sno);
        sprintf(dum," G%d.S%d ( %d x %d )",gno,sno,rows,cols);
        fraDataset->setTitle(tr("Dataset") + QString(dum));
        ledComment->SetTextToMemory(g[gno].p[sno].comments,g[gno].p[sno].orig_comments);
        model->major_changes();
    }
    else//no valid data present
    {
        sprintf(dum," Invalid set!");
        fraDataset->setTitle(tr("Dataset") + QString(dum));
    }
}

void frmSpreadSheet::doSelectEven(void)
{
    int nr,*sel=new int[2];
    getSelection(&nr,&sel);
    int rows=getsetlength(gno,sno);
    int * n_sel=new int[nr+rows/2+2];
    memcpy(n_sel,sel,nr*sizeof(int));
    for (int i=0;i<rows;i+=2)
    {
        n_sel[nr++]=i;
    }
    setSelection(nr,n_sel);
    delete[] sel;
    delete[] n_sel;
}

void frmSpreadSheet::doSelectOdd(void)
{
    int nr,*sel=new int[2];
    getSelection(&nr,&sel);
    int rows=getsetlength(gno,sno);
    int * n_sel=new int[nr+rows/2+2];
    memcpy(n_sel,sel,nr*sizeof(int));
    for (int i=1;i<rows;i+=2)
    {
        n_sel[nr++]=i;
    }
    setSelection(nr,n_sel);
    delete[] sel;
    delete[] n_sel;
}

void frmSpreadSheet::doCopySelected(void)
{
    int nr,*sel=new int[2];
    getSelection(&nr,&sel);

    QString text;
    text.clear();
    //int rows=getsetlength(gno,sno);
    int col=dataset_cols(gno,sno);

    for (int k=0;k<nr;k++)
    {
        for (int j=0;j<col;j++)
        {
            //sprintf(dummy,"%.8g\t",g[gno].p[sno].data.ex[j][sel[k]]);
            //text+=QString(dummy);
            sprintf(dummy,sformat,g[gno].p[sno].data.ex[j][sel[k]]);
            text+=QString(dummy)+QString("\t");
        }
        text+=QString("\n");
    }

    if (SystemsDecimalPoint!='.') text.replace(QString("."),QString(SystemsDecimalPoint));
    QApplication::clipboard()->setText(text);

    delete[] sel;
}

void frmSpreadSheet::keyPressEvent(QKeyEvent * e)
{
    if (e->key()==Qt::Key_Delete)
    doDelSelRow();
}

frmSpreadSheet2::frmSpreadSheet2(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Spreadsheet dataset editor"));
    setWindowIcon(QIcon(*GraceIcon));
    number_of_rows=50;//visible rows --> this should be enough...
    start_row=0;
    number_of_columns=3;
    allocated_rows=number_of_rows;
    visible_row_count=5;
    length=0;
    initiated=false;
    g_no=s_no=-1;
    table=new QTableWidget(number_of_rows,number_of_columns,this);
    table->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    table->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    Items=new QTableWidgetItem**[number_of_rows];
    for (int i=0;i<number_of_rows;i++)
    {
        Items[i]=new QTableWidgetItem*[number_of_columns];
        for (int j=0;j<number_of_columns;j++)
        {
            Items[i][j]=new QTableWidgetItem(QString(dummy),QTableWidgetItem::Type);
            table->setItem(i, j, Items[i][j]);
        }
    }
    QStringList vertHeads;
    QStringList horHeads;
    horHeads << "X" << "Y";
    for (int i=0;i<number_of_rows;i++)
    {
        sprintf(dummy,"%7d",i);
        vertHeads << QString(dummy);
    }
    table->setHorizontalHeaderLabels(horHeads);
    table->setVerticalHeaderLabels(vertHeads);
    scroll=new QScrollBar(Qt::Vertical,this);
    scroll->setSingleStep(1);
    fraDataset=new QGroupBox(tr("Dataset"),this);
    selType=new stdSetTypeSelector(this);
    ledComment=new stdLineEdit(fraDataset,tr("Comment:"),true);
    ledComment->lenText->setText(tr("Editor"));
    layout0=new QVBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(selType);
    layout0->addWidget(ledComment);
    fraDataset->setLayout(layout0);

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    //layout->addWidget(menuBar);
    layout->addWidget(fraDataset,0,0,1,2);
    layout->addWidget(table,1,0,1,1);
    layout->addWidget(scroll,1,1,1,1);
    layout->addWidget(buttonGroup,2,0,1,1);
    setLayout(layout);
    connect(scroll,SIGNAL(valueChanged(int)),SLOT(position_changed(int)));
    /*QTableWidget * table;
QTableWidgetItem *** Items;//the Entries!
stdSetTypeSelector *selType
QGroupBox * fraDataset;
stdLineEdit * ledComment;
QVBoxLayout * layout0;
stdButtonGroup * buttonGroup;
QVBoxLayout * layout;*/
}

void frmSpreadSheet2::resizeEvent(QResizeEvent * event)
{
    static double guessed_number_of_rows;
//static int real_height;
    event->accept();
    //QSize si=event->size();
//real_height=Items[0][0]->tableWidget()->height();
    //cout << si.width() << " x " << si.height() << "/" << real_height << " one line=" << table->horizontalHeader()->height() << "/";
    //cout << "rowHeight()=" << table->rowHeight(1) << " WidgetHeight=" << table->height() << " scrollHeight=" << table->horizontalScrollBar()->height();
    guessed_number_of_rows=(table->height()-table->horizontalHeader()->height()-table->horizontalScrollBar()->height()-STD_SPACING)*1.0/(table->rowHeight(1));
    //cout << " --> " << guessed_number_of_rows << endl;
    visible_row_count=int(guessed_number_of_rows+1);
    scroll->setRange(0,length-visible_row_count+6);
    scroll->setPageStep(visible_row_count);
    //cout << length << " / " << int(guessed_number_of_rows) << endl;
}

void frmSpreadSheet2::position_changed(int pos)
{
    start_row=pos;
    update_entries();
}

void frmSpreadSheet2::init(int gno,int sno)
{
    g_no=gno;
    s_no=sno;
    start_row=0;
    length=getsetlength(gno,sno);
    initiated=true;
    update_entries();
}

void frmSpreadSheet2::update_entries(void)
{
    static char dummy[128];
    static QStringList vertHeads;
    static QString emptyEntry("");
    if (initiated==false) return;
    vertHeads.clear();
    for (int i=start_row;i<start_row+visible_row_count;i++)
    {
        sprintf(dummy,"%7d",i);
        vertHeads << QString(dummy);
        for (int j=0;j<2;j++)
        {
            //sprintf(dummy,out_format,p.data.ex[col][ro]);
            if (i<length)
            {
                sprintf(dummy,"%g",g[g_no].p[s_no].data.ex[j][i]);
                Items[i-start_row][j]->setText(QString(dummy));
            }
            else
            {
                Items[i-start_row][j]->setText(emptyEntry);
            }
        }
    }
    table->setVerticalHeaderLabels(vertHeads);
}

void frmSpreadSheet2::doApply(void)
{

}

void frmSpreadSheet2::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSpreadSheet2::doClose(void)
{
    hide();
}

myTableWidget::myTableWidget(int r, int c,QWidget * parent):QTableWidget(r,c,parent)
{
}

void myTableWidget::wheelEvent(QWheelEvent * e)
{
    e->accept();
    emit(wheeled(e->delta()));
}

void myTableWidget::keyPressEvent(QKeyEvent * event)
{
    static int keynr;
    event->accept();
    keynr=event->key();
    //cout << "press " << char(event->key()) << "|" << event->key() << endl;
    //if (!(keynr==Qt::Key_Tab || keynr==Qt::Key_Backtab || keynr==Qt::Key_Return || keynr==Qt::Key_Enter || keynr==Qt::Key_PageUp || keynr==Qt::Key_PageDown || keynr==Qt::Key_Down || keynr==Qt::Key_Up || keynr==Qt::Key_Home || keynr==Qt::Key_End))
    if (!(keynr==Qt::Key_Tab || keynr==Qt::Key_Backtab || keynr==Qt::Key_PageUp || keynr==Qt::Key_PageDown || keynr==Qt::Key_Down || keynr==Qt::Key_Up || keynr==Qt::Key_Home || keynr==Qt::Key_End))
        QTableWidget::keyPressEvent(event);
    else
        emit newDirection(keynr);
}

void myTableWidget::keyReleaseEvent(QKeyEvent * event)
{
    static int keynr;
    event->accept();
    keynr=event->key();
    //cout << "release " << char(event->key()) << " | " << event->key() << " | row= " << currentRow() << endl;
    //if (!(keynr==Qt::Key_Tab || keynr==Qt::Key_Backtab || keynr==Qt::Key_Return || keynr==Qt::Key_Enter || keynr==Qt::Key_PageUp || keynr==Qt::Key_PageDown || keynr==Qt::Key_Down || keynr==Qt::Key_Up || keynr==Qt::Key_Home || keynr==Qt::Key_End))
    if (!(keynr==Qt::Key_Tab || keynr==Qt::Key_Backtab || keynr==Qt::Key_PageUp || keynr==Qt::Key_PageDown || keynr==Qt::Key_Down || keynr==Qt::Key_Up || keynr==Qt::Key_Home || keynr==Qt::Key_End))
        QTableWidget::keyReleaseEvent(event);
    //else
    //emit newDirection(keynr);
}

frmSpreadSheet3::frmSpreadSheet3(QWidget * parent):QDialog(parent)
{
    working=false;
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Spreadsheet dataset editor"));
    setWindowIcon(QIcon(*GraceIcon));

    CreateActions();

    EditColumn=new frmEditColumnProp(this);
    EditColumn->hide();
    connect(EditColumn,SIGNAL(newColumnFormat(int,int,int)),SLOT(setColumnFormat(int,int,int)));

    int number;
    char dummy[50];
    QString entr[NUMBER_OF_SETTYPES+2];
    menuBar=new QMenuBar(this);
    mnuFile=new QMenu(tr("&File"));
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actClose);
    mnuEdit=new QMenu(tr("&Edit"));
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actAddRow);
    mnuEdit->addAction(actDelSelRow);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actColumnFormat);
    mnuHelp=new QMenu(tr("&Help"));
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnDataSetEditor);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    /*scroll=new QScrollArea(this);
spread=new spreadSheet(scroll,0,5,3);
scroll->setWidget(spread);*/

    //4number_of_rows=100;//std-Row-count
    //filled_rows=0;
    number_of_visible_entries=5;//just a guess
    number_of_columns=6;//maximum number of columns
    //setColumnHidden( int column, bool hide );

    for (int i=0;i<6;i++)
    {
        col_format[i]=1;
        col_precision[i]=5;
        EditColumn->col_format[i]=col_format[i];
        EditColumn->col_precision[i]=col_precision[i];
    }

    strcpy(dummy,"");

    //table=new QTableWidget(number_of_rows,number_of_columns,this);
    //the number of lines will not change later!!!
    table=new myTableWidget(MAX_NUMBER_OF_LINES_IN_SPREADSHEET,number_of_columns,this);
    connect(table,SIGNAL(newDirection(int)),this,SLOT(changeDirection(int)));
    table->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    //table->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    table->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    Items=new QTableWidgetItem**[MAX_NUMBER_OF_LINES_IN_SPREADSHEET+1];
    for (int i=0;i<=MAX_NUMBER_OF_LINES_IN_SPREADSHEET;i++)
    {
        Items[i]=new QTableWidgetItem*[number_of_columns+1];
        for (int j=0;j<=number_of_columns;j++)
        {
            Items[i][j]=new QTableWidgetItem(QString(dummy),QTableWidgetItem::Type);
            table->setItem(i, j, Items[i][j]);
        }
    }
    connect(table,SIGNAL(currentCellChanged(int,int,int,int)),SLOT(currentCellChangedWrapper(int,int,int,int)));
    connect(table,SIGNAL(cellChanged(int,int)),SLOT(itemChanged(int,int)));
    connect(table,SIGNAL(wheeled(int)),SLOT(wheel_used(int)));
    QStringList vertHeads;
    QStringList horHeads;
    horHeads << "X" << "Y";
    for (int i=0;i<MAX_NUMBER_OF_LINES_IN_SPREADSHEET;i++)//initialize everything here
    {
        sprintf(dummy,"%7d",i);
        vertHeads << QString(dummy);
    }
    table->setHorizontalHeaderLabels(horHeads);
    table->setVerticalHeaderLabels(vertHeads);
    connect(table->horizontalHeader(),SIGNAL(sectionClicked(int)),SLOT(HHeaderClicked(int)));

    scroll=new QScrollBar(Qt::Vertical,this);
    //scroll=table->verticalScrollBar();
    scroll->setSingleStep(1);
    connect(scroll,SIGNAL(valueChanged(int)),SLOT(position_changed(int)));

    fraDataset=new QGroupBox(tr("Dataset"),this);

    number=NUMBER_OF_SETTYPES;
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(fraDataset,tr("Type:"),number,entr);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(changeDataSet(int)));
    //selType=new stdSetTypeSelector(this);

    ledComment=new stdLineEdit(fraDataset,tr("Comment:"),true);
    ledComment->lenText->setText(tr("Editor"));
    layout0=new QVBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(selType);
    layout0->addWidget(ledComment);
    fraDataset->setLayout(layout0);

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(0);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar,0,0,1,2);
#endif
    layout->addWidget(fraDataset,1,0,1,2);
    layout->addWidget(table,2,0,1,1);
    layout->addWidget(scroll,2,1,1,1);
    layout->addWidget(buttonGroup,3,0,1,2);
    setLayout(layout);
    start_row=0;
    inited=false;
}

void frmSpreadSheet3::HHeaderClicked(int i)
{
    EditColumn->initToColumn(i);
    EditColumn->show();
    EditColumn->raise();
}

void frmSpreadSheet3::init(int g_no,int set_no)
{
    if (inited==true && isVisible()==false) return;//do nothing, as long as nothing is visible!
    inited=true;//just for the first init...
    start_row=0;
    disconnect(table,SIGNAL(cellChanged(int,int)), this, SLOT(itemChanged(int,int)));
    char dummy[64];
    QString ds1=tr("Dataset");
    sprintf(dummy," G%d.S%d",g_no,set_no);
    QString ds2=ds1+QString(dummy);
    fraDataset->setTitle(ds2);
    //set new graph- and set-number
    gno=g_no;
    setno=set_no;
    plotarr p;
    //get set data
    get_graph_plotarr(g_no, set_no, &p);
    //Set the comment
    ledComment->SetTextToMemory(g[g_no].p[set_no].comments,g[g_no].p[set_no].orig_comments);
    //ledComment->lenText->setText(getcomment(g_no, set_no));

    //delete everything
    //for (int i=number_of_columns-1;i>=0;i--)
    //table->removeColumn(i);
    //for (int i=0;i<number_of_rows;i++)
    //delete[] Items[i];
    //delete[] Items;

    //renew all entries
    setLength=getsetlength(g_no, set_no);

    /*
if (filled_rows<30)//Minimum is 30 lines (see below)
number_of_rows=30;
else
number_of_rows=5+filled_rows;//at least 5 more than needed
*/

    number_of_columns=settype_cols(p.type);
    if (number_of_columns<2)
    {
        cout << "WARNING: number_of_columns=" << number_of_columns << endl;
        number_of_columns=2;
    }
    table->setColumnCount(number_of_columns);

    //recreate whole spreadsheet
    /*
table->setRowCount(number_of_rows);
table->setColumnCount(number_of_columns);
    Items=new QTableWidgetItem**[number_of_rows];
    for (int i=0;i<number_of_rows;i++)
    {
    Items[i]=new QTableWidgetItem*[number_of_columns];
        for (int j=0;j<number_of_columns;j++)
        {
        Items[i][j]=new QTableWidgetItem(QString(""),QTableWidgetItem::Type);
        table->setItem(i, j, Items[i][j]);
        }
        }
*/
    disconnect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(changeDataSet(int)));
    selType->setCurrentIndex(p.type);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(changeDataSet(int)));
    connect(table,SIGNAL(cellChanged(int,int)),this,SLOT(itemChanged(int,int)));
    //resize(this->size());
    //update_entries(); --> will be done in 'position_changed(0);' below
    scroll->setValue(0);
    position_changed(0);
}

void frmSpreadSheet3::changeDataSet(int type)
{
    set_dataset_type(this->gno, this->setno, type);
    mainWin->mainArea->completeRedraw();
}

void frmSpreadSheet3::setColumnFormat(int col,int format,int precision)
{
    col_format[col]=format;
    col_precision[col]=precision;
    update_entries();
}

void frmSpreadSheet3::resizeEvent(QResizeEvent * event)
{
    event->accept();
    static double guessed_number_of_visible_entries;
    guessed_number_of_visible_entries=(table->size().height()-table->horizontalHeader()->height()-table->horizontalScrollBar()->height())*1.0/table->rowHeight(1);
    number_of_visible_entries=int(guessed_number_of_visible_entries);//before: '+1'
    scroll->setPageStep(number_of_visible_entries);
    scroll->setRange(0,setLength-number_of_visible_entries+12);//'+10' because 10 empty rows at the end
    //cout << "number_of_visible_entries = " << number_of_visible_entries << endl;
    update_entries();
}

void frmSpreadSheet3::wheel_used(int d)//translate mouse-wheel to scroll events
{
    if (d<0)
        scroll->setValue(scroll->value()+1);
    else
        scroll->setValue(scroll->value()-1);
}

void frmSpreadSheet3::position_changed(int pos)
{
    start_row=pos;//only start_row actually changed here!
    update_entries();
}

void frmSpreadSheet3::update_entries(void)//show data in table
{
    if (working==true) return;
    working=true;
    static double guessed_number_of_visible_entries;
    guessed_number_of_visible_entries=(table->size().height()-table->horizontalHeader()->height()-table->horizontalScrollBar()->height())*1.0/table->rowHeight(1);
    number_of_visible_entries=int(guessed_number_of_visible_entries);//'+1'

    disconnect (table,SIGNAL(cellChanged(int,int)), this, SLOT(itemChanged(int,int)));
    char setPrec[5];
    char out_format[16];
    char dummy[128];
    plotarr * p=NULL;
    QString emptyEntry("");
    //get_graph_plotarr(gno, setno, &p);//we do not need a copy here, we only read data
    if (is_valid_gno(gno) == TRUE && is_valid_setno(gno,setno) == TRUE)
    {
        p=g[gno].p+setno;
    }

    /*
int setcolumns=settype_cols(p->type);
if (setcolumns!=number_of_columns)
{
    cout << "wrong column-count: " << setcolumns << "<->" << number_of_columns << endl;
    return;
}
*/

    QStringList vertHeads;
    QStringList horHeads;
    horHeads << QString("X") << QString("Y");
    for (int i=1;i<number_of_columns-1;i++)
    {
        sprintf(dummy,"Y%d",i);
        horHeads << QString(dummy);
    }
    for (int i=0;i<=number_of_visible_entries+5;i++)//we will only update what is visible!
    {
        sprintf(dummy,"%7d",i+start_row);
        vertHeads << QString(dummy);
        /*if (i<number_of_visible_entries)
    table->setRowHidden(i,false);
    else
    table->setRowHidden(i,true);*/
    }
    table->setHorizontalHeaderLabels(horHeads);
    table->setVerticalHeaderLabels(vertHeads);

    if (is_valid_setno(gno,setno) == FALSE || p->data.len<=0)//entries not valid any more since set not valid
    {
        //table->clearContents();
        for (int i=0;i<=number_of_visible_entries+1;i++)//deleting the visible entries
        {
            for (int j=0;j<number_of_columns;j++)
            {
                Items[i][j]->setText(emptyEntry);
            }
        }
    }
    else//valid set
    {
        setLength=getsetlength(gno,setno);
        //if (filled_rows<0) filled_rows=0;
        //else if (filled_rows>100) filled_rows=100;//filled rows is the maximum number of entries to be filled...probably
        for (int col=0;col<number_of_columns;col++)
        {
            table->setColumnHidden(col,false);
            sprintf(setPrec,"%%.%d",col_precision[col]);
            switch (col_format[col])
            {
            case 0://decimal
                sprintf(out_format,"%sf",setPrec);
                break;
            case 1://general
                sprintf(out_format,"%sg",setPrec);
                break;
            case 2://exponential
                sprintf(out_format,"%se",setPrec);
                break;
            case 3://Date/time
                sprintf(out_format,"%%t");///NOT CORRECT
                break;
            }
            for (int ro=0;ro<=number_of_visible_entries+5;ro++)//fill the visible rows
            {
                if (ro+start_row<setLength)//fill only entries that are realy present
                {
                    sprintf(dummy,out_format,p->data.ex[col][ro+start_row]);
                    Items[ro][col]->setText(QString(dummy));
                }
                else//otherwise fill in empty entries
                    Items[ro][col]->setText(emptyEntry);
            }
        }
        /*for (int col=number_of_columns;col<6;col++)//--> we have set row- and column-count separately --> this is unneccessary
    table->setColumnHidden(col,true);*/
        table->resizeColumnsToContents();
    }
    connect(table,SIGNAL(cellChanged(int,int)),SLOT(itemChanged(int,int)));
    updateScrollBar();//we have to update this, because the number of entries could have changed
    working=false;
}

void frmSpreadSheet3::itemChanged(int row,int c)
{
    setLength=getsetlength(gno,setno);
    if (working==true || row>setLength || row<0 || c>table->columnCount() || c<0)
    {//do not disturb while working or with useless indices
        return;
    }
    ///working=true;
    ApplyError=false;
    //cout << "item changed " << row << "|" << c << endl;
    QString dummy1=Items[row][c]->text();
    double dummy2=atof(dummy1.toLocal8Bit());
    Datapoint * ps=NULL;
    int * nrs=NULL;
    Datapoint dpoint;
    int r=atoi(table->verticalHeaderItem(row)->text().toLocal8Bit().constData());//we determine the real row-number here
    zero_datapoint(&dpoint);
    if ( r < setLength )
    {
        ///Undo-Stuff
        for (int i=0;i<settype_cols(g[gno].p[setno].type);i++)
            dpoint.ex[i]=g[gno].p[setno].data.ex[i][r];
        if (g[gno].p[setno].data.s!=NULL)
            dpoint.s=copy_string(NULL,g[gno].p[setno].data.s[r]);
        dpoint.ex[c]=dummy2;
        ps=new Datapoint[2];
        memcpy(ps,&dpoint,sizeof(Datapoint));
        nrs=new int[2];
        nrs[0]=r;
        DataPointEdited(gno,setno,nrs,1,ps,2);
        delete[] ps;
        delete[] nrs;
        g[gno].p[setno].data.ex[c][r]=dummy2;
    }
    else
    {
        //char dummy[128];
        //char setPrec[5];
        //char out_format[16];
        //int n_rows=(number_of_rows-filled_rows+1)-number_of_rows+r;
        //int n_rows=r-setLength+1;
        //int ret;
        //cout << "n_rows=" << n_rows << endl;
        for (int i=setLength;i<r;i++)
        {
            //ret=add_point_at(gno, setno, i, &dpoint);
            (void)add_point_at(gno, setno, i, &dpoint);
        }
        dpoint.ex[c]=dummy2;
        //ret=add_point_at(gno, setno, r, &dpoint);
        (void)add_point_at(gno, setno, r, &dpoint);
        //filled_rows+=n_rows;
        setLength=getsetlength(gno,setno);
        /*if (number_of_rows>=filled_rows+5)
{
;//enough space
}
else
{//in the current state: number of items is not changes
QTableWidgetItem *** Items_d=new QTableWidgetItem**[number_of_rows];
for (int i=0;i<number_of_rows+n_rows;i++)
Items_d[i]=new QTableWidgetItem*[number_of_columns];
for (int i=0;i<number_of_rows;i++)
{
    for (int j=0;j<number_of_columns;j++)
    Items_d[i][j]=Items[i][j];
    delete[] Items[i];
}
delete[] Items;
Items=new QTableWidgetItem**[number_of_rows+n_rows];

for (int i=0;i<number_of_rows+n_rows;i++)
{
    Items[i]=new QTableWidgetItem*[number_of_columns];
    if (i<number_of_rows)
    {
        for (int j=0;j<number_of_columns;j++)
        Items[i][j]=Items_d[i][j];
    }
    else
    {
        table->insertRow(i);
        for (int j=0;j<number_of_columns;j++)
        {
        Items[i][j]=new QTableWidgetItem(QString(""),QTableWidgetItem::Type);
        table->setItem(i, j, Items[i][j]);
        }
    }
}
}*///end: not enough space

        /*plotarr * p=g[gno].p+setno;
//get_graph_plotarr(gno, setno, &p);
for (int col=0;col<number_of_columns;col++)
{
sprintf(setPrec,"%%.%d",col_precsision[col]);
switch (col_format[col])
{
case 0://decimal
sprintf(out_format,"%sf",setPrec);
break;
case 1://general
sprintf(out_format,"%sg",setPrec);
break;
case 2://exponential
sprintf(out_format,"%se",setPrec);
break;
case 3://Date/time
sprintf(out_format,"%%t");///NOT CORRECT
break;
}
        for (int ro=number_of_rows;ro<r;ro++)
        {
        sprintf(dummy,out_format,p->data.ex[col][ro]);
        Items[ro][col]->setText(QString(dummy));
        }
}
    if (number_of_rows<filled_rows+5)
    {
    QStringList vertHeads;
    number_of_rows+=n_rows;
        for (int i=0;i<number_of_rows;i++)
        {
        sprintf(dummy,"%7d",i);
        vertHeads << QString(dummy);
        }
    table->setVerticalHeaderLabels(vertHeads);
    }*/
    }


    /*if (start_row<=(r-number_of_visible_entries+1))
{
    cout << "start_row=" << start_row;
    start_row-=(start_row-(r-number_of_visible_entries+1))-1;
    cout << " jetzt muesste ich eigentlich --> " << start_row << endl;

    working=false;
}
cout << "a) start_row=" << start_row << endl;*/
    update_entries();
    //cout << "b) start_row=" << start_row << endl;
    updateScrollBar();
    //cout << "c) start_row=" << start_row << endl;
    int start_sav=start_row;
    spreadSheetEntryChanged();
    start_row=start_sav;
    //cout << "len=" << getsetlength(gno,setno) << " start=" << start_row << " vis=" << number_of_visible_entries << " cur_r=" << r << endl;
    working=false;
}

void frmSpreadSheet3::CreateActions(void)
{
    actClose= new QAction(tr("&Close"), this);
    actClose->setShortcut(tr("Esc"));
    connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
    actAddRow= new QAction(tr("&Add row"), this);
    connect(actAddRow, SIGNAL(triggered()), this, SLOT(doAddRow()));
    actDelSelRow= new QAction(tr("&Delete selected rows"), this);
    connect(actDelSelRow, SIGNAL(triggered()), this, SLOT(doDelSelRow()));
    actColumnFormat= new QAction(tr("&Column format..."), this);
    connect(actColumnFormat, SIGNAL(triggered()), this, SLOT(doColumnFormat()));
    actHelpOnContext= new QAction(tr("On conte&xt"), this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext, SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnDataSetEditor= new QAction(tr("On datas&et editor"), this);
    connect(actHelpOnDataSetEditor, SIGNAL(triggered()), this, SLOT(doHelpOnDataSetEditor()));
}

void frmSpreadSheet3::doApply(void)
{
    ApplyError=false;
    int r=table->currentRow();
    int c=table->currentColumn();
    itemChanged(r,c);
}

void frmSpreadSheet3::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSpreadSheet3::doClose(void)
{
    hide();
    emit(spreadSheetClosed(gno,setno));
}

void frmSpreadSheet3::doAddRow(void)
{
    int * sels;
    int nsels;
    int * gnos=new int[3];
    int * snos=new int[3];
    getSelection(&nsels,&sels);
    gnos[0]=gno;
    snos[0]=setno;
    SaveSetStatesPrevious(1,gnos,snos,UNDO_DATA);
    for (int ii=0;ii<nsels;ii++)
    {
        int i=sels[ii]+start_row, k;
        int nrows=setLength, ncols=number_of_columns;// scols;
        char **s;
        Datapoint dpoint;

        if (i > nrows || i < 0){
            errmsg(tr("Selected row out of range").toLocal8Bit().constData());
            return;
        }

        zero_datapoint(&dpoint);

        if (i < nrows) {
            for (k = 0; k < ncols; k++) {
                dpoint.ex[k] = *(getcol(gno, setno, k) + i);
            }
            if ((s = get_set_strings(gno, setno)) != NULL) {
                dpoint.s = s[i];
            }
            add_point_at(gno, setno, i + 1, &dpoint);
        } else {
            add_point_at(gno, setno, i, &dpoint);
        }

        update_set_lists(gno);
        init(gno, setno);
        mainWin->mainArea->completeRedraw();
    }
    SetsModified(1,gnos,snos,UNDO_DATA);
    delete[] sels;
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet3::doDelSelRow(void)
{
    int i;
    int * srows;
    int nsrows;
    int ndatapoints=getsetlength(gno,setno);
    int * gnos=new int[3];
    int * snos=new int[3];
    gnos[0]=gno;
    snos[0]=setno;
    SaveSetStatesPrevious(1,gnos,snos,UNDO_DATA);
    getSelection(&nsrows,&srows);
    char buf[64];
    if (srows[0] < 0 || srows[0] >= setLength) {
        errmsg(tr("Nothing to delete").toLocal8Bit().constData());
        return;
    }
    sprintf(buf, "Delete %d selected row(s)?", nsrows);
    if (yesno(buf, NULL, NULL, NULL)) {
        for (i = nsrows - 1; i >= 0; i--) {
            if (srows[i]+start_row>=0 && srows[i]+start_row<ndatapoints)
                del_point(gno,setno,srows[i]+start_row);
        }
        update_set_lists(gno);
        init(gno, setno);
        mainWin->mainArea->completeRedraw();
    }
    delete[] srows;
    SetsModified(1,gnos,snos,UNDO_DATA);
    delete[] gnos;
    delete[] snos;
}

void frmSpreadSheet3::doColumnFormat(void)
{
    EditColumn->initToColumn(0);
    EditColumn->show();
    EditColumn->raise();
}

void frmSpreadSheet3::doHelpOnContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmSpreadSheet3::doHelpOnDataSetEditor(void)
{
    HelpCB("doc/UsersGuide.html#SSEditor");
}

void frmSpreadSheet3::write_set(void)
{
    plotarr *p=g[gno].p+setno;
    QString dummy1;
    double dummy2;
    for (int col=0;col<number_of_columns;col++)
    {
        for (int ro=0;ro<number_of_visible_entries;ro++)
        {
            if (ro+start_row>=getsetlength(gno,setno)) break;
            dummy1=Items[ro][col]->text();
            dummy2=atof(dummy1.toLocal8Bit());
            p->data.ex[col][ro+start_row]=dummy2;
        }
    }
    spreadSheetEntryChanged();
}

void frmSpreadSheet3::spreadSheetEntryChanged(void)
{
    ledComment->SetMemoryToText(g[gno].p[setno].comments,g[gno].p[setno].orig_comments);
    //static string used
    //char * buf=new char[ledComment->text().length()+8];
    //strcpy(buf,ledComment->text().toLocal8Bit().constData());
    //setcomment(gno,setno,buf);
    set_dirtystate();
    mainWin->mainArea->completeRedraw();
    //delete[] buf;
}

void frmSpreadSheet3::getSelection(int * n_of_sel,int ** sel)
{
    int nsel=10;
    int * sels=new int[nsel];
    int * old_sel;
    bool row_active;
    *n_of_sel=0;
    for (int i=0;i<MAX_NUMBER_OF_LINES_IN_SPREADSHEET;i++)//look in every line that has been allocated
    {
        row_active=false;
        for (int j=0;j<number_of_columns;j++)
        {
            if (Items[i][j]->isSelected()==true)
            {
                row_active=true;
                break;
            }
        }
        if (row_active==true)
        {//new selected row found
            if (nsel==*n_of_sel)
            {//not enough data for selection-storage
                old_sel=sels;
                sels=new int[nsel+30];
                nsel+=30;
                for (int k=0;k<*n_of_sel;k++)
                    sels[k]=old_sel[k];
                delete[] old_sel;
            }
            sels[*n_of_sel]=i;
            (*n_of_sel)++;
        }
    }
    *sel=new int[*n_of_sel];
    for (int i=0;i<*n_of_sel;i++)
        (*sel)[i]=sels[i];
    delete[] sels;
}

void frmSpreadSheet3::updateScrollBar(void)
{
    disconnect(scroll,SIGNAL(valueChanged(int)),this,SLOT(position_changed(int)));
    //scroll->setRange(0,getsetlength(gno,setno)-number_of_visible_entries+1);
    scroll->setRange(0,getsetlength(gno,setno)-1);
    scroll->setValue(start_row);
    scroll->setPageStep(number_of_visible_entries);
    connect(scroll,SIGNAL(valueChanged(int)),SLOT(position_changed(int)));
}

void frmSpreadSheet3::changeDirection(int keynr)
{
    if (working==true) return;
    working=true;
    nextScroll=scroll->value();
    nextRow=table->currentRow();
    nextCol=table->currentColumn();
    //cout << "start_row=" << start_row << " current_row=" << table->currentRow() << " scroll=" << scroll->value() << endl;
    switch (keynr)
    {
    case Qt::Key_Tab:
        //cout << "Tab" << endl;
        StepRight(nextRow,nextCol);
        break;
    case Qt::Key_Backtab:
        //cout << "BackTab" << endl;
        StepLeft(nextRow,nextCol);
        break;
        /*case Qt::Key_Return:
break;
case Qt::Key_Enter:
break;*/
    case Qt::Key_PageUp:
        nextScroll-=number_of_visible_entries-1;
        break;
    case Qt::Key_PageDown:
        nextScroll+=number_of_visible_entries-1;
        break;
    case Qt::Key_Down:
        if (table->currentRow()<number_of_visible_entries)
        {
            nextRow++;
            //cout << "new row" << endl;
        }
        else
        {
            nextScroll++;
            //cout << "new scroll "<< nextScrollValue << endl;
        }
        break;
    case Qt::Key_Up:
        if (table->currentRow()>0)
            nextRow--;
        else
            nextScroll--;
        break;
    case Qt::Key_Home:
        nextRow=0;
        nextScroll=0;
        break;
    case Qt::Key_End:
        nextRow=number_of_visible_entries-2;
        nextScroll=scroll->maximum();
        break;
        //defaut:
        //cout << keynr << endl;
        break;
    }

    if (nextRow!=table->currentRow() || nextCol!=table->currentColumn())
        table->setCurrentCell(nextRow,nextCol);
    working=false;
    if (nextScroll<0) nextScroll=0;
    if (nextScroll!=scroll->value())
        scroll->setValue(nextScroll);
}

void frmSpreadSheet3::currentCellChangedWrapper(int currentRow, int currentColumn, int previousRow, int previousColumn)
{
    (void)previousColumn;
    bool setEdit;
    if (working==true) return;
    working=true;
    setEdit=false;
    nextRow=currentRow;
    nextCol=currentColumn;
    nextScroll=scroll->value();
    ///cout << "(" << previousRow << "|" << previousColumn << ") --> (" << currentRow << "|" << currentColumn << ") vis_entr.=" << number_of_visible_entries << endl;
    if (currentRow>previousRow && currentRow>=number_of_visible_entries)
    {
        nextRow=number_of_visible_entries-1;
        nextScroll+=currentRow-previousRow;
        //cout << "Row hat Bereich nach unten verlassen!" << endl;
        setEdit=true;
        if (nextRow!=table->currentRow() || nextCol!=table->currentColumn())
            table->setCurrentCell(nextRow,nextCol);
    }
    else if (currentRow<previousRow && currentRow==0 && scroll->value()>0)
    {
        nextRow=1;
        nextScroll+=currentRow-previousRow;
        //cout << "Gone up" << endl;
        setEdit=true;
        if (nextRow!=table->currentRow() || nextCol!=table->currentColumn())
            table->setCurrentCell(nextRow,nextCol);
    }
    working=false;
    if (nextScroll<0) nextScroll=0;
    if (nextScroll!=scroll->value())
        scroll->setValue(nextScroll);
    if (setEdit==true)
        table->editItem(Items[nextRow][nextCol]);
}

void frmSpreadSheet3::StepLeft(int curRow,int curCol)//rows are in visible coordinates!
{
    nextRow=curRow;
    nextCol=curCol-1;
    nextScroll=scroll->value();
    if (nextCol<0)
    {
        nextCol=number_of_columns-1;
        nextRow--;
    }
    //column-changes are always within visible range / row-changes only sometimes
    if (nextRow<0)//row would leave visible area now
    {
        nextRow=0;//set actual row to last visible one
        nextScroll--;//scroll contents down
    }
    /// actually do something here
}

void frmSpreadSheet3::StepRight(int curRow,int curCol)//rows are in visible coordinates!
{
    nextRow=curRow;
    nextCol=curCol+1;
    nextScroll=scroll->value();
    if (nextCol>=number_of_columns)
    {
        nextCol=0;
        nextRow++;
    }
    //column-changes are always within visible range / row-changes only sometimes
    if (nextRow>=number_of_visible_entries)//row would leave visible area now
    {
        nextRow=number_of_visible_entries-1;//set actual row to last visible one
        nextScroll++;//scroll contents down
    }
    /// actually do something here
}

frmLine_Props::frmLine_Props(QWidget * parent,bool edit):QWidget(parent)
{
    editWindow=edit;
    int number;
    QString * entr=new QString[5];

    /*setFont(*stdFont);
if (edit)
setWindowTitle(tr("Edit Line"));
else
setWindowTitle(tr("Lines"));
setWindowIcon(QIcon(*GraceIcon));*/

    lines_color_item=new ColorSelector(this);
    lines_width_item=new LineWidthSelector(this);
    lines_style_item=new LineStyleSelector(this);

    fraArrow=new QGroupBox(tr("Arrow"),this);
    number=4;
    entr[0]=tr("None");
    entr[1]=tr("Start");
    entr[2]=tr("End");
    entr[3]=tr("Both ends");
    lines_arrow_item=new StdSelector(fraArrow,tr("Place at:"),number,entr);
    number=3;
    entr[0]=tr("Line");
    entr[1]=tr("Filled");
    entr[2]=tr("Opaque");
    lines_atype_item=new StdSelector(fraArrow,tr("Type:"),number,entr);
    lines_asize_item=new LineWidthSelector(fraArrow);
    lines_asize_item->lblText->setText(tr("Length:"));
    lines_asize_item->spnLineWidth->setRange(-10.0,10.0);
    lines_a_dL_ff_item=new LineWidthSelector(fraArrow);
    lines_a_dL_ff_item->lblText->setText(tr("d/L form factor:"));
    lines_a_dL_ff_item->spnLineWidth->setRange(0.0,10.0);
    lines_a_dL_ff_item->spnLineWidth->setSingleStep(0.1);
    lines_a_lL_ff_item=new LineWidthSelector(fraArrow);
    lines_a_lL_ff_item->lblText->setText(tr("l/L form factor:"));
    lines_a_lL_ff_item->spnLineWidth->setRange(-1.0,1.0);
    lines_a_lL_ff_item->spnLineWidth->setSingleStep(0.1);

    lines_loc_item=new PositionSelector(this);

    buttonGroup=new stdButtonGroup(this,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(lines_arrow_item);
    layout2->addWidget(lines_atype_item);
    layout2->addWidget(lines_asize_item);
    layout2->addWidget(lines_a_dL_ff_item);
    layout2->addWidget(lines_a_lL_ff_item);
    fraArrow->setLayout(layout2);

    layout->addWidget(lines_color_item);
    layout->addWidget(lines_width_item);
    layout->addWidget(lines_style_item);
    layout->addWidget(fraArrow);
    layout->addWidget(lines_loc_item);
    if (edit)
    {
        ledCoords[0]=new stdLineEdit(this,QString("X1="));
        layout->addWidget(ledCoords[0]);
        ledCoords[1]=new stdLineEdit(this,QString("Y1="));
        layout->addWidget(ledCoords[1]);
        ledCoords[2]=new stdLineEdit(this,QString("X2="));
        layout->addWidget(ledCoords[2]);
        ledCoords[3]=new stdLineEdit(this,QString("Y2="));
        layout->addWidget(ledCoords[3]);
    }
    layout->addWidget(buttonGroup);
    setLayout(layout);

    lines_loc_item->setCurrentIndex(1);
    lines_color_item->setCurrentIndex(1);
    lines_width_item->setValue(1.0);
    lines_style_item->setCurrentIndex(1);
    lines_asize_item->setValue(1.0);
    lines_a_dL_ff_item->setValue(1.0);
    lines_a_lL_ff_item->setValue(1.0);

    connect(lines_arrow_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(lines_atype_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(lines_asize_item,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(lines_a_dL_ff_item,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(lines_a_lL_ff_item,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(lines_color_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(lines_color_item,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(lines_width_item,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(lines_style_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));

    connect(lines_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
}

void frmLine_Props::init(int id)
{
    if (id>=number_of_lines() || (id<0 && editWindow==true)) return;
    bool sav_imm_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    //char buf[256];
    obj_id=id;
    disconnect(lines_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
    if (editWindow==false)
    {
        SetOptionChoice(lines_color_item, line_color);
        lines_color_item->setAlpha(line_alpha);
        SetOptionChoice(lines_style_item, line_lines);
        SetSpinChoice(lines_width_item, line_linew);
        SetChoice(lines_arrow_item, line_arrow_end);
        SetChoice(lines_atype_item, line_atype);
        SetSpinChoice(lines_asize_item, line_asize);
        SetSpinChoice(lines_a_dL_ff_item, line_a_dL_ff);
        SetSpinChoice(lines_a_lL_ff_item, line_a_lL_ff);
        lines_loc_item->setCurrentIndex(line_loctype == COORD_VIEW ? 1 : 0);
    }
    else
    {
        int lineno = obj_id;
        SetOptionChoice(lines_color_item, lines[lineno].color);
        lines_color_item->setAlpha(lines[lineno].alpha);
        SetOptionChoice(lines_style_item, lines[lineno].lines);
        SetSpinChoice(lines_width_item, lines[lineno].linew);
        SetChoice(lines_arrow_item, lines[lineno].arrow_end);
        SetChoice(lines_atype_item, lines[lineno].arrow.type);
        SetSpinChoice(lines_asize_item, lines[lineno].arrow.length);
        SetSpinChoice(lines_a_dL_ff_item, lines[lineno].arrow.dL_ff);
        SetSpinChoice(lines_a_lL_ff_item, lines[lineno].arrow.lL_ff);
        lines_loc_item->setCurrentIndex(lines[lineno].loctype == COORD_VIEW ? 1 : 0);
        ledCoords[0]->setDoubleValue("%.12f",lines[lineno].x1);
        ledCoords[1]->setDoubleValue("%.12f",lines[lineno].y1);
        ledCoords[2]->setDoubleValue("%.12f",lines[lineno].x2);
        ledCoords[3]->setDoubleValue("%.12f",lines[lineno].y2);
    }
    connect(lines_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
    immediateUpdate=sav_imm_upd;
    updateRunning=false;
}

void frmLine_Props::viewCoordsChanged(int i)
{
    (void)i;
    if (editWindow==false) return;
    int lineno = obj_id;
    double k[4];
    if( lines[lineno].loctype == lines_loc_item->currentValue()) return;
    bool old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;

    xv_evalexpr(ledCoords[0], k+0);
    xv_evalexpr(ledCoords[1], k+1);
    xv_evalexpr(ledCoords[2], k+2);
    xv_evalexpr(ledCoords[3], k+3);

    if( lines[lineno].loctype == COORD_VIEW )
    {
        lines[lineno].gno = get_cg();
        lines[lineno].loctype = COORD_WORLD;
        //view2world( atof(xv_getstr(ledCoords[0])), atof(xv_getstr(ledCoords[1])),&lines[lineno].x1,&lines[lineno].y1 );
        //view2world( atof(xv_getstr(ledCoords[2])), atof(xv_getstr(ledCoords[3])),&lines[lineno].x2,&lines[lineno].y2 );
        view2world( k[0],k[1],&lines[lineno].x1,&lines[lineno].y1 );
        view2world( k[2],k[3],&lines[lineno].x2,&lines[lineno].y2 );
    }
    else
    {
        lines[lineno].loctype = COORD_VIEW;
        //world2view( atof(xv_getstr(ledCoords[0])), atof(xv_getstr(ledCoords[1])),&lines[lineno].x1,&lines[lineno].y1 );
        //world2view( atof(xv_getstr(ledCoords[2])), atof(xv_getstr(ledCoords[3])),&lines[lineno].x2,&lines[lineno].y2 );
        world2view( k[0],k[1],&lines[lineno].x1,&lines[lineno].y1 );
        world2view( k[2],k[3],&lines[lineno].x2,&lines[lineno].y2 );
    }
    init(obj_id);
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmLine_Props::doAccept(void)
{
    int lineno = obj_id;
    double k[4];
    bool changes=false;
    ListOfChanges.clear();
    ListOfOldStates.clear();
    if (editWindow==false)//edit preferences
    {
        line_asize = GetSpinChoice(lines_asize_item);
        line_color = GetOptionChoice(lines_color_item);
        line_alpha = lines_color_item->alpha();
        line_arrow_end = GetChoice(lines_arrow_item);
        line_atype = GetChoice(lines_atype_item);
        line_a_dL_ff = GetSpinChoice(lines_a_dL_ff_item);
        line_a_lL_ff = GetSpinChoice(lines_a_lL_ff_item);
        line_lines = GetOptionChoice(lines_style_item);
        line_linew = GetSpinChoice(lines_width_item);
        line_loctype = lines_loc_item->currentValue();
    }
    else//edit object
    {
        SaveObjectData(lineno,OBJECT_LINE);
        xv_evalexpr(ledCoords[0], k+0);
        xv_evalexpr(ledCoords[1], k+1);
        xv_evalexpr(ledCoords[2], k+2);
        xv_evalexpr(ledCoords[3], k+3);

        sprintf(dummy,"with line %d",lineno);
        ListOfChanges << QString(dummy);
        ListOfOldStates << QString(dummy);
        if (lines[lineno].color != GetOptionChoice(lines_color_item))
        {
            changes=true;
        }
        sprintf(dummy,"    line color %d",GetOptionChoice(lines_color_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line color %d",lines[lineno].color);
        ListOfOldStates << QString(dummy);
        //}
        if (lines[lineno].loctype != lines_loc_item->currentValue())
        {
            changes=true;
        }
        sprintf(dummy,"    line loctype %s",!lines_loc_item->currentValue()?"view":"world");
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line loctype %s",!lines[lineno].loctype?"view":"world");
        ListOfOldStates << QString(dummy);
        //}
        if (lines[lineno].lines != GetOptionChoice(lines_style_item))
        {
            changes=true;
        }
        sprintf(dummy,"    line linestyle %d",GetOptionChoice(lines_style_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line linestyle %d",lines[lineno].lines);
        ListOfOldStates << QString(dummy);
        //}
        if (lines[lineno].linew != GetSpinChoice(lines_width_item))
        {
            changes=true;
        }
        sprintf(dummy,"    line linewidth %f",GetSpinChoice(lines_width_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line linewidth %f",lines[lineno].linew);
        ListOfOldStates << QString(dummy);
        //}
        if (lines[lineno].arrow_end != GetChoice(lines_arrow_item))
        {
            changes=true;
        }
        sprintf(dummy,"    line arrow %d",GetChoice(lines_arrow_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line arrow %d",lines[lineno].arrow_end);
        ListOfOldStates << QString(dummy);
        //}
        if (lines[lineno].arrow.type != GetChoice(lines_atype_item))
        {
            changes=true;
        }
        sprintf(dummy,"    line arrow type %d",GetChoice(lines_atype_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line arrow type %d",lines[lineno].arrow.type);
        ListOfOldStates << QString(dummy);
        //}
        if (lines[lineno].arrow.length != GetSpinChoice(lines_asize_item))
        {
            changes=true;
        }
        sprintf(dummy,"    line arrow length %f",GetSpinChoice(lines_asize_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line arrow length %f",lines[lineno].arrow.length);
        ListOfOldStates << QString(dummy);
        //}
        if (lines[lineno].arrow.dL_ff != GetSpinChoice(lines_a_dL_ff_item) || lines[lineno].arrow.lL_ff != GetSpinChoice(lines_a_lL_ff_item))
        {
            changes=true;
        }
        sprintf(dummy,"    line arrow layout %f, %f",GetSpinChoice(lines_a_dL_ff_item),GetSpinChoice(lines_a_lL_ff_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line arrow layout %f, %f",lines[lineno].arrow.dL_ff,lines[lineno].arrow.lL_ff);
        ListOfOldStates << QString(dummy);
        //}
        if (lines[lineno].alpha != lines_color_item->alpha())
        {
            changes=true;
        }
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: LINE %d ALPHA %d\n",lineno,lines_color_item->alpha());
        ListOfChanges << QString(dummy);
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: LINE %d ALPHA %d\n",lineno,lines[lineno].alpha);
        ListOfOldStates << QString(dummy);
        if (lines[lineno].x1!=k[0] || lines[lineno].y1!=k[1] || lines[lineno].x2!=k[2] || lines[lineno].y2!=k[3])
        {
            changes=true;
        }
        sprintf(dummy,"    line %f, %f, %f, %f",k[0],k[1],k[2],k[3]);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    line %f, %f, %f, %f",lines[lineno].x1,lines[lineno].y1,lines[lineno].x2,lines[lineno].y2);
        ListOfOldStates << QString(dummy);
        //}
        //if (ListOfChanges.size()>1)
        //{
        ListOfChanges << QString("    line on");
        ListOfChanges << QString("line def");
        ListOfOldStates << QString("    line on");
        ListOfOldStates << QString("line def");
        //}
        lines[lineno].color = GetOptionChoice(lines_color_item);
        lines[lineno].alpha = lines_color_item->alpha();
        lines[lineno].loctype = lines_loc_item->currentValue();
        lines[lineno].lines = GetOptionChoice(lines_style_item);
        lines[lineno].linew = GetSpinChoice(lines_width_item);
        lines[lineno].arrow_end = GetChoice(lines_arrow_item);
        lines[lineno].arrow.type = GetChoice(lines_atype_item);
        lines[lineno].arrow.length = GetSpinChoice(lines_asize_item);
        lines[lineno].arrow.dL_ff = GetSpinChoice(lines_a_dL_ff_item);
        lines[lineno].arrow.lL_ff = GetSpinChoice(lines_a_lL_ff_item);
        lines[lineno].x1=k[0];
        lines[lineno].y1=k[1];
        lines[lineno].x2=k[2];
        lines[lineno].y2=k[3];
        ObjectDataModified(lineno,OBJECT_LINE);
        set_dirtystate();
        if (GlobalInhibitor==false)
            mainWin->mainArea->completeRedraw();
        if (changes==false)
        {
            ListOfChanges.clear();
            ListOfOldStates.clear();
        }
    }
    set_action(action_flag);
}

void frmLine_Props::doClose(void)
{
    parentWidget()->hide();
    set_action(action_flag);
}

void frmLine_Props::update0(void)
{
    static int i,nr;//,errpos;
    if (!immediateUpdate) return;
    bool sav_im_up;
    sav_im_up=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    GlobalInhibitor=true;
    doAccept();//do this without actually doing something
    nr=nr_of_true_changes(ListOfChanges);
    //errpos=0;
    if (nr>0)
    {
        for (i=0;i<ListOfChanges.size();i++)
        {
            strcpy(command,ListOfChanges.at(i).toLocal8Bit().constData());
            //errpos = scanner(command);
            (void)scanner(command);
        }
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
    }
    ListOfChanges.clear();
    ListOfOldStates.clear();
    GlobalInhibitor=false;
    immediateUpdate=sav_im_up;
    updateRunning=false;
}

void frmLine_Props::update1(int v)
{
    (void)v;
    update0();
}

void frmLine_Props::update2(QString v)
{
    (void)v;
    update0();
}

void frmLine_Props::update3(bool v)
{
    (void)v;
    update0();
}

void frmLine_Props::update4(double v)
{
    (void)v;
    update0();
}

frmLineProps::frmLineProps(QWidget * parent,bool edit):QDialog(parent)
{
//setFont(*stdFont);
    if (edit)
    setWindowTitle(tr("Edit Line"));
    else
    setWindowTitle(tr("Lines"));
    setWindowIcon(QIcon(*GraceIcon));

    QVBoxLayout * layout=new QVBoxLayout;
    layout->setMargin(0);
    layout->setSpacing(0);
    flp=new frmLine_Props(this,edit);
    layout->addWidget(flp);
    setLayout(layout);
    if (edit)
    resize(LastSize_EditLineProps);
    else
    resize(LastSize_LineProps);
}

frmLineProps::~frmLineProps()
{
    if (flp->editWindow)
    LastSize_EditLineProps=this->size();
    else
    LastSize_LineProps=this->size();
}

void frmLineProps::init(int id)
{
    flp->init(id);
}

void frmLineProps::doAccept(void)
{
    flp->doAccept();
}

void frmLineProps::doClose(void)
{
    //flp->doClose();
    hide();
}

frmEllipse_Props::frmEllipse_Props(QWidget * parent,bool edit,bool ellip):QWidget(parent)
{
    obj_id=-1;//invalid id!! call init!!
    //setFont(*stdFont);
    //setWindowIcon(QIcon(*GraceIcon));
    editWindow=edit;
    ellipse=ellip;
    /*if (edit)
{
    if (ellipse)
    setWindowTitle(tr("Edit ellipse"));
    else
    setWindowTitle(tr("Edit box"));
}
else
{
    if (ellipse)
    setWindowTitle(tr("Ellipses"));
    else
    setWindowTitle(tr("Boxes"));
}*/
    ellip_color_item=new ColorSelector(this);
    ellip_linew_item=new LineWidthSelector(this);
    ellip_lines_item=new LineStyleSelector(this);
    ellip_fillpat_item=new FillPatternSelector(this);
    ellip_fillcol_item=new ColorSelector(this);
    ellip_loc_item=new PositionSelector(this);
    ellip_rot_item=new stdSlider(this,tr("Rotation"),0,180);
    buttonGroup=new stdButtonGroup(this,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(ellip_color_item);
    layout->addWidget(ellip_linew_item);
    layout->addWidget(ellip_lines_item);
    layout->addWidget(ellip_fillpat_item);
    layout->addWidget(ellip_fillcol_item);
    layout->addWidget(ellip_loc_item);
    layout->addWidget(ellip_rot_item);
    if (edit)
    {//I will not use these for immediate updates!
        if (ellipse)//Ellipse
        {
            ledCoords[0]=new stdLineEdit(this,tr("Xcentre="));
            layout->addWidget(ledCoords[0]);
            ledCoords[1]=new stdLineEdit(this,tr("Ycentre="));
            layout->addWidget(ledCoords[1]);
            ledCoords[2]=new stdLineEdit(this,tr("Width="));
            layout->addWidget(ledCoords[2]);
            ledCoords[3]=new stdLineEdit(this,tr("Height="));
            layout->addWidget(ledCoords[3]);
        }
        else//box
        {
            ledCoords[0]=new stdLineEdit(this,tr("Xmin="));
            layout->addWidget(ledCoords[0]);
            ledCoords[1]=new stdLineEdit(this,tr("Ymin="));
            layout->addWidget(ledCoords[1]);
            ledCoords[2]=new stdLineEdit(this,tr("Xmax="));
            layout->addWidget(ledCoords[2]);
            ledCoords[3]=new stdLineEdit(this,tr("Ymax="));
            layout->addWidget(ledCoords[3]);
        }
        ellip_rot_item->setVisible(true);
    }
    else
        ellip_rot_item->setVisible(false);

    layout->addWidget(buttonGroup);
    setLayout(layout);

    ellip_color_item->setCurrentIndex(1);
    ellip_lines_item->setCurrentIndex(1);
    ellip_fillcol_item->setCurrentIndex(1);
    ellip_loc_item->setCurrentIndex(1);
    ellip_linew_item->setValue(1.0);

    connect(ellip_color_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(ellip_color_item,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(ellip_linew_item,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(ellip_lines_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(ellip_fillpat_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(ellip_fillcol_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(ellip_fillcol_item,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(ellip_rot_item,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    //do not use the following for immediate updates!!
    //connect(ellip_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(ellip_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),SLOT(viewCoordsChanged(int)));
}

void frmEllipse_Props::init(int id)
{
    if ( (id>=number_of_boxes() && ellipse==false) || (id>=number_of_ellipses() && ellipse==true) || (id<0 && editWindow==true)) return;
    bool sav_imm_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    char buf[256];
    obj_id=id;
    disconnect(ellip_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
    if (editWindow==false)
    {
        if (ellipse==false)
        {
            SetOptionChoice(ellip_color_item, box_color);
            ellip_color_item->setAlpha(box_alpha);
            SetOptionChoice(ellip_lines_item, box_lines);
            SetSpinChoice(ellip_linew_item, box_linew);
            SetOptionChoice(ellip_fillpat_item, box_fillpat);
            SetOptionChoice(ellip_fillcol_item, box_fillcolor);
            ellip_fillcol_item->setAlpha(box_fillcolor);
            ellip_rot_item->setValue(0);
            ellip_loc_item->setCurrentIndex(box_loctype == COORD_VIEW ? 1 : 0);
        }
        else
        {
            SetOptionChoice(ellip_color_item, ellipse_color);
            ellip_color_item->setAlpha(ellipse_alpha);
            SetOptionChoice(ellip_lines_item, ellipse_lines);
            SetSpinChoice(ellip_linew_item, ellipse_linew);
            SetOptionChoice(ellip_fillpat_item, ellipse_fillpat);
            SetOptionChoice(ellip_fillcol_item, ellipse_fillcolor);
            ellip_fillcol_item->setAlpha(ellipse_fillalpha);
            ellip_rot_item->setValue(0);
            ellip_loc_item->setCurrentIndex(ellipse_loctype == COORD_VIEW ? 1 : 0);
        }
    }
    else
    {
        int ellipno =id;
        if (ellipse==true)
        {
            SetOptionChoice(ellip_color_item, ellip[ellipno].color);
            ellip_color_item->setAlpha(ellip[ellipno].alpha);
            SetOptionChoice(ellip_lines_item, ellip[ellipno].lines);
            SetSpinChoice(ellip_linew_item, ellip[ellipno].linew);
            SetOptionChoice(ellip_fillpat_item, ellip[ellipno].fillpattern);
            SetOptionChoice(ellip_fillcol_item, ellip[ellipno].fillcolor);
            ellip_fillcol_item->setAlpha(ellip[ellipno].fillalpha);
            ellip_rot_item->setValue(ellip[ellipno].rot);
            ellip_loc_item->setCurrentIndex(ellip[ellipno].loctype == COORD_VIEW ? 1 : 0);
            sprintf(buf, "%.12f", 0.5*(ellip[ellipno].x1+ellip[ellipno].x2));
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(ledCoords[0], buf);
            sprintf(buf, "%.12f", 0.5*(ellip[ellipno].y1+ellip[ellipno].y2));
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(ledCoords[1], buf);
            sprintf(buf, "%.12f", fabs(ellip[ellipno].x1-ellip[ellipno].x2) );
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(ledCoords[2], buf);
            sprintf(buf, "%.12f", fabs(ellip[ellipno].y1-ellip[ellipno].y2) );
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(ledCoords[3], buf);
        }
        else//box
        {
            SetOptionChoice(ellip_color_item, boxes[ellipno].color);
            ellip_color_item->setAlpha(boxes[ellipno].alpha);
            SetOptionChoice(ellip_lines_item, boxes[ellipno].lines);
            SetSpinChoice(ellip_linew_item, boxes[ellipno].linew);
            SetOptionChoice(ellip_fillpat_item, boxes[ellipno].fillpattern);
            SetOptionChoice(ellip_fillcol_item, boxes[ellipno].fillcolor);
            ellip_fillcol_item->setAlpha(boxes[ellipno].fillalpha);
            ellip_rot_item->setValue(boxes[ellipno].rot);
            ellip_loc_item->setCurrentIndex(boxes[ellipno].loctype == COORD_VIEW ? 1 : 0);
            sprintf(buf, "%.12f", boxes[ellipno].x1);
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(ledCoords[0], buf);
            sprintf(buf, "%.12f", boxes[ellipno].y1);
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(ledCoords[1], buf);
            sprintf(buf, "%.12f", boxes[ellipno].x2);
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(ledCoords[2], buf);
            sprintf(buf, "%.12f", boxes[ellipno].y2);
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(ledCoords[3], buf);
        }
    }
    connect(ellip_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
    immediateUpdate=sav_imm_upd;
    updateRunning=false;
}

void frmEllipse_Props::viewCoordsChanged(int i)
{
    (void)i;
    if (editWindow==false) return;//there are no coordinates visible --> nothing to do
    int boxno = obj_id;
    int ellipno = obj_id;
    double x1, x2, y1, y2;
    bool old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    if (ellipse==false)//it is a box
    {
        if( ellip_loc_item->currentValue() == boxes[boxno].loctype )
        {
            return;
        }

        xv_evalexpr(ledCoords[0], &x1);
        xv_evalexpr(ledCoords[2], &x2);
        xv_evalexpr(ledCoords[1], &y1);
        xv_evalexpr(ledCoords[3], &y2);

        if( boxes[boxno].loctype == COORD_VIEW )
        {
            boxes[boxno].gno = get_cg();
            boxes[boxno].loctype = COORD_WORLD;
            //view2world( atof(xv_getstr(ledCoords[0])), atof(xv_getstr(ledCoords[1])),&boxes[boxno].x1,&boxes[boxno].y1 );
            //view2world( atof(xv_getstr(ledCoords[2])), atof(xv_getstr(ledCoords[3])),&boxes[boxno].x2,&boxes[boxno].y2 );
            view2world( x1,y1,&boxes[boxno].x1,&boxes[boxno].y1 );
            view2world( x2,y2,&boxes[boxno].x2,&boxes[boxno].y2 );
        }
        else
        {
            boxes[boxno].loctype = COORD_VIEW;
            //world2view( atof(xv_getstr(ledCoords[0])), atof(xv_getstr(ledCoords[1])),&boxes[boxno].x1,&boxes[boxno].y1 );
            //world2view( atof(xv_getstr(ledCoords[2])), atof(xv_getstr(ledCoords[3])),&boxes[boxno].x2,&boxes[boxno].y2 );
            world2view( x1,y1,&boxes[boxno].x1,&boxes[boxno].y1 );
            world2view( x2,y2,&boxes[boxno].x2,&boxes[boxno].y2 );
        }
    }//end of it is a box
    else
    {//it is an ellipse
        if(ellip_loc_item->currentValue() == ellip[ellipno].loctype)
        {
            return;
        }
        xv_evalexpr(ledCoords[0], &x1);
        xv_evalexpr(ledCoords[2], &x2);
        xv_evalexpr(ledCoords[1], &y1);
        xv_evalexpr(ledCoords[3], &y2);

        if( ellip[ellipno].loctype == COORD_VIEW ) {
            ellip[ellipno].gno = get_cg();
            ellip[ellipno].loctype = COORD_WORLD;
            view2world( x1-x2/2., y1-y2/2., &ellip[ellipno].x1,&ellip[ellipno].y1 );
            view2world( x1+x2/2., y1+y2/2., &ellip[ellipno].x2,&ellip[ellipno].y2 );
        } else {
            ellip[ellipno].loctype = COORD_VIEW;
            world2view( x1-x2/2., y1-y2/2., &ellip[ellipno].x1,&ellip[ellipno].y1 );
            world2view( x1+x2/2., y1+y2/2., &ellip[ellipno].x2,&ellip[ellipno].y2 );
        }
    }
    init(obj_id);
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmEllipse_Props::doAccept(void)
{
    int ellipno = obj_id;
    double a, b, c, d;
    bool changes=false;
    ListOfChanges.clear();
    ListOfOldStates.clear();
    if (editWindow==false)//edit preferences
    {
        if (ellipse==true)
        {
            ellipse_color = GetOptionChoice(ellip_color_item);
            ellipse_alpha = ellip_color_item->alpha();
            ellipse_loctype = ellip_loc_item->currentValue();
            ellipse_lines = GetOptionChoice(ellip_lines_item);
            ellipse_linew = GetSpinChoice(ellip_linew_item);
            ellipse_fillcolor = GetOptionChoice(ellip_fillcol_item);
            ellipse_fillalpha = ellip_fillcol_item->alpha();
            ellipse_fillpat = GetOptionChoice(ellip_fillpat_item);
        }
        else
        {
            box_color = GetOptionChoice(ellip_color_item);
            box_alpha = ellip_color_item->alpha();
            box_loctype = ellip_loc_item->currentValue();
            box_lines = GetOptionChoice(ellip_lines_item);
            box_linew = GetSpinChoice(ellip_linew_item);
            box_fillcolor = GetOptionChoice(ellip_fillcol_item);
            box_fillalpha = ellip_fillcol_item->alpha();
            box_fillpat = GetOptionChoice(ellip_fillpat_item);
        }
    }
    else//edit Object
    {

        if (xv_evalexpr(ledCoords[0], &a ) != RETURN_SUCCESS ||
                xv_evalexpr(ledCoords[2], &b ) != RETURN_SUCCESS ||
                xv_evalexpr(ledCoords[1], &c ) != RETURN_SUCCESS ||
                xv_evalexpr(ledCoords[3], &d ) != RETURN_SUCCESS ) {
            return;
        }
        if (ellipse==true)//it's an ellipse
        {
            SaveObjectData(ellipno,OBJECT_ELLIPSE);
            sprintf(dummy,"with ellipse %d",ellipno);
            ListOfChanges << QString(dummy);
            ListOfOldStates << QString(dummy);
            if (ellip[ellipno].color != GetOptionChoice(ellip_color_item))
            {
                changes=true;
            }
            sprintf(dummy,"    ellipse color %d",GetOptionChoice(ellip_color_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    ellipse color %d",ellip[ellipno].color);
            ListOfOldStates << QString(dummy);
            //}
            if (ellip[ellipno].loctype != ellip_loc_item->currentValue())
            {
                changes=true;
            }
            sprintf(dummy,"    ellipse loctype %s",!ellip_loc_item->currentValue()?"view":"world");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    ellipse loctype %s",!ellip[ellipno].loctype?"view":"world");
            ListOfOldStates << QString(dummy);
            //}
            if (ellip[ellipno].lines != GetOptionChoice(ellip_lines_item))
            {
                changes=true;
            }
            sprintf(dummy,"    ellipse linestyle %d",GetOptionChoice(ellip_lines_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    ellipse linestyle %d",ellip[ellipno].lines);
            ListOfOldStates << QString(dummy);
            //}
            if (ellip[ellipno].linew != GetSpinChoice(ellip_linew_item))
            {
                changes=true;
            }
            sprintf(dummy,"    ellipse linewidth %f",GetSpinChoice(ellip_linew_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    ellipse linewidth %f",ellip[ellipno].linew);
            ListOfOldStates << QString(dummy);
            //}
            if (ellip[ellipno].fillcolor != GetOptionChoice(ellip_fillcol_item))
            {
                changes=true;
            }
            sprintf(dummy,"   ellipse fill color %d",GetOptionChoice(ellip_fillcol_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"   ellipse fill color %d",ellip[ellipno].fillcolor);
            ListOfOldStates << QString(dummy);
            //}
            if (ellip[ellipno].fillpattern != GetOptionChoice(ellip_fillpat_item))
            {
                changes=true;
            }
            sprintf(dummy,"    ellipse fill pattern %d",GetOptionChoice(ellip_fillpat_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    ellipse fill pattern %d",ellip[ellipno].fillpattern);
            ListOfOldStates << QString(dummy);
            //}
            if (ellip[ellipno].alpha != ellip_color_item->alpha() || ellip[ellipno].fillalpha != ellip_fillcol_item->alpha())
            {
                changes=true;
            }
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: ELLIPSE %d ALPHA %d %d\n",ellipno,ellip_color_item->alpha(),ellip_fillcol_item->alpha());
            ListOfChanges << QString(dummy);
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: ELLIPSE %d ALPHA %d %d\n",ellipno,ellip[ellipno].alpha,ellip[ellipno].fillalpha);
            ListOfOldStates << QString(dummy);
            if (ellip[ellipno].x1 != a - b/2. || ellip[ellipno].x2 != a + b/2. || ellip[ellipno].y1 != c - d/2. || ellip[ellipno].y2 != c + d/2.)
            {
                changes=true;
            }
            sprintf(dummy,"    ellipse %f, %f, %f, %f",a - b/2.,c - d/2.,a + b/2.,c + d/2.);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    ellipse %f, %f, %f, %f",ellip[ellipno].x1,ellip[ellipno].y1,ellip[ellipno].x2,ellip[ellipno].y2);
            ListOfOldStates << QString(dummy);
            //}
            //if (ListOfChanges.size()>1)
            //{
            ListOfChanges << QString("    ellipse on");
            ListOfChanges << QString("ellipse def");
            ListOfOldStates << QString("    ellipse on");
            ListOfOldStates << QString("ellipse def");
            //}
            if (changes==false)
            {
                ListOfOldStates.clear();
                ListOfChanges.clear();
            }
            ellip[ellipno].color = GetOptionChoice(ellip_color_item);
            ellip[ellipno].alpha = ellip_color_item->alpha();
            ellip[ellipno].loctype = ellip_loc_item->currentValue();
            ellip[ellipno].lines = GetOptionChoice(ellip_lines_item);
            ellip[ellipno].linew = GetSpinChoice(ellip_linew_item);
            ellip[ellipno].fillcolor = GetOptionChoice(ellip_fillcol_item);
            ellip[ellipno].fillalpha = ellip_fillcol_item->alpha();
            ellip[ellipno].fillpattern = GetOptionChoice(ellip_fillpat_item);
            ellip[ellipno].rot = ellip_rot_item->value();
            ellip[ellipno].x1 = a - b/2.;
            ellip[ellipno].x2 = a + b/2.;
            ellip[ellipno].y1 = c - d/2.;
            ellip[ellipno].y2 = c + d/2.;
            ObjectDataModified(ellipno,OBJECT_ELLIPSE);
        }
        else//it's a box
        {
            SaveObjectData(ellipno,OBJECT_BOX);
            sprintf(dummy,"with box %d",ellipno);
            ListOfChanges << QString(dummy);
            ListOfOldStates << QString(dummy);
            if (boxes[ellipno].color != GetOptionChoice(ellip_color_item))
            {
                changes=true;
            }
            sprintf(dummy,"    box color %d",GetOptionChoice(ellip_color_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    box color %d",boxes[ellipno].color);
            ListOfOldStates << QString(dummy);
            //}
            if (boxes[ellipno].loctype != ellip_loc_item->currentValue())
            {
                changes=true;
            }
            sprintf(dummy,"    box loctype %s",!ellip_loc_item->currentValue()?"view":"world");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    box loctype %s",!boxes[ellipno].loctype?"view":"world");
            ListOfOldStates << QString(dummy);
            //}
            if (boxes[ellipno].lines != GetOptionChoice(ellip_lines_item))
            {
                changes=true;
            }
            sprintf(dummy,"    box linestyle %d",GetOptionChoice(ellip_lines_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    box linestyle %d",boxes[ellipno].lines);
            ListOfOldStates << QString(dummy);
            //}
            if (boxes[ellipno].linew != GetSpinChoice(ellip_linew_item))
            {
                changes=true;
            }
            sprintf(dummy,"    box linewidth %f",GetSpinChoice(ellip_linew_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    box linewidth %f",boxes[ellipno].linew);
            ListOfOldStates << QString(dummy);
            //}
            if (boxes[ellipno].fillcolor != GetOptionChoice(ellip_fillcol_item))
            {
                changes=true;
            }
            sprintf(dummy,"   box fill color %d",GetOptionChoice(ellip_fillcol_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"   box fill color %d",boxes[ellipno].fillcolor);
            ListOfOldStates << QString(dummy);
            //}
            if (boxes[ellipno].fillpattern != GetOptionChoice(ellip_fillpat_item))
            {
                changes=true;
            }
            sprintf(dummy,"    box fill pattern %d",GetOptionChoice(ellip_fillpat_item));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    box fill pattern %d",boxes[ellipno].fillpattern);
            ListOfOldStates << QString(dummy);
            //}
            if (boxes[ellipno].alpha != ellip_color_item->alpha() || boxes[ellipno].fillalpha != ellip_fillcol_item->alpha())
            {
                changes=true;
            }
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: BOX %d ALPHA %d %d\n",ellipno,ellip_color_item->alpha(),ellip_fillcol_item->alpha());
            ListOfChanges << QString(dummy);
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: BOX %d ALPHA %d %d\n",ellipno,boxes[ellipno].alpha,boxes[ellipno].fillalpha);
            ListOfOldStates << QString(dummy);
            if (boxes[ellipno].x1 != a || boxes[ellipno].x2 != b || boxes[ellipno].y1 != c || boxes[ellipno].y2 != d)
            {
                changes=true;
            }
            sprintf(dummy,"    box %f, %f, %f, %f",a,c,b,d);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    box %f, %f, %f, %f",boxes[ellipno].x1,boxes[ellipno].y1,boxes[ellipno].x2,boxes[ellipno].y2);
            ListOfOldStates << QString(dummy);
            //}
            //if (ListOfChanges.size()>1)
            //{
            ListOfChanges << QString("    box on");
            ListOfChanges << QString("box def");
            ListOfOldStates << QString("    box on");
            ListOfOldStates << QString("box def");
            //}
            if (changes==false)
            {
                ListOfChanges.clear();
                ListOfOldStates.clear();
            }
            boxes[ellipno].color = GetOptionChoice(ellip_color_item);
            boxes[ellipno].alpha = ellip_color_item->alpha();
            boxes[ellipno].loctype = ellip_loc_item->currentValue();
            boxes[ellipno].lines = GetOptionChoice(ellip_lines_item);
            boxes[ellipno].linew = GetSpinChoice(ellip_linew_item);
            boxes[ellipno].fillcolor = GetOptionChoice(ellip_fillcol_item);
            boxes[ellipno].fillalpha = ellip_fillcol_item->alpha();
            boxes[ellipno].fillpattern = GetOptionChoice(ellip_fillpat_item);
            boxes[ellipno].rot = ellip_rot_item->value();
            boxes[ellipno].x1 = a;
            boxes[ellipno].x2 = b;
            boxes[ellipno].y1 = c;
            boxes[ellipno].y2 = d;
            ObjectDataModified(ellipno,OBJECT_BOX);
        }
        set_dirtystate();
        if (GlobalInhibitor==false)
        {
            mainWin->mainArea->completeRedraw();
            ListOfChanges.clear();
            ListOfOldStates.clear();
        }
    }
    set_action(action_flag);
}

void frmEllipse_Props::doClose(void)
{
    parentWidget()->hide();
    set_action(action_flag);
}

void frmEllipse_Props::update0(void)
{
    static int i,nr;//errpos;
    static int sav_settings_i[14];
    static double sav_settings_d[2];
    bool imm_upd_sav;
    if (!immediateUpdate) return;
    imm_upd_sav=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    GlobalInhibitor=true;
    doAccept();//do this without actually doing something
    nr=nr_of_true_changes(ListOfChanges);
    //errpos=0;
    if (nr>0)
    {
        sav_settings_i[0]=ellipse_color;
        sav_settings_i[1]=ellipse_loctype;
        sav_settings_i[2]=ellipse_lines;
        sav_settings_d[0]=ellipse_linew;
        sav_settings_i[3]=ellipse_fillcolor;
        sav_settings_i[4]=ellipse_fillpat;
        sav_settings_i[5]=box_color;
        sav_settings_i[6]=box_loctype;
        sav_settings_i[7]=box_lines;
        sav_settings_d[1]=box_linew;
        sav_settings_i[8]=box_fillcolor;
        sav_settings_i[9]=box_fillpat;
        sav_settings_i[10]=ellipse_alpha;
        sav_settings_i[11]=ellipse_fillalpha;
        sav_settings_i[12]=box_alpha;
        sav_settings_i[13]=box_fillalpha;

        for (i=0;i<ListOfChanges.size();i++)
        {
            strcpy(command,ListOfChanges.at(i).toLocal8Bit().constData());
            //errpos = scanner(command);
            (void)scanner(command);
        }
        set_dirtystate();

        ellipse_color=sav_settings_i[0];
        ellipse_loctype=sav_settings_i[1];
        ellipse_lines=sav_settings_i[2];
        ellipse_linew=sav_settings_d[0];
        ellipse_fillcolor=sav_settings_i[3];
        ellipse_fillpat=sav_settings_i[4];
        box_color=sav_settings_i[5];
        box_loctype=sav_settings_i[6];
        box_lines=sav_settings_i[7];
        box_linew=sav_settings_d[1];
        box_fillcolor=sav_settings_i[8];
        box_fillpat=sav_settings_i[9];
        ellipse_alpha=sav_settings_i[10];
        ellipse_fillalpha=sav_settings_i[11];
        box_alpha=sav_settings_i[12];
        box_fillalpha=sav_settings_i[13];
    }
    mainWin->mainArea->completeRedraw();
    ListOfChanges.clear();
    ListOfOldStates.clear();
    GlobalInhibitor=false;
    immediateUpdate=imm_upd_sav;
    updateRunning=false;
}

void frmEllipse_Props::update1(int v)
{
    (void)v;
    update0();
}

void frmEllipse_Props::update2(QString v)
{
    (void)v;
    update0();
}

void frmEllipse_Props::update3(bool v)
{
    (void)v;
    update0();
}

void frmEllipse_Props::update4(double v)
{
    (void)v;
    update0();
}

frmEllipseProps::frmEllipseProps(QWidget * parent,bool edit,bool ellip):QDialog(parent)
{
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    QVBoxLayout * layout=new QVBoxLayout;
    layout->setMargin(0);
    layout->setSpacing(0);
    flp=new frmEllipse_Props(this,edit,ellip);
    layout->addWidget(flp);
    setLayout(layout);
    if (edit)
    {
        if (ellip)
        {
            setWindowTitle(tr("Edit ellipse"));
            resize(LastSize_EditEllipseProps);
        }
        else
        {
            setWindowTitle(tr("Edit box"));
            resize(LastSize_EditBoxProps);
        }
    }
    else
    {
        if (ellip)
        {
            setWindowTitle(tr("Ellipses"));
            resize(LastSize_EllipseProps);
        }
        else
        {
            setWindowTitle(tr("Boxes"));
            resize(LastSize_BoxProps);
        }
    }
}

frmEllipseProps::~frmEllipseProps()
{
    if (flp->editWindow)
    {
        if (flp->ellipse)
            LastSize_EditEllipseProps=this->size();
        else
            LastSize_EditBoxProps=this->size();
    }
    else
    {
        if (flp->ellipse)
            LastSize_EllipseProps=this->size();
        else
            LastSize_BoxProps=this->size();
    }
}

void frmEllipseProps::init(int id)
{
    flp->init(id);
}

void frmEllipseProps::doAccept(void)
{
    flp->doAccept();
}

void frmEllipseProps::doClose(void)
{
    //flp->doClose();
    hide();
}

frmPointExplorer::frmPointExplorer(QWidget * parent):QDialog(parent)
{
    int minwidth=72;
    track_setno=-1;
    gno=sno=loc_pos=-1;//invalid
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Point explorer"));
    setWindowIcon(QIcon(*GraceIcon));

    lblInstructions=new QLabel(tr("Point explorer"),this);
    lblInstructions->setFrameStyle(QFrame::Box | QFrame::Raised);
    lblRestrToSet=new QLabel(tr("Restrict to set:"),this);
    list=new uniList(SETLIST,this);
    list->setBehavior(true,false,false);
    list->set_graph_number(get_cg(),false);
    list->update_number_of_entries();
    list->setGeometry(0,0,400,80);
    connect(list,SIGNAL(new_selection(int)),SLOT(selectionChanged(int)));
    ledPointLocation=new stdLineEdit(this,tr("Point location:"));
    ledPointLocation->lenText->setText(QString(""));
    ledPointData=new stdLineEdit(this,tr("Point data:"));
    ledPointData->lenText->setText(QString(""));

    grpButtons=new QGroupBox(this);
    layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);

    cmdGoTo=new QPushButton(tr("Goto point"),this);
    connect(cmdGoTo,SIGNAL(clicked()),SLOT(doGoTo()));
    cmdTrack=new QPushButton(tr("Track"),this);
    cmdTrack->setMinimumWidth(minwidth);
    connect(cmdTrack,SIGNAL(clicked()),SLOT(doTrack()));
    cmdMove=new QPushButton(tr("Move"),this);
    cmdMove->setMinimumWidth(minwidth);
    connect(cmdMove,SIGNAL(clicked()),SLOT(doMove()));
    cmdMoveX=new QPushButton(tr("Move X"),this);
    cmdMoveX->setMinimumWidth(minwidth);
    connect(cmdMoveX,SIGNAL(clicked()),SLOT(doMoveX()));
    cmdMoveY=new QPushButton(tr("Move Y"),this);
    cmdMoveY->setMinimumWidth(minwidth);
    connect(cmdMoveY,SIGNAL(clicked()),SLOT(doMoveY()));
    cmdPrepend=new QPushButton(tr("Prepend"),this);
    cmdPrepend->setMinimumWidth(minwidth);
    connect(cmdPrepend,SIGNAL(clicked()),SLOT(doPrepend()));
    cmdAppend=new QPushButton(tr("Append"),this);
    cmdAppend->setMinimumWidth(minwidth);
    connect(cmdAppend,SIGNAL(clicked()),SLOT(doAppend()));
    cmdInsert=new QPushButton(tr("Insert"),this);
    cmdInsert->setMinimumWidth(minwidth);
    connect(cmdInsert,SIGNAL(clicked()),SLOT(doInsert()));
    cmdDelete=new QPushButton(tr("Delete"),this);
    cmdDelete->setMinimumWidth(minwidth);
    connect(cmdDelete,SIGNAL(clicked()),SLOT(doDelete()));
    cmdClose=new QPushButton(tr("Close"),this);
    cmdClose->setMinimumWidth(minwidth);
    connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    layout1->addWidget(cmdTrack);
    layout1->addWidget(cmdMove);
    layout1->addWidget(cmdMoveX);
    layout1->addWidget(cmdMoveY);
    layout1->addWidget(cmdPrepend);
    layout1->addWidget(cmdAppend);
    layout1->addWidget(cmdInsert);
    layout1->addWidget(cmdDelete);
    layout1->addWidget(cmdClose);

    for (int i=0;i<9;i++)
        layout1->setStretch(i,1);
    grpButtons->setLayout(layout1);

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(lblInstructions,0,0,1,2);
    layout->addWidget(lblRestrToSet,1,0,1,2);
    layout->addWidget(list,2,0,3,2);
    layout->addWidget(ledPointLocation,5,0,1,1);
    layout->addWidget(cmdGoTo,5,1,1,1);
    layout->addWidget(ledPointData,6,0,1,2);
    layout->addWidget(grpButtons,7,0,1,2);
    for (int i=0;i<2;i++)
        layout->setRowStretch(i,0);
    layout->setRowStretch(2,1);
    setLayout(layout);
    resize(LastSize_FormPointExplorer);
}

frmPointExplorer::~frmPointExplorer()
{
    LastSize_FormPointExplorer=this->size();
}

void frmPointExplorer::selectionChanged(int a)
{
    (void)a;
    int count;
    int * numbers=new int[2];
    list->get_selection(&count,&numbers);
    if (count >= 1) {
        track_setno = numbers[0];
    } else {
        ;
        //track_setno = -1;
    }
    delete[] numbers;
}

void frmPointExplorer::init(void)
{
    list->set_graph_number(get_cg(),false);
    list->update_number_of_entries();
    lblInstructions->setText(tr("Point explorer"));
}

void frmPointExplorer::doGoTo(void)
{
    int * selection=new int[3];
    int number;
    list->get_selection(&number,&selection);
    if (number!=1)
        return;
    else
        track_setno=selection[0];
    int ind;
    WPoint wp;
    VPoint vp;
    xv_evalexpri(ledPointLocation, &ind);
    if (get_point(cg, track_setno, ind, &wp) == RETURN_SUCCESS)
    {
        gno=cg;
        sno=track_setno;
        loc_pos=ind;
        update_point_locator(cg,track_setno,ind);
        vp = Wpoint2Vpoint(wp);
        setpointer(vp);
    }
    else
    {
        SetTextString(ledPointData, QString("").toLocal8Bit().data());
        errmsg(tr("Point index out of range").toLocal8Bit().constData());
    }
}

void frmPointExplorer::doTrack(void)
{
    if (action_flag==TRACKER)
    {
    set_action(DO_NOTHING);
    }
    else
    {
    int * selection=new int[3];
    int number;
    list->get_selection(&number,&selection);
    if (number!=1)
        return;
    else
        track_setno=selection[0];
    set_action(DO_NOTHING);
    SetLabel(lblInstructions, tr("Track points").toLocal8Bit().data());
    set_action(TRACKER);
    }
}

void frmPointExplorer::update_point_locator(int g_no, int setno, int loc)
{
    int col, ncols;
    Datapoint dpoint;
    char *s=new char[512], buf[64];
    if (get_datapoint(g_no, setno, loc, &ncols, &dpoint) == RETURN_SUCCESS)
    {
        SelectListChoice(list,setno);
        gno=g_no;
        sno=setno;
        loc_pos=loc;
        //s = copy_string(NULL, "(");
        strcpy(s,"(");
        for (col = 0; col < ncols; col++)
        {
            sprintf(buf, "%g", dpoint.ex[col]);
            SetDecimalSeparatorToUserValue(buf);
            //s = concat_strings(s, buf);
            strcat(s,buf);
            if (col != ncols - 1)
            {
                //s = concat_strings(s, ", ");
                if (DecimalPointToUse=='.')
                    strcat(s,", ");
                else//','
                    strcat(s," | ");
            }
        }
        if (dpoint.s != NULL)
        {
            if (DecimalPointToUse=='.')
                strcat(s,",\"");
            else
                strcat(s," | \"");

            strcat(s,dpoint.s);
            strcat(s,"\"");
            //s = concat_strings(s, ", \"");
            //s = concat_strings(s, dpoint.s);
            //s = concat_strings(s, "\"");
        }
        //s = concat_strings(s, ")");
        strcat(s,")");
        SetTextString(ledPointData, s);
        //xfree(s);
        sprintf(buf, "%d", loc);
        xv_setstr(ledPointLocation, buf);
        track_setno=setno;
    }
    else
    {
        track_setno = -1;
        ///SelectListChoices(track_set_sel, 0, NULL);
        SelectListChoices(list,0,NULL);
        SetTextString(ledPointData, QString("").toLocal8Bit().data());
        xv_setstr(ledPointLocation, QString("").toLocal8Bit().data());
    }
}

void frmPointExplorer::doMove(void)
{
    set_action(DO_NOTHING);
    track_move_dir = MOVE_POINT_XY;
    SetLabel(lblInstructions, tr("Move points").toLocal8Bit().data());
    set_action(MOVE_POINT1ST);
    selectionChanged(0);
}

void frmPointExplorer::doMoveX(void)
{
    set_action(DO_NOTHING);
    track_move_dir = MOVE_POINT_X;
    SetLabel(lblInstructions, tr("Move points along x").toLocal8Bit().data());
    set_action(MOVE_POINT1ST);
    selectionChanged(0);
}

void frmPointExplorer::doMoveY(void)
{
    set_action(DO_NOTHING);
    track_move_dir = MOVE_POINT_Y;
    SetLabel(lblInstructions, tr("Move points along y").toLocal8Bit().data());
    set_action(MOVE_POINT1ST);
    selectionChanged(0);
}

void frmPointExplorer::doPrepend(void)
{
    set_action(DO_NOTHING);
    track_add_at = ADD_POINT_BEGINNING;
    SetLabel(lblInstructions, tr("Add points at the beginning of set").toLocal8Bit().data());
    set_action(ADD_POINT);
    selectionChanged(0);
}

void frmPointExplorer::doAppend(void)
{
    set_action(DO_NOTHING);
    track_add_at = ADD_POINT_END;
    SetLabel(lblInstructions, tr("Add points to the end of set").toLocal8Bit().data());
    set_action(ADD_POINT);
    selectionChanged(0);
}

void frmPointExplorer::doInsert(void)
{
    set_action(DO_NOTHING);
    track_add_at = ADD_POINT_NEAREST;
    SetLabel(lblInstructions, tr("Add points to the nearest position").toLocal8Bit().data());
    set_action(ADD_POINT);
    selectionChanged(0);
}

void frmPointExplorer::doDelete(void)
{
    set_action(DO_NOTHING);
    SetLabel(lblInstructions, tr("Delete points").toLocal8Bit().data());
    set_action(DEL_POINT);
    selectionChanged(0);
}

void frmPointExplorer::doClose(void)
{
    set_action(DO_NOTHING);
    hide();
}

frmText_Props::frmText_Props(QWidget * parent,bool edit):QWidget(parent)
{
    obj_id=-1;
    editWindow=edit;
    /*setFont(*stdFont);
if (edit)
setWindowTitle(tr("Edit String"));
else
setWindowTitle(tr("Strings"));
setWindowIcon(QIcon(*GraceIcon));*/

    strings_font_item=new FontSelector(this);
    strings_color_item=new ColorSelector(this);
    strings_just_item=new JustificationSelector(this);
    strings_loc_item=new PositionSelector(this);
    strings_rot_item=new stdSlider(this,tr("Rotation"),0,360);
    strings_size_item=new stdSlider(this,tr("Size"),0,1000);
    buttonGroup=new stdButtonGroup(this,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    if (edit)
    {
        string_item=new stdLineEdit(this,QString("String:"),true);
        layout->addWidget(string_item);
        layout->addWidget(strings_color_item);
        layout->addWidget(strings_font_item);
    }
    else//properties in general
    {
        layout->addWidget(strings_font_item);
        layout->addWidget(strings_color_item);
    }
    layout->addWidget(strings_just_item);
    layout->addWidget(strings_loc_item);
    if (edit)
    {
        ledCoords[0]=new stdLineEdit(this,QString("X="));
        layout->addWidget(ledCoords[0]);
        ledCoords[1]=new stdLineEdit(this,QString("Y="));
        layout->addWidget(ledCoords[1]);
    }
    else
    {
        ledCoords[0]=NULL;
        ledCoords[1]=NULL;
    }
    layout->addWidget(strings_rot_item);
    layout->addWidget(strings_size_item);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    strings_size_item->setValue(100);
    strings_color_item->setCurrentIndex(1);
    strings_loc_item->setCurrentIndex(1);
    if (edit)
        connect(string_item->lenText,SIGNAL(returnPressed()),SLOT(update0()));
    connect(strings_font_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(strings_color_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(strings_color_item,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(strings_just_item->cmbJustSelect,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(strings_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    if (edit)
    {
        for (int i=0;i<2;i++)
            connect(ledCoords[i]->lenText,SIGNAL(returnPressed()),SLOT(update0()));
    }
    connect(strings_rot_item,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(strings_size_item,SIGNAL(valueChanged(int)),SLOT(update1(int)));

    connect(strings_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
}

void frmText_Props::init(int id)
{
    if (id>=number_of_strings() || (id<0 && editWindow==true)) return;
    bool sav_imm_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    char buf[1024];
    plotstr *pstring;
    obj_id=id;
    disconnect(strings_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
    if (editWindow==false)
    {
        SetOptionChoice(strings_font_item, string_font);
        SetOptionChoice(strings_color_item, string_color);
        strings_color_item->setAlpha(string_alpha);
        SetCharSizeChoice(strings_size_item, string_size*100);
        SetAngleChoice(strings_rot_item, string_rot);
        strings_loc_item->setCurrentIndex(string_loctype == COORD_VIEW ? 1 : 0);
        SetOptionChoice(strings_just_item, string_just);
    }
    else
    {
        pstring = &pstr[obj_id];
        //SetTextString(string_item, pstring->s);
        string_item->SetTextToMemory(pstring->s_plotstring,pstring->alt_plotstring);
        SetOptionChoice(strings_color_item, pstring->color);
        strings_color_item->setAlpha(pstring->alpha);
        SetOptionChoice(strings_just_item, pstring->just);
        SetOptionChoice(strings_font_item, pstring->font );
        SetCharSizeChoice(strings_size_item, pstring->charsize*100);
        SetAngleChoice(strings_rot_item, pstring->rot);
        strings_loc_item->setCurrentIndex(pstring->loctype == COORD_VIEW ? 1 : 0);
        sprintf(buf, "%.12f", pstring->x);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(ledCoords[0], buf);
        sprintf(buf, "%.12f", pstring->y);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(ledCoords[1], buf);
    }
    connect(strings_loc_item->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
    immediateUpdate=sav_imm_upd;
    updateRunning=false;
}

void frmText_Props::viewCoordsChanged(int i)
{
    (void)i;
    int stringno = obj_id;
    if (editWindow==false) return;
    bool old_upd=immediateUpdate;
    double d1,d2;
    immediateUpdate=false;
    updateRunning=true;
    xv_evalexpr(ledCoords[0],&d1);
    xv_evalexpr(ledCoords[1],&d2);
    if(pstr[stringno].loctype == strings_loc_item->currentValue())
    {
        return;
    }
    if( pstr[stringno].loctype == COORD_VIEW ) {
        pstr[stringno].gno = get_cg();
        pstr[stringno].loctype = COORD_WORLD;
        //view2world( atof(xv_getstr(ledCoords[0])),atof(xv_getstr(ledCoords[1])),&pstr[stringno].x,&pstr[stringno].y );
        view2world( d1,d2,&pstr[stringno].x,&pstr[stringno].y );
    }
    else
    {
        pstr[stringno].loctype = COORD_VIEW;
        //world2view( atof(xv_getstr(ledCoords[0])),atof(xv_getstr(ledCoords[1])),&pstr[stringno].x,&pstr[stringno].y );
        world2view( d1,d2,&pstr[stringno].x,&pstr[stringno].y );
    }
    init(obj_id);
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmText_Props::doAccept(void)
{
    if (editWindow==false)//edit preferences
    {
        string_font = GetOptionChoice(strings_font_item);
        string_color = GetOptionChoice(strings_color_item);
        string_alpha = strings_color_item->alpha();
        string_size = GetCharSizeChoice(strings_size_item)/100.0;
        string_rot = GetAngleChoice(strings_rot_item);
        string_loctype = GetChoice(strings_loc_item) ? COORD_VIEW : COORD_WORLD;
        string_just = GetOptionChoice(strings_just_item);
    }
    else
    {
        int stringno=obj_id;
        double d1,d2;
        int counter=0;
        bool changes=false;
        ListOfChanges.clear();
        ListOfOldStates.clear();
        sprintf(dummy,"with string %d",stringno);
        ListOfChanges << QString(dummy);
        ListOfOldStates << QString(dummy);
        if (pstr[stringno].active==false)
        {
            changes=true;
        }
        ListOfChanges << QString("    string on");
        ListOfOldStates << QString("    string off");
        counter++;
        //}
        if (pstr[stringno].color != GetOptionChoice(strings_color_item))
        {
            changes=true;
        }
        sprintf(dummy,"    string color %d",GetOptionChoice(strings_color_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    string color %d",pstr[stringno].color);
        ListOfOldStates << QString(dummy);
        counter++;
        //}
        if (pstr[stringno].loctype != (GetChoice(strings_loc_item)? COORD_VIEW : COORD_WORLD) )
        {
            changes=true;
        }
        sprintf(dummy,"    string loctype %s",GetChoice(strings_loc_item)?"view":"world");
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    string loctype %s",pstr[stringno].loctype?"view":"world");
        ListOfOldStates << QString(dummy);
        counter++;
        //}
        if (pstr[stringno].font != GetOptionChoice(strings_font_item))
        {
            changes=true;
        }
        sprintf(dummy,"    string font %d",GetOptionChoice(strings_font_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    string font %d",pstr[stringno].font);
        ListOfOldStates << QString(dummy);
        counter++;
        //}
        if (pstr[stringno].just != GetOptionChoice(strings_just_item))
        {
            changes=true;
        }
        sprintf(dummy,"    string just %d",GetOptionChoice(strings_just_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    string just %d",pstr[stringno].just);
        ListOfOldStates << QString(dummy);
        counter++;
        //}
        if (pstr[stringno].rot != GetAngleChoice(strings_rot_item))
        {
            changes=true;
        }
        sprintf(dummy,"    string rot %f",GetAngleChoice(strings_rot_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    string rot %d",pstr[stringno].rot);
        ListOfOldStates << QString(dummy);
        counter++;
        //}
        if (pstr[stringno].charsize != GetCharSizeChoice(strings_size_item)/100.0)
        {
            changes=true;
        }
        sprintf(dummy,"    string char size %f",GetCharSizeChoice(strings_size_item)/100.0);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    string char size %f",pstr[stringno].charsize);
        ListOfOldStates << QString(dummy);
        counter++;
        //}
        if (pstr[stringno].alpha != strings_color_item->alpha())
        {
            changes=true;
        }
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: STRING %d ALPHA %d\n",stringno,strings_color_item->alpha());
        ListOfChanges << QString(dummy);
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: STRING %d ALPHA %d\n",stringno,pstr[stringno].alpha);
        ListOfOldStates << QString(dummy);

        xv_evalexpr(ledCoords[0],&d1);
        xv_evalexpr(ledCoords[1],&d2);
        if (d1!=pstr[stringno].x || d2!=pstr[stringno].y)
        {
            changes=true;
        }
        sprintf(dummy,"    string %f, %f",d1,d2);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    string %f, %f",pstr[stringno].x,pstr[stringno].y);
        ListOfOldStates << QString(dummy);
        counter++;
        //}
        char * ch1,*ch2;
        ch1=pstr[stringno].alt_plotstring;//alt=original in UTF8
        ch2=GetTextString(string_item);
        if (!(ch1==NULL || ch2==NULL))
        {
            if (strcmp(ch1,ch2) || counter>0)
            {
                changes=true;
            }
        }
        else if (ch1!=ch2 || counter>0) changes=true;//counter is always >0 --> changes always==true
        sprintf(dummy,"    string def \"%s\"",GetTextString(string_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    string def \"%s\"",pstr[stringno].alt_plotstring);
        ListOfOldStates << QString(dummy);
        //}
        if (slider_status<=1)//this means: no slider action or slider just started to slide and we haven't saved the last state yet
        {
            //cout << "slider_status=" << slider_status << " saving settings" << endl;
            SaveObjectData(stringno,OBJECT_STRING);
            if (slider_status==1)//we saved the old state before slider action, no more saving dring slider action
            {
                slider_status=2;
                /*if (strings_rot_item->sldSlider->isSliderDown()==true)
                    {
                    slider_start_value=pstr[stringno].rot;//value before slider change
                    cout << "RotationChanged" << endl;
                    }
                    else if (strings_size_item->sldSlider->isSliderDown()==true)
                    {
                    slider_start_value=pstr[stringno].charsize;
                    cout << "CharSizeChanged" << endl;
                    }*/
            }
            else//slider_status=0;
            {
                strings_rot_item->old_value=strings_rot_item->value();
                strings_size_item->old_value=strings_size_item->value();
            }
        }
        /// do the actual changes
        string_item->DynSetMemoryToText(pstr[stringno].s_plotstring,pstr[stringno].alt_plotstring);
        //pstr[stringno].s = copy_string(pstr[stringno].s, GetTextString(string_item));
        pstr[stringno].color = GetOptionChoice(strings_color_item);
        pstr[stringno].alpha = strings_color_item->alpha();
        pstr[stringno].loctype = GetChoice(strings_loc_item) ? COORD_VIEW : COORD_WORLD;
        pstr[stringno].font = GetOptionChoice(strings_font_item);
        pstr[stringno].just = GetOptionChoice(strings_just_item);
        pstr[stringno].x=d1;
        pstr[stringno].y=d2;
        pstr[stringno].charsize = GetCharSizeChoice(strings_size_item)/100.0;
        pstr[stringno].rot = GetAngleChoice(strings_rot_item);
        /// finished doing the changes
        if (slider_status==0 || slider_status==3)//no slider action or the slider just stopped to slide
        {
            //cout << "slider status = " << slider_status << endl;
            if (slider_status==3)//slider action stopped
            {
                ListOfOldStates.clear();//during slider action only the slider values could have been changed
                sprintf(dummy,"with string %d",stringno);
                ListOfOldStates << QString(dummy);

                if (strings_rot_item->old_value!=strings_rot_item->value())
                {
                    //cout << "rotation changed: " << strings_rot_item->old_value << " --> " << strings_rot_item->value() << endl;
                    sprintf(dummy,"    string rot %d",strings_rot_item->old_value);
                    ListOfOldStates << QString(dummy);
                    strings_rot_item->old_value=strings_rot_item->value();
                    ObjectDataModified(stringno,OBJECT_STRING);
                }
                else if (strings_size_item->old_value!=strings_size_item->value())
                {
                    //cout << "char size changed: " << strings_size_item->old_value << " --> " << strings_size_item->value() << endl;
                    sprintf(dummy,"    string char size %f",strings_size_item->old_value/100.0);
                    ListOfOldStates << QString(dummy);
                    strings_size_item->old_value=strings_size_item->value();
                    ObjectDataModified(stringno,OBJECT_STRING);
                }
                /*if (strings_rot_item->sldSlider->isSliderDown()==true)
                {
                //slider_start_value=pstr[stringno].rot;//value before slider change
                cout << "RotationChanged" << endl;
                }
                else if (strings_size_item->sldSlider->isSliderDown()==true)
                {
                //slider_start_value=pstr[stringno].charsize;
                cout << "CharSizeChanged" << endl;
                }*/

            }
            else if (slider_status==0)
            {
                ObjectDataModified(stringno,OBJECT_STRING);
            }
            slider_status=0;//we saved the new settings of the string
        }
        set_dirtystate();
        if (GlobalInhibitor==false)
            mainWin->mainArea->completeRedraw();
        if (changes==false)
        {
            ListOfChanges.clear();
            ListOfOldStates.clear();
        }
    }
    set_action(action_flag);
}

void frmText_Props::doClose(void)
{
    parentWidget()->hide();
    set_action(action_flag);
}

//immediate updates
void frmText_Props::update0(void)
{
    static int i,nr;//,errpos;
    if (!immediateUpdate) return;
    GlobalInhibitor=true;
    ListOfChanges.clear();
    doAccept();//do this without actually doing something
    nr=nr_of_true_changes(ListOfChanges);
    //errpos=0;
    if (nr>0)
    {
        for (i=0;i<ListOfChanges.size();i++)
        {
            strcpy(command,ListOfChanges.at(i).toLocal8Bit().constData());
            //errpos = scanner(command);
            (void)scanner(command);
            if (ListOfChanges.at(i).contains(QString("string def")))
            {
                string_item->DynSetMemoryToText(pstr[obj_id].s_plotstring,pstr[obj_id].alt_plotstring);
            }
        }
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
    }
    ListOfChanges.clear();
    ListOfOldStates.clear();
    GlobalInhibitor=false;
}

void frmText_Props::update1(int v)
{
    (void)v;
    update0();
}

void frmText_Props::update2(QString v)
{
    (void)v;
    update0();
}

void frmText_Props::update3(bool v)
{
    (void)v;
    update0();
}

void frmText_Props::update4(double v)
{
    (void)v;
    update0();
}

frmTextProps::frmTextProps(QWidget * parent,bool edit):QDialog(parent)
{
//setFont(*stdFont);
    if (edit)
        setWindowTitle(tr("Edit String"));
    else
        setWindowTitle(tr("Strings"));
    setWindowIcon(QIcon(*GraceIcon));
    QVBoxLayout * layout=new QVBoxLayout;
    layout->setMargin(0);
    layout->setSpacing(0);
    flp=new frmText_Props(this,edit);
    layout->addWidget(flp);
    setLayout(layout);
    if (edit==true)
    {
        connect(flp->string_item,SIGNAL(NoMoreValidAdr()),SLOT(doClose()));
        resize(LastSize_EditTextProps);
    }
    else
    {
        resize(LastSize_TextProps);
    }
}

frmTextProps::~frmTextProps()
{
    if (flp->editWindow)
    LastSize_EditTextProps=this->size();
    else
    LastSize_TextProps=this->size();
}

void frmTextProps::init(int id)
{
    flp->init(id);
}

void frmTextProps::doAccept(void)
{
    flp->doAccept();
}

void frmTextProps::doClose(void)
{
    //flp->doClose();
    hide();
}

frmDrawObjects::frmDrawObjects(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Objects"));
    setWindowIcon(QIcon(*GraceIcon));
    cmdText=new QPushButton(tr("Text"));
    cmdText->setToolTip(tr("Create a text annotation (Crtl+Alt+T)"));
    connect(cmdText,SIGNAL(clicked()),SLOT(doText()));
    cmdTextProp=new QPushButton(tr("Text props..."));
    cmdTextProp->setToolTip(tr("Edit general text properties"));
    connect(cmdTextProp,SIGNAL(clicked()),SLOT(doTextProp()));
    cmdLine=new QPushButton(tr("Line"));
    cmdLine->setToolTip(tr("Create a line or an arrow (Crtl+Alt+L)"));
    connect(cmdLine,SIGNAL(clicked()),SLOT(doLine()));
    cmdLineProp=new QPushButton(tr("Line props..."));
    cmdLineProp->setToolTip(tr("Edit general line properties"));
    connect(cmdLineProp,SIGNAL(clicked()),SLOT(doLineProp()));
    cmdBox=new QPushButton(tr("Box"));
    cmdBox->setToolTip(tr("Create a box (Crtl+Alt+B)"));
    connect(cmdBox,SIGNAL(clicked()),SLOT(doBox()));
    cmdBoxProp=new QPushButton(tr("Box props..."));
    cmdBoxProp->setToolTip(tr("Edit general box properties"));
    connect(cmdBoxProp,SIGNAL(clicked()),SLOT(doBoxProp()));
    cmdEllipse=new QPushButton(tr("Ellipse"));
    cmdEllipse->setToolTip(tr("Create an ellipse (Crtl+Alt+E)"));
    connect(cmdEllipse,SIGNAL(clicked()),SLOT(doEllipse()));
    cmdEllipseProp=new QPushButton(tr("Ellipse props..."));
    cmdEllipseProp->setToolTip(tr("Edit general ellipse properties"));
    connect(cmdEllipseProp,SIGNAL(clicked()),SLOT(doEllipseProp()));
    cmdEditObj=new QPushButton(tr("Edit object"));
    cmdEditObj->setToolTip(tr("Edit an existing object"));
    connect(cmdEditObj,SIGNAL(clicked()),SLOT(doEditObj()));
    cmdMoveObj=new QPushButton(tr("Move object"));
    cmdMoveObj->setToolTip(tr("Move an existing object (Crtl+M)"));
    connect(cmdMoveObj,SIGNAL(clicked()),SLOT(doMoveObj()));
    cmdCopyObj=new QPushButton(tr("Copy object"));
    cmdCopyObj->setToolTip(tr("Copy an object"));
    connect(cmdCopyObj,SIGNAL(clicked()),SLOT(doCopyObj()));
    cmdDelObj=new QPushButton(tr("Delete object"));
    cmdDelObj->setToolTip(tr("Delete an object (Crtl+D)"));
    connect(cmdDelObj,SIGNAL(clicked()),SLOT(doDelObj()));
    cmdClearAllText=new QPushButton(tr("Clear all text"));
    cmdClearAllText->setToolTip(tr("Delete all text objects"));
    connect(cmdClearAllText,SIGNAL(clicked()),SLOT(doClearAllText()));
    cmdClearAllLines=new QPushButton(tr("Clear all lines"));
    cmdClearAllLines->setToolTip(tr("Delete all lines and arrows"));
    connect(cmdClearAllLines,SIGNAL(clicked()),SLOT(doClearAllLines()));
    cmdClearAllBoxes=new QPushButton(tr("Clear all boxes"));
    cmdClearAllBoxes->setToolTip(tr("Delete all box objects"));
    connect(cmdClearAllBoxes,SIGNAL(clicked()),SLOT(doClearAllBoxes()));
    cmdClearAllEllipses=new QPushButton(tr("Clear all ellipses"));
    cmdClearAllEllipses->setToolTip(tr("Delete all ellipse objects"));
    connect(cmdClearAllEllipses,SIGNAL(clicked()),SLOT(doClearAllEllipses()));
    cmdClose=new QPushButton(tr("Close"));
    cmdClose->setToolTip(tr("Close this dialog"));
    connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    CreateIcons();
    layout=new QGridLayout;
    layout->setSpacing(STD_SPACING);
    layout->setMargin(STD_MARGIN);
    layout->addWidget(cmdText,0,0);
    layout->addWidget(cmdTextProp,1,0);
    layout->addWidget(cmdLine,2,0);
    layout->addWidget(cmdLineProp,3,0);
    layout->addWidget(cmdBox,4,0);
    layout->addWidget(cmdBoxProp,5,0);
    layout->addWidget(cmdEllipse,6,0);
    layout->addWidget(cmdEllipseProp,7,0);
    layout->addWidget(cmdEditObj,0,1);
    layout->addWidget(cmdMoveObj,1,1);
    layout->addWidget(cmdCopyObj,2,1);
    layout->addWidget(cmdDelObj,3,1);
    layout->addWidget(cmdClearAllText,4,1);
    layout->addWidget(cmdClearAllLines,5,1);
    layout->addWidget(cmdClearAllBoxes,6,1);
    layout->addWidget(cmdClearAllEllipses,7,1);
    layout->addWidget(cmdClose,8,1);
    setLayout(layout);
    resize(LastSize_FormDrawObjects);
    redisplayButtons();
}

frmDrawObjects::~frmDrawObjects()
{
    LastSize_FormDrawObjects=this->size();
}

QIcon CreateIconFromPNG(QString png_file)
{
QImage img1;
img1.load(png_file);
QImage img2(img1.size(),QImage::Format_ARGB32);
QRgb r1;
QColor col1;
QPainter paint1;
img2.fill(Qt::transparent);
int w,h;
w=img1.width();
h=img1.height();
paint1.begin(&img2);
for (int i=0;i<h;i++)
{
    for (int j=0;j<w;j++)
    {
    r1=img1.pixel(j,i);
        if (qRed(r1)==255 && qGreen(r1)==255 && qBlue(r1)==255)
        {
        ;
        }
        else
        {
        col1=QColor(r1);
        paint1.setPen(col1);
        paint1.drawPoint(j,i);
        }
    }
}
paint1.end();
return QIcon(QPixmap::fromImage(img2,Qt::AutoColor));
}

void frmDrawObjects::CreateIcons(void)
{
    QString icondir=QString(qt_grace_icons_dir);//grace_path("fonts/icons");
    icondir+=QDir::separator();
/*buttonIcons[0]=QIcon(icondir+"CreateText.png");
buttonIcons[1]=QIcon(icondir+"TextProps.png");
buttonIcons[2]=QIcon(icondir+"DrawLine.png");
buttonIcons[3]=QIcon(icondir+"LineProps.png");
buttonIcons[4]=QIcon(icondir+"DrawBox.png");
buttonIcons[5]=QIcon(icondir+"BoxProps.png");
buttonIcons[6]=QIcon(icondir+"DrawEllipse.png");
buttonIcons[7]=QIcon(icondir+"EllipseProps.png");
buttonIcons[8]=QIcon(icondir+"EditObject.png");
buttonIcons[9]=QIcon(icondir+"MoveObject.png");
buttonIcons[10]=QIcon(icondir+"CopyObject.png");
buttonIcons[11]=QIcon(icondir+"DeleteObject.png");
buttonIcons[12]=QIcon(icondir+"ClearText2.png");
buttonIcons[13]=QIcon(icondir+"ClearLines.png");
buttonIcons[14]=QIcon(icondir+"ClearBoxes.png");
buttonIcons[15]=QIcon(icondir+"ClearEllipses.png");
buttonIcons[16]=QIcon(icondir+"CloseObjects.png");*/
    buttonIcons[0]=CreateIconFromPNG(icondir+"CreateText.png");
    buttonIcons[1]=CreateIconFromPNG(icondir+"TextProps.png");
    buttonIcons[2]=CreateIconFromPNG(icondir+"DrawLine.png");
    buttonIcons[3]=CreateIconFromPNG(icondir+"LineProps.png");
    buttonIcons[4]=CreateIconFromPNG(icondir+"DrawBox.png");
    buttonIcons[5]=CreateIconFromPNG(icondir+"BoxProps.png");
    buttonIcons[6]=CreateIconFromPNG(icondir+"DrawEllipse.png");
    buttonIcons[7]=CreateIconFromPNG(icondir+"EllipseProps.png");
    buttonIcons[8]=CreateIconFromPNG(icondir+"EditObject.png");
    buttonIcons[9]=CreateIconFromPNG(icondir+"MoveObject.png");
    buttonIcons[10]=CreateIconFromPNG(icondir+"CopyObject.png");
    buttonIcons[11]=CreateIconFromPNG(icondir+"DeleteObject.png");
    buttonIcons[12]=CreateIconFromPNG(icondir+"ClearText2.png");
    buttonIcons[13]=CreateIconFromPNG(icondir+"ClearLines.png");
    buttonIcons[14]=CreateIconFromPNG(icondir+"ClearBoxes.png");
    buttonIcons[15]=CreateIconFromPNG(icondir+"ClearEllipses.png");
    buttonIcons[16]=CreateIconFromPNG(icondir+"CloseObjects.png");
}

void frmDrawObjects::redisplayButtons(void)
{
if (icon_preferences==2)//icons only
{
    cmdText->setText(QString(""));
    cmdTextProp->setText(QString(""));
    cmdLine->setText(QString(""));
    cmdLineProp->setText(QString(""));
    cmdBox->setText(QString(""));
    cmdBoxProp->setText(QString(""));
    cmdEllipse->setText(QString(""));
    cmdEllipseProp->setText(QString(""));
    cmdEditObj->setText(QString(""));
    cmdMoveObj->setText(QString(""));
    cmdCopyObj->setText(QString(""));
    cmdDelObj->setText(QString(""));
    cmdClearAllText->setText(QString(""));
    cmdClearAllLines->setText(QString(""));
    cmdClearAllBoxes->setText(QString(""));
    cmdClearAllEllipses->setText(QString(""));
    cmdClose->setText(QString(""));
    layout->setColumnMinimumWidth(0,30);
    layout->setColumnMinimumWidth(1,30);
    this->setMaximumWidth(70);
    this->resize(70,this->height());
}
else//text or text+icons
{
    cmdText->setText(tr("Text"));
    cmdTextProp->setText(tr("Text props..."));
    cmdLine->setText(tr("Line"));
    cmdLineProp->setText(tr("Line props..."));
    cmdBox->setText(tr("Box"));
    cmdBoxProp->setText(tr("Box props..."));
    cmdEllipse->setText(tr("Ellipse"));
    cmdEllipseProp->setText(tr("Ellipse props..."));
    cmdEditObj->setText(tr("Edit object"));
    cmdMoveObj->setText(tr("Move object"));
    cmdCopyObj->setText(tr("Copy object"));
    cmdDelObj->setText(tr("Delete object"));
    cmdClearAllText->setText(tr("Clear all text"));
    cmdClearAllLines->setText(tr("Clear all lines"));
    cmdClearAllBoxes->setText(tr("Clear all boxes"));
    cmdClearAllEllipses->setText(tr("Clear all ellipses"));
    cmdClose->setText(tr("Close"));
    layout->setColumnMinimumWidth(0,100);
    layout->setColumnMinimumWidth(1,100);
    this->setMaximumWidth(250);
    this->resize(230,this->height());
}

if (icon_preferences==0)//text only
{
    cmdText->setIcon(QIcon());
    cmdTextProp->setIcon(QIcon());
    cmdLine->setIcon(QIcon());
    cmdLineProp->setIcon(QIcon());
    cmdBox->setIcon(QIcon());
    cmdBoxProp->setIcon(QIcon());
    cmdEllipse->setIcon(QIcon());
    cmdEllipseProp->setIcon(QIcon());
    cmdEditObj->setIcon(QIcon());
    cmdMoveObj->setIcon(QIcon());
    cmdCopyObj->setIcon(QIcon());
    cmdDelObj->setIcon(QIcon());
    cmdClearAllText->setIcon(QIcon());
    cmdClearAllLines->setIcon(QIcon());
    cmdClearAllBoxes->setIcon(QIcon());
    cmdClearAllEllipses->setIcon(QIcon());
    cmdClose->setIcon(QIcon());
}
else//icons only or icons+text
{
    cmdText->setIcon(buttonIcons[0]);
    cmdTextProp->setIcon(buttonIcons[1]);
    cmdLine->setIcon(buttonIcons[2]);
    cmdLineProp->setIcon(buttonIcons[3]);
    cmdBox->setIcon(buttonIcons[4]);
    cmdBoxProp->setIcon(buttonIcons[5]);
    cmdEllipse->setIcon(buttonIcons[6]);
    cmdEllipseProp->setIcon(buttonIcons[7]);
    cmdEditObj->setIcon(buttonIcons[8]);
    cmdMoveObj->setIcon(buttonIcons[9]);
    cmdCopyObj->setIcon(buttonIcons[10]);
    cmdDelObj->setIcon(buttonIcons[11]);
    cmdClearAllText->setIcon(buttonIcons[12]);
    cmdClearAllLines->setIcon(buttonIcons[13]);
    cmdClearAllBoxes->setIcon(buttonIcons[14]);
    cmdClearAllEllipses->setIcon(buttonIcons[15]);
    cmdClose->setIcon(buttonIcons[16]);
}

}

void frmDrawObjects::doText(void)
{
    if (action_flag==STR_LOC)
    set_action(DO_NOTHING);
    else
    set_action(STR_LOC);
}

void frmDrawObjects::doTextProp(void)
{
    if (TextProps==NULL)
    {
        TextProps=new frmTextProps(mainWin);
    }
    TextProps->show();
    TextProps->raise();
}

void frmDrawObjects::doLine(void)
{
    if (action_flag==MAKE_LINE_1ST || action_flag==MAKE_LINE_2ND)
    set_action(DO_NOTHING);
    else
    set_action(MAKE_LINE_1ST);
}

void frmDrawObjects::doLineProp(void)
{
    if (LineProps==NULL)
    {
        LineProps=new frmLineProps(mainWin);
    }
    LineProps->show();
    LineProps->raise();
}

void frmDrawObjects::doBox(void)
{
    if (action_flag==MAKE_BOX_1ST || action_flag==MAKE_BOX_2ND)
    set_action(DO_NOTHING);
    else
    set_action(MAKE_BOX_1ST);
}

void frmDrawObjects::doBoxProp(void)
{
    if (BoxProps==NULL)
    {
        BoxProps=new frmEllipseProps(mainWin,false,false);
    }
    BoxProps->init(0);//id is ignored here
    BoxProps->show();
    BoxProps->raise();
}

void frmDrawObjects::doEllipse(void)
{
    if (action_flag==MAKE_ELLIP_1ST || action_flag==MAKE_ELLIP_2ND)
    set_action(DO_NOTHING);
    else
    set_action(MAKE_ELLIP_1ST);
}

void frmDrawObjects::doEllipseProp(void)
{
    if (EllipseProps==NULL)
    {
        EllipseProps=new frmEllipseProps(mainWin,false,true);
    }
    EllipseProps->init(0);//id is ignored here
    EllipseProps->show();
    EllipseProps->raise();
}

void frmDrawObjects::doEditObj(void)
{
    if (action_flag==EDIT_OBJECT)
    set_action(DO_NOTHING);
    else
    set_action(EDIT_OBJECT);
}

void frmDrawObjects::doMoveObj(void)
{
    if (action_flag==MOVE_OBJECT_1ST || action_flag==MOVE_OBJECT_2ND)
    set_action(DO_NOTHING);
    else
    set_action(MOVE_OBJECT_1ST);
}

void frmDrawObjects::doCopyObj(void)
{
    if (action_flag==COPY_OBJECT1ST || action_flag==COPY_OBJECT2ND)
    set_action(DO_NOTHING);
    else
    set_action(COPY_OBJECT1ST);
}

void frmDrawObjects::doDelObj(void)
{
    if (action_flag==DEL_OBJECT)
    set_action(DO_NOTHING);
    else
    set_action(DEL_OBJECT);
}

void frmDrawObjects::doClearAllText(void)
{
    if (yesno("Delete all text strings?", NULL, NULL, NULL))
    {
        nrOfUndoObjs=0;
        undoObjs=new int[maxstr];
        for (int i=0;i<maxstr;i++)
        {
            if (pstr[i].active==TRUE)
            {
                undoObjs[nrOfUndoObjs++]=i;
            }
        }
        if (nrOfUndoObjs>0)
            ObjectsDeleted(nrOfUndoObjs,undoObjs,OBJECT_STRING);
        delete[] undoObjs;
        do_clear_text();
        mainWin->mainArea->completeRedraw();
    }
}

void frmDrawObjects::doClearAllLines(void)
{
    if (yesno("Delete all lines?", NULL, NULL, NULL))
    {
        nrOfUndoObjs=0;
        undoObjs=new int[maxlines];
        for (int i=0;i<maxlines;i++)
        {
            if (lines[i].active==TRUE)
            {
                undoObjs[nrOfUndoObjs++]=i;
            }
        }
        if (nrOfUndoObjs>0)
            ObjectsDeleted(nrOfUndoObjs,undoObjs,OBJECT_LINE);
        delete[] undoObjs;
        do_clear_lines();
        mainWin->mainArea->completeRedraw();
    }
}

void frmDrawObjects::doClearAllBoxes(void)
{
    if (yesno("Delete all boxes?", NULL, NULL, NULL))
    {
        nrOfUndoObjs=0;
        undoObjs=new int[maxboxes];
        for (int i=0;i<maxboxes;i++)
        {
            if (boxes[i].active==TRUE)
            {
                undoObjs[nrOfUndoObjs++]=i;
            }
        }
        if (nrOfUndoObjs>0)
            ObjectsDeleted(nrOfUndoObjs,undoObjs,OBJECT_BOX);
        delete[] undoObjs;
        do_clear_boxes();
        mainWin->mainArea->completeRedraw();
    }
}

void frmDrawObjects::doClearAllEllipses(void)
{
    if (yesno("Delete all ellipses?", NULL, NULL, NULL))
    {
        nrOfUndoObjs=0;
        undoObjs=new int[maxellipses];
        for (int i=0;i<maxellipses;i++)
        {
            if (ellip[i].active==TRUE)
            {
                undoObjs[nrOfUndoObjs++]=i;
            }
        }
        if (nrOfUndoObjs>0)
            ObjectsDeleted(nrOfUndoObjs,undoObjs,OBJECT_ELLIPSE);
        delete[] undoObjs;
        do_clear_ellipses();
        mainWin->mainArea->completeRedraw();
    }
}

void frmDrawObjects::doClose(void)
{
    set_action(DO_NOTHING);
    hide();
}

frmPlot_Appearance::frmPlot_Appearance(QWidget * parent):QWidget(parent)
{
    //setFont(*stdFont);
    //setWindowTitle(tr("QtGrace: Plot appearance"));
    //setWindowIcon(QIcon(*GraceIcon));

    fraFont=new QGroupBox(tr("Font"),this);

    QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
    selFontSize=new LineWidthSelector(this);
    selFontSize->lblText->setText(tr("Global font size multiplicator:"));
    selFontSize->spnLineWidth->setRange(0.0,1000.0);
    selFontSize->spnLineWidth->setDecimals(2);
    selFontSize->spnLineWidth->setValue(100.0);
    selFontSize->spnLineWidth->setSingleStep(1.0);
    selFontSize->spnLineWidth->setSuffix(tr(" %"));
    selFontSize->setLocale(newLocale);

    layout4=new QVBoxLayout;
    layout4->setSpacing(STD_SPACING);
    layout4->setMargin(STD_MARGIN);
    layout4->addWidget(selFontSize);
    fraFont->setLayout(layout4);

    fraPageBackgr=new QGroupBox(tr("Page background"),this);
    bg_color_item=new ColorSelector(fraPageBackgr);
    bg_color_item->setCurrentIndex(0);
    bg_fill_item=new QCheckBox(tr("Fill"),fraPageBackgr);
    bg_fill_item->setChecked(TRUE);
    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    layout1->addWidget(bg_color_item,0,0,1,2);
    layout1->addWidget(bg_fill_item,0,2,1,1);
    fraPageBackgr->setLayout(layout1);

    fraTimeStamp=new QGroupBox(tr("Time stamp"),this);
    timestamp_active_item=new QCheckBox(tr("Show time stamp"),fraTimeStamp);
    timestamp_active_item->setChecked(FALSE);
    chkPathStamp=new QCheckBox(tr("Show file path"),fraTimeStamp);
    chkPathStamp->setChecked(FALSE);
    timestamp_font_item=new FontSelector(fraTimeStamp);
    timestamp_color_item=new ColorSelector(fraTimeStamp);
    timestamp_color_item->setCurrentIndex(1);
    timestamp_size_item=new stdSlider(fraTimeStamp,tr("Character size"),0,1000);
    timestamp_size_item->setValue(100);
    timestamp_rotate_item=new stdSlider(fraTimeStamp,tr("Angle"),0,360);
    timestamp_rotate_item->setValue(0);
    ledStampCoords[0]=new stdLineEdit(fraTimeStamp,tr("Timestamp X:"));
    ledStampCoords[0]->setText(QString("0.03"));
    ledStampCoords[1]=new stdLineEdit(fraTimeStamp,tr("Timestamp Y:"));
    ledStampCoords[1]->setText(QString("0.03"));
    layout2=new QVBoxLayout;
    layout2->setSpacing(STD_SPACING);
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(timestamp_active_item);
    layout2->addWidget(chkPathStamp);
    layout2->addWidget(timestamp_font_item);
    layout2->addWidget(timestamp_color_item);
    layout2->addWidget(timestamp_size_item);
    layout2->addWidget(timestamp_rotate_item);
    layout2->addWidget(ledStampCoords[0]);
    layout2->addWidget(ledStampCoords[1]);
    fraTimeStamp->setLayout(layout2);

    fraDescription=new QGroupBox(tr("Project description"),this);
    layout3=new QVBoxLayout;
    layout3->setSpacing(STD_SPACING);
    layout3->setMargin(STD_MARGIN);
    txtDescription=new QTextEdit(fraDescription);
    layout3->addWidget(txtDescription);
    fraDescription->setLayout(layout3);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    connect(timestamp_rotate_item,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(timestamp_size_item,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(bg_fill_item,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(timestamp_active_item,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(chkPathStamp,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(bg_color_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(bg_color_item,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(timestamp_color_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(timestamp_color_item,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(timestamp_font_item,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(ledStampCoords[0],SIGNAL(changed()),SLOT(update0()));
    connect(ledStampCoords[1],SIGNAL(changed()),SLOT(update0()));
    connect(selFontSize,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout->addWidget(fraPageBackgr);
    layout->addWidget(fraFont);
    layout->addWidget(fraTimeStamp);
    layout->addWidget(fraDescription);
    layout->addWidget(buttonGroup);
    layout->setStretch(0,0);
    layout->setStretch(1,1);
    layout->setStretch(2,0);
    setLayout(layout);
}

frmPlot_Appearance::~frmPlot_Appearance()
{
}

void frmPlot_Appearance::update0(void)
{
    static int i,nr;//,errpos;
    bool imm_upd_sav;
    if (!immediateUpdate) return;
    imm_upd_sav=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    GlobalInhibitor=true;
    SavePlotAppearance();
    doApply();//do this without actually doing something
    nr=nr_of_true_changes(ListOfChanges);
    //errpos=0;
    /*cout << "nr=" << nr << endl;
for (i=0;i<ListOfChanges.size();i++)
cout << ListOfChanges.at(i).toLocal8Bit().constData() << endl;*/
    if (nr>0)
    {
        for (i=0;i<ListOfChanges.size();i++)
        {
            strcpy(command,ListOfChanges.at(i).toLocal8Bit().constData());
            //errpos = scanner(command);
            (void)scanner(command);
        }
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
    }
    PlotAppearanceModified();
    ListOfChanges.clear();
    ListOfOldStates.clear();
    GlobalInhibitor=false;
    immediateUpdate=imm_upd_sav;
    updateRunning=false;
}

void frmPlot_Appearance::update1(int v)
{
    (void)v;
    update0();
}

void frmPlot_Appearance::update2(QString v)
{
    (void)v;
    update0();
}

void frmPlot_Appearance::update3(bool v)
{
    (void)v;
    update0();
}

void frmPlot_Appearance::update4(double v)
{
    (void)v;
    update0();
}

void frmPlot_Appearance::doApply(void)
{
    char dummy[MAX_STRING_LENGTH];
    double ddummy1,ddummy2;
    ApplyError=false;
    QString strDescr=txtDescription->toPlainText();
    int descrLen=strDescr.length();
    char * nDescr=new char[2+descrLen];
    char * oDescr=get_project_description();
    strcpy(nDescr,strDescr.toLocal8Bit().constData());
    ///Undo-Stuff
    if (!GlobalInhibitor)
        SavePlotAppearance();

    ListOfChanges.clear();
    ListOfOldStates.clear();

    if (GetOptionChoice(bg_color_item)!=getbgcolor())
    {
        sprintf(dummy,"background color %d",GetOptionChoice(bg_color_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"background color %d",getbgcolor());
        ListOfOldStates << QString(dummy);
    }
    if (GetToggleButtonState(bg_fill_item)!=getbgfill())
    {
        sprintf(dummy,"page background fill %s",GetToggleButtonState(bg_fill_item)?"on":"off");
        ListOfChanges << QString(dummy);
        sprintf(dummy,"page background fill %s",getbgfill()?"on":"off");
        ListOfOldStates << QString(dummy);
    }
    if (timestamp.active != GetToggleButtonState(timestamp_active_item))
    {
        sprintf(dummy,"timestamp %s",GetToggleButtonState(timestamp_active_item)?"on":"off");
        ListOfChanges << QString(dummy);
        sprintf(dummy,"timestamp %s",timestamp.active?"on":"off");
        ListOfOldStates << QString(dummy);
    }
    if (timestamp.font != GetOptionChoice(timestamp_font_item))
    {
        sprintf(dummy,"timestamp font %d",GetOptionChoice(timestamp_font_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"timestamp font %d",timestamp.font);
        ListOfOldStates << QString(dummy);
    }
    if (timestamp.color != GetOptionChoice(timestamp_color_item))
    {
        sprintf(dummy,"timestamp color %d",GetOptionChoice(timestamp_color_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"timestamp color %d",timestamp.color);
        ListOfOldStates << QString(dummy);
    }
    if (timestamp.charsize != GetCharSizeChoice(timestamp_size_item)/100.0)
    {
        sprintf(dummy,"timestamp char size %f",GetCharSizeChoice(timestamp_size_item)/100.0);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"timestamp char size %f",timestamp.charsize);
        ListOfOldStates << QString(dummy);
    }
    if (timestamp.rot != GetAngleChoice(timestamp_rotate_item))
    {
        sprintf(dummy,"timestamp rot %d",(int)GetAngleChoice(timestamp_rotate_item));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"timestamp rot %d",timestamp.rot);
        ListOfOldStates << QString(dummy);
    }
    xv_evalexpr(ledStampCoords[0], &ddummy1);
    xv_evalexpr(ledStampCoords[1], &ddummy2);
    if (timestamp.x!=ddummy1 || timestamp.y!=ddummy2)
    {
        sprintf(dummy,"timestamp %f, %f",ddummy1,ddummy2);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"timestamp %f, %f",timestamp.x,timestamp.y);
        ListOfOldStates << QString(dummy);
    }
    if (!compare_strings(nDescr,oDescr))
    {
        sprintf(dummy,"description \"%s\"",nDescr);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"description \"%s\"",oDescr);
        ListOfOldStates << QString(dummy);
    }
    if (timestamp.alpha!=timestamp_color_item->alpha() || getbgalpha()!=bg_color_item->alpha())
    {
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: PLOT_ALPHA %d %d\n",bg_color_item->alpha(),timestamp_color_item->alpha());
        ListOfChanges << QString(dummy);
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: PLOT_ALPHA %d %d\n",getbgalpha(),timestamp.alpha);
        ListOfOldStates << QString(dummy);
    }
    if (!GlobalInhibitor)
    {
        universal_font_size_factor=selFontSize->value()*0.01;
        setbgcolor(GetOptionChoice(bg_color_item));
        setbgfill(GetToggleButtonState(bg_fill_item));
        setbgalpha(bg_color_item->alpha());
        timestamp.active = GetToggleButtonState(timestamp_active_item);
        timestamp.path = GetToggleButtonState(chkPathStamp);
        timestamp.font = GetOptionChoice(timestamp_font_item);
        timestamp.color = GetOptionChoice(timestamp_color_item);
        timestamp.alpha = timestamp_color_item->alpha();
        timestamp.charsize = GetCharSizeChoice(timestamp_size_item)/100.0;
        timestamp.rot = GetAngleChoice(timestamp_rotate_item);
        xv_evalexpr(ledStampCoords[0], &timestamp.x);
        xv_evalexpr(ledStampCoords[1], &timestamp.y);
        set_project_description(nDescr);
        ///Undo-Stuff
        PlotAppearanceModified();
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
        ListOfChanges.clear();
        ListOfOldStates.clear();
    }
    /*for (int i=0;i<ListOfChanges.size();i++)
cout << ListOfChanges.at(i).toLocal8Bit().constData() << endl;*/
}

void frmPlot_Appearance::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmPlot_Appearance::doClose(void)
{
//parentWidget()->hide();
    emit(closeWish());
}

void frmPlot_Appearance::init(void)
{
    SetOptionChoice(bg_color_item, getbgcolor());
    bg_color_item->setAlpha(getbgalpha());
    SetToggleButtonState(bg_fill_item, getbgfill());
    SetToggleButtonState(timestamp_active_item, timestamp.active);
    SetToggleButtonState(chkPathStamp, timestamp.path);
    SetOptionChoice(timestamp_font_item, timestamp.font);
    SetOptionChoice(timestamp_color_item, timestamp.color);
    timestamp_color_item->setAlpha(timestamp.alpha);
    SetCharSizeChoice(timestamp_size_item, timestamp.charsize*100);
    SetAngleChoice(timestamp_rotate_item, timestamp.rot);
    char * oDescr=get_project_description();
    txtDescription->setText(QString(oDescr));
    ledStampCoords[0]->setDoubleValue("%g",timestamp.x);
    ledStampCoords[1]->setDoubleValue("%g",timestamp.y);
    selFontSize->setValue(universal_font_size_factor*100.0);
}

frmPlotAppearance::frmPlotAppearance(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    min_w=326;
    min_h=549;
    bar_w=bar_h=20;
    setWindowTitle(tr("QtGrace: Plot appearance"));
    setWindowIcon(QIcon(*GraceIcon));
    QVBoxLayout * layout=new QVBoxLayout;
    layout->setMargin(0);
    layout->setSpacing(0);
    flp=new frmPlot_Appearance(this);
    connect(flp,SIGNAL(closeWish()),SLOT(doClose()));
    scroll=new QScrollArea;
    scroll->setWidget(flp);
    layout->addWidget(scroll);
    //layout->addWidget(flp);
    setLayout(layout);
    /// flp->buttonGroup->cmdAccept->setDefault(true); //deactivated --> apply is default (otherwise the editable slider behave strange)
    /// flp->buttonGroup->cmdAccept->setFocus();
    //resize(QSize(min_w,min_h));
    resize(LastSize_FormPlotAppearance);
}

frmPlotAppearance::~frmPlotAppearance()
{
    LastSize_FormPlotAppearance=this->size();
}

void frmPlotAppearance::init(void)
{
    flp->init();
}

void frmPlotAppearance::doApply(void)
{
    flp->doApply();
}

void frmPlotAppearance::doAccept(void)
{
    flp->doAccept();
}

void frmPlotAppearance::doClose(void)
{
    //flp->doClose();
    hide();
}

void frmPlotAppearance::resizeEvent(QResizeEvent * event)
{
//cout << "resize: " << event->size().width() << "x" << event->size().height() << " bar_w=" << bar_w << " bar_h=" << bar_h << endl;
int n_size_w=event->size().width(),n_size_h=event->size().height();
int actual_space_w=n_size_w,actual_space_h=n_size_h;
if (small_screen_adjustments & 2)
{
    for (int i=0;i<2;i++)
    {
        if (actual_space_w<min_w)
        {
            n_size_w=min_w;
            actual_space_h=event->size().height()-bar_h;
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
        if (actual_space_h<min_h)
        {
            n_size_h=min_h;
            actual_space_w=event->size().width()-bar_w;
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
    }
this->setMinimumSize(0,0);
if (scroll->verticalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_w-=bar_w;
if (scroll->horizontalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_h-=bar_h;
}
else
{
this->setMinimumSize(min_w,min_h);
scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
}
flp->resize(QSize(n_size_w,n_size_h));
}

frmLocatorProps::frmLocatorProps(QWidget * parent):QDialog(parent)
{
    int number;
    QString * entr=new QString[NUM_FMT_OPTION_ITEMS+2];
    char dummy[10];

//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Locator properties"));
    setWindowIcon(QIcon(*GraceIcon));

    fraXProp=new QGroupBox(tr("X properties"),this);
    fraYProp=new QGroupBox(tr("Y properties"),this);
    fraFixedPoint=new QGroupBox(tr("Fixed Point"),this);

    number=6;
    entr[0]=QString("[X, Y]");
    entr[1]=QString("[DX, DY]");
    entr[2]=QString("[DISTANCE]");
    entr[3]=QString("[Phi, Rho]");
    entr[4]=QString("[VX, VY]");
    entr[5]=QString("[SX, SY]");

    selLocDisplType=new StdSelector(this,tr("Locator display type:"),number,entr);
    number=NUM_FMT_OPTION_ITEMS;
    for (int i=0;i<number;i++)
    {
        entr[i]=QString(fmt_option_items[i].label);
    }
    selXFormat=new StdSelector(fraXProp,tr("Format:"),number,entr);
    selXFormat->setCurrentIndex(2);
    selYFormat=new StdSelector(fraYProp,tr("Format:"),number,entr);
    selYFormat->setCurrentIndex(2);
    number=17;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i]=QString(dummy);
    }
    selXPrecision=new StdSelector(fraXProp,tr("Precision:"),number,entr);
    selXPrecision->setCurrentIndex(6);
    selYPrecision=new StdSelector(fraYProp,tr("Precision:"),number,entr);
    selYPrecision->setCurrentIndex(6);

    chkEnableFixed=new QCheckBox(tr("Enable"),fraFixedPoint);
    ledFixedCoords[0]=new stdLineEdit(fraFixedPoint,tr("X:"));
    ledFixedCoords[1]=new stdLineEdit(fraFixedPoint,tr("Y:"));

    layout1=new QVBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(selXFormat);
    layout1->addWidget(selXPrecision);
    fraXProp->setLayout(layout1);
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selYFormat);
    layout2->addWidget(selYPrecision);
    fraYProp->setLayout(layout2);

    layout3=new QGridLayout;
    layout3->setMargin(STD_MARGIN);
    layout3->addWidget(chkEnableFixed,0,0);
    layout3->addWidget(ledFixedCoords[0],1,0);
    layout3->addWidget(ledFixedCoords[1],1,1);
    fraFixedPoint->setLayout(layout3);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(selLocDisplType);
    layout->addWidget(fraXProp);
    layout->addWidget(fraYProp);
    layout->addWidget(fraFixedPoint);
    layout->addWidget(buttonGroup);
    layout->setStretch(0,0);
    layout->setStretch(1,1);
    layout->setStretch(2,1);
    layout->setStretch(3,1);
    layout->setStretch(4,0);
    setLayout(layout);
    resize(LastSize_FormLocatorProps);
    delete[] entr;
}

frmLocatorProps::~frmLocatorProps()
{
    LastSize_FormLocatorProps=this->size();
}

void frmLocatorProps::doApply(void)
{
    (void)locator_define_notify_proc();
}

void frmLocatorProps::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmLocatorProps::doClose(void)
{
    hide();
}

void frmLocatorProps::init(void)
{
    update_locator_items(get_cg());
}

/*
 * Notify and event procs
 */
int frmLocatorProps::locator_define_notify_proc(void)
{
    ApplyError=false;
    char dummy[MAX_STRING_LENGTH];
    GLocator locator;
    GLocator locator2;
    int gno;

    gno = get_cg();

    if (get_graph_locator(gno, &locator) != RETURN_SUCCESS) {
        return RETURN_FAILURE;
    }
    else
        get_graph_locator(gno, &locator2);
    SaveLocatorFixPoint(gno);
    locator.pt_type = selLocDisplType->currentIndex();
    locator.fx = selXFormat->currentIndex();
    locator.fy = selYFormat->currentIndex();
    locator.px = selXPrecision->currentIndex();
    locator.py = selYPrecision->currentIndex();
    locator.pointset = chkEnableFixed->isChecked()==TRUE?1:0;
    xv_evalexpr(ledFixedCoords[0], &locator.dsx );
    xv_evalexpr(ledFixedCoords[1], &locator.dsy );

    ListOfChanges.clear();;
    sprintf(dummy,"with g%d",get_cg());
    ListOfChanges << QString(dummy);

    if (locator.pt_type != locator2.pt_type)
    {
        sprintf(dummy,"g%d fixedpoint type %d",get_cg(),locator.pt_type);
        ListOfChanges << QString(dummy);
    }
    if (locator.fx!=locator2.fx || locator.fy!=locator2.fy)
    {
        sprintf(dummy,"g%d fixedpoint format %s, %s",get_cg(),fmt_option_items[locator.fx].label,fmt_option_items[locator.fy].label);
        ListOfChanges << QString(dummy);
    }
    if (locator.px!=locator2.px || locator.py!=locator2.py)
    {
        sprintf(dummy,"g%d fixedpoint prec %d, %d",get_cg(),locator.px,locator.py);
        ListOfChanges << QString(dummy);
    }
    if (locator.pointset!=locator2.pointset)
    {
        sprintf(dummy,"g%d fixedpoint %s",get_cg(),locator.pointset?"on":"off");
        ListOfChanges << QString(dummy);
    }
    if (locator.dsx!=locator2.dsx || locator.dsy!=locator2.dsy)
    {
        sprintf(dummy,"g%d fixedpoint xy %f, %f",get_cg(),locator.dsx,locator.dsy);
        //cout << locator2.dsx << " " << locator2.dsy << endl;
        ListOfChanges << QString(dummy);
    }
    /*
for (int i=0;i<ListOfChanges.size();i++)
cout << ListOfChanges.at(i).toLocal8Bit().constData() << endl;
*/
    set_graph_locator(gno, &locator);
    LocatorFixPointModified(gno);
    mainWin->mainArea->completeRedraw();
    return 0;
}

void frmLocatorProps::update_locator_items(int gno)
{
    GLocator locator;
    char buf[256];

    if (get_graph_locator(gno, &locator) != RETURN_SUCCESS)
    {
        return;
    }

    int number=6;
    QString * entr=new QString[33];
    if (DecimalPointToUse=='.')
    {
        entr[0]=QString("[X, Y]");
        entr[1]=QString("[DX, DY]");
        entr[2]=QString("[DISTANCE]");
        entr[3]=QString("[Phi, Rho]");
        entr[4]=QString("[VX, VY]");
        entr[5]=QString("[SX, SY]");
    }
    else//',' is decimal separator --> use a '|' as separation between numbers
    {
        entr[0]=QString("[X | Y]");
        entr[1]=QString("[DX | DY]");
        entr[2]=QString("[DISTANCE]");
        entr[3]=QString("[Phi | Rho]");
        entr[4]=QString("[VX | VY]");
        entr[5]=QString("[SX | SY]");
    }
    selLocDisplType->setNewEntries(number,entr);
    delete[] entr;

    selLocDisplType->setCurrentIndex(locator.pt_type);

    if (locator.pointset==1)
        chkEnableFixed->setChecked(TRUE);
    else
        chkEnableFixed->setChecked(FALSE);

    selXFormat->setCurrentIndex(locator.fx);
    selYFormat->setCurrentIndex(locator.fy);
    /*SetOptionChoice(loc_formatx, locator.fx);
    SetOptionChoice(loc_formaty, locator.fy);*/
    selXPrecision->setCurrentIndex(locator.px);
    selYPrecision->setCurrentIndex(locator.py);
    /*SetChoice(loc_precx, locator.px);
    SetChoice(loc_precy, locator.py);*/
    sprintf(buf, "%g", locator.dsx);
    SetDecimalSeparatorToUserValue(buf);
    ledFixedCoords[0]->setText(QString(buf));
    //xv_setstr(locx_item, buf);
    sprintf(buf, "%g", locator.dsy);
    SetDecimalSeparatorToUserValue(buf);
    ledFixedCoords[1]->setText(QString(buf));
    //xv_setstr(locy_item, buf);
}

frmConsole::frmConsole(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Console"));
    setWindowIcon(QIcon(*GraceIcon));
    CreateActions();

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu("&File",this);
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actSave);
    mnuFile->addAction(actClose);
    mnuEdit=new QMenu("&Edit",this);
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actCopy);
    mnuEdit->addAction(actClear);
    mnuOptions=new QMenu("&Options",this);
    mnuOptions->setTearOffEnabled(TRUE);
    mnuOptions->addAction(actPopOnError);
    mnuHelp=new QMenu("&Help",this);
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnConsole);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addMenu(mnuOptions);
    menuBar->addSeparator();
    menuBar->addMenu( mnuHelp );

    lblMessages=new QLabel(tr("Messages:"));
    lblMessages->setAlignment(Qt::AlignHCenter);
    txtMessages=new QTextEdit();
    txtMessages->setReadOnly(TRUE);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(lblMessages);
    layout->addWidget(txtMessages);
    setLayout(layout);
    //resize(500,250);
    resize(LastSize_FormConsole);
}

frmConsole::~frmConsole()
{
    LastSize_FormConsole=this->size();
}

void frmConsole::CreateActions(void)
{
    actSave=new QAction(tr("&Save..."),this);
    actSave->setShortcut(tr("Ctrl+S"));
    actSave->setStatusTip(tr("Save content to file"));
    connect(actSave,SIGNAL(triggered()), this, SLOT(doSave()));
    actClose=new QAction(tr("&Close"),this);
    actClose->setShortcut(tr("Esc"));
    actClose->setStatusTip(tr("Close console"));
    connect(actClose,SIGNAL(triggered()), this, SLOT(doClose()));
    actHelpOnContext=new QAction(tr("On Conte&xt"),this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext,SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnConsole=new QAction(tr("On &console"),this);
    connect(actHelpOnConsole,SIGNAL(triggered()), this, SLOT(doHelpOnConsole()));
    actPopOnError=new QAction(tr("Popup only on &errors"),this);
    actPopOnError->setCheckable(TRUE);
    actPopOnError->setChecked(FALSE);
    connect(actPopOnError,SIGNAL(triggered()), this, SLOT(doPopOnError()));
    actClear=new QAction(tr("&Clear"),this);
    connect(actClear,SIGNAL(triggered()), this, SLOT(doClear()));
    actCopy=new QAction(tr("Copy"),this);
    connect(actCopy,SIGNAL(triggered()), this, SLOT(doCopy()));
}

void frmConsole::errwin(const char *msg)
{
    txtMessages->append(tr("[Error] ")+msg);
    show();
    raise();
}

void frmConsole::msgwin(const char *msg)
{
    txtMessages->append(msg);
    show();
    raise();
}

void frmConsole::doSave(void)
{
    QString text=txtMessages->toPlainText();
    QString fileName = QFileDialog::getSaveFileName(this, tr("Save Messages"),"/",tr("Text files (*.txt)"));
    if (!fileName.isNull())
    {
        ofstream ofi;
        ofi.open(fileName.toLocal8Bit());
        ofi << text.toLocal8Bit().data() << endl;
        ofi.close();
    }
}

void frmConsole::doClose(void)
{
    hide();
}

void frmConsole::doCopy(void)
{
    txtMessages->copy();
}

void frmConsole::doClear(void)
{
    txtMessages->clear();
}

void frmConsole::doHelpOnContext(void)
{
    mainWin->setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmConsole::doHelpOnConsole(void)
{
    HelpCB("doc/UsersGuide.html#console");
}

void frmConsole::doPopOnError(void)
{
    ;
}

frmSetOp::frmSetOp(QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[16];

 //setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Data set operations"));
    setWindowIcon(QIcon(*GraceIcon));
    CreateActions();
    prev_operation=0;

    lblDataSet=new QLabel(tr("Data sets:"),this);
    listSets=new uniList(SETLIST,this);
    listSets->setBehavior(true,true,true);

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu("&File",this);
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actClose);
    mnuHelp=new QMenu("&Help",this);
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnSetOp);

    menuBar->addMenu(mnuFile);
    menuBar->addSeparator();
    menuBar->addMenu( mnuHelp );

    number=7;
    entr[0]=tr("Sort");
    entr[1]=tr("Reverse");
    entr[2]=tr("Join");
    entr[3]=tr("Split");
    entr[4]=tr("Drop points");
    entr[5]=tr("Restrict");
    entr[6]=tr("Swap columns");
    selOperation=new StdSelector(this,tr("Operation type:"),number,entr);
    selOperation->entryValues[0]=DATASETOP_SORT;
    selOperation->entryValues[1]=DATASETOP_REVERSE;
    selOperation->entryValues[2]=DATASETOP_JOIN;
    selOperation->entryValues[3]=DATASETOP_SPLIT;
    selOperation->entryValues[4]=DATASETOP_DROP;
    selOperation->entryValues[5]=DATASETOP_RESTRICT;
    selOperation->entryValues[6]=DATASETOP_SWAP_COLS;
    connect(selOperation->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(changeSelection(int)));
    number=6;
    entr[0]=QString("X");
    entr[1]=QString("Y");
    entr[2]=QString("Y1");
    entr[3]=QString("Y2");
    entr[4]=QString("Y3");
    entr[5]=QString("Y4");
    selSortOn=new StdSelector(this,tr("Sort on:"),number,entr);
    selSwap1=new StdSelector(this,tr("Swap column"),number,entr);
    selSwap2=new StdSelector(this,tr("with column"),number,entr);
    number=2;
    entr[0]=tr("Ascending");
    entr[1]=tr("Descending");
    selSortOrder=new StdSelector(this,tr("Order:"),number,entr);

    ledLength=new stdLineEdit(this,tr("Length:"));
    ledLength->setVisible(FALSE);
    ledStart=new stdLineEdit(this,tr("Start at:"));
    ledStart->setVisible(FALSE);
    ledStop=new stdLineEdit(this,tr("Stop at:"));
    ledStop->setVisible(FALSE);
    selSwap1->setVisible(FALSE);
    selSwap2->setVisible(FALSE);

    number=7;
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRegion=new StdSelector(this,tr("Restrictions:"),number,entr);
    selRegion->setVisible(FALSE);
    chkInvert=new QCheckBox(tr("Negate region"),this);
    chkInvert->setVisible(FALSE);
    chkCreateNew=new QCheckBox(tr("Create new set"),this);
    chkCreateNew->setVisible(FALSE);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar,0,0,1,2);
#endif
    layout->addWidget(lblDataSet,1,0,1,2);
    layout->addWidget(listSets,2,0,3,2);
    layout->addWidget(selOperation,5,0,1,2);
    layout->addWidget(selSortOn,6,0);
    layout->addWidget(selSortOrder,6,1);
    layout->addWidget(ledLength,6,0,1,2);
    layout->addWidget(ledStart,6,0);
    layout->addWidget(ledStop,6,1);
    layout->addWidget(selRegion,7,0,1,2);
    layout->addWidget(chkInvert,8,0,1,1);
    layout->addWidget(chkCreateNew,8,1,1,1);
    layout->addWidget(selSwap1,9,0,1,1);
    layout->addWidget(selSwap2,9,1,1,1);
    layout->addWidget(buttonGroup,10,0,1,2);

    layout->setRowStretch(0,0);
    layout->setRowStretch(1,0);
    layout->setRowStretch(2,1);
    layout->setRowStretch(3,1);
    layout->setRowStretch(4,1);
    layout->setRowStretch(5,0);
    layout->setRowStretch(6,0);
    layout->setRowStretch(7,0);
    layout->setRowStretch(8,0);
    layout->setRowStretch(9,0);
    layout->setRowStretch(10,0);
    resize(LastSize_FormSetOPS);
    setLayout(layout);
}

frmSetOp::~frmSetOp()
{
    LastSize_FormSetOPS=this->size();
}

void frmSetOp::init(void)
{
    listSets->set_graph_number(get_cg(),false);
    listSets->update_number_of_entries();
}

void frmSetOp::changeSelection(int i)
{
if (i==prev_operation) return;

    switch (prev_operation)
    {
    case DATASETOP_SORT://Sort
        selSortOn->setVisible(FALSE);
        selSortOrder->setVisible(FALSE);
        break;
    case DATASETOP_REVERSE://Reverse
        break;
    case DATASETOP_JOIN://Join
        break;
    case DATASETOP_SPLIT://Split
        ledLength->setVisible(FALSE);
        break;
    case DATASETOP_DROP://Drop points
        ledStart->setVisible(FALSE);
        ledStop->setVisible(FALSE);
        break;
    case DATASETOP_RESTRICT://Restrict sets
        selRegion->setVisible(FALSE);
        chkInvert->setVisible(FALSE);
        chkCreateNew->setVisible(FALSE);
        break;
    case DATASETOP_SWAP_COLS://Swap columns
        selSwap1->setVisible(FALSE);
        selSwap2->setVisible(FALSE);
        break;
    }

    switch (i)
    {
    case DATASETOP_SORT://Sort
        selSortOn->setVisible(TRUE);
        selSortOrder->setVisible(TRUE);
        break;
    case DATASETOP_REVERSE://Reverse
        break;
    case DATASETOP_JOIN://Join
        break;
    case DATASETOP_SPLIT://Split
        ledLength->setVisible(TRUE);
        break;
    case DATASETOP_DROP://Drop points
        ledStart->setVisible(TRUE);
        ledStop->setVisible(TRUE);
        break;
    case DATASETOP_RESTRICT://Restrict sets
        selRegion->setVisible(TRUE);
        chkInvert->setVisible(TRUE);
        chkCreateNew->setVisible(TRUE);
        break;
    case DATASETOP_SWAP_COLS://Swap columns
        selSwap1->setVisible(TRUE);
        selSwap2->setVisible(TRUE);
        break;
    }
    prev_operation=i;
}

void frmSetOp::CreateActions(void)
{
    actClose=new QAction(tr("&Close"),this);
    connect(actClose,SIGNAL(triggered()), this, SLOT(doClose()));
    actHelpOnContext=new QAction(tr("On conte&xt"),this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext,SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnSetOp=new QAction(tr("On data&set operations"),this);
    connect(actHelpOnSetOp,SIGNAL(triggered()), this, SLOT(doHelpOnSetOp()));
}

void frmSetOp::doClose(void)
{
    hide();
}

void frmSetOp::doApply(void)
{
static int son[MAX_SET_COLS] = {DATA_X, DATA_Y, DATA_Y1, DATA_Y2, DATA_Y3, DATA_Y4};
    ApplyError=false;

    int i;
    int sorton, stype, lpart;
    int optype,ret=RETURN_SUCCESS;

    int nsets,*selset,*gnos=NULL;
    selset=new int[2];
    listSets->get_selection(&nsets,&selset);

    if (nsets < 1) {
        ApplyError=true;
        errmsg(tr("No set selected").toLocal8Bit().constData());
    } else {
        optype=selOperation->currentIndex();
            gnos=new int[nsets+1];
            for (i=0;i<nsets;i++) gnos[i]=cg;
        switch (optype) {
        case DATASETOP_SORT:
            sorton = son[selSortOn->currentIndex()];
            stype = selSortOrder->currentIndex();
            ret=SmallSetOperations(nsets,gnos,selset,optype,sorton,stype,1);
            break;
        case DATASETOP_REVERSE:
            ret=SmallSetOperations(nsets,gnos,selset,optype,1,1,1);
            break;
        case DATASETOP_JOIN:
            ret=SmallSetOperations(nsets,gnos,selset,optype,1,1,1);
            break;
        case DATASETOP_SPLIT:
            xv_evalexpri(ledLength, &lpart);
            ret=SmallSetOperations(nsets,gnos,selset,optype,lpart,1,1);
            break;
        case DATASETOP_DROP:
            xv_evalexpri(ledStart, &sorton);
            xv_evalexpri(ledStop, &stype);
            ret=SmallSetOperations(nsets,gnos,selset,optype,sorton,stype,1);
            break;
        case DATASETOP_RESTRICT:
            switch (selRegion->currentIndex())
            {
            case 0:
                sorton=RESTRICT_NONE;
                break;
            case 1:
                sorton=RESTRICT_REG0;
                break;
            case 2:
                sorton=RESTRICT_REG1;
                break;
            case 3:
                sorton=RESTRICT_REG2;
                break;
            case 4:
                sorton=RESTRICT_REG3;
                break;
            case 5:
                sorton=RESTRICT_REG4;
                break;
            case 6:
                sorton=RESTRICT_WORLD;
                break;
            }
            stype=(chkInvert->isChecked()==true)?1:0;
            lpart=(chkCreateNew->isChecked()==true)?1:0;
            ret=SmallSetOperations(nsets,gnos,selset,optype,sorton,stype,lpart);
            break;
        case DATASETOP_SWAP_COLS:
            stype=selSwap1->currentValue();
            lpart=selSwap2->currentValue();
            ret=SmallSetOperations(nsets,gnos,selset,optype,lpart,stype,1);
            break;
        }
        listSets->update_number_of_entries();
            if (optype==DATASETOP_JOIN && nsets>0)
            {
            listSets->set_new_selection(1,selset);
            }
            else if (optype==DATASETOP_SPLIT && nsets>0)
            {
            listSets->set_new_selection(new_set_no,new_set_nos);
            }
            else
            {
            listSets->set_new_selection(nsets,selset);
            }
        update_set_lists(cg);
        mainWin->mainArea->completeRedraw();
    }
    delete[] selset;
    delete[] gnos;
    if (ret>0) ApplyError=true;
}

void frmSetOp::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSetOp::doHelpOnContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmSetOp::doHelpOnSetOp(void)
{
    HelpCB("doc/UsersGuide.html#data-set-operations");
}

frmCommands::frmCommands(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    min_w=500;
    min_h=500;
    bar_w=bar_h=20;
    scroll=new QScrollArea();
    flp=new QWidget();
    scroll->setWidget(flp);
    QVBoxLayout * m_layout=new QVBoxLayout();
    m_layout->setMargin(0);
    m_layout->setSpacing(0);
    m_layout->addWidget(scroll);

    setWindowTitle(tr("QtGrace: Commands"));

    setWindowIcon(QIcon(*GraceIcon));

    FormReadHistory=NULL;
    FormWriteHistory=NULL;

    lblCommand=new QLabel(tr("Command:"),this);
    lenCommand=new QLineEdit(QString(""),this);
    //txtCommands=new QTextEdit(this);
    list=new QListWidget(this);
    connect(list,SIGNAL(itemDoubleClicked(QListWidgetItem*)),SLOT(doDoubleClick(QListWidgetItem*)));
    grpBox1=new QGroupBox(this);
    grpBox2=new QGroupBox(this);

    grpBox3=new QGroupBox(this);
    layout3=new QGridLayout();
    layout3->setMargin(STD_MARGIN);
    layout3->setSpacing(STD_SPACING);
    grpSource=new grpSelect(tr("Source"),this);
    grpDestination=new grpSelect(tr("Destination"),this);
    grpDestination->enable_sync(grpSource->listSet);
    cmdReplayWithReplace=new QPushButton(tr("Replay replacing set-Ids"),this);
    connect(cmdReplayWithReplace,SIGNAL(clicked()),SLOT(doReplayWithReplace()));
    layout3->addWidget(grpSource,0,0);
    layout3->addWidget(grpDestination,0,1);
    layout3->addWidget(cmdReplayWithReplace,1,0,1,2);
    grpBox3->setLayout(layout3);

    layout1=new QHBoxLayout();
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    layout2=new QHBoxLayout();
    layout2->setMargin(STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    layout=new QVBoxLayout();
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);

    cmdAdd=new QPushButton(tr("Add"),grpBox1);
    connect(cmdAdd,SIGNAL(clicked()),SLOT(doAdd()));
    cmdDelete=new QPushButton(tr("Delete"),grpBox1);
    connect(cmdDelete,SIGNAL(clicked()),SLOT(doDelete()));
    cmdReplace=new QPushButton(tr("Replace"),grpBox1);
    connect(cmdReplace,SIGNAL(clicked()),SLOT(doReplace()));
    cmdUp=new QPushButton(tr("Up"),grpBox1);
    connect(cmdUp,SIGNAL(clicked()),SLOT(doUp()));
    cmdDown=new QPushButton(tr("Down"),grpBox1);
    connect(cmdDown,SIGNAL(clicked()),SLOT(doDown()));

    layout1->addWidget(cmdAdd);
    layout1->addWidget(cmdDelete);
    layout1->addWidget(cmdReplace);
    layout1->addWidget(cmdUp);
    layout1->addWidget(cmdDown);
    grpBox1->setLayout(layout1);

    cmdRead=new QPushButton(tr("Read..."),grpBox2);
    connect(cmdRead,SIGNAL(clicked()),SLOT(doRead()));
    cmdSave=new QPushButton(tr("Save..."),grpBox2);
    connect(cmdSave,SIGNAL(clicked()),SLOT(doSave()));
    cmdClear=new QPushButton(tr("Clear"),grpBox2);
    connect(cmdClear,SIGNAL(clicked()),SLOT(doClear()));
    cmdReplay=new QPushButton(tr("Replay"),grpBox2);
    connect(cmdReplay,SIGNAL(clicked()),SLOT(doReplay()));
    cmdClose=new QPushButton(tr("Close"),grpBox2);
    connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    cmdHelp=new QPushButton(tr("Help"),grpBox2);
    connect(cmdHelp,SIGNAL(clicked()),SLOT(doHelp()));

    layout2->addWidget(cmdRead);
    layout2->addWidget(cmdSave);
    layout2->addWidget(cmdClear);
    layout2->addWidget(cmdReplay);
    layout2->addWidget(cmdClose);
    layout2->addWidget(cmdHelp);
    grpBox2->setLayout(layout2);

    grpSpecial=new QGroupBox(this);
    layout4=new QHBoxLayout(this);
    layout4->setSpacing(STD_SPACING);
    layout4->setMargin(STD_MARGIN);
    lblSpecial=new QLabel(tr("Special Command:"),this);
    cmbSpecial=new QComboBox(this);
    cmbSpecial->addItem("None");
    cmbSpecial->addItem("Add last formula");
    cmbSpecial->addItem("Minus last formula");
    cmbSpecial->addItem("Multiply with last formula");
    cmbSpecial->addItem("Divide by last formula");
    cmbSpecial->addItem("Remember value");
    cmbSpecial->addItem("Add last value");
    cmbSpecial->addItem("Minus last Value");
    cmbSpecial->addItem("Multiply with value");
    cmbSpecial->addItem("Divide by value");
    cmbSpecial->addItem("Use last formula");
    cmbSpecial->addItem("Use remembered formula");
    cmbSpecial->addItem("Create new Set");
    cmbSpecial->addItem("Extract feature");
    cmbSpecial->addItem("Special formula");
    cmbSpecial->addItem("Append data point");
    cmbSpecial->addItem("Filter");
    cmbSpecial->addItem("Regression");

    cmbSpecial2=new QComboBox(this);
    cmbSpecial2->addItem(tr("---"));

    cmdSpecial=new QPushButton(tr("Insert"),this);
    connect(cmbSpecial,SIGNAL(currentIndexChanged(int)),SLOT(Special1Changed(int)));
    connect(cmbSpecial2,SIGNAL(currentIndexChanged(int)),SLOT(Special2Changed(int)));
    connect(cmdSpecial,SIGNAL(clicked()),SLOT(doInsertSpecial()));
    layout4->addWidget(lblSpecial);
    layout4->addWidget(cmbSpecial);
    layout4->addWidget(cmbSpecial2);
    layout4->addWidget(cmdSpecial);
    grpSpecial->setLayout(layout4);

    //layout->addWidget(txtCommands);
    layout->addWidget(grpBox3);
    layout->addWidget(list);
    layout->addWidget(grpBox1);
    layout->addWidget(grpBox2);
    layout->addWidget(grpSpecial);
    layout->addWidget(lblCommand);
    layout->addWidget(lenCommand);
    layout->setStretchFactor(grpBox3,3);
    layout->setStretchFactor(list,3);
    layout->setStretchFactor(grpBox1,0);
    layout->setStretchFactor(grpBox2,0);
    layout->setStretchFactor(lblCommand,0);
    layout->setStretchFactor(lenCommand,0);

flp->setLayout(layout);
setLayout(m_layout);
    //this->resize(QSize(min_w+5,min_h+5));
    resize(LastSize_FormCommands);
}

frmCommands::~frmCommands()
{
    LastSize_FormCommands=this->size();
}

void frmCommands::doAdd(void)
/*
 * copy the contents of the command line to the story list without executing it
 */
{
    int npos, *pos=new int[2], newpos;
    QString comtxt=lenCommand->text();
    if (!comtxt.isEmpty())
    {
        getListSelection(&npos,&pos);
        if (npos==0)
        {
            newpos=0;
        }
        else
        {
            newpos=pos[0]+1;
        }
        list->insertItem(newpos,comtxt);
        list->setCurrentRow(newpos);
    }
    lenCommand->clear();
    delete[] pos;
}

void frmCommands::getListSelection(int * number,int ** selection)
{
    *number=0;
    for (int i=0;i<list->count();i++)
        if (list->item(i)->isSelected()) *number=*number+1;
    //QModelIndexList listentries=selectedIndexes();
    //*number=listentries.size();
    if (*number<=0) return;
    delete[] *selection;
    *selection=new int[*number];
    *number=0;
    for (int i=0;i<list->count();i++)
    {
        //*(*selection+i)=listentries.at(i)->data( listentries.at(i).row();
        if (list->item(i)->isSelected())
        {
            *(*selection+*number)=i;
            *number=*number+1;
        }
    }
    sort(*number,*selection);
}

void frmCommands::doDelete(void)
/* delete a entry from the history list */
{
    QListWidgetItem * wi;
    for (int i=0;i<list->count();i++)
    {
        if (list->item(i)->isSelected())
        {
            wi=list->takeItem(i);
            delete wi;
        }
    }
    list->hide();
    list->show();
}

void frmCommands::doReplace(void)
/*
 * replace a entry in the history list with the command line
 * without executing it
 */
{
    int nr,*sel=new int[5];
    getListSelection(&nr,&sel);
    if (nr!=1)
    {
        delete[] sel;
        return;
    }
    list->insertItem(sel[0]+1,lenCommand->text());
    list->takeItem(sel[0]);
    delete[] sel;
}

void frmCommands::doUp(void)
{
    int sel_numb=-1;
    for (int i=0;i<list->count();i++)
    {
        if (list->item(i)->isSelected())
        {
            sel_numb=i;
        }
    }
    if (sel_numb>0 && sel_numb<=list->count())
    {
        QListWidgetItem * wi,*wi2;
        wi=list->takeItem(sel_numb-1);
        wi2=list->takeItem(sel_numb-1);
        list->insertItem(sel_numb-1,wi);
        list->insertItem(sel_numb-1,wi2);
        list->setCurrentItem(wi2);
        list->hide();
        list->show();
    }
}

void frmCommands::doDown(void)
{
    int sel_numb=-1;
    for (int i=0;i<list->count();i++)
    {
        if (list->item(i)->isSelected())
        {
            sel_numb=i;
        }
    }
    if (sel_numb>=0 && sel_numb<list->count())
    {
        QListWidgetItem * wi,*wi2;
        wi=list->takeItem(sel_numb);
        wi2=list->takeItem(sel_numb);
        list->insertItem(sel_numb,wi);
        list->insertItem(sel_numb,wi2);
        list->setCurrentItem(wi);
        list->hide();
        list->show();
    }
}

void frmCommands::doRead(void)
{
if (should_open_grace_file_dialog())
{
    if (FormReadHistory==NULL)
    {
        FormReadHistory=new frmIOForm(READ_PARAMETERS,this);
        connect(FormReadHistory,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
        QString FileExtension("*.com");
        QString script_dir(qt_grace_script_dir);
        FormReadHistory->selector->setFilterFromExtern(script_dir,FileExtension);
        //FormReadHistory->selector->filterExtension=FileExtension;
        FormReadHistory->setWindowTitle(tr("QtGrace: Read history"));
        FormReadHistory->init();
        FormReadHistory->grpParamGraph->hide();
        FormReadHistory->selector->showFilesLikeFilter();
    }
    FormReadHistory->show();
    FormReadHistory->raise();
    FormReadHistory->activateWindow();
}
else
{
mainWin->UseOperatingSystemFileDialog(READ_COMMANDS_FILE,tr("QtGrace: Read history"),Last_Dialog_Path[READ_COMMANDS_FILE],tr("Command files (*.com);;All files (*)"));
}
}

void frmCommands::doSave(void)
{
if (should_open_grace_file_dialog())
{
    if (FormWriteHistory==NULL)
    {
        FormWriteHistory=new frmIOForm(WRITE_PARAMETERS,this);
        connect(FormWriteHistory,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
        QString FileExtension("*.com");
        QString script_dir(qt_grace_script_dir);
        FormWriteHistory->selector->setFilterFromExtern(script_dir,FileExtension);
        FormWriteHistory->selector->filterExtension=FileExtension;
        FormWriteHistory->setWindowTitle(tr("QtGrace: Write history"));
        FormWriteHistory->init();
        FormWriteHistory->grpParamGraph->hide();
        FormWriteHistory->selector->showFilesLikeFilter();
    }
    FormWriteHistory->show();
    FormWriteHistory->raise();
    FormWriteHistory->activateWindow();
}
else
{
mainWin->UseOperatingSystemFileDialog(WRITE_COMMANDS_FILE,tr("QtGrace: Write history"),Last_Dialog_Path[WRITE_COMMANDS_FILE],tr("Command files (*.com);;All files (*)"));
}
}

void frmCommands::IOrequested(int type,QString file,bool exists,bool writeable,bool readable)
{
    char filename[256];
    strcpy(filename,file.toLocal8Bit());
    char buf[512];
    FILE *fp,*pp;
    (void)exists;
    (void)writeable;
    (void)readable;
    if (type==WRITE_PARAMETERS || type==WRITE_COMMANDS_FILE)
    {
        int hc=list->count(),i;
        QListWidgetItem * lwid;
        pp = grace_openw(filename);
        if (pp != NULL) {
            for (i = 0; i < hc; i++) {
                lwid=list->item(i);
                strcpy(buf,lwid->text().toLocal8Bit());
                fprintf(pp, "%s\n", buf);
            }
            grace_close(pp);
        }
        if (FormWriteHistory)
        FormWriteHistory->hide();
    }
    else//READ_PARAMETERS || READ_COMMMANDS_FILE
    {
        int sl;
        if ((fp = grace_openr(filename, SOURCE_DISK)) != NULL) {
            while (grace_fgets(buf, 255, fp) != NULL) {
                sl = strlen(buf);
                buf[sl - 1] = 0;
                if (strlen(buf) == 0) {
                    continue;
                }
                list->addItem(QString(buf));
            }
            grace_close(fp);
        }
        if (FormReadHistory)
        FormReadHistory->hide();
    }
}

int frmCommands::next_unused_new_set(void)
{
    int hc=list->count();
    int * nr_list=new int[hc+2];
    int len_nr_list=0;
    int i,nex=0,tm,tm2;
    bool exists;
    QListWidgetItem * lwid;
    char * ts,ts2[64],ts3[64];
    strcpy(ts2,"#QTGRACE_SPECIAL CREATE NEW_SET ");
    for (i = 0; i < hc; i++)
    {
        lwid=list->item(i);
        ts=new char[2+strlen(lwid->text().toLatin1())];
        strcpy(ts,lwid->text().toLatin1());//commands should be representable in Latin1-encoding
        strncpy(ts3,ts,strlen(ts2));
        ts3[strlen(ts2)]='\0';
        if (strcmp(ts2,ts3)==0)//we found a special command to create a set
        {
        tm2=sscanf(ts+strlen(ts2),"S%dN",&tm);
        if (tm2==1)
        nr_list[len_nr_list++]=tm;
        }
        delete[] ts;
    }
    if (len_nr_list<=0) return 0;
    tm=nr_list[0];//we search for the maximum
    for (i=0;i<len_nr_list;i++) if (nr_list[i]>tm) tm=nr_list[i];
    nex=tm+1;
    for (i=0;i<nex;i++)//look for an unoccupied value lower than nex
    {
    exists=false;
        for (int j=0;j<len_nr_list;j++)
        {
            if (nr_list[j]==i)
            {
            exists=true;
            break;
            }
        }
        if (exists==false)
        {
        nex=i;
        break;
        }
    }
    delete[] nr_list;
return nex;
}

void frmCommands::resizeEvent(QResizeEvent * event)
{
//cout << "resize: " << event->size().width() << "x" << event->size().height() << " bar_w=" << bar_w << " bar_h=" << bar_h << endl;
//return;
int n_size_w=event->size().width(),n_size_h=event->size().height();
int actual_space_w=n_size_w,actual_space_h=n_size_h;
    for (int i=0;i<2;i++)
    {
        if (actual_space_w<min_w)
        {
            n_size_w=min_w;
            actual_space_h=event->size().height()-bar_h;
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
        if (actual_space_h<min_h)
        {
            n_size_h=min_h;
            actual_space_w=event->size().width()-bar_w;
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
    }
if (scroll->verticalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_w-=bar_w;
if (scroll->horizontalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_h-=bar_h;
flp->resize(QSize(n_size_w,n_size_h));
}

void frmCommands::doClear(void)
{
    int ret=QMessageBox::question(this,tr("Are you sure?"),tr("Delete all entries from list of commands?"),QMessageBox::Yes,QMessageBox::No);
    if (ret==QMessageBox::Yes)
        list->clear();
}

#define MAXERR 5

void frmCommands::doReplay(void)
{
    int errpos;
    char ts[512];//,ts2[32];
    int i;
    int hc=list->count();
    QListWidgetItem * lwid;
    error_count = 0;
    activate_id_replacing=false;
    clear_new_set_ids();//prepare for the generation of new set-ids
    for (i = 0; i < hc; i++)
    {
        lwid=list->item(i);
        strcpy(ts,lwid->text().toLatin1());//commands should be representable in Latin1-encoding
        /*strncpy(ts2,ts,16);
        ts2[16]='\0';
        if (strcmp(ts2,"#QTGRACE_SPECIAL") == 0)
            errpos = special_Scanner(ts+17,false);
            else*/
        //cout << "Replay: ts=#" << ts << "#" << endl;
        errpos = scanner(ts);//the scanner is able to process the #QTGRACE_SPECIAL-commands
        if (errpos)
        {
            error_count++;
        }
        if (error_count > MAXERR)
        {
            if (yesno("Lots of errors, cancel?", NULL, NULL, NULL))
            {
                break;
            }
            else
            {
                error_count = 0;
            }
        }
    }
    mainWin->mainArea->completeRedraw();
}

int frmCommands::special_Scanner(char * command,bool replace)
{
    QString replayed_command;
    char operation[512],operand[512],temp_val[512];
    int pos=0,len=0;
//char * com;
    int o_n_sets,n_sets,type,realization,absolute,debug,point_extension,oversampling,rno,invr;
    int * o_gnos=NULL;
    int * o_snos=NULL;
    int * gnos=NULL;
    int * snos=NULL;
    double limits[2];
    int orders[2];
    char x_formula[512];
    double ripple;
    (void)replace;
    cout << "#" << command << "#" << endl;
    sscanf(command,"%s %s",operation,operand);
    cout << "#"<< operation << "#" << operand << "#" << endl;
    if (strcmp(operation,"USE")==0)
    {
        if (strcmp(operand,"LAST_FORMULA")==0)
        {
            replayed_command=QString(last_formula);
        }
        else//Remembered Formula
        {
            replayed_command=QString(saved_formula);
        }
    }
    else if (strcmp(operation,"REMEMBER")==0)
    {
        if (strcmp(operand,"Formula")==0)
        {
            strcpy(saved_formula,last_formula);
        }
        else if (operand[4]=='a')
        {
            pos=atoi(operand+5);
            saved_value=last_fit_falues[pos];
            //cout << "saved_value=" << saved_value << endl;
        }
        else//special case
        {

        }
        /// Save something
    }
    else if (strcmp(operation,"FILTER_SET")==0)
    {
        cout << "parse filter" << endl;

        ParseFilterCommand(operand,o_n_sets,&o_gnos,&o_snos,n_sets,&gnos,&snos,type,realization,limits,orders,x_formula,ripple,absolute,debug,point_extension,oversampling,rno,invr);

    }
    else if (strcmp(operation,"REGRESSION")==0)
    {
        cout << "parse regression" << endl;

    }
    else//not "USE" and not "REMEMBER"-command
    {
        replayed_command=QString("Y=Y");
        if (strcmp(operation,"ADD")==0)
        {
            replayed_command+=QString("+(");
        }
        else if (strcmp(operation,"MINUS")==0)
        {
            replayed_command+=QString("-(");
        }
        else if (strcmp(operation,"MULTIPLY")==0)
        {
            replayed_command+=QString("*(");
        }
        else if (strcmp(operation,"DIVIDE")==0)
        {
            replayed_command+=QString("/(");
        }
        if (strcmp(operand,"LAST_VALUE")==0)
        {
            sprintf(temp_val,"%g",saved_value);
            replayed_command+=QString(temp_val);
        }
        else if (strcmp(operand,"LAST_FORMULA")==0)
        {
            len=strlen(last_formula);
            pos=0;
            for (int i=0;i<len;i++){if (last_formula[i]=='='){pos=i; break;}}
            replayed_command+=QString(last_formula+pos);
        }
        else//SAVED_FORMULA
        {
            len=strlen(saved_formula);
            pos=0;
            for (int i=0;i<len;i++){if (saved_formula[i]=='='){pos=i; break;}}
            replayed_command+=QString(saved_formula+pos);
        }
        replayed_command+=QString(")");
    }
    /// replace set ids
    /// execute command (scanner...)
qDebug() << "replayed Command #" << replayed_command.toLatin1().constData() << "#";
    strcpy(temp_val,replayed_command.toLatin1().constData());
    return scanner(temp_val);
}

void replace_set_nrs_and_graph_nrs(QString & command,int setnr,int graphnr)
{
static QString s_rep("S#");
static QString g_rep("G#");
QString s_nr=QString::number(setnr);
QString g_nr=QString::number(graphnr);
command.replace(s_rep,s_nr);
command.replace(g_rep,g_nr);
}

void frmCommands::doReplayWithReplace(void)
{
    int nr_src,nr_dest;
    int src_gno,dest_gno;
    int * srcSets=new int[2];
    int * destSets=new int[2];
    int errpos,stop_with_error=0;
    char ts[1024];
    int i,return_value;
    int hc=list->count();
    QListWidgetItem * lwid;
    QStringList ListOfCommands;
    QString commandString,lhs,rhs;
    QString replacedString;
    bool containsEquals;
    int specialType;
    struct FoundSetID * foundIDs=new struct FoundSetID[4];
    char * parameters;
    class formula_to_process formula1;
    QString all_formulas_in_one,temp_string;

    int nr=0;
    /*int nr_unique_ids=0,*unique_id=new int[2];
    int o_n_sets,n_sets;
    int * o_gnos=NULL;
    int * o_snos=NULL;
    int * gnos=NULL;
    int * snos=NULL;
    int type,realization,absolute,debug,point_extension,oversampling,rno,invr;
    double limits[2];
    int orders[2];
    char x_formula[MAX_STRING_LENGTH];
    double ripple;*/

    grpSource->listSet->get_selection(&nr_src,&srcSets);
    grpDestination->listGraph->get_selection(&nr_dest,&destSets);
    src_gno=grpSource->listSet->gr_no;
    if (nr_src<1)
    {
        errmsg(tr("Please select at least one source set!").toLocal8Bit().constData());
        stop_with_error=1;
        goto end_of_replay_with_replace;
    }
    if (nr_dest!=1)
    {
        errmsg(tr("Please select a single graph as destination!").toLocal8Bit().constData());
        stop_with_error=1;
        goto end_of_replay_with_replace;
    }
    else
    {
        dest_gno=destSets[0];
    }
    grpDestination->listSet->get_selection(&nr_dest,&destSets);
    if (nr_dest>0 && nr_dest!=nr_src)
    {
        errmsg(tr("Number of destination sets does not match number of source sets!").toLocal8Bit().constData());
        stop_with_error=1;
        goto end_of_replay_with_replace;
    }

    /// do we need this?
    if (nr_dest>0)
    {
    QList<int> sets_to_save;
    QList<int> gnos_to_save;
    sets_to_save.clear();
    gnos_to_save.clear();
        for (int i=0;i<nr_dest;i++)
        {
        gnos_to_save << dest_gno;
        sets_to_save << destSets[i];
        }
    save_set_comments(gnos_to_save,sets_to_save);
    }

    replace_o_set_ids=nr_src;
    replace_n_set_ids=nr_src;//the number of sets in source and destination have to be the same -- set-id=-1 if no destination has been selected
    //number of set ids (original and new set ids - meaning right and left hand side of an equation)
    //if set-id is '-1' a new set is to be allocated and the new id is writen in the id-arrays
    //gnos always have to be real ids and no '-1'
    if (replace_o_gnos!=NULL) delete[] replace_o_gnos;
    if (replace_o_snos!=NULL) delete[] replace_o_snos;
    if (replace_n_gnos!=NULL) delete[] replace_n_gnos;
    if (replace_n_snos!=NULL) delete[] replace_n_snos;
    replace_o_gnos=new int[nr_src];
    replace_n_gnos=new int[nr_src];
    replace_o_snos=new int[nr_src];
    replace_n_snos=new int[nr_src];

    for (int i=0;i<nr_src;i++)
    {
        replace_o_gnos[i]=src_gno;
        replace_n_gnos[i]=dest_gno;
        replace_o_snos[i]=srcSets[i];
        if (nr_dest==0)
        {
            replace_n_snos[i]=nextset(dest_gno);
            copyset(src_gno,srcSets[i],dest_gno,replace_n_snos[i]);
        }
        else
        {
            replace_n_snos[i]=destSets[i];
        }
    }

    activate_id_replacing=true;
    error_count = 0;

    ListOfCommands.clear();
    all_formulas_in_one.clear();
    for (i = 0; i < hc; i++)//copy every command in the list (needed to be able to alter he commands on the fly)
    {
    lwid=list->item(i);
    temp_string=lwid->text();
    ListOfCommands << lwid->text();
    remove_beginning_whitespaces(temp_string);
        if (temp_string.length()>0)
        {
            //if (temp_string.at(0).toLatin1()!='#')
            if (formula_to_process::is_comment(temp_string)!=1)
            {
            all_formulas_in_one+=temp_string;
            if (i<hc-1) all_formulas_in_one+=QString(";");
            }
        }
    }
    formula1.init_formula(all_formulas_in_one);
//qDebug() << "REPLAY: AllFormulas=" << all_formulas_in_one;

    /// this command is obsolete
    clear_new_set_ids();//prepare for the generation of new set-ids

    for (int jj=0;jj<nr_src;jj++)//do the commands for every set in the source-list
    {//loop over all selected sets
        replace_o_set_ids=replace_n_set_ids=1;
        replace_o_snos[0]=srcSets[jj];
            if (nr_dest==0)
            replace_n_snos[0]=-1;
            else
            replace_n_snos[0]=destSets[jj];

        current_origin_set=replace_o_snos[0];
        current_origin_graph=replace_o_gnos[0];
        current_target_set=replace_n_snos[0];
        current_target_graph=replace_n_gnos[0];

        formula1.execute_formula(current_target_graph,current_target_set,current_origin_graph,current_origin_set,1,return_value);
//qDebug() << "REPLAY: replacedFormula=" << ;
        formula1.increase_counters();
        continue;/// loop over all sets ends here, because all formulas are copied into one
        //set_parser_setno(current_origin_graph,current_origin_set);

        for (i = 0; i < hc; i++)//do every command in the list
        {
            //lwid=list->item(i);
            //strcpy(ts,lwid->text().toLocal8Bit());
                //commandString=lwid->text();
            strcpy(ts,ListOfCommands.at(i).toLatin1().constData());
//qDebug() << "REPLAY: Command=#" << ts << "#";
            prependSetID(ts,replace_n_snos[0],replace_n_gnos[0],replace_o_snos[0],replace_o_gnos[0]);
//qDebug() << "REPLAY: prep set ids: Command=" << ts;
            specialType=containsSpecialCommand(ts,&parameters);
            if (specialType==SPECIAL_NONE && ts[0]=='#')
            {
            continue;//this is just a comment
            }
qDebug() << "cont_spec_Comm " << specialType << " : Command=" << ts;
            commandString=QString(ts);
            //cout << "specialType=" << specialType << endl;
            if (specialType>0)//a special command --> qtspecial_scanner will automaticaly do the replacing of set-ids
            {
            errpos=qtspecial_scanner(ts,&error_count);
            }
            else
            {//no qt-special-command
                //cout << "no qt special: " << commandString.toLatin1().constData() << endl;
                find_set_ids(ts,&nr,&foundIDs);
                containsEquals=commandString.contains(QString("="));
//qDebug() << ts << " CONTAINS EQUALS=" << containsEquals;
                if (containsEquals)//we have to split the command into two sections before further processing
                {
                    nr=commandString.indexOf(QString("="));
                    lhs=commandString.left(nr);//separate the command into left hand side and right hand side of '='
                    rhs=commandString.mid(nr+1);
                        replace_set_nrs_and_graph_nrs(lhs,replace_n_snos[0],replace_n_gnos[0]);
                        replace_set_nrs_and_graph_nrs(rhs,replace_o_snos[0],replace_o_gnos[0]);
                    //for (int j=0;j<nr_src;j++)//do the command for every source set
                    //{
                    commandString.clear();
                    strcpy(ts,lhs.toLatin1().constData());
                    find_set_ids(ts,&nr,&foundIDs);
                    for (int k=0;k<nr;k++)//set the 'new' target-set-ids according to the destination sets
                    {
                        if (foundIDs[k].characteristic==1)//constant id (no real replacement)
                        {
                            foundIDs[k].repl_gno=foundIDs[k].gno;
                            foundIDs[k].repl_sno=foundIDs[k].sno;
                        }
                        else if (foundIDs[k].characteristic==2)//count ids upwards starting with found id
                        {
                            foundIDs[k].repl_gno=foundIDs[k].gno;
                            foundIDs[k].repl_sno=foundIDs[k].sno+jj;
                        }
                        else
                        {
                            foundIDs[k].repl_gno=dest_gno;
                            foundIDs[k].repl_sno=replace_n_snos[0];//destSets[j];
                        }
                    }
                    replacedString=ReplaceSetIds(ts,nr,foundIDs);//do the replacing
                        commandString=replacedString+QString("=");
                    strcpy(ts,rhs.toLatin1().constData());
                    find_set_ids(ts,&nr,&foundIDs);
                    for (int k=0;k<nr;k++)//set the 'new' set-ids according to the source sets
                    {
                        if (foundIDs[k].characteristic==1)//constant id (no real replacement)
                        {
                            foundIDs[k].repl_gno=foundIDs[k].gno;
                            foundIDs[k].repl_sno=foundIDs[k].sno;
                        }
                        else if (foundIDs[k].characteristic==2)//count ids upwards starting with found id
                        {
                            foundIDs[k].repl_gno=foundIDs[k].gno;
                            foundIDs[k].repl_sno=foundIDs[k].sno+jj;
                        }
                        else
                        {
                            foundIDs[k].repl_gno=src_gno;
                            foundIDs[k].repl_sno=replace_o_snos[0];//srcSets[j];
                        }
                    }
                    replacedString=ReplaceSetIds(ts,nr,foundIDs);//do the replacing
                        commandString+=replacedString;
                    strcpy(ts,commandString.toLatin1().constData());//copy the replaced string into a C-string
//qDebug() << "new command A=#" << ts << "#";
                    errpos = scanner(ts);//execute the new command
                    //}
                }//end contains(=)
                else if (nr>0)//a command without a '=' but at least 1 set-id
                {
                    //for (int j=0;j<nr_src;j++)//do the command for every source set
                    //{
                    strcpy(ts,commandString.toLatin1().constData());//copy original command string
                    for (int k=0;k<nr;k++)//set the 'new' set-ids according to the source sets
                    {
                        if (foundIDs[k].characteristic==1)//constant id (no real replacement)
                        {
                            foundIDs[k].repl_gno=foundIDs[k].gno;
                            foundIDs[k].repl_sno=foundIDs[k].sno;
                        }
                        else if (foundIDs[k].characteristic==2)//count ids upwards starting with found id
                        {
                            foundIDs[k].repl_gno=foundIDs[k].gno;
                            foundIDs[k].repl_sno=foundIDs[k].sno+jj;
                        }
                        else
                        {
                            foundIDs[k].repl_gno=src_gno;
                            foundIDs[k].repl_sno=replace_o_snos[0];//srcSets[j];
                        }
                    }
                    replacedString=ReplaceSetIds(ts,nr,foundIDs);//do the replacing
                    strcpy(ts,replacedString.toLatin1().constData());//copy the replaced string into a C-string
//qDebug() << "new command B=#" << ts << "#";
                    errpos = scanner(ts);//execute the new command
                    //}
                }
                else//no complete set-id and no '='
                {
                    find_graph_ids(ts,&nr,&foundIDs);//search for sinuglar graph-ids
                    if (nr>0)//we found something
                    {
                        for (int i=0;i<nr;i++)
                        {
                            foundIDs[i].repl_gno=dest_gno;
                        }
                        replacedString=ReplaceGraphIds(ts,nr,foundIDs);//do the replacing
                        strcpy(ts,replacedString.toLatin1().constData());//copy the replaced string into a C-string
//qDebug() << "new command C=#" << ts << "#";
                        errpos = scanner(ts);//execute the new command
                    }
                    else
                        errpos = scanner(ts);
                }

            }//end of if-no-qtspecial-command

            if (errpos)
            {
                error_count+=errpos;
            }
            if (error_count > MAXERR)
            {
                if (yesno("Lots of errors, cancel?", NULL, NULL, NULL))
                {
                    break;
                }
                else
                {
                    error_count = 0;
                }
            }

        }//end of loop through all commands

    }//end of loop through all set-IDs

end_of_replay_with_replace:
    /// do we need this?
    if (nr_dest>0 && stop_with_error==0)
    {
    restore_set_comments();
    }
    mainWin->mainArea->completeRedraw();
    activate_id_replacing=false;
    delete[] srcSets;
    delete[] destSets;
}

void frmCommands::doClose(void)
{
    hide();
}

void frmCommands::doHelp(void)
{
    HelpCB("doc/UsersGuide.html#commands");
}

void frmCommands::doInsertSpecial(void)
{
    QString newCommand("#QTGRACE_SPECIAL ");
    int nr=cmbSpecial->currentIndex();
    if (nr==0) return;
    int n_set;
//cout << "inserting" << endl;
    switch (nr)
    {
    case 1://"Add last Formula"
        newCommand+=QString("ADD LAST_FORMULA");
        break;
    case 2://"Minus last Formula"
        newCommand+=QString("MINUS LAST_FORMULA");
        break;
    case 3://"Multiply with last Formula"
        newCommand+=QString("MULTIPLY LAST_FORMULA");
        break;
    case 4://"Divide by last Formula"
        newCommand+=QString("DIVIDE LAST_FORMULA");
        break;
    case 5://"Remember Value"
        newCommand+=QString("REMEMBER ")+cmbSpecial2->currentText();
        /// Hier fehlt VILLEICHT was!
        break;
    case 6://"Add last Value"
        newCommand+=QString("ADD LAST_VALUE");
        break;
    case 7://"Minus last Value"
        newCommand+=QString("MINUS LAST_VALUE");
        break;
    case 8://"Multiply with Value"
        newCommand+=QString("MULTIPLY LAST_VALUE");
        break;
    case 9://"Divide by Value"
        newCommand+=QString("DIVIDE LAST_VALUE");
        break;
    case 10://"Use Last Formula"
        newCommand+=QString("USE LAST_FORMULA");
        break;
    case 11://"Use Remembered Formula"
        newCommand+=QString("USE SAVED_FORMULA");
        break;
    case 12://"Create New Set"
        newCommand+=QString("CREATE NEW_SET ");
        n_set=next_unused_new_set();
        newCommand=QString("S")+QString::number(n_set)+QString("N");//I removed the '+' at the beginning (command=S0N without CREATE_NEW)
        break;
    case 13://"Special Formula"
        newCommand+=QString("EXTRACT a19=");
            switch (cmbSpecial2->currentIndex())
            {
            case 0:
                newCommand=QString("a19=MIN(G0.S0.Y)");
                break;
            case 1:
                newCommand=QString("a19=MAX(G0.S0.Y)");
                break;
            case 2:
                newCommand=QString("a19=AVG(G0.S0.Y)");
                break;
            case 3:
                newCommand=QString("a19=SD(G0.S0.Y)");
                break;
            case 4:
                newCommand+=QString("MEDIAN(Y)");
                break;
            case 5:
                newCommand=QString("a19=MIN(G0.S0.X)");
                break;
            case 6:
                newCommand=QString("a19=MAX(G0.S0.X)");
                break;
            case 7:
                newCommand=QString("a19=AVG(G0.S0.X)");
                break;
            case 8:
                newCommand=QString("a19=SD(G0.S0.X)");
                break;
            case 9:
                newCommand+=QString("MEDIAN(X)");
                break;
            case 10:
                newCommand+=QString("FREQUENCY()");
                break;
            case 11:
                newCommand+=QString("PERIOD()");
                break;
            case 12:
                newCommand+=QString("ZERO_CROSSING()");
                break;
            case 13:
                newCommand+=QString("RISE_TIME()");
                break;
            case 14:
                newCommand+=QString("FALL_TIME()");
                break;
            case 15:
                newCommand+=QString("SLOPE()");
                break;
            case 16:
                newCommand+=QString("Y_INTERCEPTION()");
                break;
            case 17:
                newCommand+=QString("SET_LENGTH()");
                break;
            case 18:
                newCommand+=QString("HALF_MAX_WIDTH()");
                break;
            case 19:
                newCommand+=QString("BARYCENTER_X()");
                break;
            case 20:
                newCommand+=QString("BARYCENTER_Y()");
                break;
            case 21:
                newCommand=QString("a19=G0.S0.X[IMAX(G0.S0.Y)]");
                break;
            case 22:
                newCommand=QString("a19=G0.S0.Y[IMAX(G0.S0.X)]");
                break;
            case 23:
                newCommand=QString("a19=INT(G0.S0.X,G0.S0.Y)");
                break;
            case 24:
                newCommand+=QString("Y_VALUE_CROSSING(0.0)");
                break;
            case 25:
                newCommand+=QString("X_VALUE_CROSSING(0.0)");
                break;
            }
        break;
    case 15://"APPEND New Point"
        newCommand+=QString("APPEND G0.S0{0.0;0.0}");
        break;
    case 16://"Filter"
        newCommand+=QString("FILTER_SET <nr_of_source_sets>,<nr_of_target_sets>{<first_source_graph>,<first_source_set>;<second_source_graph>,<second_source_set>;...}{<first_destination_graph>,<first_destination_set>;...}{<type>;<realization>;<order_first_cutoff>;<order_second_cutoff>;<absolute_values>;<debug>;<point_extension>;<oversampling>;<region_nr>;<negate_region>;<first_frequency(Hz)>;<second_frequency(Hz)>;<chebychev_ripples(dB)>;<x_transformation_formula>}");
        break;
    case 17://"Regression"
        newCommand+=QString("REGRESSION <nr_of_source_sets>,<nr_of_target_sets>{<first_source_graph>,<first_source_set>;<second_source_graph>,<second_source_set>;...}{<Type_of_fit>,<restriction>,<invert_region>,<nr_of_points>,<Load>,<start>,<stop>,<x_$t_formula>}");
        break;
    default://"None"
        /*Do nothing*/
        break;
    }

    int npos, *pos=new int[2], newpos;
    getListSelection(&npos,&pos);
    if (npos==0)
    {
        newpos=0;
    }
    else
    {
        newpos=pos[0]+1;
    }
    list->insertItem(newpos,newCommand);
    list->setCurrentRow(newpos);
    delete[] pos;
}

void frmCommands::Special1Changed(int nr)
{
    //cout << "special 1 changed = " << nr << endl;
    cmbSpecial2->clear();
    if (nr==5)//"Remember Value"
    {
        cmbSpecial2->addItem(tr("Formula"));
        cmbSpecial2->addItem(tr("Fit_a0"));
        cmbSpecial2->addItem(tr("Fit_a1"));
        cmbSpecial2->addItem(tr("Fit_a2"));
        cmbSpecial2->addItem(tr("Fit_a3"));
        cmbSpecial2->addItem(tr("Fit_a4"));
        cmbSpecial2->addItem(tr("Fit_a5"));
        cmbSpecial2->addItem(tr("Fit_a6"));
        cmbSpecial2->addItem(tr("Fit_a7"));
        cmbSpecial2->addItem(tr("Fit_a8"));
        cmbSpecial2->addItem(tr("Fit_a9"));
        /*cmbSpecial2->addItem(tr("Sum"));
        cmbSpecial2->addItem(tr("Mean"));*/
    }
    else if (nr==13)//"Special formula"
    {
        cmbSpecial2->addItem(tr("Y min"));
        cmbSpecial2->addItem(tr("Y max"));
        cmbSpecial2->addItem(tr("Y average"));
        cmbSpecial2->addItem(tr("Y std. deviation"));
        cmbSpecial2->addItem(tr("Y median"));
        cmbSpecial2->addItem(tr("X min"));
        cmbSpecial2->addItem(tr("X max"));
        cmbSpecial2->addItem(tr("X average"));
        cmbSpecial2->addItem(tr("X std. deviation"));
        cmbSpecial2->addItem(tr("X median"));
        cmbSpecial2->addItem(tr("Frequency"));
        cmbSpecial2->addItem(tr("Period"));
        cmbSpecial2->addItem(tr("Zero crossing"));
        cmbSpecial2->addItem(tr("Rise time"));
        cmbSpecial2->addItem(tr("Fall time"));
        cmbSpecial2->addItem(tr("Slope"));
        cmbSpecial2->addItem(tr("Y intercept"));
        cmbSpecial2->addItem(tr("Set length"));
        cmbSpecial2->addItem(tr("Half max width"));
        cmbSpecial2->addItem(tr("Barycenter X"));
        cmbSpecial2->addItem(tr("Barycenter Y"));
        cmbSpecial2->addItem(tr("X of Ymax"));
        cmbSpecial2->addItem(tr("Y of Xmax"));
        cmbSpecial2->addItem(tr("Integral"));
        cmbSpecial2->addItem(tr("Y Value crossing"));
        cmbSpecial2->addItem(tr("X Value crossing"));
    }
    else
    {
        cmbSpecial2->addItem(tr("---"));
    }
}

void frmCommands::Special2Changed(int nr)
{
    (void)nr;
    //cout << "special 2 changed = " << nr << endl;
}

void frmCommands::doDoubleClick(QListWidgetItem * index)
{
    lenCommand->setText(index->text());
}

frmDeviceOptions::frmDeviceOptions(int device,QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[5];

    Device=device;
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    grpPSoptions=new QGroupBox(tr("PS options"),this);
    layout0=new QVBoxLayout;
    layout0->setMargin(STD_MARGIN);
    ps_setup_grayscale_item=new QCheckBox(tr("Grayscale output"),grpPSoptions);
    layout0->addWidget(ps_setup_grayscale_item);
    ps_setup_level2_item=new QCheckBox(tr("PS Level 2"),grpPSoptions);
    ps_setup_level2_item->setChecked(TRUE);
    layout0->addWidget(ps_setup_level2_item);
    number=3;
    entr[0]=tr("7bit");
    entr[1]=tr("8bit");
    entr[2]=tr("Binary");
    ps_setup_docdata_item=new StdSelector(grpPSoptions,tr("Document data:"),number,entr);
    ps_setup_docdata_item->setCurrentIndex(1);
    layout0->addWidget(ps_setup_docdata_item);
    grpPSoptions->setLayout(layout0);
    grpPSoptions->setVisible(FALSE);
    grpPageOffset=new QGroupBox(tr("Page offset (pt)"),this);
    layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    ps_setup_offset_x_item=new stdIntSelector(grpPageOffset,tr("X:"),-999,999);
    ps_setup_offset_x_item->spnInt->setSingleStep(10);
    layout1->addWidget(ps_setup_offset_x_item);
    ps_setup_offset_y_item=new stdIntSelector(grpPageOffset,tr("Y:"),-999,999);
    ps_setup_offset_y_item->spnInt->setSingleStep(10);
    layout1->addWidget(ps_setup_offset_y_item);
    grpPageOffset->setLayout(layout1);
    grpPageOffset->setVisible(FALSE);
    grpHardware=new QGroupBox(tr("Hardware"),this);
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    number=3;
    entr[0]=tr("Automatic");
    entr[1]=tr("Match size");
    entr[2]=tr("Manual");
    ps_setup_feed_item=new StdSelector(grpHardware,tr("Media feed:"),number,entr);
    layout2->addWidget(ps_setup_feed_item);
    ps_setup_hwres_item=new QCheckBox(tr("Set hardware resolution"),grpHardware);
    layout2->addWidget(ps_setup_hwres_item);
    grpHardware->setLayout(layout2);
    grpHardware->setVisible(FALSE);

    grpPNMoptions=new QGroupBox(tr("PNM options"),this);
    layout3=new QVBoxLayout;
    layout3->setMargin(STD_MARGIN);
    number=3;
    entr[0]=tr("1-bit mono (PBM)");
    entr[1]=tr("8-bit grayscale (PGM)");
    entr[2]=tr("8-bit color (PPM)");
    pnm_setup_format_item=new StdSelector(grpPNMoptions,tr("Format:"),number,entr);
    pnm_setup_format_item->setCurrentIndex(2);
    layout3->addWidget(pnm_setup_format_item);
    pnm_setup_rawbits_item=new QCheckBox(tr("\"Rawbits\""),grpPNMoptions);
    pnm_setup_rawbits_item->setChecked(TRUE);
    layout3->addWidget(pnm_setup_rawbits_item);
    grpPNMoptions->setLayout(layout3);
    grpPNMoptions->setVisible(FALSE);

    grpEPSoptions=new QGroupBox(tr("EPS options"),this);
    layout4=new QVBoxLayout;
    layout4->setMargin(STD_MARGIN);
    eps_setup_grayscale_item=new QCheckBox(tr("Grayscale output"),grpEPSoptions);
    layout4->addWidget(eps_setup_grayscale_item);
    eps_setup_level2_item=new QCheckBox(tr("PS Level 2"),grpEPSoptions);
    eps_setup_level2_item->setChecked(TRUE);
    layout4->addWidget(eps_setup_level2_item);
    eps_setup_tight_bb_item=new QCheckBox(tr("Tight BBox"),grpEPSoptions);
    eps_setup_tight_bb_item->setChecked(TRUE);
    layout4->addWidget(eps_setup_tight_bb_item);
    number=3;
    entr[0]=tr("7bit");
    entr[1]=tr("8bit");
    entr[2]=tr("Binary");
    eps_setup_docdata_item=new StdSelector(grpPSoptions,tr("Document data:"),number,entr);
    eps_setup_docdata_item->setCurrentIndex(1);
    layout4->addWidget(eps_setup_docdata_item);
    grpEPSoptions->setLayout(layout4);
    grpEPSoptions->setVisible(FALSE);

    grpJPEGoptions=new QGroupBox(tr("JPEG options"),this);
    layout5=new QVBoxLayout;
    layout5->setMargin(STD_MARGIN);
    selQuality=new stdIntSelector(grpJPEGoptions,tr("Quality:"),0,100);
    selQuality->setValue(75);
    selQuality->spnInt->setSingleStep(5);
    layout5->addWidget(selQuality);
    chkOptimize=new QCheckBox(tr("Optimize"),grpJPEGoptions);
    layout5->addWidget(chkOptimize);
    chkProgressive=new QCheckBox(tr("Progressive"),grpJPEGoptions);
    layout5->addWidget(chkProgressive);
    chkJPG_Grayscale=new QCheckBox(tr("Grayscale"),grpJPEGoptions);
    layout5->addWidget(chkJPG_Grayscale);
    grpJPEGoptions->setLayout(layout5);
    grpJPEGoptions->setVisible(FALSE);
    grpJPEGadvoptions=new QGroupBox(tr("JPEG advanced options"),this);
    layout6=new QVBoxLayout;
    layout6->setMargin(STD_MARGIN);
    selSmoothing=new stdIntSelector(grpJPEGadvoptions,tr("Smoothing:"),0,100);
    selSmoothing->spnInt->setSingleStep(10);
    layout6->addWidget(selSmoothing);
    chkForceBaseline=new QCheckBox(tr("Force baseline"),grpJPEGadvoptions);
    layout6->addWidget(chkForceBaseline);
    number=3;
    entr[0]=tr("Fast integer");
    entr[1]=tr("Slow integer");
    entr[2]=tr("Float");
    selDCT=new StdSelector(grpJPEGadvoptions,tr("DCT:"),number,entr);
    selDCT->setCurrentIndex(1);
    layout6->addWidget(selDCT);
    grpJPEGadvoptions->setLayout(layout6);
    grpJPEGadvoptions->setVisible(FALSE);

    grpPNGoptions=new QGroupBox(tr("PNG options"),this);
    layout7=new QVBoxLayout;
    layout7->setMargin(STD_MARGIN);
    chkInterlaced=new QCheckBox(tr("Interlaced"),grpPNGoptions);
    layout7->addWidget(chkInterlaced);
    chkTransparent=new QCheckBox(tr("Transparent"),grpPNGoptions);
    layout7->addWidget(chkTransparent);
    selCompression=new stdIntSelector(grpPNGoptions,tr("Compression:"),0,9);
    selCompression->setValue(4);
    layout7->addWidget(selCompression);
    grpPNGoptions->setLayout(layout7);
    grpPNGoptions->setVisible(FALSE);

    grpBMPoptions=new QGroupBox(tr("BMP options"),this);
    layout8=new QVBoxLayout;
    layout8->setMargin(STD_MARGIN);
    sldQuality=new stdSlider(grpBMPoptions,tr("Quality"),0,100);
    layout8->addWidget(sldQuality);
    sldQuality->setValue(outputQuality);
    chkGrayscale=new QCheckBox(tr("Grayscale"),grpBMPoptions);
    layout8->addWidget(chkGrayscale);
    grpBMPoptions->setLayout(layout8);
    grpBMPoptions->setVisible(FALSE);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    switch (device)
    {
    case DEVICE_PS:
        setWindowTitle(tr("QtGrace: PS options"));
        grpPSoptions->setVisible(TRUE);
        grpPageOffset->setVisible(TRUE);
        grpHardware->setVisible(TRUE);
        layout->addWidget(grpPSoptions);
        layout->addWidget(grpPageOffset);
        layout->addWidget(grpHardware);
        break;
    case DEVICE_EPS:
        setWindowTitle(tr("QtGrace: EPS options"));
        grpEPSoptions->setVisible(TRUE);
        layout->addWidget(grpEPSoptions);
        break;
    case DEVICE_PNM:
        setWindowTitle(tr("QtGrace: PNM options"));
        grpPNMoptions->setVisible(TRUE);
        layout->addWidget(grpPNMoptions);
        break;
    case DEVICE_JPEG:
        setWindowTitle(tr("QtGrace: JPEG options"));
        grpJPEGoptions->setVisible(TRUE);
        grpJPEGadvoptions->setVisible(TRUE);
        layout->addWidget(grpJPEGoptions);
        layout->addWidget(grpJPEGadvoptions);
        break;
    case DEVICE_PNG:
        setWindowTitle(tr("QtGrace: PNG options"));
        grpPNGoptions->setVisible(TRUE);
        layout->addWidget(grpPNGoptions);
        break;
    case DEVICE_BMP:
        setWindowTitle(tr("QtGrace: BMP options"));
        grpBMPoptions->setTitle(tr("BMP options"));
        grpBMPoptions->setVisible(TRUE);
        layout->addWidget(grpBMPoptions);
        break;
    case DEVICE_TIFF:
        setWindowTitle(tr("QtGrace: TIFF options"));
        grpBMPoptions->setTitle(tr("TIFF options"));
        grpBMPoptions->setVisible(TRUE);
        layout->addWidget(grpBMPoptions);
        break;
    }
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormDeviceOptions);
}

frmDeviceOptions::~frmDeviceOptions()
{
    LastSize_FormDeviceOptions=this->size();
}

void frmDeviceOptions::init(void)
{
    if (Device==DEVICE_BMP || Device==DEVICE_JPEG || Device==DEVICE_PNG || Device==DEVICE_TIFF)
    {
        sldQuality->setValue(outputQuality);
        chkGrayscale->setChecked(outputGrayscale);
    }
    else if (Device==DEVICE_PS)
    {
        SetToggleButtonState(ps_setup_grayscale_item, ps_setup_grayscale);
        SetToggleButtonState(ps_setup_level2_item, ps_setup_level2);
        SetSpinChoice(ps_setup_offset_x_item, (double) ps_setup_offset_x);
        SetSpinChoice(ps_setup_offset_y_item, (double) ps_setup_offset_y);
        SetOptionChoice(ps_setup_feed_item, ps_setup_feed);
        SetToggleButtonState(ps_setup_hwres_item, ps_setup_hwres);
        SetOptionChoice(ps_setup_docdata_item, ps_setup_docdata);
    }
    else if (Device==DEVICE_EPS)
    {
        SetToggleButtonState(eps_setup_grayscale_item, eps_setup_grayscale);
        SetToggleButtonState(eps_setup_level2_item, eps_setup_level2);
        SetToggleButtonState(eps_setup_tight_bb_item, eps_setup_tight_bb);
        SetOptionChoice(eps_setup_docdata_item, eps_setup_docdata);
    }
    else if (Device==DEVICE_PNM)
    {
        SetChoice(pnm_setup_format_item, pnm_setup_format);
        SetToggleButtonState(pnm_setup_rawbits_item, pnm_setup_rawbits);
    }
    else
    {

    }
}

void frmDeviceOptions::doApply(void)
{
    ApplyError=false;
    if (Device==DEVICE_BMP || Device==DEVICE_JPEG || Device==DEVICE_PNG || Device==DEVICE_TIFF)
    {
        outputQuality=sldQuality->value();
        outputGrayscale=chkGrayscale->isChecked();
    }
    else if (Device==DEVICE_PS)
    {
        ps_setup_grayscale = GetToggleButtonState(ps_setup_grayscale_item);
        ps_setup_level2    = GetToggleButtonState(ps_setup_level2_item);
        ps_setup_offset_x  = (int) GetSpinChoice(ps_setup_offset_x_item);
        ps_setup_offset_y  = (int) GetSpinChoice(ps_setup_offset_y_item);
        ps_setup_feed      = GetOptionChoice(ps_setup_feed_item);
        ps_setup_hwres     = GetToggleButtonState(ps_setup_hwres_item);
        ps_setup_docdata   = GetOptionChoice(ps_setup_docdata_item);
    }
    else if (Device==DEVICE_EPS)
    {
        eps_setup_grayscale = GetToggleButtonState(eps_setup_grayscale_item);
        eps_setup_level2 = GetToggleButtonState(eps_setup_level2_item);
        eps_setup_tight_bb = GetToggleButtonState(eps_setup_tight_bb_item);
        eps_setup_docdata = GetOptionChoice(eps_setup_docdata_item);
    }
    else if (Device==DEVICE_PNM)
    {
        pnm_setup_format = GetChoice(pnm_setup_format_item);
        pnm_setup_rawbits = GetToggleButtonState(pnm_setup_rawbits_item);
    }
    else
    {
    ;
    }
}

void frmDeviceOptions::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmDeviceOptions::doClose(void)
{
    hide();
}

frmDeviceActivator::frmDeviceActivator(QWidget * parent):QDialog(parent)
{
setWindowTitle(tr("QtGrace: Enable/Disable export formats"));
layout=new QGridLayout;
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);
cmdAll=new QPushButton(tr("Activate all"),this);
cmdApply=new QPushButton(tr("Accept"),this);
cmdClose=new QPushButton(tr("Close"),this);
connect(cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(cmdAll,SIGNAL(clicked()),SLOT(doAll()));
connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
int index=0;
layout->addWidget(cmdAll,index++,0,1,2);
alloc_checks=3;
chkDeviceActive=new QCheckBox*[alloc_checks];
    for (int i=0;i<alloc_checks;i++)
    {
    chkDeviceActive[i]=new QCheckBox(QString("test"),this);
    layout->addWidget(chkDeviceActive[i],index++,0,1,2);
    }
layout->addWidget(cmdApply,index,0,1,1);
layout->addWidget(cmdClose,index++,1,1,1);
setLayout(layout);
resize(LastSize_DeviceActivator);
}

frmDeviceActivator::~frmDeviceActivator()
{
    LastSize_DeviceActivator=this->size();
}

void frmDeviceActivator::doAll(void)
{
    for (int i=0;i<alloc_checks;i++)
    {
    chkDeviceActive[i]->setChecked(true);
    }
}

void frmDeviceActivator::init(void)
{
//delete old checkBoxes
    for (int i=0;i<alloc_checks;i++)
    {
    delete chkDeviceActive[i];
    }
delete[] chkDeviceActive;
//create new checkBoxes
alloc_checks=number_of_devices();
chkDeviceActive=new QCheckBox*[alloc_checks];
int index=1;
    for (int i=0;i<alloc_checks;i++)
    {
    chkDeviceActive[i]=new QCheckBox(QString(get_device_name(i)),this);
    layout->addWidget(chkDeviceActive[i],index++,0,1,2);
    chkDeviceActive[i]->setChecked(isDeviceActive(i));
    }
    chkDeviceActive[DEVICE_TERM]->hide();
    chkDeviceActive[DEVICE_TERM]->setChecked(true);//Screen is always active
layout->addWidget(cmdApply,index,0,1,1);
layout->addWidget(cmdClose,index++,1,1,1);
}

void frmDeviceActivator::doApply(void)
{
    for (int i=0;i<alloc_checks;i++)
    {
    setDeviceActive(i,chkDeviceActive[i]->isChecked());
    }
        if (FormDeviceSetup!=NULL)
        {
        FormDeviceSetup->changeDeviceList(FormDeviceSetup->cur_version);
        }
    doClose();
}

void frmDeviceActivator::doClose(void)
{
hide();
}

frmUserDefaultGeometries::frmUserDefaultGeometries(QWidget * parent):QDialog(parent)
{
    int row=0,column=0;
    setWindowTitle(tr("QtGrace: Settings for User-Default-Geometries"));
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QGridLayout();
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    lblDescription=new QLabel(tr("Settings for quick changes in page geometry. Negative values mean: no changes."),this);
    layout->addWidget(lblDescription,row,0,1,10);
    lblTitles[0]=new QLabel(tr("#"),this);
    lblTitles[1]=new QLabel(tr("Active"),this);
    lblTitles[2]=new QLabel(tr("Name"),this);
    lblTitles[3]=new QLabel(tr("Format"),this);
    lblTitles[4]=new QLabel(tr("Orientation"),this);
    lblTitles[5]=new QLabel(tr("Width"),this);
    lblTitles[6]=new QLabel(tr("Height"),this);
    lblTitles[7]=new QLabel(tr("Unit"),this);
    lblTitles[8]=new QLabel(tr("DPI"),this);
    lblTitles[9]=new QLabel(tr("Antialiasing"),this);
    lblTitles[10]=new QLabel(tr("Linescaling"),this);
    row=1;
    for (int i=0;i<11;i++)
    {
    layout->addWidget(lblTitles[i],row,i,1,1);
    }
    row++;
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    column=0;
    lblNr[i]=new QLabel(QString::number(i+1),this);
    layout->addWidget(lblNr[i],row,column++,1,1);
    chkActive1[i]=new QCheckBox(QString(""),this);
    layout->addWidget(chkActive1[i],row,column++,1,1);
    lenName[i]=new QLineEdit(this);
    layout->addWidget(lenName[i],row,column++,1,1);
    cmbDevice[i]=new QComboBox(this);
        cmbDevice[i]->addItem(tr("No change"));
        for (int j=0;j<number_of_devices();j++)
        {
        cmbDevice[i]->addItem(get_device_name(j));
        }
    layout->addWidget(cmbDevice[i],row,column++,1,1);
    cmbOrientation[i]=new QComboBox(this);
        cmbOrientation[i]->addItem(tr("No change"));
        cmbOrientation[i]->addItem(tr("Landscape"));
        cmbOrientation[i]->addItem(tr("Portrait"));
    layout->addWidget(cmbOrientation[i],row,column++,1,1);
    spnWidth[i]=new QDoubleSpinBox(this);
        spnWidth[i]->setRange(-1.0,100000.0);
        spnWidth[i]->setSingleStep(1.0);
        spnWidth[i]->setDecimals(2);
    layout->addWidget(spnWidth[i],row,column++,1,1);
    spnHeight[i]=new QDoubleSpinBox(this);
        spnHeight[i]->setRange(-1.0,100000.0);
        spnHeight[i]->setSingleStep(1.0);
        spnHeight[i]->setDecimals(2);
    layout->addWidget(spnHeight[i],row,column++,1,1);
    cmbUnit[i]=new QComboBox(this);
        cmbUnit[i]->addItem(tr("No change"));
        cmbUnit[i]->addItem(tr("pix"));
        cmbUnit[i]->addItem(tr("in"));
        cmbUnit[i]->addItem(tr("cm"));
    layout->addWidget(cmbUnit[i],row,column++,1,1);
    spnResolution[i]=new QDoubleSpinBox(this);
        spnResolution[i]->setRange(-1.0,6000.0);
        spnResolution[i]->setSingleStep(1.0);
        spnResolution[i]->setDecimals(2);
    layout->addWidget(spnResolution[i],row,column++,1,1);
    cmbAntialiasing[i]=new QComboBox(this);
        cmbAntialiasing[i]->addItem(tr("No change"));
        cmbAntialiasing[i]->addItem(tr("None"));
        cmbAntialiasing[i]->addItem(tr("Fonts only"));
        cmbAntialiasing[i]->addItem(tr("Plot only"));
        cmbAntialiasing[i]->addItem(tr("Fonts and plot"));
    layout->addWidget(cmbAntialiasing[i],row,column++,1,1);
    cmbLineScaling[i]=new QComboBox(this);
        cmbLineScaling[i]->addItem(tr("No change"));
        cmbLineScaling[i]->addItem(tr("No scaling"));
        cmbLineScaling[i]->addItem(tr("Line scaling"));
    layout->addWidget(cmbLineScaling[i],row++,column++,1,1);
    }

    empty=new QWidget(this);
    layout0=new QGridLayout(this);
    layout0->setSpacing(STD_SPACING);
    layout0->setMargin(0);
    lblActive2=new QLabel(tr("Activate internal default quick-selection-geometries:"),this);
    layout->addWidget(lblActive2,row++,0,1,11);
    int max_in_row=4,row2=0,column2=0;
    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
    chkActive2[i]=new QCheckBox(QString(DefaultSystemDeviceGeometry[i].name),this);
    layout0->addWidget(chkActive2[i],row2,column2++);
        if (column2>=max_in_row)
        {
        row2++;
        column2=0;
        }
    }
    empty->setLayout(layout0);
    layout->addWidget(empty,row++,0,1,11);
    buttons=new stdButtonGroup(this);
    connect(buttons->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttons->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttons->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    layout->addWidget(buttons,row,0,1,11);
    setLayout(layout);
    redisplaySeparators();
    resize(LastSize_FormUserDefaultDevice);
}

frmUserDefaultGeometries::~frmUserDefaultGeometries()
{
LastSize_FormUserDefaultDevice=this->size();
}

void frmUserDefaultGeometries::init(void)
{
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    lenName[i]->setText(QString::fromLocal8Bit(DefaultUserDeviceGeometry[i].name));
    chkActive1[i]->setChecked((bool)DefaultUserDeviceGeometry[i].active);
    cmbDevice[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].dev_nr+1);
    cmbOrientation[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].orientation+1);
    spnWidth[i]->setValue(DefaultUserDeviceGeometry[i].width);
    spnHeight[i]->setValue(DefaultUserDeviceGeometry[i].height);
    cmbUnit[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].unit+1);
    spnResolution[i]->setValue(DefaultUserDeviceGeometry[i].dpi);
    cmbAntialiasing[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].Antialiasing+1);
    cmbLineScaling[i]->setCurrentIndex(DefaultUserDeviceGeometry[i].ScaleLineWidth+1);
    }
    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
    chkActive2[i]->setChecked((bool)DefaultSystemDeviceGeometry[i].active);
    }
}

void frmUserDefaultGeometries::doApply(void)
{
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    strcpy(DefaultUserDeviceGeometry[i].name,lenName[i]->text().toLocal8Bit().constData());
    DefaultUserDeviceGeometry[i].active=(chkActive1[i]->isChecked()==true?TRUE:FALSE);
    DefaultUserDeviceGeometry[i].dev_nr=cmbDevice[i]->currentIndex()-1;
    DefaultUserDeviceGeometry[i].orientation=cmbOrientation[i]->currentIndex()-1;
    DefaultUserDeviceGeometry[i].width=spnWidth[i]->value();
    DefaultUserDeviceGeometry[i].height=spnHeight[i]->value();
    DefaultUserDeviceGeometry[i].unit=cmbUnit[i]->currentIndex()-1;
    DefaultUserDeviceGeometry[i].dpi=spnResolution[i]->value();
    DefaultUserDeviceGeometry[i].Antialiasing=cmbAntialiasing[i]->currentIndex()-1;
    DefaultUserDeviceGeometry[i].ScaleLineWidth=cmbLineScaling[i]->currentIndex()-1;
    }
    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
    DefaultSystemDeviceGeometry[i].active=(chkActive2[i]->isChecked()==true?TRUE:FALSE);
    }
    emit(newUserDefaults());
}

void frmUserDefaultGeometries::doAccept(void)
{
    ApplyError=false;
    doApply();
    if (ApplyError==false)
    doClose();
}

void frmUserDefaultGeometries::doClose(void)
{
    hide();
}

void frmUserDefaultGeometries::redisplaySeparators(void)
{
    QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
///qDebug() << "newLocale=" << DecimalPointToUse;
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    spnWidth[i]->setLocale(newLocale);
    spnHeight[i]->setLocale(newLocale);
    spnResolution[i]->setLocale(newLocale);
    spnWidth[i]->setValue(spnWidth[i]->value());
    spnHeight[i]->setValue(spnHeight[i]->value());
    spnResolution[i]->setValue(spnResolution[i]->value());
    }
}

frmDeviceSetup::frmDeviceSetup(QWidget * parent):QDialog(parent)
{
    cur_version=0;
    actNativePrinterDialog=NULL;
    printDialog=NULL;
    int number;
    QString entr[32];
    int i_entr[32];
    strcpy(out_format_int,"%.0f");
    strcpy(out_format_float,"%.2f");
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: File Export Setup"));
    setWindowIcon(QIcon(*GraceIcon));
    cur_dev=0;
    parent_of_print_dialog=0;

    CreateActions();
//cout << "DeviceSetup_Start: " << actNativePrinterDialog << endl;

    grpDevSetup=new QGroupBox(tr("Device setup"),this);
    grpOutput=new QGroupBox(tr("Output"),this);
    grpPage=new QGroupBox(tr("Page-Settings"),this);
    grpFonts=new QGroupBox(tr("Font-Settings"),this);

    grpPage->setCheckable(true);
    connect(grpPage,SIGNAL(toggled(bool)),this,SLOT(geometryGroupToggled(bool)));
    grpFonts->setCheckable(true);
    connect(grpFonts,SIGNAL(toggled(bool)),this,SLOT(fontGroupToggled(bool)));

    device_opts_item=new QPushButton(tr("Format options..."),grpDevSetup);
    connect(device_opts_item,SIGNAL(clicked()),this,SLOT(doDevOpt()));
    wbut=new QPushButton(tr("Browse..."),grpOutput);
    connect(wbut,SIGNAL(clicked()),this,SLOT(doBrowse()));

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu("&File",this);
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actNativePrinterDialog);
    mnuFile->addAction(actPrintToFile);
    mnuFile->addSeparator();
    mnuFile->addAction(actClose);
    mnuOptions=new QMenu("&Options",this);
    mnuOptions->setTearOffEnabled(TRUE);
    mnuOptions->addAction(dsync_item);
    mnuOptions->addAction(psync_item);
    mnuQuickSelect=new QMenu("&Quick Format Selection",this);
    mnuQuickSelect->setTearOffEnabled(TRUE);
    mnuHelp=new QMenu("&Help",this);
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnDevSetup);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuOptions);
    menuBar->addMenu(mnuQuickSelect);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    number=number_of_devices();
    for (int i=0;i<number;i++)
    {
    entr[i]=get_device_name(i);
    }
    devices_item=new StdSelector(grpDevSetup,tr("Output format:"),number,entr);
    connect(devices_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(DeviceChanged(int)));
    number=2;
    entr[0]=tr("Landscape");
    entr[1]=tr("Portrait");
    i_entr[0]=PAGE_ORIENT_LANDSCAPE;
    i_entr[1]=PAGE_ORIENT_PORTRAIT;
    page_orient_item=new StdSelector(grpPage,tr("Orientation:"),number,entr);
    page_orient_item->setValues(i_entr);
    connect(page_orient_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(OrientationChanged(int)));

    quickMapper=new QSignalMapper();
        for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
        {
        act_quickSel[i]=new QAction(tr("User Default ") + QString::number(i+1) + QString(": ") + QString::fromLocal8Bit(DefaultUserDeviceGeometry[i].name),this);
        connect(act_quickSel[i], SIGNAL(triggered()), quickMapper, SLOT(map()));
        quickMapper->setMapping(act_quickSel[i],-NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i);
        mnuQuickSelect->addAction(act_quickSel[i]);
        }
    connect(quickMapper, SIGNAL(mapped(int)),this, SLOT(QuickResolutionChange(int)));
    mnuQuickSelect->addSeparator();

    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
    //entr[i]+=QString(" (")+QString::number(quick_pg[i].width)+QString("x")+QString::number(quick_pg[i].height)+QString(")");
    act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i]=new QAction(QString(DefaultSystemDeviceGeometry[i].name),this);
    connect(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i], SIGNAL(triggered()), quickMapper, SLOT(map()));
    quickMapper->setMapping(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i],i);
    mnuQuickSelect->addAction(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i]);
    }
    mnuQuickSelect->addSeparator();
    act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS]=new QAction(tr("Edit User Default Geometries"),this);
    mnuQuickSelect->addAction(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS]);
    connect(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS],SIGNAL(triggered()),this,SLOT(doDefaultPageGeometrySetup()));
    mnuQuickSelect->addSeparator();
    act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS+1]=new QAction(tr("Discard changes / Reset settings"),this);
    mnuQuickSelect->addAction(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS+1]);
    connect(act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+NR_OF_QUICKSELECTOPTIONS+1],SIGNAL(triggered()),this,SLOT(doReset()));

    quick_resolution_selector=new StdSelector(grpPage,tr("Quick select:"),number,entr);
    connect(quick_resolution_selector->cmbSelect,SIGNAL(activated(int)),SLOT(QuickResolutionChange(int)));

    number=12;
    entr[0]=tr("Custom");
    entr[1]=tr("Letter");
    entr[2]=tr("A4");
    entr[3]=tr("A3");
    entr[4]=tr("A2");
    entr[5]=tr("A1");
    entr[6]=tr("A0");
    entr[7]=tr("B4");
    entr[8]=tr("B5");
    entr[9]=tr("B6");
    entr[10]=tr("Legal");
    entr[11]=tr("Tabloid");
    i_entr[0]=PAGE_FORMAT_CUSTOM;
    i_entr[1]=PAGE_FORMAT_USLETTER;
    i_entr[2]=PAGE_FORMAT_A4;
    i_entr[3]=PAGE_FORMAT_A3;
    i_entr[4]=PAGE_FORMAT_A2;
    i_entr[5]=PAGE_FORMAT_A1;
    i_entr[6]=PAGE_FORMAT_A0;
    i_entr[7]=PAGE_FORMAT_B4;
    i_entr[8]=PAGE_FORMAT_B5;
    i_entr[9]=PAGE_FORMAT_B6;
    i_entr[10]=PAGE_FORMAT_USLEGAL;
    i_entr[11]=PAGE_FORMAT_USTABLOID;
    page_format_item=new StdSelector(grpPage,tr("Size:"),number,entr);
    page_format_item->setValues(i_entr);
    connect(page_format_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(SizeChanged(int)));

    print_string_item=new stdLineEdit(grpOutput,tr("Print command:"));
    print_string_item->lenText->setText(QString(""));
    print_string_item->setVisible(false);
    printfile_item=new stdLineEdit(grpOutput,tr("File name:"));
    printfile_item->lenText->setText(QString(""));
    page_x_item=new stdLineEdit(grpPage,tr("Dimensions:"));
    page_y_item=new stdLineEdit(grpPage,tr("x"));
    dev_res_item=new stdLineEdit(grpPage,tr("Resolution (dpi):"));
    connect(dev_res_item->lenText,SIGNAL(textEdited(QString)),SLOT(dpiInputChanged(QString)));
    //connect(dev_res_item->lenText,SIGNAL(returnPressed()),SLOT(DpisChanged()));
    page_size_unit_item=new QComboBox(grpPage);
    page_size_unit_item->addItem(tr("pix"));
    page_size_unit_item->addItem(tr("in"));
    page_size_unit_item->addItem(tr("cm"));
    connect(page_size_unit_item,SIGNAL(currentIndexChanged(int)),this,SLOT(DimChanged(int)));
    chkDontChangeSize=new QCheckBox(tr("Don't reposition Graph(s) "),this);
    chkScaleLineWidthByResolution=new QCheckBox(tr("Scale line width by resolution "),this);
    chkUseAntialiasing=new QCheckBox(tr("Enable antialiasing (except for fonts) "),this);

    printto_item=new QCheckBox(tr("Print to file"),grpOutput);
    connect(printto_item,SIGNAL(stateChanged(int)),this,SLOT(PrintToFileClicked(int)));
    printto_item->setVisible(false);

    fontaa_item=new QCheckBox(tr("Enable font antialiasing"),grpFonts);
    devfont_item=new QCheckBox(tr("Use device fonts"),grpFonts);
    devfont_item->setChecked(TRUE);
/*
qDebug() << "DeviceSetup_Mitte: " << actNativePrinterDialog;

    actNativePrinterDialog=new QAction(this);
    connect(actNativePrinterDialog,SIGNAL(triggered()),this,SLOT(doNativePrinterDialog()));

qDebug() << "DeviceSetup_Ende: " << actNativePrinterDialog;
*/
    cmdNativePrinterDialog=new QPushButton(tr("Open native printer dialog"),this);
    connect(cmdNativePrinterDialog,SIGNAL(clicked()),this,SLOT(doNativePrinterDialog()));
    cmdNativePrinterDialog->setVisible(false);

    cmdDoPrint=new QPushButton(tr("Export to File"),this);
    connect(cmdDoPrint,SIGNAL(clicked()),SLOT(doPrintToFile()));
    QFont ExportCmdFont=cmdDoPrint->font();
    ExportCmdFont.setBold(true);
    cmdDoPrint->setFont(ExportCmdFont);

    cmdUseScreenResolution=new QPushButton(tr("Use screen resolution"),this);
    connect(cmdUseScreenResolution,SIGNAL(clicked()),SLOT(doUseScreenResolution()));

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

        for (int i=0;i<7;i++)
        DevOptions[i]=NULL;

    layout0=new QHBoxLayout();
    layout0->setMargin(STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(devices_item);
    layout0->addWidget(device_opts_item);
    grpDevSetup->setLayout(layout0);
    layout1=new QGridLayout();
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
        /*layout1->addWidget(printto_item,0,0,1,1);
        layout1->addWidget(cmdDoPrint,0,1,1,1);
        layout1->addWidget(cmdNativePrinterDialog,0,2,1,1);*/
    layout1->addWidget(cmdDoPrint,1,0,1,3);
        //layout1->addWidget(cmdDoPrint,1,0,1,1);
        //layout1->addWidget(cmdNativePrinterDialog,1,1,1,1);
        //layout1->addWidget(print_string_item,1,0,1,3);
    layout1->addWidget(printfile_item,0,0,1,2);
    layout1->addWidget(wbut,0,2);
    grpOutput->setLayout(layout1);
    layout2=new QGridLayout();
    layout2->setMargin(STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    layout2->addWidget(page_orient_item,0,0,1,2);
    layout2->addWidget(page_format_item,0,2,1,2);
    layout2->addWidget(page_x_item,1,0,1,2);
    layout2->addWidget(page_y_item,1,2);
    layout2->addWidget(page_size_unit_item,1,3);
    layout2->addWidget(dev_res_item,2,0);//,1,2
    layout2->addWidget(cmdUseScreenResolution,2,1);
    layout2->addWidget(chkDontChangeSize,3,1);//,2,1,1,2);
    layout2->addWidget(chkScaleLineWidthByResolution,3,2);
    layout2->setRowStretch(0,1);
    layout2->setRowStretch(1,1);
    layout2->setRowStretch(2,1);
    layout2->setRowStretch(3,1);
    layout2->setRowStretch(4,10);
    layout2->setColumnStretch(0,2);
    layout2->setColumnStretch(1,2);
    layout2->setColumnStretch(2,2);
    //layout2->addWidget(quick_resolution_selector,3,0);
    quick_resolution_selector->hide();
    layout2->addWidget(chkUseAntialiasing,3,0);
    grpPage->setLayout(layout2);
    layout3=new QGridLayout();
    layout3->setMargin(STD_MARGIN);
    layout3->setSpacing(STD_SPACING);
    layout3->addWidget(fontaa_item,0,0);
    layout3->addWidget(devfont_item,0,1);
    layout3->setRowStretch(0,1);
    layout3->setRowStretch(1,10);
    grpFonts->setLayout(layout3);

    layout=new QVBoxLayout();
    layout->setMargin(STD_MARGIN);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(grpDevSetup);
    layout->addWidget(grpOutput);
    layout->addWidget(grpPage);
    layout->addWidget(grpFonts);
    layout->addWidget(buttonGroup);
    layout->addStretch(10);

    /*layout->setStretch(0,0);
    layout->setStretch(1,1);
    layout->setStretch(2,1);
    layout->setStretch(3,1);
    layout->setStretch(4,1);
    layout->setStretch(5,0);
    layout->setStretch(6,10);*/
    setLayout(layout);

    printto_item->setChecked(TRUE);
    PrintToFileClicked(Qt::Checked);
    page_format_item->setCurrentIndex(1);
    DeviceChanged(0);
    resize(LastSize_FormDeviceSetup);
}

frmDeviceSetup::~frmDeviceSetup()
{
    showPageSettings=grpPage->isChecked();
    showFontSettings=grpFonts->isChecked();
    LastSize_FormDeviceSetup=this->size();
}

void frmDeviceSetup::init(int dev)
{
    //SetOptionChoice(devices_item, dev);
    devices_item->setCurrentValue(dev);
    DeviceChanged(dev);
    dsync_item->setChecked(sync_device_dims);
    psync_item->setChecked(rescale_plot_on_size_change);
//qDebug() << "ShowPage=" << showPageSettings;
//qDebug() << "ShowFont=" << showFontSettings;
    grpPage->setChecked((bool)showPageSettings);
    grpFonts->setChecked((bool)showFontSettings);
    recreateQuickMenu();
}

void frmDeviceSetup::CreateActions(void)
{
    actNativePrinterDialog=new QAction(tr("&Print"),this);
    actNativePrinterDialog->setShortcut(tr("Ctrl+P"));
    actNativePrinterDialog->setStatusTip(tr("Print on physical printer, using the settings in this dialog."));
    connect(actNativePrinterDialog,SIGNAL(triggered()), this, SLOT(doPrintToPrinter()));
    actPrintToFile=new QAction(tr("&Export to file"),this);
    actPrintToFile->setShortcut(tr("Ctrl+F"));
    connect(actPrintToFile,SIGNAL(triggered()), this, SLOT(doPrintToFile()));
    dsync_item=new QAction(tr("&Sync page size of screen and all output formats"),this);
    dsync_item->setCheckable(TRUE);
    dsync_item->setChecked(TRUE);
    connect(dsync_item,SIGNAL(triggered()), this, SLOT(doSyncPage()));
    psync_item=new QAction(tr("&Rescale plot on page size change"),this);
    psync_item->setCheckable(TRUE);
    psync_item->setChecked(FALSE);
    connect(psync_item,SIGNAL(triggered()), this, SLOT(doRescalePlot()));
    actClose=new QAction(tr("&Close"),this);
    actClose->setShortcut(tr("Esc"));
    connect(actClose,SIGNAL(triggered()), this, SLOT(doClose()));
    actHelpOnContext=new QAction(tr("On conte&xt"),this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext,SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnDevSetup=new QAction(tr("On &device setup"),this);
    connect(actHelpOnDevSetup,SIGNAL(triggered()), this, SLOT(doHelpOnDevSetup()));
}

void frmDeviceSetup::PrintToFileClicked(int i)
{
    if (i==Qt::Checked)
    {
        print_string_item->setEnabled(FALSE);
        printfile_item->setEnabled(TRUE);
        wbut->setEnabled(TRUE);
    }
    else if (i==Qt::Unchecked)
    {
        print_string_item->setEnabled(TRUE);
        printfile_item->setEnabled(FALSE);
        wbut->setEnabled(FALSE);
    }
}

void frmDeviceSetup::DeviceChanged(int device_id)//output-device changed (screen, pdf, png, ...)
{
    char buf[GR_MAXPATHLEN];//, *bufptr;
    int page_units;
    double page_x, page_y;
    (void)device_id;
    PageFormat pf;

    Page_geometry pg;
    Device_entry dev;

    //cur_dev=device_id;
    //dev = get_device_props(device_id);

    cur_dev=devices_item->currentValue();
    dev = get_device_props(cur_dev);

    pg = dev.pg;

    if (dev.setup == NULL) {
        SetSensitive(device_opts_item, false);
    } else {
        SetSensitive(device_opts_item, true);
    }

    if (dev.type==DEVICE_TERM)
    {
        device_opts_item->setText(tr("Copy page to clipboard."));
        SetSensitive(device_opts_item, true);
    }
    else
    {
        device_opts_item->setText(tr("Format options..."));
    }

    //if (print_file == NULL || print_file[0] == '\0') {
    if (print_file[0] == '\0') {
        strcpy(print_file, mybasename(get_docname()));
    }

    /// * Replace existing filename extension */
    /*bufptr = strrchr(print_file, '.');
            if (bufptr) {
                *(bufptr + 1) = '\0';
            } else {
                strcat(print_file, ".");
            }
            strcat(print_file, dev.fext);*/
    /// sprintf(print_file,"%s.%s",get_docbname(),dev.fext);

    QString pf1=printfile_item->lenText->text();
    if (!pf1.isEmpty())
    {
//qDebug() << "repalce suffix of existing filename";
    replaceSuffix(pf1,QString(dev.fext));
    }
    else
    {
//qDebug() << "generate filename with suffix";
    pf1=get_filename_with_extension(cur_dev);
    //pf1=get_filename_with_extension(device_id);
    }
/*
    QString print_file_with_extension=get_filename_with_extension(device_id);
    strcpy(print_file,print_file_with_extension.toLocal8Bit().constData());
*/
    strcpy(print_file,pf1.toLocal8Bit().constData());

    //qDebug() << "pf1=" << pf1;

    printfile_item->lenText->setText(pf1);
    //xv_setstr(printfile_item, print_file);
    xv_setstr(print_string_item, get_print_cmd());

    switch (dev.type) {
    case DEVICE_TERM://for the screen
        grpOutput->setVisible(false);
        break;
    case DEVICE_FILE://output to a file
        grpOutput->setVisible(true);
        SetToggleButtonState(printto_item, true);
        SetSensitive(printto_item, true);
        //SetSensitive(printto_item, false);
        SetSensitive(print_string_item, false);
        //SetSensitive(rc_filesel, true);
        SetSensitive(printfile_item, true);
        SetSensitive(wbut, true);
        break;
    case DEVICE_PRINT://output to a printer
        grpOutput->setVisible(true);
        SetToggleButtonState(printto_item, get_ptofile());
        SetSensitive(printto_item, true);
        if (get_ptofile() == true) {
            //SetSensitive(rc_filesel, true);
            SetSensitive(printfile_item, true);
            SetSensitive(wbut, true);
            SetSensitive(printto_item, true);
            //SetSensitive(printto_item, false);
            SetSensitive(print_string_item, false);
        } else {
            //SetSensitive(rc_filesel, false);
            /// SetSensitive(printfile_item, false);
            SetSensitive(printfile_item, true);
            /// SetSensitive(wbut, false);
            SetSensitive(wbut, true);
            SetSensitive(printto_item, true);
            SetSensitive(print_string_item, true);
        }
        break;
    }

    SetOptionChoice(page_orient_item, pg.width < pg.height ? PAGE_ORIENT_PORTRAIT : PAGE_ORIENT_LANDSCAPE);
    pf = get_page_format(cur_dev);
    //pf = get_page_format(device_id);
    SetOptionChoice(page_format_item, pf);
    if (pf == PAGE_FORMAT_CUSTOM) {
        SetSensitive(page_x_item, true);
        SetSensitive(page_y_item, true);
        SetSensitive(page_orient_item, false);
    } else {
        SetSensitive(page_x_item, false);
        SetSensitive(page_y_item, false);
        SetSensitive(page_orient_item, true);
    }

    sprintf (buf, out_format_int, pg.dpi);
    xv_setstr(dev_res_item, buf);

    page_units = GetOptionChoice(page_size_unit_item);

    switch (page_units) {
    case 0:     /* pixels */
        out_format=out_format_int;
        page_x = (double) pg.width;
        page_y = (double) pg.height;
        break;
    case 1:      /* inches */
        out_format=out_format_float;
        page_x = ((double) pg.width / pg.dpi);
        page_y = ((double) pg.height / pg.dpi);
        break;
    case 2:      /* cm */
        out_format=out_format_float;
        page_x = (CM_PER_INCH * (double)pg.width / pg.dpi);
        page_y = (CM_PER_INCH * (double)pg.height / pg.dpi);
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }

    sprintf (buf, out_format, page_x);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_x_item, buf);

    sprintf (buf, out_format, page_y);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_y_item, buf);

    SetToggleButtonState(fontaa_item, dev.fontaa);
    SetToggleButtonState(devfont_item, dev.devfonts);
    SetToggleButtonState(chkScaleLineWidthByResolution,ScaleLineWidthByResolution);
    SetToggleButtonState(chkUseAntialiasing,general_antialiasing);
//replaceFileNameOnly(QString("nname"));
}

void frmDeviceSetup::OrientationChanged(int value)//change the page orientation
{
    int orientation = value;
    double px, py;
    //float px1,py1;
    int px2,py2;
    char buf[256];
    int page_units = GetOptionChoice(page_size_unit_item);
    int format = page_format_item->currentValue();
    double dpis;
    if (xv_evalexpr(dev_res_item, &dpis) != RETURN_SUCCESS) {
        errmsg(tr("Invalid dpi").toLocal8Bit().constData());
        return;
    }
    if (dpis <= 0.0 && startupphase==0) {
        errmsg(tr("Device resolution(s) <= 0").toLocal8Bit().constData());
        return;
    }
if (format!=PAGE_FORMAT_CUSTOM)
{
    switch (page_units)
    {
    case 0:     /* pixels */
        out_format=out_format_int;
        return_Page_Dimensions_pix(format,orientation,dpis,&px2,&py2);
        px=px2;
        py=py2;
        break;
    case 1:      /* inches */
        out_format=out_format_float;
        return_Page_Dimensions_in(format,orientation,&px,&py);
        /*px=px1;
        py=py1;*/
        break;
    case 2:      /* cm */
        out_format=out_format_float;
        return_Page_Dimensions_cm(format,orientation,&px,&py);
        /*px=px1;
        py=py1;*/
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }
}
else//custom format
{
    if (xv_evalexpr(page_x_item, &px) != RETURN_SUCCESS ||
            xv_evalexpr(page_y_item, &py) != RETURN_SUCCESS ) {
        errmsg(tr("Invalid page dimension(s)").toLocal8Bit().constData());
        return;
    }
}

    if ((orientation == PAGE_ORIENT_LANDSCAPE && px > py) ||
        (orientation == PAGE_ORIENT_PORTRAIT  && px < py) ) {
        sprintf (buf, out_format, px);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_x_item, buf);
        sprintf (buf, out_format, py);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_y_item, buf);
    } else {
        sprintf (buf, out_format, py);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_x_item, buf);
        sprintf (buf, out_format, px);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_y_item, buf);
    }
/*
}
else//not a custom value-->one of the preset-values
{
    sprintf (buf, out_format, py);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_x_item, buf);
    sprintf (buf, out_format, px);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_y_item, buf);
}
cout << "finished orentation changed" << endl;*/
}

void frmDeviceSetup::SizeChanged(int i_value)//change between Custom,Letter,A4 and so on
{
    int orientation;
    int value=page_format_item->currentValue();
    int x, y;
    double px, py;
    int page_units;
    double dpi;
    char buf[256];
    (void)i_value;
    if (value == PAGE_FORMAT_CUSTOM) {
        SetSensitive(page_x_item, true);
        SetSensitive(page_y_item, true);
        SetSensitive(page_orient_item, false);
        return;
    } else {
        SetSensitive(page_x_item, false);
        SetSensitive(page_y_item, false);
        SetSensitive(page_orient_item, true);
    }
    orientation = GetOptionChoice(page_orient_item);
    return_Page_Dimensions_pix(value,orientation,72.0,&x,&y);
    /*switch (value) {
    case PAGE_FORMAT_USLETTER:
        x = 612;
        y = 792;
        break;
    case PAGE_FORMAT_A4:
        x = 595;
        y = 842;
        break;
    case PAGE_FORMAT_CUSTOM:
    default:
        return;
    }*/
    //x and y are now the sizes in pixels at 72dpi
    page_units = GetOptionChoice(page_size_unit_item);
    switch (page_units) {
    case 0:      /* pixels */
        if (xv_evalexpr(dev_res_item, &dpi) != RETURN_SUCCESS) {
            errmsg(tr("Invalid dpi").toLocal8Bit().constData());
            return;
        }
        if (dpi <= 0.0 && startupphase==0) {
            errmsg(tr("Device resolution(s) <= 0").toLocal8Bit().constData());
            return;
        }
        out_format=out_format_int;
        return_Page_Dimensions_pix(value,orientation,dpi,&x,&y);
        px = x;
        py = y;
        break;
    case 1:      /* inches */
        out_format=out_format_float;
        px = x/72.0;
        py = y/72.0;
        break;
    case 2:      /* cm */
        out_format=out_format_float;
        px = x/72.0*CM_PER_INCH;
        py = y/72.0*CM_PER_INCH;
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }

    /*if ((orientation == PAGE_ORIENT_LANDSCAPE && px > py) ||
            (orientation == PAGE_ORIENT_PORTRAIT  && px < py) ) {*/
        sprintf (buf, out_format, px);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_x_item, buf);
        sprintf (buf, out_format, py);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_y_item, buf);
    /*} else {
        sprintf (buf, "%.2f", py);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_x_item, buf);
        sprintf (buf, "%.2f", px);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(page_y_item, buf);
    }*/

/*if (i==0)
{
page_orient_item->setEnabled(FALSE);
page_size_unit_item->setEnabled(TRUE);
page_x_item->setEnabled(TRUE);
page_y_item->setEnabled(TRUE);
}
else
{
page_orient_item->setEnabled(TRUE);
page_size_unit_item->setEnabled(FALSE);
page_x_item->setEnabled(FALSE);
page_y_item->setEnabled(FALSE);
}*/
}

void frmDeviceSetup::setLikeDefaultGeometry(UserDeviceGeometry * dg)
{
this->blockSignals(true);
    if (dg->dev_nr>=0)
    {
        int index=-1;
        for (int i=0;i<devices_item->number_of_entries;i++)
        {
            if (!strcmp(devices_item->entries[i].toLocal8Bit().constData(),get_device_name(dg->dev_nr)))
            {
            index=i;
            break;
            }
        }
        if (index>=0)
        devices_item->setCurrentIndex(index);
    }
    if (dg->orientation>=0)
    page_orient_item->setCurrentIndex(dg->orientation);
    if (dg->width>=0)
    page_x_item->setText(QString::number(dg->width,'f',2));
    if (dg->height>=0)
    page_y_item->setText(QString::number(dg->height,'f',2));
    if (dg->unit>=0)
    page_size_unit_item->setCurrentIndex(dg->unit);
    if (dg->dpi>=0)
    dev_res_item->setText(QString::number(dg->dpi,'f',2));
if (dg->Antialiasing>=0)
{
    //0=No Antialiasing
    //1=Font Antialiasing Only
    //2=Graph Antialiaing Only
    //3=Graph and Font Antialiasing
    //-1=no change
        if (dg->Antialiasing==1 || dg->Antialiasing==3)
        fontaa_item->setChecked(true);
        else
        fontaa_item->setChecked(false);
    if (dg->Antialiasing==2 || dg->Antialiasing==3)
    chkUseAntialiasing->setChecked(true);
    else
    chkUseAntialiasing->setChecked(false);
}
    if (dg->ScaleLineWidth>=0)
    {
        if (dg->ScaleLineWidth==0)
        chkScaleLineWidthByResolution->setChecked(false);
        else
        chkScaleLineWidthByResolution->setChecked(true);
    }
    page_format_item->setCurrentIndex(0);
    //qDebug() << "User Default " << curval;
this->blockSignals(false);
}

void frmDeviceSetup::QuickResolutionChange(int val)
{
int curval=NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+val;
//qDebug() << "QuickResolutionChanged=" << curval;
if (val<0)
{
setLikeDefaultGeometry(DefaultUserDeviceGeometry+curval);
}
else
{
setLikeDefaultGeometry(DefaultSystemDeviceGeometry+val);
    if (val==0 || val==1)//Letter
    {
    page_format_item->setCurrentIndex(1);
    }
    else if (val==2 || val==3)//A4
    {
    page_format_item->setCurrentIndex(2);
    }
}
}

void frmDeviceSetup::DimChanged(int i)//change between units for device-dimensions (pixel/inch or cm)
{
char buf[256];
double page_x, page_y;
//float px1,py1;
int px2,py2;
double dev_res;
int page_units = i;//pix,in,cm
int format=page_format_item->currentValue();//Custom / DIN A4 / Letter / and so on...
int orientation = GetOptionChoice(page_orient_item);
    if (xv_evalexpr(dev_res_item, &dev_res) != RETURN_SUCCESS) {
        errmsg(tr("Invalid device resolution").toLocal8Bit().constData());
        return;
    }
    if (dev_res <= 0.0 && startupphase==0) {
        errmsg(tr("Device resolution(s) <= 0").toLocal8Bit().constData());
        return;
    }
    switch (page_units)
    {
    case 0:     /* pixels */
        out_format=out_format_int;
        return_Page_Dimensions_pix(format,orientation,dev_res,&px2,&py2);
        page_x=px2;
        page_y=py2;
        break;
    case 1:      /* inches */
        out_format=out_format_float;
        return_Page_Dimensions_in(format,orientation,&page_x,&page_y);
        /*page_x=px1;
        page_y=py1;*/
        break;
    case 2:      /* cm */
        out_format=out_format_float;
        return_Page_Dimensions_cm(format,orientation,&page_x,&page_y);
        /*page_x=px1;
        page_y=py1;*/
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }
if (format==PAGE_FORMAT_CUSTOM)
{
    if (xv_evalexpr(page_x_item, &page_x) != RETURN_SUCCESS ||
        xv_evalexpr(page_y_item, &page_y) != RETURN_SUCCESS ) {
        errmsg(tr("Invalid page dimension(s)").toLocal8Bit().constData());
        return;
    }
//0=pixel
//1=inch
//2=cm
    if (current_page_units == page_units) {
        ;
    } else if (current_page_units == 0 && page_units == 1) {
        //pixel-->inch
        page_x /= dev_res;
        page_y /= dev_res;
    } else if (current_page_units == 0 && page_units == 2) {
        //pixel-->cm
        page_x /= (dev_res/CM_PER_INCH);
        page_y /= (dev_res/CM_PER_INCH);
    } else if (current_page_units == 1 && page_units == 0) {
        //inch-->pixel
        page_x *= dev_res;
        page_y *= dev_res;
    } else if (current_page_units == 1 && page_units == 2) {
        //inch-->cm
        page_x *= CM_PER_INCH;
        page_y *= CM_PER_INCH;
    } else if (current_page_units == 2 && page_units == 0) {
        //cm-->pixel
        page_x *= (dev_res/CM_PER_INCH);
        page_y *= (dev_res/CM_PER_INCH);
    } else if (current_page_units == 2 && page_units == 1) {
        //cm-->inch
        page_x /= CM_PER_INCH;
        page_y /= CM_PER_INCH;
    } else {
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }
}
    switch (page_units)
    {
    case 0:     /* pixels */
        out_format=out_format_int;
        break;
    case 1:      /* inches */
    case 2:      /* cm */
        out_format=out_format_float;
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        return;
    }
    current_page_units = page_units;

    sprintf (buf, out_format, page_x);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_x_item, buf);
    sprintf (buf, out_format, page_y);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(page_y_item, buf);
}

void frmDeviceSetup::DpisChanged(void)
{
OrientationChanged(page_orient_item->currentValue());
}

void frmDeviceSetup::changeDeviceList(int version)//this is useful for a change in the usage of libHaru (activate/deactivate it) and other output formats
{
//version=0 --> all
//version=1 --> just screen
//version=2 --> everything except Screen
int old_selection=devices_item->currentValue();
int number=number_of_devices();
QString * entr=new QString[number];
int * i_entr=new int[number];
int index=0;
    for (int i=0;i<number;i++)
    {
        if (((version==0 && isDeviceActive(i)) || (version==1 && i==DEVICE_SCREEN) || (version==2 && i!=DEVICE_SCREEN && isDeviceActive(i))) && (i!=DEVICE_PDF_HARU || (i==DEVICE_PDF_HARU && use_libHaru==TRUE)) )
        {
        entr[index]=get_device_name(i);
        i_entr[index++]=i;
        }
    }
cur_version=version;
disconnect(devices_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(DeviceChanged(int)));
devices_item->setNewEntries(index,entr,i_entr);
devices_item->setCurrentValue(old_selection);
connect(devices_item->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(DeviceChanged(int)));
    if (version==1)//just screen
    {
    setWindowTitle(tr("QtGrace: Page setup"));
    devices_item->setVisible(false);
    devices_item->setEnabled(false);
    grpDevSetup->setTitle(tr("Screenshot"));
    actHelpOnDevSetup->setText(tr("On &page setup"));
    }
    else//everything else --> the usual device-setup
    {
    setWindowTitle(tr("QtGrace: File Export Setup"));
    devices_item->setVisible(true);
    devices_item->setEnabled(true);
    grpDevSetup->setTitle(tr("Select output format"));
    actHelpOnDevSetup->setText(tr("On &output formats"));
    }
}

void frmDeviceSetup::doApply(void)
{
    ApplyError=false;
    int seldevice;
    double page_x, page_y;
    double dpi;
    int page_units;
    Device_entry dev;
    Page_geometry pg;
    int do_redraw = FALSE;

    int nr_of_gr=number_of_graphs();
    double old_small,new_small;
    Page_geometry cur_pg=get_page_geometry();
    Page_geometry old_pg=cur_pg;
    old_small=cur_pg.width<cur_pg.height?cur_pg.width:cur_pg.height;

    stdOutputFormat = seldevice = GetOptionChoice(devices_item);
    ScaleLineWidthByResolution=chkScaleLineWidthByResolution->isChecked()?TRUE:FALSE;
    general_antialiasing=chkUseAntialiasing->isChecked()?TRUE:FALSE;

    SaveDeviceState(seldevice,GetToggleButtonState(dsync_item));
    ListOfChanges.clear();
    ListOfOldStates.clear();

    dev = get_device_props(seldevice);

    sprintf(dummy,"@page size %ld, %ld",dev.pg.width,dev.pg.height);
    ListOfOldStates << QString(dummy);

    if (dev.type != DEVICE_TERM)
    {
        hdevice = seldevice;
        set_ptofile(GetToggleButtonState(printto_item));
        //strcpy(print_file, xv_getstr(printfile_item));
        strcpy(print_file,printfile_item->lenText->text().toLocal8Bit().constData());
//qDebug() << "print_file=" << print_file;
//qDebug() << "LineEdit=" << printfile_item->lenText->text();
        if (get_ptofile())
        {
            //strcpy(print_file, xv_getstr(printfile_item));
            set_exportname(print_file);
        }
        else
        {
            set_print_cmd(xv_getstr(print_string_item));
        }

    }

    dev.devfonts = GetToggleButtonState(devfont_item);
    dev.fontaa = GetToggleButtonState(fontaa_item);

    if (xv_evalexpr(page_x_item, &page_x) != RETURN_SUCCESS ||
        xv_evalexpr(page_y_item, &page_y) != RETURN_SUCCESS  )
    {
        errmsg(tr("Invalid page dimension(s)").toLocal8Bit().constData());
        ApplyError=true;
        goto end_dev_setup_apply;
    }

    if (xv_evalexpr(dev_res_item, &dpi) != RETURN_SUCCESS || dpi <= 0.0)
    {
        errmsg(tr("Invalid dpi").toLocal8Bit().constData());
        ApplyError=true;
        goto end_dev_setup_apply;
    }

    page_units = GetOptionChoice(page_size_unit_item);

    switch (page_units) {
    case 0:
        pg.width =  (long) page_x;
        pg.height = (long) page_y;
        break;
    case 1:
        pg.width =  (long) (page_x * dpi);
        pg.height = (long) (page_y * dpi);
        break;
    case 2:
        pg.width =  (long) (page_x * dpi / CM_PER_INCH);
        pg.height = (long) (page_y * dpi / CM_PER_INCH);
        break;
    default:
        errmsg(tr("Internal error").toLocal8Bit().constData());
        ApplyError=true;
        goto end_dev_setup_apply;
    }

    pg.dpi = dpi;

    if (GetToggleButtonState(dsync_item) == TRUE)
    {
    //cout << "doApply" << endl;
    //cout << pg.width << " x " << pg.height << " dpi=" << pg.dpi << endl;
        set_page_dimensions((int) rint(72.0*pg.width/pg.dpi),
                            (int) rint(72.0*pg.height/pg.dpi),
                            GetToggleButtonState(psync_item) == TRUE);
        do_redraw = TRUE;
    }

    dev.pg = pg;
    if (set_device_props(seldevice, dev) != RETURN_SUCCESS)
    {
        errmsg(tr("Invalid page dimensions or DPI").toLocal8Bit().constData());
        ApplyError=true;
        goto end_dev_setup_apply;
    }

    if (seldevice == tdevice)
    {
        do_redraw = TRUE;
    }

    setExportTypeDescription(dev.fext);

    sprintf(dummy,"@page size %ld, %ld",dev.pg.width,dev.pg.height);
    ListOfChanges << QString(dummy);

    //undo-stuff
    DeviceModified(seldevice,GetToggleButtonState(dsync_item));

    cur_pg=get_page_geometry();
    new_small=cur_pg.width<cur_pg.height?cur_pg.width:cur_pg.height;

    if (new_small!=old_small && chkDontChangeSize->isChecked()==true && nr_of_gr>0)//relation between viewport and pixels is changed and the users wants the graphs not to be changed
    {
        int * gnos=new int[nr_of_gr+1];
            for (int i=0;i<nr_of_gr;i++)
            gnos[i]=i;
        SaveGraphStatesPrevious(nr_of_gr,gnos,UNDO_APPEARANCE);//call this before the modification
        for (int i=0;i<nr_of_gr;i++)
        {
            g[i].v.xv1/=new_small/old_small;
            g[i].v.xv2/=new_small/old_small;
            g[i].v.yv1/=new_small/old_small;
            g[i].v.yv2/=new_small/old_small;
            g[i].v.yv1-=((double)old_pg.height-(double)cur_pg.height)/new_small;
            g[i].v.yv2-=((double)old_pg.height-(double)cur_pg.height)/new_small;
        }
        GraphsModified(nr_of_gr,gnos,UNDO_APPEARANCE);//call this after the modification
        addAditionalDescriptionToLastNode(-1,tr("Graph(s) repositioned"),QString());
        delete[] gnos;
    }
/*
    orig_page_w=device_table[0].pg.width;//save original size
    orig_page_h=device_table[0].pg.height;
    device_table[0].pg.width=orig_page_w*GeneralPageZoomFactor;//use Page Zoom
    device_table[0].pg.height=orig_page_h*GeneralPageZoomFactor;
*/
    if (do_redraw)
    {
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
    }
end_dev_setup_apply:
    set_left_footer(NULL);
    ;//end
}

void frmDeviceSetup::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmDeviceSetup::fontGroupToggled(bool t)
{
    if (t==true)//show
    {
        deltaFonts=this->height()-buttonGroup->y()-buttonGroup->height();
        fontaa_item->setVisible(t);
        devfont_item->setVisible(t);
        deltaFonts-=this->height()-buttonGroup->y()-buttonGroup->height();
        qApp->processEvents();
    }
    else//hide
    {
        deltaFonts=this->height()-buttonGroup->y()-buttonGroup->height();
        fontaa_item->setVisible(t);
        devfont_item->setVisible(t);
        deltaFonts-=this->height()-buttonGroup->y()-buttonGroup->height();
        qApp->processEvents();
        this->update();
        this->repaint();
        qApp->processEvents();
    //qDebug() << "deltaFonts=" << deltaFonts;
    this->resize(this->width(),this->height()+deltaFonts);
    }
}

void frmDeviceSetup::geometryGroupToggled(bool t)
{
    if (t==true)//show
    {
        deltaGeometry=this->height()-buttonGroup->y()-buttonGroup->height();
        cmdUseScreenResolution->setVisible(true);
        page_orient_item->setVisible(true);
        page_format_item->setVisible(true);
        page_x_item->setVisible(true);
        page_y_item->setVisible(true);
        dev_res_item->setVisible(true);
        page_size_unit_item->setVisible(true);
        chkDontChangeSize->setVisible(true);
        chkScaleLineWidthByResolution->setVisible(true);
        chkUseAntialiasing->setVisible(true);
        qApp->processEvents();
        deltaGeometry-=this->height()-buttonGroup->y()-buttonGroup->height();
    }
    else//hide
    {
        deltaGeometry=this->height()-buttonGroup->y()-buttonGroup->height();
    //qDebug() << "Ausgangspos=" << deltaGeometry;
        cmdUseScreenResolution->setVisible(false);
        page_orient_item->setVisible(false);
        page_format_item->setVisible(false);
        page_x_item->setVisible(false);
        page_y_item->setVisible(false);
        dev_res_item->setVisible(false);
        page_size_unit_item->setVisible(false);
        chkDontChangeSize->setVisible(false);
        chkScaleLineWidthByResolution->setVisible(false);
        chkUseAntialiasing->setVisible(false);
        qApp->processEvents();
        this->update();
        this->repaint();
        qApp->processEvents();
    //qDebug() << "Nachher=" << this->height()-buttonGroup->y()-buttonGroup->height();
        deltaGeometry-=this->height()-buttonGroup->y()-buttonGroup->height();
    //qDebug() << "deltaGeomtry=" << deltaGeometry;
    this->resize(this->width(),this->height()+deltaGeometry);
    }
}

void frmDeviceSetup::doDefaultPageGeometrySetup(void)
{
    if (FormUserDefaultGeometries==NULL)
    {
    FormUserDefaultGeometries=new frmUserDefaultGeometries(this);
    connect(FormUserDefaultGeometries,SIGNAL(newUserDefaults()),this,SLOT(recreateQuickMenu()));
    }
    FormUserDefaultGeometries->init();
    FormUserDefaultGeometries->show();
    FormUserDefaultGeometries->raise();
    FormUserDefaultGeometries->activateWindow();
}

void frmDeviceSetup::doReset(void)
{
    init(devices_item->currentValue());
}

void frmDeviceSetup::recreateQuickMenu(void)
{
    for (int i=0;i<NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES;i++)
    {
    act_quickSel[i]->setText(tr("User Default ") + QString::number(i+1) + QString(": ") + QString::fromLocal8Bit(DefaultUserDeviceGeometry[i].name));
        if (DefaultUserDeviceGeometry[i].active==TRUE)
        act_quickSel[i]->setVisible(true);
        else
        act_quickSel[i]->setVisible(false);
    }
    for (int i=0;i<NR_OF_QUICKSELECTOPTIONS;i++)
    {
        if (DefaultSystemDeviceGeometry[i].active==TRUE)
        act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i]->setVisible(true);
        else
        act_quickSel[NR_OF_USER_DEFAULT_DEVICE_GEOMETRIES+i]->setVisible(false);
    }
    mnuQuickSelect->update();
}

void frmDeviceSetup::closeEvent(QCloseEvent * e)
{
e->accept();
doClose();
}

void frmDeviceSetup::doClose(void)
{
    if (devices_item->number_of_entries>1)
    //{
    lastPrintDevice=devices_item->currentValue();
    /*cout << "closing PageSetup" << endl;
    }
    else
    cout << "closing ScreenSetup" << endl;*/
    showPageSettings=grpPage->isChecked();
    showFontSettings=grpFonts->isChecked();
    hide();
}

void frmDeviceSetup::doPrintToFile(void)
{
static int save_dirty_state=dirtystate;
    doApply();
    if (ApplyError==true) return;
    mainWin->PrintToFile();
dirtystate=save_dirty_state;
update_app_title();
    /*bool old_state=printto_item->isChecked();
    doPrint();
    printto_item->setChecked(old_state);
    printto_item->setEnabled(true);*/
}

void frmDeviceSetup::doPrintToPrinter(void)
{
static int save_dirty_state=dirtystate;
//cout << "doPrintToPrinter" << endl;
    doApply();
if (ApplyError==true) return;
    whoCalledThePrinter=1;
    mainWin->Print();
dirtystate=save_dirty_state;
update_app_title();
    whoCalledThePrinter=0;//reset to default
}

void frmDeviceSetup::doSyncPage(void)
{}

void frmDeviceSetup::doRescalePlot(void)
{}

void frmDeviceSetup::doHelpOnContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmDeviceSetup::doHelpOnDevSetup(void)
{
    HelpCB("doc/UsersGuide.html#print-setup");
}

void frmDeviceSetup::doBrowse(void)
{
QFileInfo qf(printfile_item->lenText->text());
    int seldevice = GetOptionChoice(devices_item);
    Device_entry dev = get_device_props(seldevice);
    QString FileExtension(dev.fext);
    QString absPath=qf.absoluteDir().absolutePath();
    cur_FileName=qf.completeBaseName()+QString(".")+FileExtension;

if (should_open_grace_file_dialog())
{
    if (FormSelectOutputFile==NULL)
    {
        FormSelectOutputFile=new frmIOForm(SELECT_PRINT_FILE,this);
        connect(FormSelectOutputFile,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    FileExtension=QString("*.")+FileExtension;
    FormSelectOutputFile->selector->setFilterFromExtern(absPath,FileExtension);

    FormSelectOutputFile->init();
    FormSelectOutputFile->ledSelection->setText(qf.absoluteFilePath());

    FormSelectOutputFile->show();
    FormSelectOutputFile->raise();
    FormSelectOutputFile->activateWindow();
}
else
{
    FileExtension=QString(dev.name)+QString(" (")+QString("*.")+FileExtension;
    FileExtension+=QString(");;All files (*)");
mainWin->UseOperatingSystemFileDialog(SELECT_PRINT_FILE,tr("QtGrace: Select print file"),absPath,FileExtension);
}
}

void frmDeviceSetup::IOrequested(int type,QString file,bool exists,bool writeable,bool readable)
{
    (void)type;
    (void)exists;
    (void)writeable;
    (void)readable;
    QString nfile=file;
    nfile.replace(QString("/\\"),QDir::separator());
    QFileInfo qf(nfile);
    if (qf.completeBaseName().isEmpty())
    {
    nfile+=cur_FileName;
    }
    printfile_item->setText(nfile);
    if (FormSelectOutputFile)
    FormSelectOutputFile->hide();
}

void frmDeviceSetup::doDevOpt(void)
{
    int device_id;
    int dev_nr=-1;
    Device_entry dev;
    device_id = GetOptionChoice(devices_item);

    if (device_id==DEVICE_TERM)//special case!
    {
        int save_focus_flag=draw_focus_flag;
        printing_in_file=true;
        if (save_focus_flag==TRUE || getbgfill()==FALSE)
        {
            draw_focus_flag = FALSE;
            mainWin->mainArea->completeRedraw();
        }
        QImage * pixm=new QImage();
        *pixm=MainPixmap->copy();
        qApp->clipboard()->setImage(*pixm);
        delete pixm;
        printing_in_file=false;
        draw_focus_flag = save_focus_flag;
        if (save_focus_flag==TRUE || getbgfill()==FALSE)
        {
            mainWin->mainArea->completeRedraw();
        }
        QMessageBox::information(this,tr("Information"),tr("Page copied to clipboard."));
        return;
    }

    dev = get_device_props(device_id);
    if (dev.setup == NULL) {
        /* Should never come to here */
        errmsg(tr("No options can be set for this device").toLocal8Bit().constData());
    } else {
        dev_nr=find_dev_nr(dev.name);
        //(dev.setup)();
    }

/*qDebug() << "device_id =" << device_id;
qDebug() << "dev_nr    =" << dev_nr;*/

    switch (dev_nr)
    {
    case DEVICE_PS:
        if (DevOptions[0]==NULL)
        {
            DevOptions[0]=new frmDeviceOptions(DEVICE_PS,this);
        }
        DevOptions[0]->init();
        DevOptions[0]->show();
        DevOptions[0]->raise();
        break;
    case DEVICE_EPS:
        if (DevOptions[1]==NULL)
        {
            DevOptions[1]=new frmDeviceOptions(DEVICE_EPS,this);
        }
        DevOptions[1]->init();
        DevOptions[1]->show();
        DevOptions[1]->raise();
        break;
    case DEVICE_PNM:
        if (DevOptions[2]==NULL)
        {
            DevOptions[2]=new frmDeviceOptions(DEVICE_PNM,this);
        }
        DevOptions[2]->init();
        DevOptions[2]->show();
        DevOptions[2]->raise();
        break;
    case DEVICE_JPEG:
        if (DevOptions[3]==NULL)
        {
            //DevOptions[3]=new frmDeviceOptions(DEVICE_JPEG,this);
            DevOptions[3]=new frmDeviceOptions(DEVICE_BMP,this);
            DevOptions[3]->setWindowTitle(tr("QtGrace: JPEG options"));
            DevOptions[3]->grpBMPoptions->setTitle(tr("JPEG options"));
        }
        DevOptions[3]->init();
        DevOptions[3]->show();
        DevOptions[3]->raise();
        break;
    case DEVICE_PNG:
        if (DevOptions[4]==NULL)
        {
            //DevOptions[4]=new frmDeviceOptions(DEVICE_PNG,this);
            DevOptions[4]=new frmDeviceOptions(DEVICE_BMP,this);
            DevOptions[4]->setWindowTitle(tr("QtGrace: PNG options"));
            DevOptions[4]->grpBMPoptions->setTitle(tr("PNG options"));
        }
        DevOptions[4]->init();
        DevOptions[4]->show();
        DevOptions[4]->raise();
        break;
    case DEVICE_BMP:
        if (DevOptions[5]==NULL)
        {
            DevOptions[5]=new frmDeviceOptions(DEVICE_BMP,this);
        }
        DevOptions[5]->init();
        DevOptions[5]->show();
        DevOptions[5]->raise();
        break;
    case DEVICE_TIFF:
        if (DevOptions[6]==NULL)
        {
            DevOptions[6]=new frmDeviceOptions(DEVICE_TIFF,this);
        }
        DevOptions[6]->init();
        DevOptions[6]->show();
        DevOptions[6]->raise();
        break;
    default:
        ;//Do nothing
        break;
    }
}

void frmDeviceSetup::doUseScreenResolution(void)
{
dev_res_item->setText(QString::number(QApplication::desktop()->physicalDpiX()));
DpisChanged();
}

bool frmDeviceSetup::openNativePrinter(int dev)//returns true, if everything is ok, and returns false, if the user selected cancel
{
/*static char dummy[1024];
bool ret=true;
int ret_val1;*/

curdev = get_device_props(dev);
tmp_dev = get_device_props(DEVICE_SCREEN);

//ofi.open(QString(QString(user_home_dir)+QDir::separator()+QString("Printer_Debug.txt")).toLocal8Bit().constData());

FormProgress->init(QObject::tr("Printing..."),5);
FormProgress->show();
FormProgress->raise();
FormProgress->activateWindow();

int orientation=curdev.pg.height<curdev.pg.width?0:1;
if (stdPrinter!=NULL)//delete stdPrinter
{
delete stdPrinter;
stdPrinter=NULL;
}
if (stdPrinter==NULL)
{
    if (useHDPrinterOutput==TRUE)
    stdPrinter=new QPrinter(QPrinter::HighResolution);//with this setting the Printer returns the maximum (interpolated) resolution possible (just used to limit the resolution if it does not fit the printer)
    else
    stdPrinter=new QPrinter(QPrinter::ScreenResolution);
stdPrinter->setFromTo(1,1);
}
stdPrinter->setColorMode(QPrinter::Color);
if (orientation==0)//landscape
{
    stdPrinter->setOrientation(QPrinter::Landscape);
}
else//Portrait
{
    stdPrinter->setOrientation(QPrinter::Portrait);
}

//ofi << "Vor Print Dialog " << endl;

/*
#ifdef WINDOWS_SYSTEM
//stdPrinter->setOutputFileName(QString());//on Windows it is often counterproductive to preset the filename - sometimes the printer-dialog is bloked because Windows thinks output to a file is wanted
//stdPrinter->setOutputToFile(false);
#else
stdPrinter->setOutputFileName(FormDeviceSetup->printfile_item->text());
#endif
*/
stdPrinter->setOutputFormat(QPrinter::NativeFormat);
//stdPrinter->setResolution(curdev.pg.dpi);
stdPrinter->setResolution(typicalPrinterResolution);
//QPrintDialog * printDialog=new QPrintDialog(mainWin);

if (printDialog!=NULL)
{
delete printDialog;
printDialog=NULL;
}

printDialog=new QPrintDialog(stdPrinter,mainWin);

if (printDialog==NULL)
{
errmsg(tr("Unable to open native printer dialog.").toLocal8Bit().constData());
return false;
}

/*
//printDialog->open(,SLOT(tryPrintingOnPrinter));
QTime st1;
st1.start();
ret_val1=printDialog->exec();
int millisec=st1.restart();
if (millisec<500) ret_val1=printDialog->exec();
*/

printDialog->setModal(true);

/*connect(printDialog,SIGNAL(accepted(QPrinter *)),SLOT(printerAccepted(QPrinter *)));
connect(printDialog,SIGNAL(rejected()),SLOT(printerRejected()));*/
qApp->processEvents();

/*ofi << "nach new PrintDialog" << endl;
cout << "nach new PrintDialog" << endl;*/

if (printDialog->exec() == QDialog::Accepted)
printerAccepted(stdPrinter);
else
printerRejected();

/*
if (printDialog!=NULL)
{
    cout << "vor show" << endl;
printDialog->show();
cout << "nach show" << endl;
printDialog->raise();
printDialog->activateWindow();
}*/

qApp->processEvents();
//printDialog->open(this,SLOT(printerAccepted(QPrinter*)));

return true;
}

void frmDeviceSetup::printerAccepted(QPrinter * pri)
{
    (void)pri;
    if (printDialog==NULL) return;
/*ofi << "in PrintDialog - accepted" << endl;
cout << "in PrintDialog - accepted" << endl;*/
/*
delete stdPrinter;
stdPrinter=printDialog->printer();
QPrinterInfo pinf(*stdPrinter);
cout << "Printer selected:" << pinf.printerName().constData() << endl;
*/
FormProgress->show();
FormProgress->raise();
FormProgress->activateWindow();
    if (printDialog->printer()->isValid())
    {
/*ofi << "Paper=" << printDialog->printer()->paperRect().width() << "x" << printDialog->printer()->paperRect().height() << endl;
ofi << "Page =" << printDialog->printer()->pageRect().width() << "x" << printDialog->printer()->pageRect().height() << endl;
ofi << "printing on selected Printer: Name=\"" << printDialog->printer()->printerName().toLatin1().constData() << "\"" << endl;*/

/*         QList<int> resols=stdPrinter->supportedResolutions();
cout << "Supported resolutions:" << endl;
        for (int k=0;k<resols.length();k++)
        {
            cout << resols.at(k) << " dpi" << endl;
        }
        cout << "---" << endl;*/
int savScaleLineWidthByResolution=ScaleLineWidthByResolution;
    curdev = get_device_props(DEVICE_SCREEN);
    /*curdev.pg.width=stdPrinter->pageRect().width();
    curdev.pg.height=stdPrinter->pageRect().height();
    curdev.pg.dpi=stdPrinter->resolution();
    set_device_props(DEVICE_SCREEN,curdev);*/
/// cout << "dpi=" << cur_dev.pg.dpi << endl;
/// cout << "Page=" << cur_dev.pg.width << " x " << cur_dev.pg.height << endl;
/// QSizeF ps123=stdPrinter->paperSize(QPrinter::Millimeter);
/// qDebug() << "PaperSize(mm)         = " << ps123.width() << " x " << ps123.height();
/// ps123=stdPrinter->paperSize(QPrinter::Point);
/// qDebug() << "PaperSize(points)     = " << ps123.width() << " x " << ps123.height();
/// ps123=stdPrinter->paperSize(QPrinter::DevicePixel);
/// qDebug() << "PaperSize(dev_pixels) = " << ps123.width() << " x " << ps123.height();
QRectF ps321=stdPrinter->pageRect(QPrinter::Inch);
//qDebug() << "PaperSize(inch)       = " << ps321.width() << " x " << ps321.height();
/// qDebug() << "Resolution = " << stdPrinter->resolution() << " dpi";
//qDebug() << "curdev = " << curdev.pg.width << " x " << curdev.pg.height;
        //delete stdPrinter;
        //stdPrinter=printDialog->printer();
        //GeneralPainter->begin(printDialog->printer());
        //stdPrinter->setResolution(cur_dev.pg.dpi);
        //printDialog->printer()->setResolution(cur_dev.pg.dpi);
        /*if (orientation==0)//landscape
        {
            stdPrinter->setOrientation(QPrinter::Landscape);
        }
        else//Portrait
        {
            stdPrinter->setOrientation(QPrinter::Portrait);
        }*/
curdev.pg.dpi=typicalPrinterResolution;
stdPrinter->setResolution(curdev.pg.dpi);
//we know the size on screen, but we need to know the size that fits on the page (keeping the aspect ratio)
double width_to_height=(curdev.pg.width*1.0)/(curdev.pg.height*1.0);
double page_width_to_height=ps321.width()/ps321.height();

if (whoCalledThePrinter==0)
{
/// who called the printer:
/// 0=from Main Menu
ScaleLineWidthByResolution=TRUE;
if ((width_to_height<=1.0 && page_width_to_height>1.0) || (width_to_height>=1.0 && page_width_to_height<1.0))
{
qDebug() << "Printer orientation does not match the Page orientation";
    if (stdPrinter->orientation()==QPrinter::Portrait)
    {
    stdPrinter->setOrientation(QPrinter::Landscape);
    }
    else
    {
    stdPrinter->setOrientation(QPrinter::Portrait);
    }
ps321=stdPrinter->pageRect(QPrinter::Inch);
page_width_to_height=ps321.width()/ps321.height();
qDebug() << "Orientation Changed";
qDebug() << "PaperSize(inch)       = " << ps321.width() << " x " << ps321.height();
}
    if (page_width_to_height<=width_to_height)
    {
    curdev.pg.width=ps321.width()*curdev.pg.dpi;
    curdev.pg.height=curdev.pg.width/width_to_height;
    }
    else
    {
    curdev.pg.height=ps321.height()*curdev.pg.dpi;
    curdev.pg.width=curdev.pg.height*width_to_height;
    }
}
else
{
/// who called the printer:
/// 1=FileExortSetup-Dialog
curdev.pg.dpi=dev_res_item->getIntValue();
curdev.pg.height=page_y_item->getIntValue();
curdev.pg.width=page_x_item->getIntValue();
}

set_device_props(DEVICE_SCREEN,curdev);

/*ofi << "valid PrintDialog - start printing" << endl;
cout << "valid PrintDialog - start printing" << endl;*/

    FormProgress->increase();
        print_target=PRINT_TARGET_PRINTER;
        useQPrinter=true;
        int sav_stop_setting=stop_repaint;
        stop_repaint=FALSE;
        xdrawgraph();/// for debugging: deactivate this to inhibit the actual printing
    FormProgress->increase();
        GeneralPainter->end();/// and this

    ScaleLineWidthByResolution=savScaleLineWidthByResolution;
set_device_props(DEVICE_SCREEN,tmp_dev);

/*ofi << "valid PrintDialog - stop printing" << endl;
cout << "valid PrintDialog - stop printing" << endl;*/

        print_target=PRINT_TARGET_SCREEN;
        useQPrinter=false;
        xdrawgraph();
    FormProgress->increase();
        GeneralPainter->end();
        stdPrinter=NULL;
        stop_repaint=sav_stop_setting;

/*ofi << "valid PrintDialog - repaint screen" << endl;
cout << "valid PrintDialog - repaint screen" << endl;*/

    }
    else//Invalid Printer!?
    {
//ofi << "Invalid PrintDialog" << endl;
        if (stdPrinter->outputFileName().isEmpty() || stdPrinter->outputFileName().isNull())
            strcpy(dummy,QString(QString(qt_grace_share_dir) +QDir::separator()+ QString("QtGracePdfOutput.pdf")).toLocal8Bit());
        else
            strcpy(dummy,stdPrinter->outputFileName().toLocal8Bit());

        QSizeF size(MainPixmap->width()*1.0,MainPixmap->height()*1.0);
        stdPrinter->setPaperSize(size,QPrinter::DevicePixel);
        stdPrinter->setPageMargins(0.0,0.0,0.0,0.0,QPrinter::DevicePixel);
        stdPrinter->setResolution(72);

        if (stdPrinter->outputFormat()!=QPrinter::PdfFormat)
        {
            stdPrinter->setOutputFormat(QPrinter::PdfFormat);
        }
        if (stdPrinter->outputFileName().isEmpty() || stdPrinter->outputFileName().isNull())
        {
            stdPrinter->setOutputFileName(dummy);
        }
        errwin(QObject::tr("Invalid Printer selected. Output redirected to:").toLocal8Bit());
        errwin(dummy);
/// print_target=PRINT_TARGET_FILE;
        /*useQPrinter=true;
        xdrawgraph();
    print_target=PRINT_TARGET_SCREEN;
        useQPrinter=false;
        xdrawgraph();*/
    FormProgress->progress->setMaximum(FormProgress->progress->maximum()+3);
    FormProgress->increase();
        int save_hdevice=hdevice;
        char * sav_print_file=new char[2+strlen(print_file)];
        strcpy(sav_print_file,print_file);
        strcpy(print_file,dummy);

        hdevice=DEVICE_PDF_HARU;
        int save_dirty_state=dirtystate;
            set_ptofile(true);
            printing_in_file=true;
        do_hardcopy();
    FormProgress->increase();
            printing_in_file=false;
            print_target=PRINT_TARGET_SCREEN;
            mainWin->mainArea->completeRedraw();
        dirtystate=save_dirty_state;
            update_app_title();
        hdevice=save_hdevice;

        strcpy(print_file,sav_print_file);
        delete[] sav_print_file;
    FormProgress->increase();
    }
    this->disconnect(printDialog,SIGNAL(accepted(QPrinter*)));//SLOT(printerAccepted()));
    this->disconnect(printDialog,SIGNAL(rejected()));// SLOT(printerRejected()));
//cout << "ende Accepted A" << endl;
//ofi.close();
    FormProgress->hide();
//cout << "ende Accepted B" << endl;
    printDialog->hide();
//cout << "ende Accepted C" << endl;
    delete printDialog;
    printDialog=NULL;
//cout << "ende Accepted D" << endl;
    useQPrinter=false;
}

void frmDeviceSetup::printerRejected(void)
{
//ret=false;
    if (printDialog==NULL) return;
//cout << "ende Rejected A" << endl;
    this->disconnect(printDialog,SIGNAL(accepted(QPrinter*)));//SLOT(printerAccepted()));
    this->disconnect(printDialog,SIGNAL(rejected()));// SLOT(printerRejected()));
//ofi.close();
    FormProgress->hide();
    printDialog->hide();
    delete printDialog;
    printDialog=NULL;
    useQPrinter=false;
//cout << "ende Rejected B" << endl;
}

void frmDeviceSetup::dpiInputChanged(QString text)
{
if (text.isEmpty()) return;
int ok;
double dpi_number;//=text.toInt(&ok);
ok=xv_evalexpr(dev_res_item, &dpi_number);
if (ok==RETURN_FAILURE || page_format_item->currentValue()==PAGE_FORMAT_CUSTOM) return;
OrientationChanged(page_orient_item->currentValue());
//cout << "DPI: Text=\"" << text.toLocal8Bit().constData() << "\" umgewandelt=" << dpi_number <<  endl;
}

void frmDeviceSetup::tryPrintingOnPrinter(QPrinter * printer)
{
(void)printer;
}

void frmDeviceSetup::doNativePrinterDialog(void)
{
    //cout << "doNativePrinterDialog" << endl;
this->hide();
    if (openNativePrinter(devices_item->currentValue())==false)//only show the setup-dialog again, if the user selected cancel
    this->show();
}

void frmDeviceSetup::replaceFileNameOnly(QString nname)
{
QString oldName;
QString newName;
oldName=printfile_item->lenText->text();
//cout << "oldName=#" << oldName.toLocal8Bit().constData() << "#" << endl;
QFileInfo fi2(oldName);
newName=fi2.absolutePath();
//cout << "absPath=#" << newName.toLocal8Bit().constData() << "#" << endl;
newName+=QDir::separator()+nname;
    if (!fi2.completeSuffix().isEmpty())
    newName+=QString(".")+fi2.completeSuffix();
//cout << "newName=#" << newName.toLocal8Bit().constData() << "#" << endl;
printfile_item->lenText->setText(newName);
}

tabLinestyles::tabLinestyles(QWidget * parent):QWidget(parent)
{
int nr=4;
QString * entries=new QString[nr];
entries[0]=tr("Current");
entries[1]=tr("from project file");
entries[2]=tr("from ini file");
entries[3]=tr("Grace default");
selShowLinestyles=new StdSelector(this,tr("Show linestyles:"),nr,entries);
connect(selShowLinestyles->cmbSelect,SIGNAL(activated(int)),SLOT(show_style_changed(int)));
delete[] entries;

cur_line_len=0;
cur_line_pattern=NULL;
cur_line_pm=NULL;
cur_line_ic=NULL;
cur_line_pendash=NULL;

cur_list_len=nr_of_current_linestyles;
cur_list_entries_length=new int[cur_list_len];
cur_list_patterns=new char*[cur_list_len];
cur_list_LineIcons=new QIcon*[cur_list_len];
cur_list_LinePixmaps=new QPixmap*[cur_list_len];
cur_list_PenDashPattern=new QVector<qreal>*[cur_list_len];

for (int i=0;i<cur_list_len;i++)
{
cur_list_entries_length[i]=lenghts_of_linestyle_patterns[i];
cur_list_patterns[i]=new char[cur_list_entries_length[i]];
memcpy(cur_list_patterns[i],current_linestyle_patterns[i],sizeof(char)*cur_list_entries_length[i]);
cur_list_LineIcons[i]=NULL;
cur_list_LinePixmaps[i]=NULL;
cur_list_PenDashPattern[i]=NULL;
create_one_line_pattern(cur_list_entries_length[i],cur_list_patterns[i],cur_list_LinePixmaps+i,cur_list_LineIcons+i,cur_list_PenDashPattern+i);
}

selStyles=new LineStyleSelector(this);//at this stage the LineStyleSelector has the same entries as is currently set as standard for QtGrace
empty=new QWidget(this);
hbox=new QHBoxLayout();
hbox->setMargin(0);
hbox->setSpacing(0);
nr_of_panels=20;
panels=new Panel*[nr_of_panels];

pmExample=new QPixmap(320,100);
pmExample->fill();
whitepanel=new QPixmap(35,35);
whitepanel->fill(Qt::white);
blackpanel=new QPixmap(35,35);
blackpanel->fill(Qt::black);
mapper=new QSignalMapper(this);

    for (int i=0;i<nr_of_panels;i+=2)
    {
    panels[i]=new Panel(blackpanel,this);
    panels[i+1]=new Panel(whitepanel,this);
    hbox->addWidget(panels[i]);
    hbox->addWidget(panels[i+1]);
    connect(panels[i], SIGNAL(mouseClicked()), mapper, SLOT(map()));
    mapper->setMapping(panels[i],i);
    connect(panels[i+1], SIGNAL(mouseClicked()), mapper, SLOT(map()));
    mapper->setMapping(panels[i+1],i+1);
    }

connect(mapper,SIGNAL(mapped(int)),this,SLOT(panel_clicked(int)));

lblExample=new QLabel(QString(""),this);
lblExample->setPixmap(*pmExample);

selLen=new stdIntSelector(this,tr("Length:"),1,100);
selPos=new stdIntSelector(this,tr("Position:"),0,nr_of_current_linestyles-1);
layout=new QGridLayout();
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);
buttons=new stdButtonGroup(this,true,true,false);

cmdEdit=new QPushButton(tr("Edit"),this);
cmdAppend=new QPushButton(tr("Append"),this);
cmdInsert=new QPushButton(tr("Insert"),this);
cmdDelete=new QPushButton(tr("Delete"),this);
cmdUp=new QPushButton(tr("Up"),this);
cmdDown=new QPushButton(tr("Down"),this);

cmdUseAsCurrent=new QPushButton(tr("Use these linestyles as current"),this);
cmdUseForIni=new QPushButton(tr("Use these linestyles as current and general defaults"),this);

connect(cmdEdit,SIGNAL(clicked()),SLOT(doEdit()));
connect(cmdAppend,SIGNAL(clicked()),SLOT(doAppend()));
connect(cmdInsert,SIGNAL(clicked()),SLOT(doInsert()));
connect(cmdDelete,SIGNAL(clicked()),SLOT(doDelete()));

connect(cmdUp,SIGNAL(clicked()),SLOT(doUp()));
connect(cmdDown,SIGNAL(clicked()),SLOT(doDown()));
connect(cmdUseAsCurrent,SIGNAL(clicked()),SLOT(doUseAsCurrent()));
connect(cmdUseForIni,SIGNAL(clicked()),SLOT(doUseForIni()));

connect(buttons->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(buttons->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(buttons->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

connect(selLen,SIGNAL(currentValueChanged(int)),SLOT(currentLengthChanged(int)));

empty->setLayout(hbox);

selShowLinestyles->setToolTip(tr("Select which set of linestyles is to be displayed here"));
selStyles->setToolTip(tr("Select the linestyle to be edited"));
lblExample->setToolTip(tr("Examples of how the currently selected linestyle looks like"));
selLen->setToolTip(tr("Edit the number of black/white tiles that define the linestyle"));
selPos->setToolTip(tr("Edit the linestyle at this position in the list\nWarning: Pressing Edit will overwrite the linestyle in this position!"));
cmdEdit->setToolTip(tr("Take the black and white patterns and generate a linestyle at the currently selected position (overwriting the existing one)"));
cmdAppend->setToolTip(tr("Append a new linestyle at the end of the list"));
cmdInsert->setToolTip(tr("Insert a new linestyle at the currently selected position in the list (move the other ones down)"));
cmdDelete->setToolTip(tr("Delete the linestyle at the current position from the list"));
cmdUp->setToolTip(tr("Swap the position of the currently selected linestyle with the one above it"));
cmdDown->setToolTip(tr("Swap the position of the currently selected linestyle with the one below it"));
cmdUseAsCurrent->setToolTip(tr("Use the set of linestyles that is currently displayed as the standard for the current project."));
cmdUseForIni->setToolTip(tr("Use the set of linestyles that is currently displayed as the default set of linestyles for the current project and store it in the ini-file"));

int line=0;
int col=0;

layout->addWidget(selShowLinestyles,line++,0,1,4);

layout->addWidget(selStyles,line++,col,1,4);
connect(selStyles,SIGNAL(currentIndexChanged(int)),SLOT(currentStyleChanged(int)));
layout->addWidget(selPos,line++,col,1,4);
layout->addWidget(selLen,line++,col,1,4);
layout->addWidget(empty,line++,col,1,4);

layout->addWidget(cmdEdit,line,0,1,1);
layout->addWidget(cmdInsert,line,1,1,1);
layout->addWidget(cmdAppend,line,2,1,1);
layout->addWidget(cmdDelete,line++,3,1,1);

layout->addWidget(cmdUp,line,0,1,2);
layout->addWidget(cmdDown,line++,2,1,2);

layout->addWidget(lblExample,line++,col,1,4);

layout->addWidget(cmdUseAsCurrent,line,0,1,2);
layout->addWidget(cmdUseForIni,line++,2,1,2);

layout->addWidget(new QWidget(this),line++,col,1,4);
layout->setRowStretch(line-1,3);

layout->addWidget(buttons,line++,col,1,4);
setLayout(layout);

generate_Pattern();
currentStyleChanged(1);
}

void tabLinestyles::init(void)
{
selStyles->setCurrentIndex(1);
}

void tabLinestyles::doApply(void)
{
//cout << "Apply" << endl;
setCurrentListForAll();
}

void tabLinestyles::doAccept(void)
{
ApplyError=false;
doApply();
    if (ApplyError==false)
    doClose();
}

void tabLinestyles::doClose(void)
{
    emit(close_wish());
    //hide();
}

void tabLinestyles::doAppend(void)
{
doSingularAppend();
refillLineStyleSelector();
//reinit
}

void tabLinestyles::doSingularAppend(void)
{
//cout << "doAppend" << endl;
int * dummy=new int[cur_list_len+1];
memcpy(dummy,cur_list_entries_length,sizeof(int)*cur_list_len);
dummy[cur_list_len]=cur_line_len;
delete[] cur_list_entries_length;
cur_list_entries_length=dummy;
char ** dummy2=new char*[cur_list_len+1];
memcpy(dummy2,cur_list_patterns,sizeof(char*)*cur_list_len);
dummy2[cur_list_len]=new char[cur_line_len];
memcpy(dummy2[cur_list_len],cur_line_pattern,sizeof(char)*cur_line_len);
delete[] cur_list_patterns;
cur_list_patterns=dummy2;
QIcon ** dummy3=new QIcon*[cur_list_len+1];
memcpy(dummy3,cur_list_LineIcons,sizeof(QIcon*)*cur_list_len);
dummy3[cur_list_len]=NULL;
delete[] cur_list_LineIcons;
cur_list_LineIcons=dummy3;
QPixmap ** dummy4=new QPixmap*[cur_list_len+1];
memcpy(dummy4,cur_list_LinePixmaps,sizeof(QPixmap*)*cur_list_len);
dummy4[cur_list_len]=NULL;
delete[] cur_list_LinePixmaps;
cur_list_LinePixmaps=dummy4;
QVector<qreal> ** dummy5=new QVector<qreal>*[cur_list_len+1];
memcpy(dummy5,cur_list_PenDashPattern,sizeof(QVector<qreal>*)*cur_list_len);
dummy5[cur_list_len]=NULL;
delete[] cur_list_PenDashPattern;
cur_list_PenDashPattern=dummy5;

create_one_line_pattern(cur_list_entries_length[cur_list_len],cur_list_patterns[cur_list_len],cur_list_LinePixmaps+cur_list_len,cur_list_LineIcons+cur_list_len,cur_list_PenDashPattern+cur_list_len);

cur_list_len++;
}

void tabLinestyles::doInsert(void)
{
int nr_to_edit=selPos->value();
//cout << "doInsert " << nr_to_edit << endl;
doSingularAppend();//first we append --> then we move the last entry upwards
for (int i=cur_list_len-1;i>nr_to_edit;i--)
{
doSwap(i,i-1);
}
for (int i=0;i<cur_list_len;i++)
{
delete cur_list_LinePixmaps[i];
cur_list_LinePixmaps[i]=NULL;
delete cur_list_LineIcons[i];
cur_list_LineIcons[i]=NULL;
delete cur_list_PenDashPattern[i];
cur_list_PenDashPattern[i]=NULL;
create_one_line_pattern(cur_list_entries_length[i],cur_list_patterns[i],cur_list_LinePixmaps+i,cur_list_LineIcons+i,cur_list_PenDashPattern+i);
}
refillLineStyleSelector();
//reinit
}

void tabLinestyles::doEdit(void)
{
int nr_to_edit=selPos->value();
//cout << "doEdit " << nr_to_edit << endl;
if (nr_to_edit>=cur_list_len)
{
doAppend();
return;
}
else if (nr_to_edit<=1)
{
errmsg(QObject::tr("Linestyles 0 and 1 are not editable!").toLocal8Bit().constData());
return;
}
//just replace one line-style
delete[] cur_list_patterns[nr_to_edit];
cur_list_entries_length[nr_to_edit]=cur_line_len;
cur_list_patterns[nr_to_edit]=new char[cur_line_len];
memcpy(cur_list_patterns[nr_to_edit],cur_line_pattern,sizeof(char)*cur_line_len);
create_one_line_pattern(cur_list_entries_length[nr_to_edit],cur_list_patterns[nr_to_edit],cur_list_LinePixmaps+nr_to_edit,cur_list_LineIcons+nr_to_edit,cur_list_PenDashPattern+nr_to_edit);
refillLineStyleSelector();
//reinit
}

void tabLinestyles::doDelete(void)
{
int nr_to_edit=selPos->value();
char dummy[48];
sprintf(dummy,"%d",nr_to_edit);
if (nr_to_edit<2 || nr_to_edit>=cur_list_len)
{
QMessageBox::information(this,tr("Warning"),tr("Unable to delete LineStyle ")+QString(dummy));
return;
}
int ret=QMessageBox::question(this,tr("Delete linestyle"),tr("Really delete linestyle nr ")+QString(dummy),QMessageBox::Yes | QMessageBox::Abort,QMessageBox::Abort);
if (ret==QMessageBox::Yes)
{
//cout << "deleting " << nr_to_edit << endl;
    delete[] cur_list_patterns[nr_to_edit];
    delete cur_list_LineIcons[nr_to_edit];
    delete cur_list_LinePixmaps[nr_to_edit];
    delete cur_list_PenDashPattern[nr_to_edit];
    for (int i=nr_to_edit;i<cur_list_len-1;i++)
    {
    cur_list_patterns[i]=cur_list_patterns[i+1];
    cur_list_entries_length[i]=cur_list_entries_length[i+1];
    cur_list_LineIcons[i]=cur_list_LineIcons[i+1];
    cur_list_LinePixmaps[i]=cur_list_LinePixmaps[i+1];
    cur_list_PenDashPattern[i]=cur_list_PenDashPattern[i+1];
    }
cur_list_len--;
refillLineStyleSelector();
//reinit
}
}

void tabLinestyles::doUseAsCurrent(void)
{//Use the settings currently shown as the Current LineStyles
int ret=QMessageBox::question(this,tr("Change current Linestyles"),tr("Use the currently shown linestyle(s) as current linestyles?"),QMessageBox::Yes | QMessageBox::No);
    if (ret==QMessageBox::No) return;
copy_line_style_patterns_to_current(cur_list_len,cur_list_entries_length,cur_list_patterns);
selShowLinestyles->setCurrentIndex(0);
selStyles->setCurrentIndex(1);
}

void tabLinestyles::doUseForIni(void)
{//Use the settings currently shown for the Ini-File
int ret=QMessageBox::question(this,tr("Change current Linestyles"),tr("Use the currently shown linestyle(s) as default linestyles?"),QMessageBox::Yes | QMessageBox::No);
    if (ret==QMessageBox::No) return;
copy_line_style_patterns_to_target(cur_list_len,cur_list_entries_length,cur_list_patterns,3);
selShowLinestyles->setCurrentIndex(2);
selStyles->setCurrentIndex(1);
}

void tabLinestyles::doSwap(int a,int b)
{
static int i_tmp;
static char * c_tmp;
static QIcon * ic_tmp;
static QPixmap * pm_tmp;
static QVector<qreal> * ve_tmp;
i_tmp=cur_list_entries_length[a];
cur_list_entries_length[a]=cur_list_entries_length[b];
cur_list_entries_length[b]=i_tmp;
c_tmp=cur_list_patterns[a];
cur_list_patterns[a]=cur_list_patterns[b];
cur_list_patterns[b]=c_tmp;
ic_tmp=cur_list_LineIcons[a];
cur_list_LineIcons[a]=cur_list_LineIcons[b];
cur_list_LineIcons[b]=ic_tmp;
pm_tmp=cur_list_LinePixmaps[a];
cur_list_LinePixmaps[a]=cur_list_LinePixmaps[b];
cur_list_LinePixmaps[b]=pm_tmp;
ve_tmp=cur_list_PenDashPattern[a];
cur_list_PenDashPattern[a]=cur_list_PenDashPattern[b];
cur_list_PenDashPattern[b]=ve_tmp;
}

void tabLinestyles::doUp(void)
{
//cout << "doUp" << endl;
int nr_to_edit=selPos->value();
char dummy[48];
sprintf(dummy,"%d",nr_to_edit);
if (nr_to_edit<3)
{
QMessageBox::warning(this,tr("Error"),tr("Unable to move LineStyle ") + QString(dummy)+tr(" up."));
return;
}
doSwap(nr_to_edit,nr_to_edit-1);
refillLineStyleSelector();
//reinit
}

void tabLinestyles::doDown(void)
{
//cout << "doDown" << endl;
int nr_to_edit=selPos->value();
char dummy[48];
sprintf(dummy,"%d",nr_to_edit);
if (nr_to_edit<2 || nr_to_edit>=cur_list_len-1)
{
QMessageBox::warning(this,tr("Error"),tr("Unable to move LineStyle ") + QString(dummy)+tr(" down."));
return;
}
doSwap(nr_to_edit,nr_to_edit+1);
refillLineStyleSelector();
//reinit
}

void tabLinestyles::setCurrentListForAll(void)
{
QString ques;
ApplyError=false;
switch (selShowLinestyles->currentIndex())
{
case 0://current
ques=tr("Do you really want to set the currently set linestyle(s) as standard for QtGrace?\nThis setting will only effect the current project.") ;
break;
case 1://file
ques=tr("Do you really want to change the saved linestyle settings read from the project file?\nAltering these linestyles has no real effect. When a project file is saved, the current linestyles are stored in the file.");
break;
case 2://ini
ques=tr("Do you really want to change the default linestyles store in the ini-file?\nThese linestyles will be used if the linestyle(s) are not stored in the project file.");
break;
case 3://Grace-Std.
ques=tr("The default Grace linestyles can not be changed!\nThese linestyles are listed here in order to be able to reset other linestyle settings.");
QMessageBox::information(this,tr("Unable to change defaults"),ques);
ApplyError=true;
break;
}
int ret;
if (selShowLinestyles->currentIndex()!=3)
{
ret=QMessageBox::question(this,tr("Set linestyle for QtGrace"),ques,QMessageBox::Yes | QMessageBox::Abort,QMessageBox::Abort);
    if (ret==QMessageBox::Yes)
    {
        if (selShowLinestyles->currentIndex()==0)//current
        {
        copy_line_style_patterns_to_current(cur_list_len,cur_list_entries_length,cur_list_patterns);
        mainWin->mainArea->completeRedraw();
        }
        else if (selShowLinestyles->currentIndex()==1)//file
        {
        copy_line_style_patterns_to_target(cur_list_len,cur_list_entries_length,cur_list_patterns,2);
        }
        else if (selShowLinestyles->currentIndex()==2)//ini
        {
        copy_line_style_patterns_to_target(cur_list_len,cur_list_entries_length,cur_list_patterns,3);
        }
    }
    else
    {
    ApplyError=true;
    }
}
}

void tabLinestyles::setPanelsToOnePattern(int len,char * pat,int pan_count)
{
    for (int i=0;i<nr_of_panels;i++)
    {
    delete panels[i];
    }
    delete[] panels;
panels=new Panel*[pan_count];
int index=0;
    for (int i=0;i<len;i++)
    {
        for (int j=0;j<((int)pat[i]);j++)
        {
            if (i%2==0)
            panels[index]=new Panel(blackpanel,this);
            else
            panels[index]=new Panel(whitepanel,this);
        panels[index]->setFrameShape(QFrame::Panel);
        panels[index]->setFrameStyle(QFrame::Raised | QFrame::WinPanel);
        panels[index]->setToolTip(tr("Press here to toggle between a black or white segment"));
        if (selShowLinestyles->currentIndex()==3) panels[index]->setEnabled(false);
        hbox->addWidget(panels[index]);
        connect(panels[index], SIGNAL(mouseClicked()), mapper, SLOT(map()));
        mapper->setMapping(panels[index],index);
        index++;
        }
    }
nr_of_panels=index;
}

int pattern_length(int len,char * pat)
{
int leng=0;
    for (int i=0;i<len;i++)
    {
    leng+=pat[i];
    }
return leng;
}

void tabLinestyles::show_style_changed(int nr)
{
int * source_list_len=NULL;
int ** source_list_entry_lengths=NULL;
char *** source_list_patterns=NULL;
switch (nr)
{
case 0://current
source_list_len=&nr_of_current_linestyles;
source_list_entry_lengths=&lenghts_of_linestyle_patterns;
source_list_patterns=&current_linestyle_patterns;
break;
case 1://file
source_list_len=&n_linestyles_file;
source_list_entry_lengths=&l_linestyle_pat_file;
source_list_patterns=&linestyle_pat_file;
break;
case 2://ini
source_list_len=&n_linestyles_ini;
source_list_entry_lengths=&l_linestyle_pat_ini;
source_list_patterns=&linestyle_pat_ini;
break;
case 3://grace-std
default:
copy_std_line_style_patterns(&cur_list_len,&cur_list_entries_length,&cur_list_patterns);
break;
}
if (nr>=0 && nr<=2)
{
    for (int i=0;i<cur_list_len;i++)
    {
    if (cur_list_patterns[i]!=NULL) delete[] cur_list_patterns[i];
    }
    delete[] cur_list_patterns;
    if (cur_list_entries_length!=NULL) delete[] cur_list_entries_length;

    cur_list_len=*source_list_len;
    cur_list_entries_length=new int[cur_list_len];
    memcpy(cur_list_entries_length,(*source_list_entry_lengths),sizeof(int)*cur_list_len);
    cur_list_patterns=new char*[cur_list_len];
    for (int i=0;i<cur_list_len;i++)
    {
    cur_list_patterns[i]=new char[cur_list_entries_length[i]];
    memcpy(cur_list_patterns[i],(*source_list_patterns)[i],sizeof(char)*cur_list_entries_length[i]);
    }
    for (int i=0;i<nr_of_panels;i++)
    {
    panels[i]->setEnabled(true);
    }
    selLen->setEnabled(true);
    selPos->setEnabled(true);
    cmdEdit->setEnabled(true);
    cmdAppend->setEnabled(true);
    cmdInsert->setEnabled(true);
    cmdDelete->setEnabled(true);
    cmdUp->setEnabled(true);
    cmdDown->setEnabled(true);
}
else//Grace-std. -- not editable
{
    for (int i=0;i<nr_of_panels;i++)
    {
    panels[i]->setEnabled(false);
    }
    selLen->setEnabled(false);
    selPos->setEnabled(false);
    selLen->setEnabled(false);
    selPos->setEnabled(false);
    cmdEdit->setEnabled(false);
    cmdAppend->setEnabled(false);
    cmdInsert->setEnabled(false);
    cmdDelete->setEnabled(false);
    cmdUp->setEnabled(false);
    cmdDown->setEnabled(false);
}

for (int i=0;i<cur_list_len;i++)
{
delete cur_list_LineIcons[i];
delete cur_list_LinePixmaps[i];
delete cur_list_PenDashPattern[i];
}
delete[] cur_list_LineIcons;
delete[] cur_list_LinePixmaps;
delete[] cur_list_PenDashPattern;

cur_list_LineIcons=new QIcon*[cur_list_len];
cur_list_LinePixmaps=new QPixmap*[cur_list_len];
cur_list_PenDashPattern=new QVector<qreal>*[cur_list_len];
for (int i=0;i<cur_list_len;i++)
{
cur_list_LineIcons[i]=NULL;
cur_list_LinePixmaps[i]=NULL;
cur_list_PenDashPattern[i]=NULL;
create_one_line_pattern(cur_list_entries_length[i],cur_list_patterns[i],cur_list_LinePixmaps+i,cur_list_LineIcons+i,cur_list_PenDashPattern+i);
}

refillLineStyleSelector();

//cout << "Show nr=" << nr << endl;
}

void tabLinestyles::currentStyleChanged(int nr)
{
disconnect(selLen,SIGNAL(currentValueChanged(int)),0,0);
int len=pattern_length(cur_list_entries_length[nr],cur_list_patterns[nr]);
selLen->setValue(len);
selPos->setValue(nr);

setPanelsToOnePattern(cur_list_entries_length[nr],cur_list_patterns[nr],len);

generate_Pattern();
plotExamples();
connect(selLen,SIGNAL(currentValueChanged(int)),SLOT(currentLengthChanged(int)));
}

void tabLinestyles::currentLengthChanged(int nr)
{
//cout << "Length changed=" << nr << endl;
int len=pattern_length(cur_line_len,cur_line_pattern);
int diff=nr-len;
//cout << "Alt: Segmente=" << cur_line_len << " aktuelle_laenge=" << len << " Neu=" << nr << " Diff=" << diff << endl;
int index;
    if (diff<0)
    {
    len=0;
    index=0;
        for (int i=0;i<cur_line_len;i++)
        {
            len+=cur_line_pattern[i];
            index=i+1;
            if (len>=nr) break;
        }
        if (index%2==0)//even
        cur_line_len=index;
        else
        {
        cur_line_len=index+1;
        cur_line_pattern[index]=0;
        }
            if (len>nr)
            {
            cur_line_pattern[index-1]-=(len-nr);
            }
    }
    else if (diff>0)
    {
    cur_line_pattern[cur_line_len-1]+=diff;
    }
    else
    {
    return;
    }
len=pattern_length(cur_line_len,cur_line_pattern);
setPanelsToOnePattern(cur_line_len,cur_line_pattern,len);
generate_Pattern();
plotExamples();
}

void tabLinestyles::panel_clicked(int nr)
{
if (selShowLinestyles->currentIndex()==3) return;
    if (panels[nr]->p==blackpanel)
    panels[nr]->p=whitepanel;
    else
    panels[nr]->p=blackpanel;
panels[nr]->repaint();
generate_Pattern();
plotExamples();
}

void tabLinestyles::refillLineStyleSelector(void)
{
int current_nr=selStyles->currentIndex();
disconnect(selStyles,SIGNAL(currentIndexChanged(int)),0,0);
update_one_line_style_selector(selStyles,cur_list_len,cur_list_LinePixmaps);
selStyles->setCurrentIndex(current_nr);
connect(selStyles,SIGNAL(currentIndexChanged(int)),SLOT(currentStyleChanged(int)));
}

void tabLinestyles::generate_Pattern(void)
{
    //cout << "Generating Pattern" << endl;
char * simple=new char[nr_of_panels+8];
int nr_of_sub_patterns=0;
bool current_black=false;
bool last_black;
    if (panels[0]->p==blackpanel)
    current_black=true;
    else
    current_black=false;
//cout << 0 << " Current_Black=" << current_black << endl;
    simple[0]=1;
last_black=current_black;
for (int i=1;i<nr_of_panels;i++)
{
    if (panels[i]->p==blackpanel)
    current_black=true;
    else
    current_black=false;
//cout << i << " Current_Black=" << current_black << endl;
        if (last_black!=current_black)
        {
        last_black=current_black;
        nr_of_sub_patterns++;
        simple[nr_of_sub_patterns]=1;
        }
        else
        {
        simple[nr_of_sub_patterns]++;
        }
}
nr_of_sub_patterns++;

if (nr_of_sub_patterns<2)
{
simple[1]=0;
nr_of_sub_patterns++;
    if (panels[0]->p!=blackpanel)
    {
    simple[0]=0;
    simple[1]=1;
    }
}
else if (panels[0]->p!=blackpanel)
{
    for (int i=1;i<nr_of_sub_patterns;i++)
    {
    simple[i-1]=simple[i];
    }
    nr_of_sub_patterns--;
    if (nr_of_sub_patterns<2)
    {
    simple[1]=0;
    nr_of_sub_patterns++;
        if (panels[0]->p!=blackpanel)
        {
        simple[0]=0;
        simple[1]=1;
        }
    }
}
if (nr_of_sub_patterns%2==1)
{
simple[nr_of_sub_patterns++]=0;
}
if (cur_line_pattern!=NULL) delete[] cur_line_pattern;

cur_line_len=nr_of_sub_patterns;
cur_line_pattern=new char[cur_line_len];
memcpy(cur_line_pattern,simple,sizeof(char)*cur_line_len);

create_one_line_pattern(cur_line_len,cur_line_pattern,&cur_line_pm,&cur_line_ic,&cur_line_pendash);

/*cout << "Pattern=" << endl;
for (int i=0;i<nr_of_sub_patterns;i++)
{
    cout << (int)(simple[i]) << "  ";
}
cout << endl;*/

delete[] simple;
//cout << "End Generating Pattern" << endl;
}

void tabLinestyles::plotExamples(void)
{
    //cout << "Plot Examples" << endl;
QPainter paint1;
QPen pen;
pen.setColor(Qt::black);
if (cur_line_len==2 && (cur_line_pattern[0]==0 || cur_line_pattern[1]==0))//only one black or white pattern
{
    if (cur_line_pattern[0]==0)
    pen.setColor(Qt::white);
pen.setStyle(Qt::SolidLine);
}
else
{
pen.setStyle(Qt::CustomDashLine);
pen.setDashPattern(*cur_line_pendash);
}
delete pmExample;
int wid=lblExample->width()-20;
int siz=wid*0.3-50;
pmExample=new QPixmap(wid,wid*0.3);
pmExample->fill();

paint1.begin(pmExample);
pen.setWidth(1);
paint1.setPen(pen);
paint1.drawLine(10,10,wid-10,10);
pen.setWidth(3);
paint1.setPen(pen);
paint1.drawLine(10,20,wid-10,20);
pen.setWidth(5);
paint1.setPen(pen);
paint1.drawLine(10,30,wid-10,30);
pen.setWidth(2);
paint1.setPen(pen);
paint1.drawRect(10,40,siz,siz);
paint1.drawArc(20+siz,40,siz,siz,0,16*360);

double x,y;
x=0.0;
y=0.0;
QPointF points[70];
for (int i=0;i<70;i++)
{
x=2.0*3.1415927*4.0*i/70.0;
y=sin(x);
points[i].setX(2*siz+30+x*11);
points[i].setY(40+siz*0.5-y*siz*0.5);
}
paint1.drawPolyline(points,70);
paint1.end();

lblExample->setPixmap(*pmExample);
    //cout << "End Plot Examples" << endl;
}

void tabLinestyles::resizeEvent( QResizeEvent * event )
{
(void)event;
    //cout << "ResizeEvent" << endl;
plotExamples();
    //cout << "End Reize Event" << endl;
}

frmPreferences::frmPreferences(QWidget * parent):QWidget(parent)
{
    int number;
    QString entr[6>nr_of_translations?6:nr_of_translations];
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Preferences"));
    setWindowIcon(QIcon(*GraceIcon));

    grpResponciveness=new QGroupBox(tr("Responsiveness"),this);
    noask_item=new QCheckBox(tr("Don't ask questions"),grpResponciveness);
    dc_item=new QCheckBox(tr("Allow double clicks on canvas"),grpResponciveness);
    dc_item->setChecked(TRUE);
    number=3;
    entr[0]=tr("Button press");
    entr[1]=tr("As set");
    entr[2]=tr("Follow mouse");
    graph_focus_choice_item=new StdSelector(grpResponciveness,tr("Graph focus switch:"),number,entr);
    graph_drawfocus_choice_item=new QCheckBox(tr("Display focus markers"),grpResponciveness);
    graph_drawfocus_choice_item->setChecked(TRUE);
    autoredraw_type_item=new QCheckBox(tr("Auto redraw"),grpResponciveness);
    autoredraw_type_item->setChecked(TRUE);
    cursor_type_item=new QCheckBox(tr("Crosshair cursor"),grpResponciveness);
    ///chkShowHideWorkaround=new QCheckBox(tr("Show/Hide workaround"),grpResponciveness);
    grpRestrictions=new QGroupBox(tr("Restrictions"),this);
    max_path_item=new stdIntSelector(grpRestrictions,tr("Max drawing path length:"),0,10000000);
    max_path_item->spnInt->setSingleStep(1000);
    max_path_item->setValue(20000);
    safe_mode_item=new QCheckBox(tr("Run in safe mode"),grpRestrictions);
    safe_mode_item->setChecked(TRUE);
    grpScrollZoom=new QGroupBox(tr("Scroll/zoom"),this);
    scrollper_item=new stdSlider(grpScrollZoom,tr("Scroll %"),0,200);
    scrollper_item->setValue(5);
    shexper_item=new stdSlider(grpScrollZoom,tr("Zoom %"),0,200);
    shexper_item->setValue(5);
    linkscroll_item=new QCheckBox(tr("Linked scrolling"),grpScrollZoom);
    grpDates=new QGroupBox(tr("Dates"),this);
    number=4;
    entr[0]=tr("ISO");
    entr[1]=tr("European");
    entr[2]=tr("US");
    entr[3]=tr("None");
    hint_item=new StdSelector(grpDates,tr("Date hint:"),number,entr);
    hint_item->setCurrentIndex(3);
    date_item=new stdLineEdit(grpDates,tr("Reference date:"));
    date_item->lenText->setText(QString("-4713-01-01 12:00:00"));
    wrap_year_item=new stdLineEdit(grpDates,tr("Wrap year:"));
    char dummy[5];
    strcpy(dummy,"1950");
    wrap_year_item->setText(QString(dummy));
    wrap_year_item->setEnabled(FALSE);
    two_digits_years_item=new QCheckBox(tr("Two-digit year span"),grpDates);
    connect(two_digits_years_item,SIGNAL(stateChanged(int)),SLOT(toggleWrapYear(int)));

    buttonGroup=new stdButtonGroup(this,true,true,false);//,true);
    //buttonGroup->cmdHelp->setText(QString("Extra"));
    //connect(buttonGroup->cmdHelp,SIGNAL(clicked()),this,SLOT(doExtraPreferences()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    ///buttonGroup->cmdHelp->hide();
    /*
for (int i=0;i<nr_of_translations;i++)
{
entr[i]=QString(translator_languages[i]);
}
selLanguage=new StdSelector(this,tr("Language:"),nr_of_translations,entr);
chkExternalHelpViewer=new QCheckBox(tr("Show help-files in external html-Viewer"),this);
*/

noask_item->setToolTip(tr("If this is activated, then every question is automatically answered by \"yes\"."));
dc_item->setToolTip(tr("Open dialogs on context when double clicking on the plot-area (sensitive to the graph currently selected)"));
graph_focus_choice_item->setToolTip(tr("How to switch between graphs"));
graph_drawfocus_choice_item->setToolTip(tr("Draw small squares on the graph edges to inidcate which graph is currently selected"));
autoredraw_type_item->setToolTip(tr("This option is currently useless in QtGrace! AutoRedraw is always on!"));
cursor_type_item->setToolTip(tr("Draw a crosshair over the whole plot on the cursor"));
max_path_item->setToolTip(tr("Maximum number of points plotted in a row (larger sets are plotted in a simplified representation)"));
safe_mode_item->setToolTip(tr("File modifications are disabled in safe mode when using parser-commands (GUI-operations are unaffected)."));
scrollper_item->setToolTip(tr("How far to move the axis if scoll buttons are pressed"));
shexper_item->setToolTip(tr("How far to zoom in and out on clicking a zoom button"));
linkscroll_item->setToolTip(tr("This option is currently useless in QtGrace! Use the Graph-selector in the toolbar for this!"));
hint_item->setToolTip(tr("Used as a default date format setting for cells where dates have to be entered"));
date_item->setToolTip(tr("Used internally to convert double-values to dates"));
wrap_year_item->setToolTip(tr("Year to be used to convert two-digit-years into four-digit years (and vice versa)"));
two_digits_years_item->setToolTip(tr("Use this to allow display of years in two-digit-format (instead of four digits)"));

    layout0=new QVBoxLayout();
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(noask_item);
    layout0->addWidget(dc_item);
    layout0->addWidget(graph_focus_choice_item);
    layout0->addWidget(graph_drawfocus_choice_item);
    layout0->addWidget(autoredraw_type_item);
    layout0->addWidget(cursor_type_item);
    ///layout0->addWidget(chkShowHideWorkaround);
    grpResponciveness->setLayout(layout0);
    layout1=new QVBoxLayout();
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(max_path_item);
    layout1->addWidget(safe_mode_item);
    grpRestrictions->setLayout(layout1);
    layout2=new QVBoxLayout();
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(scrollper_item);
    layout2->addWidget(shexper_item);
    layout2->addWidget(linkscroll_item);
    grpScrollZoom->setLayout(layout2);
    grpScrollZoom->setToolTip(tr("The Scroll/zoom-settings are project-specific."));
    layout3=new QGridLayout();
    layout3->setMargin(STD_MARGIN);
    layout3->addWidget(hint_item,0,0,1,2);
    layout3->addWidget(date_item,1,0,1,2);
    layout3->addWidget(two_digits_years_item,2,0);
    layout3->addWidget(wrap_year_item,2,1);
    grpDates->setLayout(layout3);
    grpDates->setToolTip(tr("The Dates-settings are project-specific."));
    layout=new QVBoxLayout();
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout->addWidget(grpResponciveness);
    layout->addWidget(grpRestrictions);
    layout->addWidget(grpScrollZoom);
    layout->addWidget(grpDates);
    layout->addStretch(3);
    layout->addWidget(buttonGroup);

    /*layout->setStretch(0,1);
    layout->setStretch(1,1);
    layout->setStretch(2,1);
    layout->setStretch(3,1);
    layout->setStretch(4,0);*/

    setLayout(layout);
}

void frmPreferences::doExtraPreferences(void)
{
    /*if (ExtraPreferences==NULL)
    {
        ExtraPreferences=new frmExtraPreferences(0);
        ExtraPreferences->init();
    }
    ExtraPreferences->show();
    ExtraPreferences->raise();
    ExtraPreferences->activateWindow();*/
}

void frmPreferences::update_props_items(void)
{
    int itest = 0;
    int iv;
    int y, m, d, h, mm, sec;
    char date_string[64], wrap_year_string[64];

    //if (props_frame) {
#ifdef DEBUG
    if (get_debuglevel() > 8) {
        errwin(tr("Debug level > 8, resetting to 0").toLocal8Bit().constData());
        set_debuglevel(0);
    }
    SetSpinChoice(debug_item, (double) get_debuglevel());
#endif
    SetToggleButtonState(noask_item, noask);
    SetToggleButtonState(dc_item, allow_dc);

    if (focus_policy == FOCUS_SET) {
        itest = 1;
    } else if (focus_policy == FOCUS_CLICK) {
        itest = 0;
    } else if (focus_policy == FOCUS_FOLLOWS) {
        itest = 2;
    }
    SetChoice(graph_focus_choice_item, itest);
    SetToggleButtonState(graph_drawfocus_choice_item, draw_focus_flag);

    SetToggleButtonState(linkscroll_item, scrolling_islinked);
    SetToggleButtonState(autoredraw_type_item, auto_redraw);
    SetToggleButtonState(cursor_type_item, cursortype);
    ///SetToggleButtonState(chkShowHideWorkaround, showhideworkaround);
#if defined WITH_XMHTML || defined WITH_LIBHELP
    SetToggleButtonState(force_external_viewer_item, force_external_viewer);
#endif
    SetSpinChoice(max_path_item, (double) get_max_path_limit());
    SetToggleButtonState(safe_mode_item, safe_mode);
    iv = (int) rint(100*scrollper);
    SetScaleValue(scrollper_item, iv);
    iv = (int) rint(100*shexper);
    SetScaleValue(shexper_item, iv);
    switch (get_date_hint()) {
    case FMT_iso :
        itest = 0;
        break;
    case FMT_european :
        itest = 1;
        break;
    case FMT_us :
        itest = 2;
        break;
    default :
        itest = FMT_nohint;
        break;
    }
    SetChoice(hint_item, itest);
    jul_to_cal_and_time(0.0, ROUND_SECOND, &y, &m, &d, &h, &mm, &sec);
    sprintf(date_string, "%d-%02d-%02d %02d:%02d:%02d",y, m, d, h, mm, sec);
    xv_setstr(date_item, date_string);
    SetToggleButtonState(two_digits_years_item, two_digits_years_allowed());
    sprintf(wrap_year_string, "%04d", get_wrap_year());
    xv_setstr(wrap_year_item, wrap_year_string);
    SetSensitive(wrap_year_item, two_digits_years_allowed() ? true:false);
    ///selLanguage->setCurrentIndex(current_language);
    //}
}

void frmPreferences::props_define_notify_proc(void)
{
    ApplyError=false;
    double jul;
#ifdef DEBUG
    set_debuglevel((int) GetSpinChoice(debug_item));
#endif
    noask = GetToggleButtonState(noask_item);
    allow_dc = GetToggleButtonState(dc_item);
    switch (GetChoice(graph_focus_choice_item)) {
    case 0:
        focus_policy = FOCUS_CLICK;
        break;
    case 1:
        focus_policy = FOCUS_SET;
        break;
    case 2:
        focus_policy = FOCUS_FOLLOWS;
        break;
    }

    draw_focus_flag = GetToggleButtonState(graph_drawfocus_choice_item);
    scrolling_islinked = GetToggleButtonState(linkscroll_item);
    auto_redraw = GetToggleButtonState(autoredraw_type_item);
    cursortype = GetToggleButtonState(cursor_type_item);
    ///showhideworkaround= GetToggleButtonState(chkShowHideWorkaround);
#if defined WITH_XMHTML || defined WITH_LIBHELP
    force_external_viewer = GetToggleButtonState(force_external_viewer_item);
#endif
    set_max_path_limit((int) GetSpinChoice(max_path_item));
    safe_mode = GetToggleButtonState(safe_mode_item);
    scrollper = (double) GetScaleValue(scrollper_item)/100.0;
    shexper   = (double) GetScaleValue(shexper_item)/100.0;

    switch (GetChoice(hint_item)) {
    case 0 :
        set_date_hint(FMT_iso);
        break;
    case 1 :
        set_date_hint(FMT_european);
        break;
    case 2 :
        set_date_hint(FMT_us);
        break;
    default :
        set_date_hint(FMT_nohint);
        break;
    }
    if (parse_date_or_number(xv_getstr(date_item), TRUE, &jul)== RETURN_SUCCESS) {
        set_ref_date(jul);
    } else {
        errmsg(tr("Invalid date").toLocal8Bit().constData());
        ApplyError=true;
    }
    allow_two_digits_years(GetToggleButtonState(two_digits_years_item));
    set_wrap_year(atoi(xv_getstr(wrap_year_item)));
    ///change_language(selLanguage->currentIndex());
//xdrawgraph();
}

void frmPreferences::init(void)
{
    update_props_items();
}

void frmPreferences::toggleWrapYear(int i)
{
    if (i==0)
        wrap_year_item->setEnabled(FALSE);
    else
        wrap_year_item->setEnabled(TRUE);
}

void frmPreferences::doApply(void)
{
    ApplyError=false;
    int save_dirty=dirtystate;
    props_define_notify_proc();
    //mainWin->mainArea->completeRedraw();
    dirtystate=save_dirty;
}

void frmPreferences::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmPreferences::doClose(void)
{
    emit(close_wish());
    //hide();
}

frm_Preferences::frm_Preferences(QWidget * parent):QDialog(parent)
{
//QFont fntPref;
//setFont(*stdFont);
min_w=680;
min_h=680;//630;
bar_w=bar_h=20;

int index=8;
QString * entries=new QString[index];

QVBoxLayout * m_layout=new QVBoxLayout();
m_layout->setMargin(0);
m_layout->setSpacing(0);

flp=new QWidget(this);
scroll=new QScrollArea;
m_layout->addWidget(scroll);
scroll->setWidget(flp);

    setWindowTitle(tr("QtGrace: Preferences"));
    setWindowIcon(QIcon(*GraceIcon));

    vbox=new QVBoxLayout();
    vbox->setMargin(STD_MARGIN);
    vbox->setSpacing(STD_SPACING);

tabs=new QTabWidget(flp);

tab_prefs=new frmPreferences();
tab_prefs->buttonGroup->hide();
tab_linestyles=new tabLinestyles();
tab_colors=new frmColorManagement();
tab_defaults=new frmDefaults();

///GUI
tab_GUI=new QWidget(this);

guiLayout=new QVBoxLayout(this);
guiLayout->setMargin(STD_MARGIN);
guiLayout->setSpacing(STD_SPACING);

grp_tool_bar=new QGroupBox(tr("Customize interface"),this);
//lblToolBar=new QLabel(tr("Tool bar contents:"),this);
//lblStatusBar=new QLabel(tr("Status bar contents:"),this);
layout2=new QGridLayout();
layout2->setSpacing(STD_SPACING);
layout2->setMargin(STD_MARGIN);

grpToolBar=new QGroupBox(tr("Tool bar"));
layoutToolBar=new QGridLayout();
layoutToolBar->setSpacing(STD_SPACING);
layoutToolBar->setMargin(STD_MARGIN);
grpToolBar->setLayout(layoutToolBar);
grpStatusBar=new QGroupBox(tr("Status bar contents"));
layoutStatusBar=new QGridLayout();
layoutStatusBar->setSpacing(STD_SPACING);
layoutStatusBar->setMargin(STD_MARGIN);
grpStatusBar->setLayout(layoutStatusBar);
grpAppFont=new QGroupBox(tr("Gui font"));
layoutAppFont=new QGridLayout();
layoutAppFont->setSpacing(STD_SPACING);
layoutAppFont->setMargin(STD_MARGIN);
grpAppFont->setLayout(layoutAppFont);
grpBackgroundColor=new QGroupBox(tr("Background Color of Draw Area"));
grpBackgroundColor->setToolTip(tr("Select color for widget background behind plot area"));
layoutBackgroundColor=new QGridLayout();
layoutBackgroundColor->setSpacing(STD_SPACING);
layoutBackgroundColor->setMargin(STD_MARGIN);
grpBackgroundColor->setLayout(layoutBackgroundColor);

chkNewIcons=new QCheckBox(tr("Use new icons"),this);
chkNewIcons->setToolTip(tr("Use new PNG-icons for navigaion buttons"));
chkShowNavi=new QCheckBox(tr("Show navigation buttons"),this);
chkShowGraph=new QCheckBox(tr("Show graph list"),this);
chkShowSpecZoom=new QCheckBox(tr("Show special zoom buttons"),this);
//chkShowViewp=new QCheckBox(tr("Show viewport stack"),this);
chkShowPageZoom=new QCheckBox(tr("Show page zoom"),this);
chkShowPrintB=new QCheckBox(tr("Show print button"),this);
chkShowExportP=new QCheckBox(tr("Show export button"),this);

/*chkShowPanB=new QCheckBox(tr("Show pan button"),this);
chkShowPickB=new QCheckBox(tr("Show move button"),this);*/
index=3;
entries[0]=tr("Hide button");
entries[1]=tr("Show button");
entries[2]=tr("Always on");
selShowPan=new StdSelector(this,tr("Pan:"),index,entries);
selShowPick=new StdSelector(this,tr("Move:"),index,entries);
entries[0]=tr("Hide controls");
entries[1]=tr("Simple controls (Grace/XmGrace)");
entries[2]=tr("Complete list (QtGace)");
selShowViewp=new StdSelector(this,tr("Viewport:"),index,entries);

chkShowUndoRedo=new QCheckBox(tr("Show Undo/Redo buttons"),this);
selToolbarSize=new LineWidthSelector(this);
selToolbarSize->lblText->setText(tr("Toolbar size:"));
selToolbarSize->setToolTip(tr("Change size of toolbar - toolbar size\ndoes not automatically adjust to window size."));
selToolbarSize->spnLineWidth->setRange(0.1,10.0);
selToolbarSize->spnLineWidth->setDecimals(1);
selToolbarSize->spnLineWidth->setSingleStep(0.1);

chkShowHostName=new QCheckBox(tr("Show host name"),this);
chkShowHostName->setToolTip(tr("Display the name of the current host"));
chkShowDisplay=new QCheckBox(tr("Show display name"),this);
chkShowDisplay->setToolTip(tr("Display the name of the display"));
index=3;
entries[0]=tr("None");
entries[1]=tr("Complete path");
entries[2]=tr("Filename only");
selFileDisplay1=new StdSelector(this,tr("Show project file name:"),index,entries);
selFileDisplay1->setToolTip(tr("How to display the name of the current project"));
selFileDisplay2=new StdSelector(this,tr("Show export file name:"),index,entries);
selFileDisplay2->setToolTip(tr("How to display the name used for file-export"));

delete[] entries;

cmdGraceDefaults=new QPushButton(tr("Grace-default-GUI"),this);
cmdGraceDefaults->setToolTip(tr("Reset GUI to be like Grace (immediate effect)"));
connect(cmdGraceDefaults,SIGNAL(clicked()),SLOT(doGraceDefaults()));

cmdQtGraceDefaults=new QPushButton(tr("QtGrace-default-GUI"),this);
cmdQtGraceDefaults->setToolTip(tr("Reset GUI to QtGrace-default-style (immediate effect)"));
connect(cmdQtGraceDefaults,SIGNAL(clicked()),SLOT(doQtGraceDefaults()));

cmdActDevs=new QPushButton(tr("Enable/Disable export formats"),this);
cmdActDevs->setToolTip(tr("Disable unwanted export formats to simplify the export dialog"));
connect(cmdActDevs,SIGNAL(clicked()),SLOT(doActDevs()));
diaDevAct=NULL;

cmdTest=new QPushButton(tr("DEBUG: TestDialog"),this);
connect(cmdTest,SIGNAL(clicked()),SLOT(doTest()));
cmdTest->hide();

frmTest=new TestDialog(0);
frmTest->hide();

index=0;
layoutToolBar->addWidget(chkNewIcons,0,0);
layoutToolBar->addWidget(chkShowNavi,1,0);
layoutToolBar->addWidget(chkShowGraph,2,0);
layoutToolBar->addWidget(chkShowSpecZoom,0,1);
//layoutToolBar->addWidget(chkShowViewp,1,1);
layoutToolBar->addWidget(chkShowPageZoom,1,1);
layoutToolBar->addWidget(chkShowExportP,2,1);
layoutToolBar->addWidget(chkShowPrintB,0,2);
layoutToolBar->addWidget(chkShowUndoRedo,1,2);
layoutToolBar->addWidget(selToolbarSize,2,2);
layoutToolBar->addWidget(selShowViewp,3,0);
layoutToolBar->addWidget(selShowPan,3,1);
layoutToolBar->addWidget(selShowPick,3,2);

layoutStatusBar->addWidget(chkShowHostName,0,0);
layoutStatusBar->addWidget(chkShowDisplay,0,1);
layoutStatusBar->addWidget(selFileDisplay1,1,0);
layoutStatusBar->addWidget(selFileDisplay2,1,1);

layout2->addWidget(grpToolBar,index++,0,1,3);
layout2->addWidget(grpStatusBar,index++,0,1,3);

cmdSelGuiFont=new QPushButton(tr("Select Gui Font"),this);
cmdSelGuiFont->setToolTip(tr("Select a new font to be used for the whole GUI"));
cmdResetGuiFont=new QPushButton(tr("Reset Gui Font"),this);
cmdResetGuiFont->setToolTip(tr("Reset the GUI-Font to the system-default"));
lblGuiFont=new QLabel(tr("Current Font"),this);
lblGuiFont->setToolTip(tr("Font name and font parameters used for GUI-font"));

layoutAppFont->addWidget(lblGuiFont,0,0,1,2);
layoutAppFont->addWidget(cmdSelGuiFont,1,0,1,1);
layoutAppFont->addWidget(cmdResetGuiFont,1,1,1,1);

cmdSelGUIBGColor=new QPushButton(tr("Select Color"),this);
cmdSelGUIBGColor->setToolTip(tr("Select a new color for the background of the drawing area"));
cmdSetGUIBGColor_to_PageBG=new QPushButton(tr("Set to Page-Background"),this);
cmdSetGUIBGColor_to_PageBG->setToolTip(tr("Set the background color of the drawing area to the background color of the plot"));
cmdSetGUIBGColor_to_Std=new QPushButton(tr("Set to GUI-Background"),this);
cmdSetGUIBGColor_to_Std->setToolTip(tr("Reset the background color of the drawing area to the system-default"));

layoutBackgroundColor->addWidget(cmdSelGUIBGColor,0,0);
layoutBackgroundColor->addWidget(cmdSetGUIBGColor_to_PageBG,0,1);
layoutBackgroundColor->addWidget(cmdSetGUIBGColor_to_Std,0,2);

//layout2->addWidget(lblToolBar,index++,0);
/*layout2->addWidget(chkNewIcons,index++,0);
layout2->addWidget(chkShowNavi,index++,0);
layout2->addWidget(chkShowGraph,index++,0);
layout2->addWidget(chkShowSpecZoom,index++,0);
layout2->addWidget(chkShowViewp,index++,0);
layout2->addWidget(chkShowPageZoom,index++,0);
layout2->addWidget(chkShowExportP,index++,0);
layout2->addWidget(chkShowPrintB,index++,0);*/

//layout2->addWidget(lblStatusBar,index++,1);
/*layout2->addWidget(chkShowHostName,index++,1);
layout2->addWidget(chkShowDisplay,index++,1);
layout2->addWidget(selFileDisplay1,index++,1);
layout2->addWidget(selFileDisplay2,index++,1);*/

layout2->addWidget(cmdGraceDefaults,index,0);
layout2->addWidget(cmdQtGraceDefaults,index,1);
layout2->addWidget(cmdActDevs,index++,2);
layout2->addWidget(grpAppFont,index++,0,1,3);
layout2->addWidget(grpBackgroundColor,index++,0,1,3);
index++;
index++;

//lblAppearance=new QLabel(tr("Appearance"),this);

/*
QWidget * empty2=new QWidget(this);
QGridLayout * layout4=new QGridLayout();
layout4->setMargin(0);
layout4->setSpacing(STD_SPACING);
layout4->addWidget(lblGuiFont,0,0);
layout4->addWidget(cmdSelGuiFont,0,1);
layout4->addWidget(cmdResetGuiFont,0,2);
//lblBackground_Color_Text=new QLabel(tr("Background color of Draw-Area:"),this);
//layout4->addWidget(lblBackground_Color_Text,1,0,1,3);
layout4->addWidget(cmdSelGUIBGColor,2,0);
layout4->addWidget(cmdSetGUIBGColor_to_PageBG,2,1);
layout4->addWidget(cmdSetGUIBGColor_to_Std,2,2);
layout4->addWidget(cmdActDevs,3,0,1,3);
empty2->setLayout(layout4);
//layout1->addWidget(empty2);
*/

connect(cmdSelGuiFont,SIGNAL(clicked()),SLOT(changeGUIFont()));
connect(cmdResetGuiFont,SIGNAL(clicked()),SLOT(resetGUIFont()));

connect(cmdSelGUIBGColor,SIGNAL(clicked()),SLOT(select_BG_Color()));
connect(cmdSetGUIBGColor_to_Std,SIGNAL(clicked()),SLOT(set_BG_Color_to_Std()));
connect(cmdSetGUIBGColor_to_PageBG,SIGNAL(clicked()),SLOT(set_BG_Color_to_Page_BG()));

//layout2->addWidget(empty2,index++,0,1,2);

grp_tool_bar->setLayout(layout2);

grp_Startup=new QGroupBox(tr("Startup-Settings"),this);
layout3=new QVBoxLayout();
layout3->setSpacing(STD_SPACING);
layout3->setMargin(STD_MARGIN);

/*grpIniPos=new QGroupBox(tr("Initial Size and Position"),this);
layoutIniPos=new QGridLayout();
layoutIniPos->setSpacing(STD_SPACING);
layoutIniPos->setMargin(STD_MARGIN);*/

QWidget * empty=new QWidget(this);
QGridLayout * grid1=new QGridLayout(empty);
grid1->setSpacing(STD_MARGIN);
grid1->setMargin(STD_MARGIN);

QString * entr=new QString[8];
int nr=2;
entr[0]=QString("English");
entr[1]=QString("German");
selLanguage=new StdSelector(this,tr("Language:"),nr,entr);
//layout1->addWidget(selLanguage);
delete[] entr;

nr=number_of_devices();
entr=new QString[32+nr];
int * i_entr=new int[32+nr];
entr[0]=tr("Last selection");
i_entr[0]=-1;
for (int i=0;i<nr;i++)
{
    if (i!=DEVICE_SCREEN)
    {
    entr[i]=get_device_name(i);
    i_entr[i]=i;
    }
}
selDefaultPrintDevice=new StdSelector(this,tr("Default output format:"),nr,entr);
selDefaultPrintDevice->setToolTip(tr("Select an output format to be used as default"));
selDefaultPrintDevice->setValues(i_entr);

lenDefaultFile=new stdLineEdit(this,tr("Default startup file:"));
lenDefaultFile->setToolTip(tr("This file is loaded when \"File->New\" is clicked.\nThis file has to be located in the bin-folder."));
lenDefaultFile->setText(QString(default_grace_file));
cmdBrowseForDefault=new QPushButton(tr("Select default file"),this);
cmdBrowseForDefault->setToolTip(tr("Select a project file to be used as an empty project."));
connect(cmdBrowseForDefault,SIGNAL(clicked()),SLOT(doBrowseStartup()));
lblStartupWarning=new QLabel(tr("The settings in this group will take effect at the next restart of QtGrace."),this);
QFont tfont=lblStartupWarning->font();
tfont.setItalic(true);
lblStartupWarning->setFont(tfont);
grid1->addWidget(lblStartupWarning,0,0,1,3);
grid1->addWidget(selLanguage,1,0,1,3);
grid1->addWidget(selDefaultPrintDevice,2,0,1,3);
grid1->addWidget(lenDefaultFile,3,0,1,2);
grid1->addWidget(cmdBrowseForDefault,3,2,1,1);

selStdDpi=new stdIntSelector(this,tr("DPI:"),72,720);
selStdDpi->lblText->setAlignment(Qt::AlignRight);
selStdDpi->setToolTip(tr("Use this dpi-value on loading a new file"));
//lblSelStartup=new QLabel(tr("Select initial position/size:"),this);
selStartupX=new stdIntSelector(this,tr("x:"),0,QApplication::desktop()->width());
selStartupX->lblText->setAlignment(Qt::AlignRight);
selStartupX->setToolTip(tr("Initial horizontal position of upper left hand corner of QtGrace window"));
selStartupY=new stdIntSelector(this,tr("y:"),0,QApplication::desktop()->height());
selStartupY->lblText->setAlignment(Qt::AlignRight);
selStartupY->setToolTip(tr("Initial vertical position of upper left hand corner of QtGrace window"));
selStartupWidth=new stdIntSelector(this,tr("Width:"),0,QApplication::desktop()->width());
selStartupWidth->lblText->setAlignment(Qt::AlignRight);
selStartupWidth->setToolTip(tr("Initial width of QtGrace window"));
selStartupHeight=new stdIntSelector(this,tr("Height:"),0,QApplication::desktop()->height());
selStartupHeight->lblText->setAlignment(Qt::AlignRight);
selStartupHeight->setToolTip(tr("Initial height of QtGrace window"));
cmdStartupCurrent=new QPushButton(tr("Initial = current"),this);
cmdStartupCurrent->setToolTip(tr("Use the current size and position of the QtGrace main window as default for startup."));
connect(cmdStartupCurrent,SIGNAL(clicked()),SLOT(doCurrentAsStartup()));

lblStartupMain=new QLabel(tr("Main window:"),this);
nr=2;
entr[0]=tr("Default size");
entr[1]=tr("Last size");
selStartupBehavior=new StdSelector(this,tr("Dialog startup size(s):"),nr,entr);
selStartupBehavior->setToolTip(tr("What size to set for the different dialogs on startup."));

grpIniPos=new QGroupBox(tr("Initial window size and position"),this);
layoutIniPos=new QGridLayout();
layoutIniPos->setSpacing(STD_SPACING);
layoutIniPos->setMargin(STD_MARGIN);
grpIniPos->setLayout(layoutIniPos);

layoutIniPos->addWidget(lblStartupMain,0,0);
layoutIniPos->addWidget(cmdStartupCurrent,1,0);
layoutIniPos->addWidget(selStartupX,0,1);
layoutIniPos->addWidget(selStartupY,0,2);
layoutIniPos->addWidget(selStartupWidth,1,1);
layoutIniPos->addWidget(selStartupHeight,1,2);
layoutIniPos->addWidget(selStartupBehavior,2,0,1,3);

//grid1->addWidget(lblSelStartup,4,0,1,2);
/*grid1->addWidget(cmdStartupCurrent,4,2,1,1);
grid1->addWidget(selStdDpi,5,0,1,1);
grid1->addWidget(selStartupX,5,1,1,1);
grid1->addWidget(selStartupY,5,2,1,1);
grid1->addWidget(selStartupWidth,6,1,1,1);
grid1->addWidget(selStartupHeight,6,2,1,1);*/

empty->setLayout(grid1);

layout3->addWidget(empty);
layout3->addWidget(grpIniPos);
grp_Startup->setLayout(layout3);

guiLayout->addWidget(grp_tool_bar);
//guiLayout->addWidget(empty2);
guiLayout->addWidget(grp_Startup);
tab_GUI->setLayout(guiLayout);

/// BEHAVIOR
tab_Behaviour=new QWidget(this);
behavLayout=new QGridLayout();
behavLayout->setMargin(STD_MARGIN);
behavLayout->setSpacing(STD_SPACING);

QString * entr2=new QString[6];
entr2[0]=tr("Grace");
entr2[1]=tr("QtGrace");
selGeneral=new StdSelector(this,tr("General Behavior like"),2,entr2);
selGeneral->setToolTip(tr("Affects behavior settings used in Grace that are unusual. (Like the question asked on closing or loading of project fils if unsaved changes are present.)"));
delete[] entr2;

QString * entr3=new QString[avcod.length()];
for (int i=0;i<avcod.length();i++)
{
    entr3[i]=QString(avcod.at(i));
}
selCodec=new StdSelector(this,tr("File encoding:"),avcod.length(),entr3);
selCodec->setToolTip(tr("Change this setting if you want to enter non-Latin-characters directely via the keyboard.\n(When inappropriate encodings are used the characters are not saved/loaded correctely.)"));
delete[] entr3;
entr3=new QString[4];
entr3[0]=tr("None");
entr3[1]=tr("Right of Color selection");
entr3[2]=tr("Inside Color selection");
selTranspSelection=new StdSelector(this,tr("Show transparency/opacity selctors:"),3,entr3);
selTranspSelection->setToolTip(tr("How to access the opacity value for all colors.\nIf deactivated(=None), the alpha-channel will be ignored."));
delete[] entr3;
chkActivateLaTeXSupport=new QCheckBox(tr("Support simple LaTeX-commands"),this);
chkActivateLaTeXSupport->setToolTip(tr("This option lets you enter some simple LaTeX-commands inside $$-tags for labels (like $$\\alpha$$)."));
chkImmediateUpdate=new QCheckBox(tr("Immediate updates"),this);
chkImmediateUpdate->setToolTip(tr("Immediately apply every option in every dialog without having to press \"Apply\"\n(this does not affect the Preferences dialog)"));
chkEnableInlineEditing=new QCheckBox(tr("Enable text editing inside main window"),this);
chkEnableInlineEditing->setToolTip(tr("If activated, text entries (labels, titles, texts)\ncan be edited directely on screen\n(not only in a separate dialog)."));
chkEnableContextMenuInMain=new QCheckBox(tr("Enable context-menu inside main window"),this);
chkEnableContextMenuInMain->setToolTip(tr("If activated a right-click on a set summons\na context-menu in the main window."));
chkQtFonts=new QCheckBox(tr("Use Qt Fonts"),this);
chkQtFonts->setToolTip(tr("Use this option if you want to use non-latin and non greek letters or special fonts.\nWarning: The QtFonts are not supported by every output driver.\nThe QtFonts are also not savely portable.\n(If you copy your project file to another platform, the selected fonts might not be present)."));
connect(chkQtFonts,SIGNAL(toggled(bool)),SLOT(toggleQtFonts(bool)));
chkSymbolSpecial=new QCheckBox(tr("'Symbol'-font is special"),this);
chkSymbolSpecial->setToolTip(tr("Enabling this option resorts the characters in the Symbol font to match the order of the characters in the original Grace-Symbol-font"));
chkAutoPackSets=new QCheckBox(tr("Auto-pack sets"),this);
chkAutoPackSets->setToolTip(tr("When a set is removed automatically pack all sets\n(so that the set-ids have no gaps)."));
chkErrorbarsAutoscale=new QCheckBox(tr("Consider error bars for autoscale"),this);
chkErrorbarsAutoscale->setToolTip(tr("If activated autoscale makes sure that\nall error bars are visible inside the graph."));
selAutoscaleOffset=new LineWidthSelector(this);
selAutoscaleOffset->lblText->setText(tr("Min. autoscale offset (fraction of range):"));
selAutoscaleOffset->spnLineWidth->setRange(0.0,0.5);
selAutoscaleOffset->spnLineWidth->setDecimals(3);
selAutoscaleOffset->setToolTip(tr("Minimum offset between a graph-border\nand a set-point or error-bar.\nThe \"range\" is the difference between min- and max-value of all sets."));
chkAllowGestures=new QCheckBox(tr("Allow gestures in main window"),this);
chkAllowGestures->setToolTip(tr("If activated the main window accepts Pinch-/Swipe-/Pan-Gestures\nto move the visible area of a graph."));

chkAllowWheelChanges=new QCheckBox(tr("Use mouse wheel for size changes"),this);
chkAllowWheelChanges->setToolTip(tr("If activated the mouse wheel can be\nused for changing font and object sizes."));
chkAllowWheel=new QCheckBox(tr("Use mouse wheel for zooming"),this);
chkAllowWheel->setToolTip(tr("If activated the mouse wheel can\nbe used for zooming in a graph."));

chkUndoActive=new QCheckBox(tr("Undo active"),this);
chkUndoActive->setToolTip(tr("Allows undo and redo of most operations (setting for current session)."));
chkUndoActiveStart=new QCheckBox(tr("Undo active on startup"),this);
chkUndoActiveStart->setToolTip(tr("Make Undo active, when QtGrace is started"));

nr=2;
entr[0]=QString(".");
entr[1]=QString(",");
selDecSep=new StdSelector(this,tr("Decimal separator:"),nr,entr);
selDecSep->setToolTip(tr("The decimal separator used in QtGrace for input and display of decimal numbers."));
histSize=new stdIntSelector(this,tr("Maximum history size:"),0,MAX_HISTORY);
histSize->setToolTip(tr("The maximum number of project files to be remembered in the ini-file and the \"File->Resently opened files\" menu"));
histSize->lblText->setAlignment(Qt::AlignRight);
histSize->setValue(max_history);
chkAutoSetAgr=new QCheckBox(tr("Auto set .agr-file-extension"),this);
chkAutoSetAgr->setToolTip(tr("When entering a file name for saving automatically set the agr-extension."));
chkAutoSetExport=new QCheckBox(tr("Auto set export-file-extension"),this);
chkAutoSetExport->setToolTip(tr("When entering a file name for exporting automatically set the extension which is specific for the selected output format."));
chkAutoSetCWD=new QCheckBox(tr("Auto set current working directory (CWD)"),this);
chkAutoSetCWD->setToolTip(tr("On loading and saving files automatically set the Current Working Directory (CWD) to the folder where the file is in."));
chkAutoFitLoad=new QCheckBox(tr("Auto fit page after loading project"),this);
chkAutoFitLoad->setToolTip(tr("Automatically fit the page-zoom to accommodate the whole plot in the QtGrace window when loading a project file."));
chkWarnOnEncodingChange=new QCheckBox(tr("Display warning on encoding change"),this);
chkWarnOnEncodingChange->setToolTip(tr("Display an information message whenever a file is loaded that has been saved with a different encoding than that, which is currently used.\nIn this case the current encoding format is changed to the one used in the file."));/// Change Encoding or update contents to fit current encoding? Checken!

selHighlightColor=new ColorSelector(this);
selHighlightColor->setToolTip(tr("Color to highlight a set or graph in the main window.\nThe linewidth for highlighting is always 2,5x the largest selected linewidth."));
nr=6;
entr[0]=tr("No limit");
entr[1]=QString("1 s");
entr[2]=QString("2 s");
entr[3]=QString("3 s");
entr[4]=QString("4 s");
entr[5]=QString("5 s");
selHighlightTime=new StdSelector(this,tr("Maximum time for highlight:"),nr,entr);
selHighlightTime->setToolTip(tr("After this time the highlight-blinking is stopped.\nWithout limit the highlight stops if the current list looses the focus."));
chkAutoHighlight=new QCheckBox(tr("Auto-highlight new selection"),this);
chkAutoHighlight->setToolTip(tr("Activate the highlighting automatically if a new selection is made."));
chkHighlightErrorbars=new QCheckBox(tr("Highlight error bars and symbols"),this);
chkHighlightErrorbars->setToolTip(tr("If activated the errorbars and symbols of a set are highlighted as well as the line of a set."));

nr=3;
entr[0]=tr("No Icons");
entr[1]=tr("Icons and text");
entr[2]=tr("Just icons (no text)");
selIconBehavior=new StdSelector(this,tr("Icons on buttons/in lists:"),nr,entr);
selIconBehavior->setToolTip(tr("Select whether you want icons displayed on buttons and in lists or not."));

/*selFontSize=new LineWidthSelector(this);
selFontSize->lblText->setText(tr("Global font size multiplicator:"));
selFontSize->spnLineWidth->setRange(0.0,1000.0);
selFontSize->spnLineWidth->setDecimals(2);
selFontSize->spnLineWidth->setValue(100.0);
selFontSize->spnLineWidth->setSingleStep(1.0);
selFontSize->spnLineWidth->setSuffix(tr(" %"));*/

grpLoadSave=new QGroupBox(tr("Load and save"),this);
layoutLoadSave=new QGridLayout();
layoutLoadSave->setMargin(STD_MARGIN);
layoutLoadSave->setSpacing(STD_SPACING);
grpInput=new QGroupBox(tr("Input-Behavior"),this);
layoutInput=new QGridLayout();
layoutInput->setMargin(STD_MARGIN);
layoutInput->setSpacing(STD_MARGIN);
grpResponse=new QGroupBox(tr("Responsiveness"),this);
layoutResponse=new QGridLayout();
layoutResponse->setMargin(STD_MARGIN);
layoutResponse->setSpacing(STD_MARGIN);
grpHighlight=new QGroupBox(tr("Highlighting"),this);
layoutHighlight=new QGridLayout();
layoutHighlight->setMargin(STD_MARGIN);
layoutHighlight->setSpacing(STD_MARGIN);
int rindex=0;
layoutResponse->addWidget(selGeneral,rindex++,0,1,2);
layoutResponse->addWidget(selIconBehavior,rindex++,0,1,2);
layoutResponse->addWidget(selTranspSelection,rindex++,0,1,2);
layoutResponse->addWidget(chkImmediateUpdate,rindex,0,1,1);
layoutResponse->addWidget(chkEnableInlineEditing,rindex++,1,1,1);
layoutResponse->addWidget(chkAutoPackSets,rindex,0,1,1);
layoutResponse->addWidget(chkEnableContextMenuInMain,rindex++,1,1,1);
layoutResponse->addWidget(chkErrorbarsAutoscale,rindex,0,1,1);
layoutResponse->addWidget(selAutoscaleOffset,rindex++,1,1,1);
layoutResponse->addWidget(chkAllowGestures,rindex,0,1,1);
layoutResponse->addWidget(chkAllowWheel,rindex++,1,1,1);
layoutResponse->addWidget(chkAllowWheelChanges,rindex++,1,1,1);
layoutResponse->addWidget(chkUndoActive,rindex,0,1,1);
layoutResponse->addWidget(chkUndoActiveStart,rindex++,1,1,1);

layoutInput->addWidget(selDecSep,0,0,1,2);
layoutInput->addWidget(chkQtFonts,1,0,1,1);
layoutInput->addWidget(chkActivateLaTeXSupport,1,1,1,1);
layoutInput->addWidget(chkSymbolSpecial,2,0,1,1);

index=0;
layoutLoadSave->addWidget(selCodec,index,0);
layoutLoadSave->addWidget(chkWarnOnEncodingChange,index++,1);
layoutLoadSave->addWidget(histSize,index,0);
layoutLoadSave->addWidget(selStdDpi,index++,1);
layoutLoadSave->addWidget(chkAutoFitLoad,index,0);
layoutLoadSave->addWidget(chkAutoSetExport,index++,1);
layoutLoadSave->addWidget(chkAutoSetAgr,index,0);
layoutLoadSave->addWidget(chkAutoSetCWD,index++,1);

layoutHighlight->addWidget(selHighlightColor,0,0);
layoutHighlight->addWidget(selHighlightTime,0,1);
layoutHighlight->addWidget(chkAutoHighlight,1,0);
layoutHighlight->addWidget(chkHighlightErrorbars,1,1);

grpLoadSave->setLayout(layoutLoadSave);
grpInput->setLayout(layoutInput);
grpResponse->setLayout(layoutResponse);
grpHighlight->setLayout(layoutHighlight);

behavLayout->addWidget(grpResponse,0,0);
behavLayout->addWidget(grpInput,1,0);
behavLayout->addWidget(grpLoadSave,2,0);
behavLayout->addWidget(grpHighlight,3,0);

behavLayout->addWidget(cmdTest,4,0);

//behavLayout->addWidget(selFontSize,3,0);
//behavLayout->addWidget(cmdActDevs,4,0);

/*int r_index=0;
behavLayout->addWidget(selGeneral,r_index++,0,1,2);
behavLayout->addWidget(chkQtFonts,r_index,0);
behavLayout->addWidget(chkActivateLaTeXSupport,r_index++,1);
behavLayout->addWidget(chkSymbolSpecial,r_index++,0);
behavLayout->addWidget(chkImmediateUpdate,r_index++,0);
behavLayout->addWidget(selCodec,r_index++,0,1,2);
behavLayout->addWidget(selDecSep,r_index++,0,1,2);
behavLayout->addWidget(histSize,r_index++,0,1,2);
behavLayout->addWidget(selFontSize,r_index++,0,1,2);
behavLayout->addWidget(chkAutoSetAgr,r_index,0);
behavLayout->addWidget(chkAutoSetExport,r_index++,1);
behavLayout->addWidget(chkAutoSetCWD,r_index,0);
behavLayout->addWidget(chkWarnOnEncodingChange,r_index++,1);
behavLayout->addWidget(cmdActDevs,r_index++,0,1,2);*/
QWidget * empty5=new QWidget(this);
behavLayout->addWidget(empty5,5,0);
behavLayout->setRowStretch(5,3);

tab_Behaviour->setLayout(behavLayout);

/// MISC
tab_Misc=new QWidget(this);
miscLayout=new QVBoxLayout(this);
miscLayout->setMargin(STD_MARGIN);
miscLayout->setSpacing(STD_SPACING);

//lblExtLibs=new QLabel(tr("External Libraries:"),this);
grp_libFFTW3=new QGroupBox(tr("libFFTW3 (for Fourier-transformations)"),this);
chkUseFFTW3=new QCheckBox(tr("Use FFTW3"),this);
lblFFTW3_found=new QLabel(tr("FFTW3 not usable"),this);
lblfftw3_static=new QLabel(tr("FFTW3 linked as static library"),this);
ledFFTW3_dll=new stdLineEdit(this,tr("Library:"));
ledFFTW3_dll->setText(QString(""));
cmdBrowseFFTW3=new QPushButton(tr("Browse"),this);
connect(cmdBrowseFFTW3,SIGNAL(clicked()),SLOT(doBrowseFFTW3_dll()));
layout_misc0=new QGridLayout();
layout_misc0->setSpacing(STD_SPACING);
layout_misc0->setMargin(STD_MARGIN);
layout_misc0->addWidget(chkUseFFTW3,0,0,1,2);
layout_misc0->addWidget(lblFFTW3_found,0,2,1,1);
#ifndef USE_STATIC_EXT_LIB_FFTW3
layout_misc0->addWidget(ledFFTW3_dll,1,0,1,2);
layout_misc0->addWidget(cmdBrowseFFTW3,1,2,1,1);
lblfftw3_static->hide();
#else
layout_misc0->addWidget(lblfftw3_static,1,0,1,3);
ledFFTW3_dll->hide();
cmdBrowseFFTW3->hide();
#endif
grp_libFFTW3->setLayout(layout_misc0);

grp_libHaru=new QGroupBox(tr("libHaru (for pdf-export)"),this);
chkUselibHaru=new QCheckBox(tr("Use libHaru"),this);
lblHaru_found=new QLabel(tr("libHaru not usable"),this);
lblHaru_static=new QLabel(tr("libHaru linked as static library"),this);
ledHaru_dll=new stdLineEdit(this,tr("Library:"));
ledHaru_dll->setText(QString(""));
cmdBrowseHaru=new QPushButton(tr("Browse"),this);
connect(cmdBrowseHaru,SIGNAL(clicked()),SLOT(doBrowseHaru_dll()));
layout_misc1=new QGridLayout();
layout_misc1->setSpacing(STD_SPACING);
layout_misc1->setMargin(STD_MARGIN);
layout_misc1->addWidget(chkUselibHaru,0,0,1,2);
layout_misc1->addWidget(lblHaru_found,0,2,1,1);
#ifndef USE_STATIC_EXT_LIB_HARU
layout_misc1->addWidget(ledHaru_dll,1,0,1,2);
layout_misc1->addWidget(cmdBrowseHaru,1,2,1,1);
lblHaru_static->hide();
#else
layout_misc1->addWidget(lblHaru_static,1,0,1,3);
ledHaru_dll->hide();
cmdBrowseHaru->hide();
#endif
grp_libHaru->setLayout(layout_misc1);

grpMiscMisc=new QGroupBox(tr("Misc"),this);
misc2Layout=new QVBoxLayout();
misc2Layout->setMargin(STD_MARGIN);
misc2Layout->setSpacing(STD_SPACING);

chkExternalHelpViewer=new QCheckBox(tr("Show help-files in external html-viewer"),this);
lenHelpViewer=new stdLineEdit(this,tr("Help viewer:"));
lenHelpViewer->setEnabled(false);
chkShowHideException=new QCheckBox(tr("Show/Hide workaround"),this);
lblSmallScreen=new QLabel(tr("Activate scroll-bars for small screen:"),this);
chkSmallScreenMain=new QCheckBox(tr("Main window"),this);
chkSmallScreenDialogs=new QCheckBox(tr("Large dialogs"),this);

grpPrinting=new QGroupBox(tr("Printing"),this);
/*fntPref=grpPrinting->font();
fntPref.setPixelSize(fntPref.pixelSize()*1.3);
grpPrinting->setFont(fntPref);*/
misc3Layout=new QVBoxLayout();
misc3Layout->setMargin(STD_MARGIN);
misc3Layout->setSpacing(STD_SPACING);

chkUsePrintCommand=new QCheckBox(tr("Use Print command (if this is deselected the native printer dialog is used)"),this);
lenPrintCommand=new stdLineEdit(this,tr("Print command:"));
lenPrintCommand->setText("lpr");
lenPrintCommand->setEnabled(false);
chkHDPrinterOutput=new QCheckBox(tr("Use HD-output on physical printers"),this);
selPrintDpi=new stdIntSelector(this,tr("Printer resolution (dpi):"),72,4800);

//fntPref.setPixelSize(fntPref.pixelSize()/1.3);
//chkUsePrintCommand->setFont(fntPref);
//lenPrintCommand->setFont(fntPref);
//chkHDPrinterOutput->setFont(fntPref);

grpRemote=new QGroupBox(tr("Communication"),this);
layoutRemote=new QGridLayout();
layoutRemote->setMargin(STD_MARGIN);
layoutRemote->setSpacing(STD_SPACING);
chkAnnounceRemote=new QCheckBox(tr("Comment on Server/Client-communications"),this);
chkAnnounceRemote->setToolTip(tr("Shows messages on 'stderr' about ongoing\ncommunication via Server/Client-protocol."));
layoutRemote->addWidget(chkAnnounceRemote,0,0,1,1);
grpRemote->setLayout(layoutRemote);

chkUseFFTW3->setToolTip(tr("Use the fftw3-library for all fourier-transformations"));
lblFFTW3_found->setToolTip(tr("Indicates whether the fftw3-library has been found"));
lblfftw3_static->setToolTip(tr("Indicates that the fftw3-library has been statically linked to QtGrace"));
ledFFTW3_dll->setToolTip(tr("The location where the fftw3-library can be found (dynamic library)"));
cmdBrowseFFTW3->setToolTip(tr("Specify the location of the fftw3-library"));
chkUselibHaru->setToolTip(tr("Use the Haru-PDF-library in the file-output-dialog"));
lblHaru_found->setToolTip(tr("Indicates whether the Haru-PDF-library has been found"));
lblHaru_static->setToolTip(tr("Indicates that the Haru-PDF-library has been statically linked to QtGrace"));
ledHaru_dll->setToolTip(tr("The location where the Haru-PDF-library can be found (dynamic library)"));
cmdBrowseHaru->setToolTip(tr("Specify the location of the Haru-PDF-library"));
chkUsePrintCommand->setToolTip(tr("Use a system-command to address the printer"));
selPrintDpi->setToolTip(tr("The resolution used to print on a physcial printer.\nThis is necessary because the print-system of Qt does not always report the correct resolution."));
lenPrintCommand->setToolTip(tr("Specify the system-command to address the printer"));
chkHDPrinterOutput->setToolTip(tr("Use high-quality-output on physical printer\n(this may increases the resolution dramatically and result in much smaller fill-patterns)"));
chkExternalHelpViewer->setToolTip(tr("Use a different external html-viewer to display help-files\n(the default viewer of the operating system is used otherwise)"));
lenHelpViewer->setToolTip(tr("Specify alternative external html-viewer"));
chkShowHideException->setToolTip(tr("A workaround to dectivates and reactivates the plot-area on every redraw\n(this was neccessary on some Linux-systems)\nThis should not be needed any more"));
chkSmallScreenMain->setToolTip(tr("Activate a scrollbar for the tool bar\nif the height of the main window is too small.\nIf deactivated, the lower buttons may not be accessable on small screens."));
chkSmallScreenDialogs->setToolTip(tr("Activate scrollbars in some of the larger dialogs\nif the dialog is too small to display everything.\nIf deactivated, large dialogs have a minimal size."));

cmdSummonWizard=new QPushButton(tr("Summon setup wizard"),this);
connect(cmdSummonWizard,SIGNAL(clicked()),SLOT(doSummonWizard()));

misc2Layout->addWidget(chkExternalHelpViewer);
misc2Layout->addWidget(lenHelpViewer);
misc2Layout->addWidget(chkShowHideException);
misc2Layout->addWidget(lblSmallScreen);
misc2Layout->addWidget(chkSmallScreenMain);
misc2Layout->addWidget(chkSmallScreenDialogs);

//misc3Layout->addWidget(chkHDPrinterOutput);
chkHDPrinterOutput->setVisible(false);
misc3Layout->addWidget(selPrintDpi);
misc3Layout->addWidget(chkUsePrintCommand);
misc3Layout->addWidget(lenPrintCommand);

grpPrinting->setLayout(misc3Layout);
grpMiscMisc->setLayout(misc2Layout);

miscLayout->addWidget(grp_libFFTW3);
miscLayout->addWidget(grp_libHaru);
miscLayout->addWidget(grpPrinting);
miscLayout->addWidget(grpMiscMisc);
miscLayout->addWidget(grpRemote);
miscLayout->addWidget(cmdSummonWizard);
QWidget * empty6=new QWidget(this);
miscLayout->addWidget(empty6);
miscLayout->setStretch(6,3);

tab_Misc->setLayout(miscLayout);

tabs->addTab(tab_prefs,tr("Grace"));                    //0
tabs->addTab(tab_GUI,tr("QtGrace-GUI"));
tabs->addTab(tab_Behaviour,tr("QtGrace-Behavior"));
tabs->addTab(tab_Misc,tr("Miscellaneous"));
//tabs->addTab(tab_extra,tr("QtGrace (1)"));              //1
//tabs->addTab(tab_qtgrace_prefs2,tr("QtGrace (2)"));     //2
tabs->addTab(tab_defaults,tr("Defaults"));              //3
tabs->addTab(tab_linestyles,tr("Linestyles"));          //4
tabs->addTab(tab_colors,tr("Colors"));                  //5

vbox->addWidget(tabs);

buttons=new stdButtonGroup(this);

connect(buttons->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(buttons->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(buttons->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

vbox->addWidget(buttons);

flp->setLayout(vbox);

connect(tab_prefs,SIGNAL(close_wish()),SLOT(doClose()));
//connect(tab_extra,SIGNAL(close_wish()),SLOT(doClose()));
//connect(tab_qtgrace_prefs2,SIGNAL(close_wish()),SLOT(doClose()));
connect(tab_linestyles,SIGNAL(close_wish()),SLOT(doClose()));
connect(tab_colors,SIGNAL(close_wish()),SLOT(doClose()));
connect(tab_defaults,SIGNAL(close_wish()),SLOT(doClose()));
connect(tabs,SIGNAL(currentChanged(int)),SLOT(tab_changed(int)));
connect(chkExternalHelpViewer,SIGNAL(stateChanged(int)),SLOT(toggleHTMLviewer(int)));
connect(chkUsePrintCommand,SIGNAL(stateChanged(int)),SLOT(togglePrintCommand(int)));

delete[] entr;
delete[] i_entr;

setLayout(m_layout);

//resize(QSize(min_w,min_h));
resize(LastSize_Form_Preferences);
}

frm_Preferences::~frm_Preferences()
{
    LastSize_Form_Preferences=this->size();
}

void frm_Preferences::init(void)
{
tab_prefs->init();
//tab_extra->init();
//tab_qtgrace_prefs2->init();
init_GUI();
init_Behavior();
init_Misc();
tab_defaults->init();
tab_linestyles->init();
tab_colors->init();
tab_defaults->show_defaults=grdefaults;
tab_defaults->show_view=grview;
strcpy(tab_defaults->show_sformat,sformat);
redisplayContents();
}

void frm_Preferences::init_GUI(void)
{

    chkNewIcons->setChecked(use_new_icons);
    QString font_descr=qApp->font().toString();
    lblGuiFont->setText(font_descr);

    selStartupX->spnInt->setRange(0,qApp->desktop()->width()*0.9);
    selStartupY->spnInt->setRange(0,qApp->desktop()->height()*0.9);
    selStartupWidth->spnInt->setRange(100,qApp->desktop()->width());
    selStartupHeight->spnInt->setRange(100,qApp->desktop()->width());

    //Display the customization-Settings
    chkShowNavi->setChecked(show_Navi_B);
    chkShowGraph->setChecked(show_Graph_List);
    chkShowSpecZoom->setChecked(show_special_Zoom);
    //chkShowViewp->setChecked(show_Viewport_Stack);
    selShowViewp->setCurrentIndex(show_Viewport_Stack);
    chkShowPageZoom->setChecked(show_Page_Zoom);
    chkShowPrintB->setChecked(show_Print_B);
    chkShowExportP->setChecked(show_Export_B);
    /*chkShowPanB->setChecked(show_PanButton);
    chkShowPickB->setChecked(show_PickButton);*/
    selShowPan->setCurrentIndex(show_PanButton);
    selShowPick->setCurrentIndex(show_PickButton);
    chkShowUndoRedo->setChecked(show_UndoRedo_B);
    chkShowHostName->setChecked(show_host_name);
    chkShowDisplay->setChecked(show_display_name);
    selFileDisplay1->setCurrentIndex(displ_project_filename);
    selFileDisplay2->setCurrentIndex(displ_export_filename);
    selToolbarSize->setValue(toolBarSizeFactor);

    //Startup
    selDefaultPrintDevice->setCurrentValue(default_Print_Device);
    lenDefaultFile->setText(QString(default_grace_file));
    selLanguage->setCurrentIndex(current_language);//ok
    selStartupX->setValue(initial_x_pos);
    selStartupY->setValue(initial_y_pos);
    selStartupWidth->setValue(initial_width);
    selStartupHeight->setValue(initial_height);
    selStartupBehavior->setCurrentValue(initial_size_behavior);
    selStdDpi->setValue(start_dpi);

    show_Navi_B=chkShowNavi->isChecked();
    show_Graph_List=chkShowGraph->isChecked();
    show_special_Zoom=chkShowSpecZoom->isChecked();
    //show_Viewport_Stack=chkShowViewp->isChecked();
    show_Viewport_Stack=selShowViewp->currentIndex();
    show_Page_Zoom=chkShowPageZoom->isChecked();
    show_Print_B=chkShowPrintB->isChecked();
    show_Export_B=chkShowExportP->isChecked();
    show_host_name=chkShowHostName->isChecked();
    show_display_name=chkShowDisplay->isChecked();
    displ_project_filename=selFileDisplay1->currentIndex();
    displ_export_filename=selFileDisplay2->currentIndex();
}

void frm_Preferences::init_Behavior(void)
{
    selGeneral->setCurrentValue(general_behavior);
    histSize->setValue(max_history);//ok
    chkActivateLaTeXSupport->setChecked((bool)activateLaTeXsupport);
    chkImmediateUpdate->setChecked(immediateUpdate);
    chkEnableInlineEditing->setChecked(inline_editing);
    chkEnableContextMenuInMain->setChecked(context_menu_in_main);
    chkAutoPackSets->setChecked(autoPackSets);
    selIconBehavior->setCurrentIndex(icon_preferences);
    chkErrorbarsAutoscale->setChecked((bool)useErrorbarsInAutoscale);
    selAutoscaleOffset->setValue(minAutoscaleBorderOffset);
    chkAllowGestures->setChecked((bool)allow_gestures);
    chkAllowWheel->setChecked((bool)allow_wheel_zoom);
    chkAllowWheelChanges->setChecked((bool)allow_wheel_changes);
    chkUndoActive->setChecked(undo_active);
    chkUndoActiveStart->setChecked(start_with_undo_active);
    selTranspSelection->setCurrentValue(show_transparency_selector);

    //selFontSize->setValue(universal_font_size_factor*100.0);
    chkQtFonts->setChecked(useQtFonts);
    chkSymbolSpecial->setChecked(symbol_font_is_special);
        if (useQtFonts==true) chkSymbolSpecial->setEnabled(true);
        else chkSymbolSpecial->setEnabled(false);
    selDecSep->setCurrentIndex(DecimalPointToUse=='.'?0:1);

    chkAutoFitLoad->setChecked(autofit_on_load);
    chkAutoSetAgr->setChecked(auto_set_agr_extension);
    chkAutoSetCWD->setChecked(auto_set_cwd);
    chkAutoSetExport->setChecked(auto_set_export_extensions);
    chkWarnOnEncodingChange->setChecked(warn_on_encoding_change);

    selHighlightColor->setCurrentIndex(highlight_color);
    selHighlightColor->setAlpha(highlight_alpha);
    selHighlightTime->setCurrentIndex(highlight_time);
    chkAutoHighlight->setChecked(auto_highlight==TRUE?true:false);
    chkHighlightErrorbars->setChecked(highlight_errorbars==TRUE?true:false);

    int index=0;
    for (int i=0;i<avcod.length();i++)
    {
        if (FileCodec==QTextCodec::codecForName(avcod.at(i)))
        {
        index=i;
        break;
        }
    }
    selCodec->cmbSelect->setCurrentIndex(index);

}

void frm_Preferences::init_Misc(void)
{
    QColor col_red(255,0,0);
    QColor col_green(0,255,0);
    QColor col_text;
    QPalette Pal(mainWin->palette());
    col_text=Pal.color(QPalette::Text);//tmp is the standard text color

        chkUseFFTW3->setChecked(use_fftw3);
        chkUselibHaru->setChecked(use_libHaru);
        ledFFTW3_dll->setText(path_to_fftw3_lib.fileName());
        ledHaru_dll->setText(path_to_libharu.fileName());
        check_external_lib_usability();
    /*#ifdef USE_STATIC_EXT_LIB_FFTW3
        cout << "USING STATIC LIBRARY FFTW3" << endl;
    #endif*/

    QPalette Pal1(ledFFTW3_dll->lenText->palette());
        if (path_to_fftw3_lib.exists()==true)
        {
        Pal1.setColor(QPalette::Text, col_text);
        }
        else
        {
        Pal1.setColor(QPalette::Text, col_red);
        }
    ledFFTW3_dll->lenText->setPalette(Pal1);

    /*#ifdef USE_STATIC_EXT_LIB_HARU
        cout << "USING STATIC LIBRARY HARU" << endl;
    #endif*/

    QPalette Pal2(ledHaru_dll->lenText->palette());
        if (path_to_libharu.exists()==true)
        {
        Pal2.setColor(QPalette::Text, col_text);
        }
        else
        {
        Pal2.setColor(QPalette::Text, col_red);
        }
    ledHaru_dll->lenText->setPalette(Pal1);

    QPalette Pal3(lblFFTW3_found->palette());
        if (have_fftw3==TRUE)
        {
        lblFFTW3_found->setText(tr("FFTW3 usable"));
        Pal3.setColor(QPalette::Background, col_green);
        }
        else//fftw3 not found
        {
        lblFFTW3_found->setText(tr("FFTW3 NOT usable"));
        Pal3.setColor(QPalette::Background, col_red);
        }
    lblFFTW3_found->setPalette(Pal3);
    lblFFTW3_found->setAlignment(Qt::AlignCenter);
    lblFFTW3_found->setAutoFillBackground(true);

    QPalette Pal4(lblHaru_found->palette());
        if (have_libHaru==TRUE)
        {
        lblHaru_found->setText(tr("libHaru usable"));
        Pal4.setColor(QPalette::Background, col_green);
        }
        else//libHaru not found
        {
        lblHaru_found->setText(tr("libHaru NOT usable"));
        Pal4.setColor(QPalette::Background, col_red);
        }
    lblHaru_found->setPalette(Pal4);
    lblHaru_found->setAlignment(Qt::AlignCenter);
    lblHaru_found->setAutoFillBackground(true);

    //lenHome->setText(QString(GRACE_HOME));
    chkExternalHelpViewer->setChecked(display_help_externally);//ok
    lenHelpViewer->setText(QString(qtgrace_help_viewer));
    chkShowHideException->setChecked(showhideworkaround);//ok
    chkUsePrintCommand->setChecked(use_print_command);
    lenPrintCommand->setText(get_print_cmd());
    chkHDPrinterOutput->setChecked(useHDPrinterOutput);
    selPrintDpi->setValue(typicalPrinterResolution);
    chkAnnounceRemote->setChecked(comment_server_client==0?false:true);

    if (small_screen_adjustments & 1)
    chkSmallScreenMain->setChecked(true);
    else
    chkSmallScreenMain->setChecked(false);

    if (small_screen_adjustments & 2)
    chkSmallScreenDialogs->setChecked(true);
    else
    chkSmallScreenDialogs->setChecked(false);
}

void frm_Preferences::read(void)
{
    tab_prefs->doApply();
    read_GUI();
    read_Behavior();
    read_Misc();
    init();
    mainWin->mainArea->completeRedraw();
    mainWin->redisplayIcons();
}

void frm_Preferences::read_GUI(void)
{
    use_new_icons=chkNewIcons->isChecked();
    default_Print_Device=selDefaultPrintDevice->currentValue();

    //Display the customization-Settings
    show_Navi_B=chkShowNavi->isChecked();
    show_Graph_List=chkShowGraph->isChecked();
    show_special_Zoom=chkShowSpecZoom->isChecked();
    //show_Viewport_Stack=chkShowViewp->isChecked();
    show_Viewport_Stack=selShowViewp->currentIndex();
    show_Page_Zoom=chkShowPageZoom->isChecked();
    show_Print_B=chkShowPrintB->isChecked();
    show_Export_B=chkShowExportP->isChecked();
    /*show_PanButton=chkShowPanB->isChecked();
    show_PickButton=chkShowPickB->isChecked();*/
    show_PanButton=selShowPan->currentIndex();
    show_PickButton=selShowPick->currentIndex();
    show_UndoRedo_B=chkShowUndoRedo->isChecked();
    show_host_name=chkShowHostName->isChecked();
    show_display_name=chkShowDisplay->isChecked();
    displ_project_filename=selFileDisplay1->currentIndex();
    displ_export_filename=selFileDisplay2->currentIndex();
    toolBarSizeFactor=selToolbarSize->value();

    int newlanguage=selLanguage->currentIndex();
        if (newlanguage!=current_language)
        {
            current_language=newlanguage;
            /*char dummy[512];
            strcpy(dummy,"[Warning] Changing the language takes effekt after restart of QtGrace.");
            stufftext(dummy);*/
        }
        strcpy(default_grace_file,lenDefaultFile->text().toLocal8Bit().constData());
        initial_x_pos=selStartupX->value();
        initial_y_pos=selStartupY->value();
        initial_width=selStartupWidth->value();
        initial_height=selStartupHeight->value();
        initial_size_behavior=selStartupBehavior->currentValue();
        start_dpi=selStdDpi->value();
//init();
        mainWin->ManageBars();
        set_left_footer(NULL);
        FormDeviceSetup->changeDeviceList(2);
}

void frm_Preferences::read_Behavior(void)
{
    general_behavior=selGeneral->currentValue();
    //general_behavior=selGeneral->currentIndex();
    FileCodec=QTextCodec::codecForName(selCodec->cmbSelect->currentText().toLocal8Bit().constData());
    auto_set_agr_extension=chkAutoSetAgr->isChecked()==true?TRUE:FALSE;
    auto_set_export_extensions=chkAutoSetExport->isChecked()==true?TRUE:FALSE;
    auto_set_cwd=chkAutoSetCWD->isChecked()==true?TRUE:FALSE;
    autofit_on_load=chkAutoFitLoad->isChecked()==true?TRUE:FALSE;
    warn_on_encoding_change=chkWarnOnEncodingChange->isChecked()==true?TRUE:FALSE;
    if (show_transparency_selector!=selTranspSelection->currentValue())
    {
    show_transparency_selector=selTranspSelection->currentValue();
    update_alpha_selectors();
    }
    activateLaTeXsupport=chkActivateLaTeXSupport->isChecked()==true?1:0;
    immediateUpdate=chkImmediateUpdate->isChecked();
    inline_editing=chkEnableInlineEditing->isChecked();

    context_menu_in_main=chkEnableContextMenuInMain->isChecked()==true?TRUE:FALSE;
    autoPackSets=chkAutoPackSets->isChecked()==true?TRUE:FALSE;
    icon_preferences=selIconBehavior->currentIndex();

    useErrorbarsInAutoscale=chkErrorbarsAutoscale->isChecked()==true?TRUE:FALSE;
    minAutoscaleBorderOffset=selAutoscaleOffset->value();
    allow_gestures=chkAllowGestures->isChecked()==true?TRUE:FALSE;
    allow_wheel_zoom=chkAllowWheel->isChecked()==true?TRUE:FALSE;
    allow_wheel_changes=chkAllowWheelChanges->isChecked()==true?TRUE:FALSE;

    highlight_color=selHighlightColor->currentIndex();
    highlight_alpha=selHighlightColor->alpha();
    highlight_time=selHighlightTime->currentIndex();
    auto_highlight=((chkAutoHighlight->isChecked()==true)?TRUE:FALSE);
    highlight_errorbars=((chkHighlightErrorbars->isChecked()==true)?TRUE:FALSE);

    if (undo_active!=chkUndoActive->isChecked())
    {
    undo_active=chkUndoActive->isChecked();
        if (FormUndoList!=NULL)
        FormUndoList->chkActive->setChecked(undo_active);
    }
    start_with_undo_active=chkUndoActiveStart->isChecked();
//cout << "Read: redisplay" << endl;
    if (FormSetAppearance!=NULL)
    {
    FormSetAppearance->flp->tabMa->cmbSymbType->redisplayItems();
    }
//cout << "Ende Read: redisplay" << endl;
    //universal_font_size_factor=selFontSize->value()*0.01;
    bool oldQtFonts=useQtFonts;
    bool old_symbol_special=symbol_font_is_special;
    useQtFonts=chkQtFonts->isChecked();
    symbol_font_is_special=chkSymbolSpecial->isChecked();

    //use_new_print_dialog=chkNewPrintDialog->isChecked();
    //DefaultFont=defaultFont->currentIndex();
    OldDecimalPoint=DecimalPointToUse;
    DecimalPointToUse=(selDecSep->currentIndex()==0)?'.':',';
    /// if (DecimalPointToUse!=OldDecimalPoint)
    /// {
        UpdateAllWindowContents();
    /// }
    max_history=histSize->value();
//dirtystate=save_dirty;
    mainWin->recreateHistory();
    if (oldQtFonts!=useQtFonts || old_symbol_special!=symbol_font_is_special)//we change from old to new qt-fonts
    {
        update_font_selectors(true);
        copy_LaTeX_to_Grace();
        convert_Grace_Strings();
    }
}

void frm_Preferences::read_Misc(void)
{
    use_fftw3=chkUseFFTW3->isChecked();
    use_libHaru=chkUselibHaru->isChecked();
    path_to_fftw3_lib.setFileName(ledFFTW3_dll->text());
    path_to_libharu.setFileName(ledHaru_dll->text());

    set_print_cmd(lenPrintCommand->text().toLatin1().constData());
    use_print_command=chkUsePrintCommand->isChecked();
    useHDPrinterOutput=chkHDPrinterOutput->isChecked()==true?TRUE:FALSE;
    typicalPrinterResolution=selPrintDpi->value();
    display_help_externally=chkExternalHelpViewer->isChecked();
    showhideworkaround=chkShowHideException->isChecked();
    comment_server_client=chkAnnounceRemote->isChecked()==true?TRUE:FALSE;
    strcpy(qtgrace_help_viewer,lenHelpViewer->text().toLocal8Bit().constData());

    int old_small_screen=small_screen_adjustments;
    small_screen_adjustments=0;
    if (chkSmallScreenMain->isChecked()==true) small_screen_adjustments|=1;
    if (chkSmallScreenDialogs->isChecked()==true) small_screen_adjustments|=2;

    if (small_screen_adjustments!=old_small_screen)
    {
        if (FormPlotAppearance!=NULL)
        {
            if (small_screen_adjustments & 2)
            {
            FormPlotAppearance->setMinimumSize(0,0);
            }
            else
            {
            FormPlotAppearance->setMinimumSize(FormPlotAppearance->min_w,FormPlotAppearance->min_h);
            }
        FormPlotAppearance->resize(FormPlotAppearance->min_w,FormPlotAppearance->min_h);
        }
        if (FormAxisProperties!=NULL)
        {
            if (small_screen_adjustments & 2)
            {
            FormAxisProperties->setMinimumSize(0,0);
            }
            else
            {
            FormAxisProperties->setMinimumSize(FormAxisProperties->min_w,FormAxisProperties->min_h);
            }
        FormAxisProperties->resize(FormAxisProperties->min_w,FormAxisProperties->min_h);
        }
        if (FormGraphAppearance!=NULL)
        {
            if (small_screen_adjustments & 2)
            {
            FormGraphAppearance->setMinimumSize(0,0);
            }
            else
            {
            FormGraphAppearance->setMinimumSize(FormGraphAppearance->min_w,FormGraphAppearance->min_h);
            }
        FormGraphAppearance->resize(FormGraphAppearance->min_w,FormGraphAppearance->min_h);
        }
        if (FormSetAppearance!=NULL)
        {
            if (small_screen_adjustments & 2)
            {
            FormSetAppearance->setMinimumSize(0,0);
            }
            else
            {
            FormSetAppearance->setMinimumSize(FormSetAppearance->min_w,FormSetAppearance->min_h);
            }
        FormSetAppearance->resize(FormSetAppearance->min_w,FormSetAppearance->min_h);
        }
            if (small_screen_adjustments & 2)
            {
            this->setMinimumSize(0,0);
            }
            else
            {
            this->setMinimumSize(this->min_w,this->min_h);
            }
            this->resize(min_w,min_h);
    }
}

void frm_Preferences::tab_changed(int nr)
{
    /*if (nr==4)
    {
    tab_linestyles->selStyles->setCurrentIndex(1);
    tab_linestyles->currentStyleChanged(1);
    }*/
if (nr>=4)
{
buttons->setVisible(false);
}
else
{
buttons->setVisible(true);
}

}

void frm_Preferences::redisplayContents(void)
{
    QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
    /*selFontSize->setLocale(newLocale);
    selFontSize->setValue(Form_Preferences->selFontSize->value());*/
    tab_defaults->selLineWidth->setLocale(newLocale);
    tab_defaults->selLineWidth->setValue(Form_Preferences->tab_defaults->selLineWidth->value());
    for (int i=0;i<4;i++)
    tab_defaults->selviewp[i]->ReplaceNumberContents();
    selAutoscaleOffset->setLocale(newLocale);
    selAutoscaleOffset->setValue(selAutoscaleOffset->value());
    //tab_defaults->selviewp[i]->RedisplayContents();
    selToolbarSize->setLocale(newLocale);
    selToolbarSize->setValue(selToolbarSize->value());
}

void frm_Preferences::doClose(void)
{
hide();
}

void frm_Preferences::doApply(void)
{
/// Apply the different Applys --> do a special Apply for the new three tabs
    read();
}

void frm_Preferences::doAccept(void)
{
ApplyError=false;
doApply();
    if (ApplyError==false)
    hide();
}

void frm_Preferences::doGraceDefaults(void)
{
chkShowNavi->setChecked(true);
chkShowGraph->setChecked(false);
chkShowSpecZoom->setChecked(true);
//chkShowViewp->setChecked(true);
selShowViewp->setCurrentIndex(1);
chkShowPageZoom->setChecked(false);
chkShowPrintB->setChecked(false);
chkShowExportP->setChecked(false);
chkShowHostName->setChecked(true);
chkShowDisplay->setChecked(true);
selFileDisplay1->setCurrentIndex(1);
selFileDisplay2->setCurrentIndex(0);
    read_GUI();
}

void frm_Preferences::doQtGraceDefaults(void)
{
chkShowNavi->setChecked(true);
chkShowGraph->setChecked(true);
chkShowSpecZoom->setChecked(true);
//chkShowViewp->setChecked(true);
selShowViewp->setCurrentIndex(2);
chkShowPageZoom->setChecked(true);
chkShowPrintB->setChecked(false);
chkShowExportP->setChecked(false);
chkShowHostName->setChecked(false);
chkShowDisplay->setChecked(false);
selFileDisplay1->setCurrentIndex(2);
selFileDisplay2->setCurrentIndex(2);
    read_GUI();
}

void frm_Preferences::doActDevs(void)
{
    if (diaDevAct==NULL)
    {
    diaDevAct=new frmDeviceActivator(this);
    }
diaDevAct->init();
diaDevAct->show();
diaDevAct->activateWindow();
}

void frm_Preferences::changeGUIFont(void)
{
bool ok;
QFont n_font=QFontDialog::getFont(&ok,*GuiFont,Form_Preferences,tr("Select Gui Font"));
if (ok==true)
{
    QFontInfo fi(n_font);
    n_font.setPixelSize(fi.pixelSize());
    delete GuiFont;
    GuiFont=new QFont(n_font);
/*qDebug() << "font.pointSize=" << n_font.pointSize() << " fi.pointSize=" << fi.pointSize();
qDebug() << "font.pixelSize=" << n_font.pixelSize() << " fi.pixelSize=" << fi.pixelSize();*/
    QApplication::setFont(n_font);
    QString font_descr=QApplication::font().toString();
//qDebug() << "setting Font=" << font_descr.toLatin1().constData();
    lblGuiFont->setText(font_descr);
    Form_Preferences->show();
    Form_Preferences->activateWindow();
    Form_Preferences->raise();
    update_color_selectors();
}
}

void frm_Preferences::resetGUIFont(void)
{
    QString font_descr=stdGuiFont->toString();
    lblGuiFont->setText(font_descr);
    //cout << "setting Font=" << font_descr.toLatin1().constData() << endl;
    QApplication::setFont(*stdGuiFont);
    delete GuiFont;
    GuiFont=new QFont(*stdGuiFont);
    update_color_selectors();
}

void frm_Preferences::select_BG_Color(void)
{
//QColor tmp;
//cout << "select a color" << endl;
    QColor tmp=QColorDialog::getColor();
    if (tmp.isValid())
    mainWin->mainArea->setBGtoColor(tmp);
}

void frm_Preferences::set_BG_Color_to_Std(void)
{
    QColor tmp;
    QPalette Pal(mainWin->palette());
    tmp=Pal.color(QPalette::Background);
    mainWin->mainArea->setBGtoColor(tmp);
}

void frm_Preferences::set_BG_Color_to_Page_BG(void)
{
    QColor tmp;
    tmp=get_Color(getbgcolor());
    if (getbgfill()==FALSE)
    set_BG_Color_to_Std();
    else
    mainWin->mainArea->setBGtoColor(tmp);
}

void frm_Preferences::doBrowseStartup(void)
{
QString templ_dir=QString(qt_grace_templates_dir);
    QString def=QFileDialog::getOpenFileName(this,tr("Select default startup file"),templ_dir);
    if (!def.isEmpty())
    {
        int ret=QMessageBox::question(this,tr("Absolute or relative"),tr("Do you want to store the location relative to the QtGrace-templates-directory?\nIf you press 'No' the absolute path will be used."),QMessageBox::Yes,QMessageBox::No);
        if (ret==QMessageBox::Yes)//relative
        {
        //QFileInfo fi(def);
        //cout << "Absolute=" << fi.absoluteFilePath().toLocal8Bit().constData() << endl;
        QDir di(templ_dir);
        //cout << "Relative=" << relPath.toLocal8Bit().constData() << endl;
        lenDefaultFile->setText(di.relativeFilePath(def));
        }
        else
        {
        lenDefaultFile->setText(def);
        }
    }
}

void frm_Preferences::doCurrentAsStartup(void)
{
    selStartupX->setValue(mainWin->x());
    selStartupY->setValue(mainWin->y());
    selStartupWidth->setValue(mainWin->width());
    selStartupHeight->setValue(mainWin->height());
}

void frm_Preferences::toggleHTMLviewer(int entry)
{
lenHelpViewer->setEnabled((bool)entry);
}

void frm_Preferences::togglePrintCommand(int entry)
{
lenPrintCommand->setEnabled((bool)entry);
}

void frm_Preferences::toggleQtFonts(bool check)
{
    if (check==true)
    chkSymbolSpecial->setEnabled(true);
    else
    chkSymbolSpecial->setEnabled(false);
}

void frm_Preferences::doBrowseFFTW3_dll(void)
{
QFileInfo fi(path_to_fftw3_lib);
QString old_path=fi.absolutePath();
QString new_file;
#ifdef WINDOWS_SYSTEM
new_file=QFileDialog::getOpenFileName(this,tr("Select FFTW3-Library"),old_path,"*.dll");
#endif
#ifdef MAC_SYSTEM
new_file=QFileDialog::getOpenFileName(this,tr("Select FFTW3-Library"),old_path,"*.dylib");
#else
    #ifdef LINUX_SYSTEM
    new_file=QFileDialog::getOpenFileName(this,tr("Select FFTW3-Library"),old_path,"*.so");
    #endif
#endif
if (!new_file.isEmpty())
{
ledFFTW3_dll->setText(new_file);
path_to_fftw3_lib.setFileName(new_file);
init();
}
}

void frm_Preferences::doBrowseHaru_dll(void)
{
QFileInfo fi(path_to_libharu);
QString old_path=fi.absolutePath();
QString new_file;
#ifdef WINDOWS_SYSTEM
new_file=QFileDialog::getOpenFileName(this,tr("Select libHaru-PDF-Library"),old_path,"*.dll");
#endif
#ifdef MAC_SYSTEM
new_file=QFileDialog::getOpenFileName(this,tr("Select libHaru-PDF-Library"),old_path,"*.dylib");
#else
    #ifdef LINUX_SYSTEM
    new_file=QFileDialog::getOpenFileName(this,tr("Select libHaru-PDF-Library"),old_path,"*.so");
    #endif
#endif
if (!new_file.isEmpty())
{
ledHaru_dll->setText(new_file);
path_to_libharu.setFileName(new_file);
init();
}
}

void frm_Preferences::doSummonWizard(void)
{
show_setup_wizard=TRUE;
this->hide();
QTimer::singleShot(200,mainWin,SLOT(showWizard()));
}

void frm_Preferences::doTest(void)
{
frmTest->show();
}

void frm_Preferences::resizeEvent(QResizeEvent *event)
{
//cout << "resize: " << event->size().width() << "x" << event->size().height() << " bar_w=" << bar_w << " bar_h=" << bar_h << endl;
//return;
int n_size_w=event->size().width(),n_size_h=event->size().height();
int actual_space_w=n_size_w,actual_space_h=n_size_h;
if (small_screen_adjustments & 2)
{
    for (int i=0;i<2;i++)
    {
        if (actual_space_w<min_w)
        {
            n_size_w=min_w;
            actual_space_h=event->size().height()-bar_h;
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
        if (actual_space_h<min_h)
        {
            n_size_h=min_h;
            actual_space_w=event->size().width()-bar_w;
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
    }
if (scroll->verticalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_w-=bar_w;
if (scroll->horizontalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_h-=bar_h;
this->setMinimumSize(0,0);
}
else
{
scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
this->setMinimumSize(min_w,min_h);
}
flp->resize(QSize(n_size_w,n_size_h));
}

int yesnowin(const char * msg,const char * s1,const char * s2,const char * help_anchor)
{
    (void)help_anchor;
    if (s1==NULL)
        return QMessageBox::question(0,QString("Error"),QString(msg),QMessageBox::Yes | QMessageBox::No)==QMessageBox::Yes?1:0;
    else
        return QMessageBox::question(0,QString(s1),QString(msg) + QString(s2),QMessageBox::Yes | QMessageBox::No)==QMessageBox::Yes?1:0;
}

frmSpreadSheet * findOpenSpreadSheet(int gno,int setno)
{
int found=-1;
    for (int i=0;i<number_of_opened_spreadsheets;i++)
    {
        if (FormSpreadSheets[i]!=NULL)
            if (FormSpreadSheets[i]->gno==gno && FormSpreadSheets[i]->sno==setno)
            {
                found=i;
                break;
            }
    }
if (found<0)
{
return NULL;
}
else
{
return FormSpreadSheets[found];
}
}

void showSetInSpreadSheet(int gno,int setno)
{
    int found=-1;
    for (int i=0;i<number_of_opened_spreadsheets;i++)
    {
        if (FormSpreadSheets[i]!=NULL)
            if (FormSpreadSheets[i]->gno==gno && FormSpreadSheets[i]->sno==setno)
            {
                found=i;
                break;
            }
    }
    if (found>=0)
    {
        FormSpreadSheets[found]->show();
        qApp->processEvents();
        FormSpreadSheets[found]->init(FormSpreadSheets[found]->gno,FormSpreadSheets[found]->sno);
        FormSpreadSheets[found]->raise();
    }
    else//new one needed
    {
        frmSpreadSheet ** sheets=new frmSpreadSheet *[number_of_opened_spreadsheets+1];
        for (int i=0;i<number_of_opened_spreadsheets;i++)
            sheets[i]=FormSpreadSheets[i];
        delete[] FormSpreadSheets;
        FormSpreadSheets=new frmSpreadSheet *[number_of_opened_spreadsheets+1];
        for (int i=0;i<number_of_opened_spreadsheets;i++)
            FormSpreadSheets[i]=sheets[i];
        delete[] sheets;
        FormSpreadSheets[number_of_opened_spreadsheets]=new frmSpreadSheet(0);
        FormSpreadSheets[number_of_opened_spreadsheets]->init(gno,setno);
        FormSpreadSheets[number_of_opened_spreadsheets]->show();
        FormSpreadSheets[number_of_opened_spreadsheets]->raise();
        FormSpreadSheets[number_of_opened_spreadsheets]->activateWindow();
        number_of_opened_spreadsheets++;
    }
}

/*void deleteSpreadSheet(int gno,int setno)
{
    int found=-1;
    for (int i=0;i<number_of_opened_spreadsheets;i++)
    {
        if (FormSpreadSheets[i]->gno==gno && FormSpreadSheets[i]->sno==setno)
        {
            found=i;
            break;
        }
    }
}*/

void get_tracking_props(int *setno, int *move_dir, int *add_at)
{
    *setno = track_setno;
    *move_dir = track_move_dir;
    *add_at = track_add_at;
}

frmDefaults::frmDefaults(QWidget * parent):QWidget(parent)
{
grp_defaults=new QGroupBox(tr("Grace-Defaults"),this);
layout0=new QGridLayout(grp_defaults);
layout0->setMargin(STD_MARGIN);
layout0->setSpacing(STD_SPACING);
selStdColor=new ColorSelector(grp_defaults);
selStdColor->lblText->setText(tr("Standard color:"));
selBGColor=new ColorSelector(grp_defaults);
selBGColor->lblText->setText(tr("Standard background color:"));
selStdPattern=new FillPatternSelector(grp_defaults);
selLineStyle=new LineStyleSelector(grp_defaults);
selLineWidth=new LineWidthSelector(grp_defaults);
sldStdCharSize=new stdSlider(grp_defaults,tr("Character size"),0,1000);
selStdFont=new FontSelector(grp_defaults);
sldStdSymSize=new stdSlider(grp_defaults,tr("Symbol size"),0,1000);
lenDefaultFormat=new stdLineEdit(this,tr("Default data point format:"));
cmdUseThisForCurrent=new QPushButton(tr("Use these defaults as current defaults"),grp_defaults);
cmdUseThisForProjectFile=new QPushButton(tr("Use these defaults for this project file"),grp_defaults);
int nr=4;
QString * entr=new QString[4];
entr[0]=tr("Current");
entr[1]=tr("from project file");
entr[2]=tr("from ini file");
entr[3]=tr("Grace default");
selShowDefaults=new StdSelector(this,tr("Show defaults:"),nr,entr);
connect(selShowDefaults,SIGNAL(currentIndexChanged(int)),SLOT(currentShowDefaultsChanged(int)));

lblviewp=new QLabel(tr("Initial viewport for new graphs:"),this);
selviewp[0]=new stdLineEdit(this,tr("Xmin:"));
selviewp[1]=new stdLineEdit(this,tr("Ymin:"));
selviewp[2]=new stdLineEdit(this,tr("Xmax:"));
selviewp[3]=new stdLineEdit(this,tr("Ymax:"));

grp_defaults->setToolTip(tr("The settings in this group are applied as initial settings for new objects\n(like graphs, texts, lines, sets, ...)\nnot applied to existing objects and not applied to the default-startup-agr-file"));
/*selStdColor->setToolTip(tr(""));
selBGColor->setToolTip(tr(""));
selStdPattern->setToolTip(tr(""));
selLineStyle->setToolTip(tr(""));
selLineWidth->setToolTip(tr(""));
sldStdCharSize->setToolTip(tr(""));
selStdFont->setToolTip(tr(""));
sldStdSymSize->setToolTip(tr(""));*/
lenDefaultFormat->setToolTip(tr("Defaults data point format in C notation"));
cmdUseThisForCurrent->setToolTip(tr("Use the displayed defaults as the current ones\n(the current defaults are always stored in the ini-file)"));
cmdUseThisForProjectFile->setToolTip(tr("Store these defaults in the project file on next save"));
/*lblviewp->setToolTip(tr(""));
selviewp[0]->setToolTip(tr(""));
selviewp[1]->setToolTip(tr(""));
selviewp[2]->setToolTip(tr(""));
selviewp[3]->setToolTip(tr(""));*/
selShowDefaults->setToolTip(tr("Which defaults are to displayed here\n(only the current ones are used)"));

grp_SetLists=new QGroupBox(tr("List(s) of sets"),this);
layoutSetList=new QGridLayout();
layoutSetList->setMargin(STD_MARGIN);
layoutSetList->setSpacing(STD_SPACING);
chkShowDataLess=new QCheckBox(tr("Show data-less sets"),this);
chkShowDataLess->setToolTip(tr("Show sets with no datapoints in every list of sets (if present)."));
chkShowHidden=new QCheckBox(tr("Show hidden sets"),this);
chkShowHidden->setToolTip(tr("Show hidden sets in every list of sets (if present)."));
chkShowComment=new QCheckBox(tr("Show comments"),this);
chkShowComment->setToolTip(tr("Show the set comment in every list of sets."));
chkShowLegend=new QCheckBox(tr("Show legends"),this);
chkShowLegend->setToolTip(tr("Show the set legend in every list of sets."));
chkShowIcons=new QCheckBox(tr("Show icons"),this);
chkShowIcons->setToolTip(tr("Show an icon representing the set appearance in every list of sets."));
layoutSetList->addWidget(chkShowDataLess,0,0);
layoutSetList->addWidget(chkShowHidden,0,1);
layoutSetList->addWidget(chkShowComment,1,0);
layoutSetList->addWidget(chkShowLegend,1,1);
layoutSetList->addWidget(chkShowIcons,2,0);
grp_SetLists->setLayout(layoutSetList);

layout0->addWidget(selStdColor,0,0,1,2);
layout0->addWidget(selBGColor,1,0,1,2);
layout0->addWidget(selStdPattern,2,0,1,2);
layout0->addWidget(selLineStyle,3,0,1,2);
layout0->addWidget(selLineWidth,4,0,1,2);
layout0->addWidget(sldStdCharSize,5,0,1,3);
layout0->addWidget(selStdFont,6,0,1,3);
layout0->addWidget(sldStdSymSize,7,0,1,3);
layout0->addWidget(lenDefaultFormat,8,0,1,3);
layout0->addWidget(cmdUseThisForCurrent,9,0,1,2);
layout0->addWidget(cmdUseThisForProjectFile,9,2,1,1);
layout0->addWidget(lblviewp,0,2,1,1);
layout0->addWidget(selviewp[0],1,2,1,1);
layout0->addWidget(selviewp[1],2,2,1,1);
layout0->addWidget(selviewp[2],3,2,1,1);
layout0->addWidget(selviewp[3],4,2,1,1);
layout0->setColumnStretch(0,2);
layout0->setColumnStretch(1,2);
layout0->setColumnStretch(2,1);
grp_defaults->setLayout(layout0);

grpColumnFormats=new QGroupBox(tr("Spreadsheet column format"),this);
layoutColumnFormat=new QGridLayout();
layoutColumnFormat->setMargin(STD_MARGIN);
layoutColumnFormat->setSpacing(STD_SPACING);
nr=4;
entr[0]=QString("Decimal");
entr[1]=QString("General");
entr[2]=QString("Exponential");
entr[3]=QString("Date/time");
selFormat=new StdSelector(grpColumnFormats,tr("Format:"),nr,entr);
selPrecision=new stdIntSelector(grpColumnFormats,tr("Precision:"),0,20);
layoutColumnFormat->addWidget(selFormat,0,0,1,1);
layoutColumnFormat->addWidget(selPrecision,0,1,1,1);
grpColumnFormats->setLayout(layoutColumnFormat);

layout=new QVBoxLayout(this);
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);
buttonGroup=new stdButtonGroup(this);
layout->addWidget(selShowDefaults);
layout->addWidget(grp_defaults);
layout->addWidget(grp_SetLists);
layout->addWidget(grpColumnFormats);
layout->addStretch(5);
layout->addWidget(buttonGroup);
setLayout(layout);

connect(buttonGroup->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(buttonGroup->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(buttonGroup->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

connect(cmdUseThisForCurrent,SIGNAL(clicked()),SLOT(doSetCurrent()));
connect(cmdUseThisForProjectFile,SIGNAL(clicked()),SLOT(doSetFile()));

currentShowDefaultsChanged(0);
}

void frmDefaults::show_current_defaults(void)
{
selStdColor->setCurrentIndex(show_defaults.color);
selBGColor->setCurrentIndex(show_defaults.bgcolor);
selStdColor->setAlpha(show_defaults.alpha);
selBGColor->setAlpha(show_defaults.bgalpha);
selStdPattern->setCurrentIndex(show_defaults.pattern);
selLineStyle->setCurrentIndex(show_defaults.lines);
selLineWidth->setValue(show_defaults.linew);
sldStdCharSize->setValue((int)rint_2(show_defaults.charsize*100.0));
selStdFont->setCurrentIndex(show_defaults.font);
sldStdSymSize->setValue((int)rint_2(show_defaults.symsize*100.0));
lenDefaultFormat->setText(QString(show_sformat));
selviewp[0]->setDoubleValue("%.3g",show_view.xv1);
selviewp[1]->setDoubleValue("%.3g",show_view.yv1);
selviewp[2]->setDoubleValue("%.3g",show_view.xv2);
selviewp[3]->setDoubleValue("%.3g",show_view.yv2);
/*selviewp[0]->setValue(show_view.xv1);
selviewp[1]->setValue(show_view.yv1);
selviewp[2]->setValue(show_view.xv2);
selviewp[3]->setValue(show_view.yv2);*/
}

void frmDefaults::init(void)
{
//defaults
/*selStdColor->setCurrentIndex(grdefaults.color);
selBGColor->setCurrentIndex(grdefaults.bgcolor);
selStdPattern->setCurrentIndex(grdefaults.pattern);
selLineStyle->setCurrentIndex(grdefaults.lines);
selLineWidth->setValue(grdefaults.linew);
sldStdCharSize->setValue(int(grdefaults.charsize*100.0));
selStdFont->setCurrentIndex(grdefaults.font);
sldStdSymSize->setValue(int(grdefaults.symsize*100.0));
lenDefaultFormat->setText(QString(sformat));*/
show_current_defaults();

chkShowDataLess->setChecked(DefaultSetListShowDataless);
chkShowHidden->setChecked(DefaultSetListShowHidden);
chkShowComment->setChecked(DefaultSetListShowComments);
chkShowLegend->setChecked(DefaultSetListShowLegends);
chkShowIcons->setChecked(DefaultSetListShowIcons);

selFormat->setCurrentValue(SpreadsheetColumnFormat);
selPrecision->setValue(SpreadsheetColumnPrecision);
}

void frmDefaults::doSetCurrent(void)
{
readDefaultSettings();
grdefaults=show_defaults;
grview=show_view;
strcpy(sformat,show_sformat);
selShowDefaults->setCurrentIndex(0);
}

void frmDefaults::doSetFile(void)
{
readDefaultSettings();
file_defaults=show_defaults;
file_view=show_view;
strcpy(file_sformat,show_sformat);
selShowDefaults->setCurrentIndex(1);
}

void frmDefaults::readDefaultSettings(void)
{
show_defaults.color=selStdColor->currentIndex();
show_defaults.bgcolor=selBGColor->currentIndex();
show_defaults.alpha=selStdColor->alpha();
show_defaults.bgalpha=selBGColor->alpha();
show_defaults.pattern=selStdPattern->currentIndex();
show_defaults.lines=selLineStyle->currentIndex();
show_defaults.linew=selLineWidth->value();
show_defaults.charsize=sldStdCharSize->value()/100.0;
show_defaults.font=selStdFont->currentIndex();
show_defaults.symsize=sldStdSymSize->value()/100.0;
show_view.xv1=selviewp[0]->getDoubleValue();
show_view.yv1=selviewp[1]->getDoubleValue();
show_view.xv2=selviewp[2]->getDoubleValue();
show_view.yv2=selviewp[3]->getDoubleValue();
strcpy(show_sformat,lenDefaultFormat->text().toLocal8Bit().constData());
}

void frmDefaults::doApply(void)
{
    if (selShowDefaults->currentIndex()==0)
    {
    doSetCurrent();
    }
    DefaultSetListShowDataless=chkShowDataLess->isChecked()==true?TRUE:FALSE;
    DefaultSetListShowHidden=chkShowHidden->isChecked()==true?TRUE:FALSE;
    DefaultSetListShowComments=chkShowComment->isChecked()==true?TRUE:FALSE;
    DefaultSetListShowLegends=chkShowLegend->isChecked()==true?TRUE:FALSE;
    DefaultSetListShowIcons=chkShowIcons->isChecked()==true?TRUE:FALSE;
    setDefaultsInSetList();

    SpreadsheetColumnFormat=selFormat->currentValue();
    SpreadsheetColumnPrecision=selPrecision->value();

    //update_set_lists(-1);
    mainWin->mainArea->completeRedraw();
}

void frmDefaults::doAccept(void)
{
doApply();
doClose();
}

void frmDefaults::doClose(void)
{
emit(close_wish());
}

void frmDefaults::currentShowDefaultsChanged(int index)
{
    switch (index)
    {
    case 0://current
    show_defaults=grdefaults;
    show_view=grview;
    strcpy(show_sformat,sformat);
    //cmdResetToGraceStd->setEnabled(false);
    grp_defaults->setTitle(tr("Current defaults"));
    break;
    case 1://from project file
    show_defaults=file_defaults;
    show_view=file_view;
    strcpy(show_sformat,file_sformat);
    //cmdResetToGraceStd->setEnabled(true);
    grp_defaults->setTitle(tr("Defaults from project file"));
    break;
    case 2://from ini file
    show_defaults=ini_defaults;
    show_view=ini_view;
    strcpy(show_sformat,ini_sformat);
    //cmdResetToGraceStd->setEnabled(true);
    grp_defaults->setTitle(tr("Defaults from ini file"));
    break;
    case 3://grace default
    show_defaults=d_d;
    show_view=d_v;
    strcpy(show_sformat,grace_sformat);
    //cmdResetToGraceStd->setEnabled(true);
    grp_defaults->setTitle(tr("Grace defaults"));
    break;
    }
    init();

    if (index>=2)//grace defaults and ini-defaults are not editable
    {
    selStdColor->setEnabled(false);
    selBGColor->setEnabled(false);
    selStdPattern->setEnabled(false);
    selLineStyle->setEnabled(false);
    selLineWidth->setEnabled(false);
    sldStdCharSize->setEnabled(false);
    selStdFont->setEnabled(false);
    sldStdSymSize->setEnabled(false);
    lenDefaultFormat->setEnabled(false);
        for (int i=0;i<4;i++)
        selviewp[i]->setEnabled(false);
    }
    else
    {
    selStdColor->setEnabled(true);
    selBGColor->setEnabled(true);
    selStdPattern->setEnabled(true);
    selLineStyle->setEnabled(true);
    selLineWidth->setEnabled(true);
    sldStdCharSize->setEnabled(true);
    selStdFont->setEnabled(true);
    sldStdSymSize->setEnabled(true);
    lenDefaultFormat->setEnabled(true);
        for (int i=0;i<4;i++)
        selviewp[i]->setEnabled(true);
    }

}

void get_distance_between_graphs(int g1,int g2,int & direction,double & d)
{//returns the smallest distance (d) between two graphs and the direction (1=g2 right of g1, 2=g2 left of g1, 4=g2 above g1, 8=g2 below g1, combinations allowed)
view p1,p2;
double left,right,top,bottom;
char direction_name[16][32];
for (int i=0;i<16;i++) strcpy(direction_name[i],"undefined");
strcpy(direction_name[1],"right");
strcpy(direction_name[2],"left");

strcpy(direction_name[4],"above");
strcpy(direction_name[5],"above+right");
strcpy(direction_name[6],"above+left");

strcpy(direction_name[8],"below");
strcpy(direction_name[9],"below+right");
strcpy(direction_name[10],"below+left");

get_graph_viewport(g1,&p1);
get_graph_viewport(g2,&p2);
    left=-(p2.xv2-p1.xv1);
    right=p2.xv1-p1.xv2;
    top=p2.yv1-p1.yv2;
    bottom=-(p2.yv2-p1.yv1);

/*cout << "left=  " << left << endl;
cout << "right= " << right << endl;
cout << "top=   " << top << endl;
cout << "bottom=" << bottom << endl;*/

direction=(right>=0?1:0)|(left>=0?2:0)|(top>=0?4:0)|(bottom>=0?8:0);
    d=-1;
if ((left>=0.0 && left<=d) || d<0)
{
d=left;
}
if ((right>=0.0 && right<=d) || d<0)
{
d=right;
}
if ((top>=0.0 && top<=d) || d<0)
{
d=top;
}
if ((bottom>=0.0 && bottom<=d) || d<0)
{
d=bottom;
}
//cout << "direction=" << direction << " --> " << direction_name[direction] << " d=" << d << endl;
}

frmArrangeGraphs::frmArrangeGraphs(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Arrange Graphs"));
    setWindowIcon(QIcon(*GraceIcon));

    grpArrGraphs=new QGroupBox(QString(""),this);
    grpMatrix=new QGroupBox(tr("Matrix"),this);
    grpPageOffset=new QGroupBox(tr("Page offset"),this);
    grpSpacing=new QGroupBox(tr("Spacing"),this);

    lblArrGraphs=new QLabel(tr("Arrange graphs:"),grpArrGraphs);

    graphlist=new uniList(GRAPHLIST,grpArrGraphs);
    graphlist->setSelectionMode(QAbstractItemView::ExtendedSelection);

    selCols=new stdIntSelector(grpMatrix,tr("Cols:"),1,99);
    selRows=new stdIntSelector(grpMatrix,tr("Rows:"),1,99);

    /*selUpperOffset=new QDoubleSpinBox(grpPageOffset);
    selUpperOffset->setRange(0.0,1.0);
    selUpperOffset->setSingleStep(0.05);
    selUpperOffset->setValue(0.15);
    selLowerOffset=new QDoubleSpinBox(grpPageOffset);
    selLowerOffset->setRange(0.0,1.0);
    selLowerOffset->setSingleStep(0.05);
    selLowerOffset->setValue(0.15);
    selLeftOffset=new QDoubleSpinBox(grpPageOffset);
    selLeftOffset->setRange(0.0,1.0);
    selLeftOffset->setSingleStep(0.05);
    selLeftOffset->setValue(0.15);
    selRightOffset=new QDoubleSpinBox(grpPageOffset);
    selRightOffset->setRange(0.0,1.0);
    selRightOffset->setSingleStep(0.05);
    selRightOffset->setValue(0.15);*/

    selUpperOffset=new LineWidthSelector(grpPageOffset);
    selUpperOffset->setText(tr("Top:"));
    selUpperOffset->setRange(0.0,1.0);
    selUpperOffset->setDecimals(2);
    selUpperOffset->setSingleStep(0.05);
    selUpperOffset->setValue(0.15);
    selLowerOffset=new LineWidthSelector(grpPageOffset);
    selLowerOffset->setText(tr("Bottom:"));
    selLowerOffset->setRange(0.0,1.0);
    selLowerOffset->setDecimals(2);
    selLowerOffset->setSingleStep(0.05);
    selLowerOffset->setValue(0.15);
    selLeftOffset=new LineWidthSelector(grpPageOffset);
    selLeftOffset->setText(tr("Left:"));
    selLeftOffset->setRange(0.0,1.0);
    selLeftOffset->setDecimals(2);
    selLeftOffset->setSingleStep(0.05);
    selLeftOffset->setValue(0.15);
    selRightOffset=new LineWidthSelector(grpPageOffset);
    selRightOffset->setText(tr("Right:"));
    selRightOffset->setRange(0.0,1.0);
    selRightOffset->setDecimals(2);
    selRightOffset->setSingleStep(0.05);
    selRightOffset->setValue(0.15);

    selHGap=new LineWidthSelector(grpSpacing);
    selHGap->lblText->setText(tr("Hgap/width:"));
    selHGap->spnLineWidth->setRange(0.0,9.0);
    selHGap->spnLineWidth->setSingleStep(0.1);
    selHGap->spnLineWidth->setValue(0.2);
    selHGap->spnLineWidth->setDecimals(2);
    selVGap=new LineWidthSelector(grpSpacing);
    selVGap->lblText->setText(tr("Vgap/height:"));
    selVGap->spnLineWidth->setRange(0.0,9.0);
    selVGap->spnLineWidth->setSingleStep(0.1);
    selVGap->spnLineWidth->setValue(0.2);
    selVGap->spnLineWidth->setDecimals(2);

    chkAddGraphs=new QCheckBox(tr("Add graphs as needed to fill the matrix"),grpArrGraphs);
    chkAddGraphs->setChecked(TRUE);
    chkKillGraphs=new QCheckBox(tr("Kill extra graphs"),grpArrGraphs);
    int number=3;
    QString list[3];
    list[0]=tr("No");
    list[1]=tr("Keep relative position(s)");
    list[2]=tr("New relative position(s)");
    selMoveLegends=new StdSelector(grpArrGraphs,tr("Move legends:"),number,list);
    connect(selMoveLegends,SIGNAL(currentIndexChanged(int)),SLOT(MoveLegendsChanged(int)));
    selLegendX=new LineWidthSelector(grpArrGraphs);
    selLegendX->setText(tr("Relative X of legend:"));
    selLegendX->setRange(-100.0,200.0);
    selLegendX->setDecimals(2);
    selLegendX->setValue(5.0);
    selLegendX->setVisible(false);
    selLegendX->spnLineWidth->setSuffix(QString(" %"));
    selLegendY=new LineWidthSelector(grpArrGraphs);
    selLegendY->setText(tr("Relative Y of legend:"));
    selLegendY->setRange(-100.0,200.0);
    selLegendY->setDecimals(2);
    selLegendY->setValue(90.0);
    selLegendY->setVisible(false);
    selLegendY->spnLineWidth->setSuffix(QString(" %"));

    chkSnakeFill=new QCheckBox(tr("Snake fill"),grpMatrix);
    chkHPack=new QCheckBox(tr("Pack"),grpSpacing);
    chkVPack=new QCheckBox(tr("Pack"),grpSpacing);
    connect(chkHPack,SIGNAL(toggled(bool)),SLOT(PackToggled(bool)));
    connect(chkVPack,SIGNAL(toggled(bool)),SLOT(PackToggled(bool)));

    selOrder=new OrderSelector(grpMatrix);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    number=0;
    layout0=new QGridLayout();
    layout0->setMargin(STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(lblArrGraphs,number++,0,1,2);
    layout0->addWidget(graphlist,number++,0,1,2);
    layout0->addWidget(chkAddGraphs,number++,0,1,2);
    layout0->addWidget(chkKillGraphs,number++,0,1,2);
    layout0->addWidget(selMoveLegends,number++,0,1,2);
    layout0->addWidget(selLegendX,number,0,1,1);
    layout0->addWidget(selLegendY,number++,1,1,1);
    grpArrGraphs->setLayout(layout0);

    layout1=new QHBoxLayout();
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    layout1->addWidget(selCols);
    layout1->addWidget(selRows);
    layout1->addWidget(selOrder);
    layout1->addWidget(chkSnakeFill);
    grpMatrix->setLayout(layout1);

    layout2=new QGridLayout();
    layout2->setMargin(STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    layout2->addWidget(selUpperOffset,0,2);
    layout2->addWidget(selLowerOffset,2,2);
    layout2->addWidget(selLeftOffset,1,0);
    layout2->addWidget(selRightOffset,1,4);
    grpPageOffset->setLayout(layout2);

    layout3=new QHBoxLayout();
    layout3->setMargin(STD_MARGIN);
    layout3->setSpacing(STD_SPACING);
    layout3->addWidget(selHGap);
    layout3->addWidget(chkHPack);
    layout3->addWidget(selVGap);
    layout3->addWidget(chkVPack);
    grpSpacing->setLayout(layout3);

    layout=new QVBoxLayout();
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout->addWidget(grpArrGraphs);
    layout->addWidget(grpMatrix);
    layout->addWidget(grpPageOffset);
    layout->addWidget(grpSpacing);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormArrangeGraphs);
}

frmArrangeGraphs::~frmArrangeGraphs()
{
    LastSize_FormArrangeGraphs=this->size();
}

void frmArrangeGraphs::PackToggled(bool t)
{
    (void)t;
    selHGap->setEnabled(!(chkHPack->isChecked()));
    selVGap->setEnabled(!(chkVPack->isChecked()));
}

void frmArrangeGraphs::init(void)
{
QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
selUpperOffset->setLocale(newLocale);
selLowerOffset->setLocale(newLocale);
selLeftOffset->setLocale(newLocale);
selRightOffset->setLocale(newLocale);
selHGap->spnLineWidth->setLocale(newLocale);
selVGap->spnLineWidth->setLocale(newLocale);

    graphlist->update_number_of_entries();
    int *sel=new int[2];
    sel[0]=get_cg();
    graphlist->set_new_selection(1,sel);
    delete[] sel;

guessGraphOrdering();
if (guess_success==true)
{
    selUpperOffset->setValue(top_offset);
    selLowerOffset->setValue(bottom_offset);
    selLeftOffset->setValue(left_offset);
    selRightOffset->setValue(right_offset);
    selHGap->setValue(guess_hgap);
    selVGap->setValue(guess_vgap);
    chkHPack->setChecked(guess_hpack==1?true:false);
    chkVPack->setChecked(guess_vpack==1?true:false);
    selCols->setValue(guess_c);
    selRows->setValue(guess_r);
    chkSnakeFill->setChecked(guess_snake==1?true:false);
    selOrder->setCurrentIndex(guess_order);

    sel=new int[number_of_graphs()+2];
    for (int i=0;i<number_of_graphs();i++) sel[i]=i;
    graphlist->set_new_selection(number_of_graphs(),sel);
    delete[] sel;
}

}

void frmArrangeGraphs::doApply(void)
{
    ApplyError=false;
    int ngraphs, * graphs=new int[2];
    int nrows, ncols, order, snake;
    int hpack, vpack, add, kill, move_legend;
    double toff, loff, roff, boff, vgap, hgap, legendXPos, legendYPos;

    nrows = (int) GetSpinChoice(selRows);
    ncols = (int) GetSpinChoice(selCols);

    if (nrows < 1 || ncols < 1)
    {
        errmsg(tr("# of rows and columns must be > 0").toLocal8Bit().constData());
        delete[] graphs;
        ApplyError=true;
        return;// RETURN_FAILURE;
    }

    graphlist->get_selection(&ngraphs,&graphs);

    if (ngraphs == 0) {
        graphs = NULL;
    }
    
    order = selOrder->currentIndex();
    snake = GetToggleButtonState(chkSnakeFill);
    
    toff = GetSpinChoice(selUpperOffset);
    loff = GetSpinChoice(selLeftOffset);
    roff = GetSpinChoice(selRightOffset);
    boff = GetSpinChoice(selLowerOffset);

    hgap = GetSpinChoice(selHGap);
    vgap = GetSpinChoice(selVGap);
    
    add  = GetToggleButtonState(chkAddGraphs);
    kill = GetToggleButtonState(chkKillGraphs);
    move_legend = selMoveLegends->currentIndex();
    legendXPos=selLegendX->value()*0.01;
    legendYPos=selLegendY->value()*0.01;

    hpack = GetToggleButtonState(chkHPack);
    vpack = GetToggleButtonState(chkVPack);

    //Undo-Stuff
    SaveGraphStatesPrevious(ngraphs,graphs,UNDO_APPEARANCE);//save the sates of the graphs affected

    if (add && ngraphs < nrows*ncols)
    {
        int gno;
        int * gr_sav=new int[ngraphs+5];
        memcpy(gr_sav,graphs,sizeof(int)*ngraphs);
        delete[] graphs;
        graphs=new int[nrows*ncols];
        memcpy(graphs,gr_sav,sizeof(int)*ngraphs);
        delete[] gr_sav;
        //graphs = xrealloc(graphs, nrows*ncols*sizeof(int));
        for (gno = number_of_graphs(); ngraphs < nrows*ncols; ngraphs++, gno++)
        {
            graphs[ngraphs] = gno;
        }
    }

    if (kill && ngraphs > nrows*ncols) {
        for (; ngraphs > nrows*ncols; ngraphs--) {
            kill_graph(graphs[ngraphs - 1]);
        }
    }
    
    arrange_graphs(graphs, ngraphs,
                   nrows, ncols, order, snake,
                   loff, roff, toff, boff, vgap, hgap,
                   hpack, vpack, move_legend, legendXPos, legendYPos);

    //Undo-Staff
    GraphsModified(ngraphs,graphs,UNDO_APPEARANCE);
    addAditionalDescriptionToLastNode(UNDO_TYPE_GRAPH_APPEARANCE,QString(),tr("rearranged"));

    update_all();
    
    ///SelectListChoices(ui->graphs, ngraphs, graphs);
    //xfree(graphs);
    graphlist->update_number_of_entries();

    mainWin->mainArea->completeRedraw();
    graphlist->set_new_selection(ngraphs,graphs);
    delete[] graphs;
}

void frmArrangeGraphs::doClose(void)
{
    hide();
}

void frmArrangeGraphs::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmArrangeGraphs::guessGraphOrdering(void)
{
double xmin,xmax,ymin,ymax;
double width,height;
int first=-1;
tickmarks * t;

guess_r=guess_c=n_graphs=0;
guess_hgap=guess_vgap=0.0;
guess_success=0;
xmax=xmin=ymax=ymin=0.0;
//first part is getting the outer margins
for (int i=0;i<number_of_graphs();i++)
{
        if (g[i].hidden==true) continue;//only use visible graphs for checking the borders
    if (first==-1)
    {
    xmin=g[i].v.xv1;
    xmax=g[i].v.xv2;
    ymin=g[i].v.yv1;
    ymax=g[i].v.yv2;
    first=i;
    n_graphs=1;
    }
    else
    {
        if (xmin>g[i].v.xv1)
        xmin=g[i].v.xv1;
        if (xmax<g[i].v.xv2)
        xmax=g[i].v.xv2;
        if (ymin>g[i].v.yv1)
        ymin=g[i].v.yv1;
        if (ymax<g[i].v.yv2)
        ymax=g[i].v.yv2;
    n_graphs++;
    }
}
//n_graphs only inlcudes visible graphs

/*cout << "Guessed values: number_of_graphs=" << n_graphs << endl;
cout << "xmin=" << xmin << " xmax=" << xmax << endl;
cout << "ymin=" << ymin << " ymax=" << ymax << endl;
cout << "Page:" << endl;*/

get_page_viewport(&width,&height);
/*cout << width << " x " << height << endl;*/

left_offset=xmin;
right_offset=width-xmax;
bottom_offset=ymin;
top_offset=height-ymax;

//here we have the outer margins
/*cout << "Offsets:" << endl;
cout << "Left=" << left_offset << " Right=" << right_offset << endl;
cout << "Bottom=" << bottom_offset << " Top=" << top_offset << endl;*/

left_offset=0.01*rint_v2(100.0*left_offset);
right_offset=0.01*rint_v2(100.0*right_offset);
bottom_offset=0.01*rint_v2(100.0*bottom_offset);
top_offset=0.01*rint_v2(100.0*top_offset);

int direction,initial_direction,dir_first_after,dir_before_after;
double d,initial_d,tmp_d1,tmp_d2;
int index;

guess_vgap=0.2;
guess_hgap=0.2;
guess_hpack=0;
guess_vpack=0;

//now we guess the ordering
if (number_of_graphs()>1)
{
get_distance_between_graphs(0,1,initial_direction,initial_d);
index=1;
direction=initial_direction;
while (index<number_of_graphs()-1 && direction==initial_direction)
{
get_distance_between_graphs(index,index+1,direction,d);
index++;
}
//index is now the id of the first graph after switching directions
if (index>=number_of_graphs()-1)//just one row or column
{
    if (initial_direction==1 || initial_direction==2)//g1 right of g0 or left
    {
    guess_r=1;
    guess_c=number_of_graphs();
    guess_snake=0;
    guess_order=0;
        if (initial_direction==2) guess_order=1;
    guess_success=1;
        if (g[0].v.xv2-g[0].v.xv1==0.0)
        guess_hgap=0.2;
        else
        guess_hgap=initial_d/(g[0].v.xv2-g[0].v.xv1);
    }
    else if (initial_direction==4 || initial_direction==8)//g1 is above g0 or below
    {
    guess_r=number_of_graphs();
    guess_c=1;
    guess_snake=0;
    guess_order=4;
        if (initial_direction==4) guess_order=5;
    guess_success=1;
        if (g[0].v.yv2-g[0].v.yv1==0.0)
        guess_vgap=0.2;
        else
        guess_vgap=initial_d/(g[0].v.yv2-g[0].v.yv1);
    }
    else
    {
    guess_success=0;//no auto-ordering
    }
//cout << "Guessing: just one row/column: vgap=" << guess_vgap << " hgap=" << guess_hgap << endl;
}
else//more than one row and column
{
    if (initial_direction==1 || initial_direction==2)
    {
    guess_c=index;
    guess_r=number_of_graphs()/index;
    }
    else if (initial_direction==4 || initial_direction==8)
    {
    guess_r=index;
    guess_c=number_of_graphs()/index;
    }
get_distance_between_graphs(0,index,dir_first_after,tmp_d1);
get_distance_between_graphs(index-1,index,dir_before_after,tmp_d2);
    switch (initial_direction)
    {
    case 1:
        switch (dir_first_after)
        {
        case 4:
        guess_order=1;
        guess_snake=0;
        guess_success=1;
        break;
        case 5:
        guess_order=1;
        guess_snake=1;
        guess_success=1;
        break;
        case 8:
        guess_order=0;
        guess_snake=0;
        guess_success=1;
        break;
        case 9:
        guess_order=0;
        guess_snake=1;
        guess_success=1;
        break;
        default:
        guess_success=0;
        break;
        }
    break;
    case 2:
        switch (dir_first_after)
        {
        case 4:
        guess_order=3;
        guess_snake=0;
        guess_success=1;
        break;
        case 6:
        guess_order=3;
        guess_snake=1;
        guess_success=1;
        break;
        case 8:
        guess_order=2;
        guess_snake=0;
        guess_success=1;
        break;
        case 10:
        guess_order=2;
        guess_snake=1;
        guess_success=1;
        break;
        default:
        guess_success=0;
        break;
        }
    break;
    case 4:
        switch (dir_first_after)
        {
        case 1:
        guess_order=5;
        guess_snake=0;
        guess_success=1;
        break;
        case 5:
        guess_order=5;
        guess_snake=1;
        guess_success=1;
        break;
        case 2:
        guess_order=7;
        guess_snake=0;
        guess_success=1;
        break;
        case 6:
        guess_order=7;
        guess_snake=1;
        guess_success=1;
        break;
        default:
        guess_success=0;
        break;
        }
    break;
    case 8:
        switch (dir_first_after)
        {
        case 1:
        guess_order=4;
        guess_snake=0;
        guess_success=1;
        break;
        case 9:
        guess_order=4;
        guess_snake=1;
        guess_success=1;
        break;
        case 2:
        guess_order=6;
        guess_snake=0;
        guess_success=1;
        break;
        case 10:
        guess_order=6;
        guess_snake=1;
        guess_success=1;
        break;
        default:
        guess_success=0;
        break;
        }
    break;
    default:
    guess_success=0;
    break;
    }
    ///guess the gaps now
    if (guess_success==1)
    {
        switch (guess_order)
        {
        case 0:
        case 1:
        case 2:
        case 3:
            if (g[0].v.xv2-g[0].v.xv1==0.0)
            guess_hgap=0.2;
            else
            guess_hgap=initial_d/(g[0].v.xv2-g[0].v.xv1);
                if (guess_snake==1)
                guess_vgap=tmp_d2;
                else
                guess_vgap=tmp_d1;
            if (g[0].v.yv2-g[0].v.yv1==0.0)
            guess_vgap=0.2;
            else
            guess_vgap/=(g[0].v.yv2-g[0].v.yv1);
        break;
        case 4:
        case 5:
        case 6:
        case 7:
            if (g[0].v.yv2-g[0].v.yv1==0.0)
            guess_vgap=0.2;
            else
            guess_vgap=initial_d/(g[0].v.yv2-g[0].v.yv1);
                if (guess_snake==1)
                guess_hgap=tmp_d2;
                else
                guess_hgap=tmp_d1;
            if (g[0].v.xv2-g[0].v.xv1==0.0)
            guess_hgap=0.2;
            else
            guess_hgap/=(g[0].v.xv2-g[0].v.xv1);
        break;
        }
        //looking for packed graphs
        if (guess_hgap==0.0)//may be h-packed
        {
            guess_hpack=0;
            switch (guess_order)
            {
            case 0:
            case 1:
            default:
                t = get_graph_tickmarks(1, 1);//graph 1, y-axis
            break;
            case 2:
            case 3:
            case 6:
            case 7:
                t = get_graph_tickmarks(0, 1);//graph 0, y-axis
            break;
            case 4:
            case 5:
                t = get_graph_tickmarks(index, 1);//graph 'index', y-axis
            break;
            }
            if (t!=NULL)
            guess_hpack=!t->tl_flag;
        }
        else guess_hpack=0;
        if (guess_vgap==0.0)//may be v-packed
        {
            guess_vpack=0;
            switch (guess_order)
            {
            case 0:
            case 2:
            case 4:
            case 6:
            default:
                t = get_graph_tickmarks(0, 0);//graph 0, x-axis
            break;
            case 5:
            case 7:
                t = get_graph_tickmarks(1, 0);//graph 1, x-axis
            break;
            case 1:
            case 3:
                t = get_graph_tickmarks(index, 0);//graph 'index', x-axis
            break;
            }
            if (t!=NULL)
            guess_vpack=!t->tl_flag;
        }
        else guess_vpack=0;
        if (guess_vpack==1) guess_vgap=0.2;
        if (guess_hpack==1) guess_hgap=0.2;
    }
}//end more than one row or column
}//end more than one graph
else//just one graph
{
    guess_r=1;
    guess_c=1;
    guess_order=0;
    guess_snake=0;
    guess_hpack=guess_vpack=0;
    guess_success=1;
}
guess_hgap=0.1*rint_v2(guess_hgap*10.0);
guess_vgap=0.1*rint_v2(guess_vgap*10.0);
//cout << "hgap=" << guess_hgap << " vgap=" << guess_vgap << endl;
}

void frmArrangeGraphs::MoveLegendsChanged(int l)
{
    if (l==2)
    {
    selLegendX->setVisible(true);
    selLegendY->setVisible(true);
    }
    else
    {
    selLegendX->setVisible(false);
    selLegendY->setVisible(false);
    }
}

frmOverlayGraphs::frmOverlayGraphs(QWidget * parent):QDialog(parent)
{
    int number=5;
    QString entr[5];
 //setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Overlay Graphs"));
    setWindowIcon(QIcon(*GraceIcon));

    lblOverlayGraph=new QLabel(tr("Overlay graph:"),this);
    listOverlayGraph=new uniList(GRAPHLIST,this);
    listOverlayGraph->setBehavior(true,false,false);
    lblOntoGraph=new QLabel(tr("Onto graph:"),this);
    listOntoGraph=new uniList(GRAPHLIST,this);
    listOntoGraph->setBehavior(true,false,false);

    entr[0]=tr("Disabled");
    entr[1]=tr("X and Y axes different");
    entr[2]=tr("Same X axis scaling");
    entr[3]=tr("Same Y axis scaling");
    entr[4]=tr("Same X and Y axis scaling");
    selSmartAxisHint=new StdSelector(this,tr("Smart axis hint:"),number,entr);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout();
    layout->setMargin(STD_MARGIN);
    layout->addWidget(lblOverlayGraph);
    layout->addWidget(listOverlayGraph);
    layout->addWidget(lblOntoGraph);
    layout->addWidget(listOntoGraph);
    layout->addWidget(selSmartAxisHint);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormOverlayGraphs);
}

frmOverlayGraphs::~frmOverlayGraphs()
{
    LastSize_FormOverlayGraphs=this->size();
}

void frmOverlayGraphs::init(void)
{
    listOverlayGraph->update_number_of_entries();
    listOntoGraph->update_number_of_entries();
    int nr=1,*sel=new int[2];
    sel[0]=get_cg();
    listOverlayGraph->set_new_selection(nr,sel);
    listOntoGraph->set_new_selection(nr,sel);
    delete[] sel;
}

void frmOverlayGraphs::doApply(void)
{
    ApplyError=false;
    int g1, g2;
    int *gr1=new int[2];
    int *gr2=new int[2];
    int type = selSmartAxisHint->currentIndex();//GetOptionChoice(graph_overlaytype_item);
    
    listOverlayGraph->get_selection(&g1,&gr1);
    listOntoGraph->get_selection(&g2,&gr2);

    if (g1!=1)//GetSingleListChoice(graph_overlay1_choice_item, &g1) != RETURN_SUCCESS)
    {
        errmsg(tr("Please select a single graph").toLocal8Bit().constData());
        delete[] gr1;
        delete[] gr2;
        ApplyError=true;
        return;// RETURN_FAILURE;
    }
    else
    {
        g1=gr1[0];
    }

    if (g2!=1)//GetSingleListChoice(graph_overlay2_choice_item, &g2) != RETURN_SUCCESS)
    {
        errmsg(tr("Please select a single graph").toLocal8Bit().constData());
        delete[] gr1;
        delete[] gr2;
        ApplyError=true;
        return;// RETURN_FAILURE;
    }
    else
    {
        g2=gr2[0];
    }

    if (g1 == g2)
    {
        errmsg(tr("Can't overlay a graph onto itself").toLocal8Bit().constData());
        delete[] gr1;
        delete[] gr2;
        ApplyError=true;
        return;// RETURN_FAILURE;
    }

    int * gnos=new int[2];
    gnos[0]=g1;
    gnos[1]=g2;

    SaveGraphStatesPrevious(2,gnos,UNDO_APPEARANCE|UNDO_AXIS);
    overlay_graphs(g1, g2, type);
    GraphsModified(2,gnos,UNDO_APPEARANCE|UNDO_AXIS);
    addAditionalDescriptionToLastNode(-1,QObject::tr("Overlay Graphs"),QString(),-1);

    delete[] gnos;
    mainWin->mainArea->completeRedraw();
    delete[] gr1;
    delete[] gr2;
}

void frmOverlayGraphs::doClose(void)
{
    hide();
}

void frmOverlayGraphs::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

frmAutoscaleGraphs::frmAutoscaleGraphs(QWidget * parent):QDialog(parent)
{
    int number=4;
    QString entr[4];
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Autoscale Graphs"));
    setWindowIcon(QIcon(*GraceIcon));

    entr[0]=tr("None");
    entr[1]=tr("X");
    entr[2]=tr("Y");
    entr[3]=tr("XY");
    selAutoscale=new StdSelector(this,tr("Autoscale:"),number,entr);
    number=2;
    entr[0]=tr("Current");
    entr[1]=tr("All");
    selApplyToGraph=new StdSelector(this,tr("Apply to graph:"),number,entr);
    lblUseSet=new QLabel(tr("Use set:"),this);
    listSets=new uniList(SETCHOICE,this);
    listSets->setBehavior(true,false,true);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout();
    layout->setMargin(STD_MARGIN);
    layout->addWidget(selAutoscale);
    layout->addWidget(lblUseSet);
    layout->addWidget(listSets);
    layout->addWidget(selApplyToGraph);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormAutoScaleGraphs);
}

frmAutoscaleGraphs::~frmAutoscaleGraphs()
{
    LastSize_FormAutoScaleGraphs=this->size();
}

void frmAutoscaleGraphs::init(void)
{
    selAutoscale->setCurrentIndex(3);
    listSets->gr_no=get_cg();
    listSets->update_number_of_entries();
}

void frmAutoscaleGraphs::doApply(void)
{
    ApplyError=false;
    int aon, au, ap;
    int * sel=new int[2];
    aon = selAutoscale->currentIndex();
    ap = GetChoice(selApplyToGraph);
    //au = GetSelectedSet(ui->sel);
    listSets->get_selection(&au,&sel);
    if (au<1)
    {
        errmsg(tr("No set selected").toLocal8Bit().constData());
        delete[] sel;
        ApplyError=true;
        return;//RETURN_FAILURE;
    }
    au=sel[0]-1;
    int * gnos=new int[number_of_graphs()+1];
    int index=0;
    if (ap==0)//current graph
    {
        gnos[0]=ap;
        index=1;
    }
    else//all graphs
    {
        index=number_of_graphs();
        for (int i=0;i<index;i++)
            gnos[i]=i;
    }
    SaveGraphStatesPrevious(index,gnos,UNDO_APPEARANCE);
    define_autos(aon, au, ap);
    GraphsModified(index,gnos,UNDO_APPEARANCE);
    delete[] gnos;
    delete[] sel;
    //return RETURN_SUCCESS;
}

void frmAutoscaleGraphs::doClose(void)
{
    hide();
}

void frmAutoscaleGraphs::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmAutoscaleGraphs::define_autos(int aon, int au, int ap)
{
    int i, ming, maxg;

    if (au >= 0 && !is_set_active(cg, au)) {
        errmsg(tr("Set not active").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }
    if (ap) {
        ming = 0;
        maxg = number_of_graphs() - 1;
    } else {
        ming = cg;
        maxg = cg;
    }
    if (ming == cg && maxg == cg) {
        if (!is_graph_active(cg)) {
            errmsg(tr("Current graph is not active!").toLocal8Bit().constData());
            ApplyError=true;
            return;
        }
    }
    for (i = ming; i <= maxg; i++) {
        if (is_graph_active(i)) {
            autoscale_byset(i, au, aon);
        }
    }
    if (FormAxisProperties!=NULL)
        FormAxisProperties->update_ticks(cg);
    mainWin->mainArea->completeRedraw();
}

frmDataSetProperties::frmDataSetProperties(QWidget * parent):QDialog(parent)
{
    int number;
    char dummy[128];
    QString entr[50];
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Data set properties"));
    setWindowIcon(QIcon(*GraceIcon));
    gno=sno=-1;//invalid
    CreateActions();

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu("&File",this);
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actClose);
    mnuEditData=new QMenu("&Edit data",this);
    mnuEditData->setTearOffEnabled(TRUE);
    mnuEditData->addAction(actEditInSpreadsheet);
    mnuEditData->addAction(actEditInTextEditor);
    mnuCreateNew=new QMenu("Create &new",this);
    mnuCreateNew->setTearOffEnabled(TRUE);
    mnuCreateNew->addAction(actCreateNewByFormula);
    mnuCreateNew->addAction(actCreateNewInSpreadsheet);
    mnuCreateNew->addAction(actCreateNewInTextEditor);
    mnuCreateNew->addAction(actCreateNewFromBlockData);
    mnuEdit=new QMenu("&Edit",this);
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actDuplicate);
    mnuEdit->addAction(actKillData);
    mnuEdit->addSeparator();
    mnuEdit->addMenu(mnuEditData);
    mnuEdit->addMenu(mnuCreateNew);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actSetAppearance);
    mnuEdit->addAction(actSetOperations);
    mnuHelp=new QMenu("&Help",this);
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnSetProp);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    number=NUMBER_OF_SETTYPES;
    for (int i=0;i<number;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(this,tr("Type:"),number,entr);
    ledLength=new stdLineEdit(this,tr("Length:"));
    ledLength->lenText->setText(QString(""));
    ledComment=new stdLineEdit(this,tr("Comment:"),true);
    ledComment->lenText->setText(QString(""));
    grpStatistics=new QGroupBox(tr("Statistics"),this);

    background=new QWidget;
    layout0=new QGridLayout;
    layout0->setMargin(STD_MARGIN);
    HLabels[0]=new QLabel(QString(""),background);
    HLabels[1]=new QLabel(tr("Min"),background);
    HLabels[2]=new QLabel(tr("at"),background);
    HLabels[3]=new QLabel(tr("Max"),background);
    HLabels[4]=new QLabel(tr("at"),background);
    HLabels[5]=new QLabel(tr("Mean"),background);
    HLabels[6]=new QLabel(tr("Stdev"),background);

    VLabels[0]=new QLabel(tr("X"),background);
    VLabels[1]=new QLabel(tr("Y"),background);
    VLabels[2]=new QLabel(tr("Y1"),background);
    VLabels[3]=new QLabel(tr("Y2"),background);
    VLabels[4]=new QLabel(tr("Y3"),background);
    VLabels[5]=new QLabel(tr("Y4"),background);
    layout0->addWidget(HLabels[0],0,0);
    for (int i=0;i<6;i++)//row
    {
        layout0->addWidget(VLabels[i],i+1,0);
        layout0->addWidget(HLabels[1+i],0,i+1);
        for (int j=0;j<6;j++)//Column
        {
            lenStat[i*6+j]=new QLineEdit(QString(""),background);
            layout0->addWidget(lenStat[i*6+j],1+i,1+j);
        }
    }
    background->setLayout(layout0);

    layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    scroll=new QScrollArea(grpStatistics);
    scroll->setWidget(background);
    layout1->addWidget(scroll);
    grpStatistics->setLayout(layout1);

    lblDataSet=new QLabel(tr("Data sets:"),this);
    listDataSets=new uniList(SETLIST,this);
    connect(listDataSets,SIGNAL(new_selection(int)),SLOT(setChanged(int)));
    connect(listDataSets,SIGNAL(clicked(QModelIndex)),SLOT(setChanged(QModelIndex)));

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar,0,0,1,2);
#endif
    layout->addWidget(lblDataSet,1,0,1,2);
    layout->addWidget(listDataSets,2,0,1,2);
    layout->addWidget(selType,3,0);
    layout->addWidget(ledLength,3,1);
    layout->addWidget(ledComment,4,0,1,2);
    layout->addWidget(grpStatistics,5,0,1,2);
    layout->addWidget(buttonGroup,6,0,1,2);

    layout->setRowStretch(0,0);
    layout->setRowStretch(1,0);
    layout->setRowStretch(2,1);
    layout->setRowStretch(3,0);
    layout->setRowStretch(4,0);
    layout->setRowStretch(5,1);
    layout->setRowStretch(6,0);
    setLayout(layout);
    resize(LastSize_FormDataSetProperties);
}

frmDataSetProperties::~frmDataSetProperties()
{
    LastSize_FormDataSetProperties=this->size();
}

void frmDataSetProperties::CreateActions(void)
{
    actClose=new QAction(tr("&Close"),this);
    connect(actClose,SIGNAL(triggered()), this, SLOT(doClose()));
    actHelpOnContext=new QAction(tr("On conte&xt"),this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext,SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpOnSetProp=new QAction(tr("On data &sets"),this);
    connect(actHelpOnSetProp,SIGNAL(triggered()), this, SLOT(doHelpOnSetProp()));
    actKillData=new QAction(tr("Kill D&ata"),this);
    connect(actKillData,SIGNAL(triggered()), this, SLOT(doKillData()));
    actDuplicate=new QAction(tr("&Duplicate"),this);
    connect(actDuplicate,SIGNAL(triggered()), this, SLOT(doDuplicate()));
    actSetAppearance=new QAction(tr("&Set appearance..."),this);
    connect(actSetAppearance,SIGNAL(triggered()), this, SLOT(doSetAppearance()));
    actSetOperations=new QAction(tr("Set &operations..."),this);
    connect(actSetOperations,SIGNAL(triggered()), this, SLOT(doSetOperations()));
    actEditInSpreadsheet=new QAction(tr("In &spreadsheet"),this);
    connect(actEditInSpreadsheet,SIGNAL(triggered()), this, SLOT(doEditInSpreadsheet()));
    actEditInTextEditor=new QAction(tr("In t&ext editor"),this);
    connect(actEditInTextEditor,SIGNAL(triggered()), this, SLOT(doEditInTextEditor()));
    actCreateNewByFormula=new QAction(tr("By &formula"),this);
    connect(actCreateNewByFormula,SIGNAL(triggered()), this, SLOT(doCreateNewByFormula()));
    actCreateNewInSpreadsheet=new QAction(tr("In &spreadsheet"),this);
    connect(actCreateNewInSpreadsheet,SIGNAL(triggered()), this, SLOT(doCreateNewInSpreadsheet()));
    actCreateNewInTextEditor=new QAction(tr("In t&ext editor"),this);
    connect(actCreateNewInTextEditor,SIGNAL(triggered()), this, SLOT(doCreateNewInTextEditor()));
    actCreateNewFromBlockData=new QAction(tr("Form &block data"),this);
    connect(actCreateNewFromBlockData,SIGNAL(triggered()), this, SLOT(doCreateNewFromBlockData()));
}

void frmDataSetProperties::doClear(void)
{
    QString clString("");
    selType->setEnabled(false);
    ledLength->setText(clString);
    ledComment->setText(clString);
    for (int i=0;i<36;i++)
        lenStat[i]->setText(clString);
}

void frmDataSetProperties::setChanged(QModelIndex index)
{
    if (index.isValid())
    {
        setChanged(listDataSets->entries[index.row()]);
    }
}

void frmDataSetProperties::setChanged(int nr)
{
    double *datap;
    int i,j;
    double dmin, dmax;
    int imin, imax;
    double dmean, dsd;
    gno=listDataSets->gr_no;
    sno=nr;
    int ncols = dataset_cols(gno, sno);
    int number_of_sel_sets=-1;
    int * selection=new int[2];
    listDataSets->get_selection(&number_of_sel_sets,&selection);
    if (number_of_sel_sets!=1 || !is_valid_setno(gno,nr))
    {
        doClear();
        ncols=-1;
        return;
    }
    selType->setEnabled(true);
    char buf[1024];
    ledComment->setText(QString(getcomment(gno, sno)));
    //xv_setstr(tui.comment_item, getcomment(gno, setno));
    sprintf(buf, "%d", getsetlength(gno, sno));
    ledLength->setText(QString(buf));
    //xv_setstr(tui.length_item, buf);
    selType->setCurrentIndex(dataset_type(gno, sno));
    //SetOptionChoice(tui.datatype_item, dataset_type(gno, setno));
    for (i = 0; i < MAX_SET_COLS; i++)
    {
        datap = getcol(gno, sno, i);
        minmax(datap, getsetlength(gno, sno), &dmin, &dmax, &imin, &imax);
        stasum(datap, getsetlength(gno, sno), &dmean, &dsd);
        for (j = 0; j < 6; j++)
        {
            if (i < ncols)
            {
                switch (j)
                {
                case 0:
                    sprintf(buf, "%g", dmin);
                    break;
                case 1:
                    sprintf(buf, "%d", imin);
                    break;
                case 2:
                    sprintf(buf, "%g", dmax);
                    break;
                case 3:
                    sprintf(buf, "%d", imax);
                    break;
                case 4:
                    sprintf(buf, "%g", dmean);
                    break;
                case 5:
                    sprintf(buf, "%g", dsd);
                    break;
                default:
                    strcpy(buf, "");
                    break;
                }
                SetDecimalSeparatorToUserValue(buf);
                lenStat[i*6+j]->setText(QString(buf));
                //tui.rows[i][j] = copy_string(tui.rows[i][j], buf);
            }
            else
            {
                lenStat[i*6+j]->setText(QString(""));
                //tui.rows[i][j] = copy_string(tui.rows[i][j], "");
            }
        }
    }

}

void frmDataSetProperties::doKillData(void)
{
    listDataSets->popupMenu1->doKillData();
    int act_sav=undo_active;
    undo_active=FALSE;
    listDataSets->hide();
    listDataSets->show();
    undo_active=act_sav;
    repaint();
}

void frmDataSetProperties::doDuplicate(void)
{
    listDataSets->popupMenu1->doDuplicate();
    int act_sav=undo_active;
    undo_active=FALSE;
    listDataSets->hide();
    listDataSets->show();
    undo_active=act_sav;
    repaint();
}

void frmDataSetProperties::doSetAppearance(void)
{
    bool old_upd;
    old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    if (FormSetAppearance==NULL)
    {
        FormSetAppearance=new frmSetAppearance(this);
    }
    FormSetAppearance->init();
    FormSetAppearance->show();
    FormSetAppearance->raise();
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmDataSetProperties::doSetOperations(void)
{
    if (FormSetOPS==NULL)
    {
        FormSetOPS=new frmSetOperations(this);
    }
    FormSetOPS->init();
    FormSetOPS->show();
    FormSetOPS->raise();
}

void frmDataSetProperties::doHelpOnContext(void)
{
    mainWin->setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmDataSetProperties::doHelpOnSetProp(void)
{
    HelpCB("doc/UsersGuide.html#data-sets");
}

void frmDataSetProperties::doEditInSpreadsheet(void)
{
    listDataSets->popupMenu1->doEditInSpreadSheet();
}

void frmDataSetProperties::doEditInTextEditor(void)
{
    listDataSets->popupMenu1->doEditInTextEditor();
}

void frmDataSetProperties::doCreateNewByFormula(void)
{
    listDataSets->popupMenu1->doCreateByFormula();
}

void frmDataSetProperties::doCreateNewInSpreadsheet(void)
{
    listDataSets->popupMenu1->doCreateInSpreadsheet();
}

void frmDataSetProperties::doCreateNewInTextEditor(void)
{
    listDataSets->popupMenu1->doCreateInTextEditor();
}

void frmDataSetProperties::doCreateNewFromBlockData(void)
{
    listDataSets->popupMenu1->doCreateFromBlockData();
}

void frmDataSetProperties::init(void)
{
    listDataSets->set_graph_number(get_cg(),false);
    //listDataSets->update_number_of_entries();
}

void frmDataSetProperties::doApply(void)
{
    ApplyError=false;
    int error = false;
    int *selset=new int[2], nsets, i, len, setno, type;
    char *s;
    int * gnos;
    int index;

    nsets = GetListChoices(listDataSets, &selset);

    if (nsets < 1) {
        errmsg(tr("No set selected").toLocal8Bit().constData());
        ApplyError=true;
    } else {
        type = GetOptionChoice(selType);
        xv_evalexpri(ledLength, &len);
        if (len < 0)
        {
            errmsg(tr("Negative set length!").toLocal8Bit().constData());
            ApplyError=true;
            error = TRUE;
        }
        s = xv_getstr(ledComment);

        if (error == FALSE)
        {
            gnos=new int[nsets+2];
            for (i=0;i<nsets;i++)
                gnos[i]=get_cg();
            SaveSetStatesPrevious(nsets,gnos,selset,UNDO_COMPLETE);
            index=0;
            for (i = 0; i < nsets; i++)
            {
                setno = selset[i];
                //I do not check for the set comment intentionally!!
                if (type!=dataset_type(get_cg(), setno) || len!=getsetlength(get_cg(), setno)) index++;
                set_dataset_type(get_cg(), setno, type);
                setlength(get_cg(), setno, len);
                setcomment(get_cg(), setno, s);
            }

            if (index>0)
            {
                SetsModified(nsets,gnos,selset,UNDO_COMPLETE);
            }
            update_set_lists(cg);
            mainWin->mainArea->completeRedraw();
            //return RETURN_SUCCESS;
        }
    }
    delete[] selset;
}

void frmDataSetProperties::doClose(void)
{
    hide();
}

void frmDataSetProperties::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

frmSetOperations::frmSetOperations(QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[5];
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Set operations"));
    setWindowIcon(QIcon(*GraceIcon));

    grpSource=new grpSelect(tr("Source"),this);
    grpDestination=new grpSelect(tr("Destination"),this);
    grpDestination->enable_sync(grpSource->listSet);

    number=4;
    entr[0]=tr("Copy");
    entr[1]=tr("Move");
    entr[2]=tr("Swap");
    entr[3]=tr("Copy Legend");
    selType=new StdSelector(this,tr("Type of operation:"),number,entr);
    selType->entryValues[0]=OPTYPE_COPY;
    selType->entryValues[1]=OPTYPE_MOVE;
    selType->entryValues[2]=OPTYPE_SWAP;
    selType->entryValues[3]=OPTYPE_COPY_LEGEND;

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);

    layout->addWidget(grpSource,0,0);
    layout->addWidget(grpDestination,0,1);
    layout->addWidget(selType,1,0,1,2);
    layout->addWidget(buttonGroup,2,0,1,2);
    setLayout(layout);
    resize(LastSize_FormSetOperations);
}

frmSetOperations::~frmSetOperations()
{
    LastSize_FormSetOperations=this->size();
}

void frmSetOperations::init(void)
{
    grpSource->update_number_of_entries();
    grpDestination->update_number_of_entries();
    int nr_sel=1;
    int sel=get_cg();
    grpSource->listGraph->set_new_selection(nr_sel,&sel);
    grpSource->listSet->set_graph_number(sel,false);
    grpSource->listSet->update_number_of_entries();
    grpDestination->listGraph->set_new_selection(nr_sel,&sel);
    grpDestination->listSet->set_graph_number(sel,false);
    grpDestination->listSet->update_number_of_entries();
}

void frmSetOperations::doApply(void)
{
    ApplyError=false;
    int optype, error;
    int i, g1_ok, g2_ok, ns1, ns2, gno1, gno2, setno2;
    int *svalues1=new int[2];
    int *svalues2=new int[2];
    char dummy[128];

    optype = selType->currentValue();
    
    grpSource->listGraph->get_selection(&ns1,&svalues1);
    grpDestination->listGraph->get_selection(&ns2,&svalues2);
    gno1=gno2=0;
    if (ns1!=1)
    {
        g1_ok=RETURN_FAILURE;
    }
    else
    {
        g1_ok=RETURN_SUCCESS;
        gno1=svalues1[0];
    }
    if (ns2!=1)
    {
        g2_ok=RETURN_FAILURE;
    }
    else
    {
        g2_ok=RETURN_SUCCESS;
        gno2=svalues2[0];
    }
    grpSource->listSet->get_selection(&ns1,&svalues1);
    grpDestination->listSet->get_selection(&ns2,&svalues2);

    error = FALSE;
    if (g1_ok == RETURN_FAILURE || g2_ok == RETURN_FAILURE) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Please select single source and destination graphs").toLocal8Bit().constData());
    } else if (ns1 == 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("No source sets selected").toLocal8Bit().constData());
    } else if (ns2 == 0 && (optype == OPTYPE_SWAP || optype == OPTYPE_COPY_LEGEND)) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("No destination sets selected").toLocal8Bit().constData());
    } else if (ns1 != ns2 && (optype == OPTYPE_SWAP || optype == OPTYPE_COPY_LEGEND || ns2 != 0)) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Different number of source and destination sets").toLocal8Bit().constData());
    } else if (gno1 == gno2 && ns2 == 0 && optype == OPTYPE_MOVE) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Can't move a set to itself").toLocal8Bit().constData());
    } else {
        int * gnos=new int[ns1+ns2+2];
        int * snos=new int[ns1+ns2+2];
        int index=0;
        if (ns1==1)
        {
            sprintf(dummy," [G%d.S%d]",gno1,svalues1[0]);
        }
        if (optype!=OPTYPE_MOVE)
        {//save only the states in the target area
            for (i=0;i<ns2;i++)
                gnos[i]=gno2;
            if (optype==OPTYPE_COPY_LEGEND)
                SaveSetStatesPrevious(ns2,gnos,svalues2,UNDO_APPEARANCE);
            else
                SaveSetStatesPrevious(ns2,gnos,svalues2,UNDO_COMPLETE);
        }
        else
        {//save origin and target
            for (i=0;i<ns1;i++)
            {
                gnos[i]=gno1;
                snos[i]=svalues1[i];
            }
            for (i=0;i<ns2;i++)
            {
                gnos[i+ns1]=gno2;
                snos[i+ns1]=svalues2[i];
            }
            SaveSetStatesPrevious(ns2+ns1,gnos,snos,UNDO_COMPLETE);
        }
        for (i = 0; i < ns1; i++) {
            switch (optype) {
            case OPTYPE_SWAP:
                UndoSwapSets(gno1, svalues1[i], gno2, svalues2[i]);
                if (do_swapset(gno1, svalues1[i], gno2, svalues2[i])!= RETURN_SUCCESS) {
                    error = TRUE;
                }
                break;
            case OPTYPE_COPY:
                if (ns2 == 0) {
                    setno2 = nextset(gno2);
                } else {
                    setno2 = svalues2[i];
                }
                snos[index++]=setno2;
                if (do_copyset(gno1, svalues1[i], gno2, setno2)!= RETURN_SUCCESS) {
                    error = TRUE;
                }
                break;
            case OPTYPE_MOVE:
                if (ns2 == 0) {
                    setno2 = nextset(gno2);
                } else {
                    setno2 = svalues2[i];
                }
                snos[index++]=setno2;
                if (do_moveset(gno1, svalues1[i], gno2, setno2)!= RETURN_SUCCESS) {
                    error = TRUE;
                }
                break;
            case OPTYPE_COPY_LEGEND:
                strcpy(g[gno2].p[svalues2[i]].lstr,g[gno1].p[svalues1[i]].lstr);
                strcpy(g[gno2].p[svalues2[i]].orig_lstr,g[gno1].p[svalues1[i]].orig_lstr);
                strcpy(g[gno2].p[svalues2[i]].comments,g[gno1].p[svalues1[i]].comments);
                strcpy(g[gno2].p[svalues2[i]].orig_comments,g[gno1].p[svalues1[i]].orig_comments);
                break;
            }
        }
        if (optype==OPTYPE_COPY || optype==OPTYPE_MOVE)
        {
            for (i=0;i<index;i++)
                gnos[i]=gno2;
            SetsModified(index,gnos,snos,UNDO_COMPLETE);
            if (optype==OPTYPE_COPY)
            {
                if (ns1==1)
                {
                    addAditionalDescriptionToLastNode(-1,QObject::tr("Set coppied")+QString(dummy),QString(),-1);
                }
                else
                {
                    addAditionalDescriptionToLastNode(-1,QObject::tr("Sets coppied"),QString(),-1);
                }
            }
            else
            {
                if (ns1==1)
                {
                    addAditionalDescriptionToLastNode(-1,QObject::tr("Set moved")+QString(dummy),QString(),-1);
                }
                else
                {
                    addAditionalDescriptionToLastNode(-1,QObject::tr("Sets moved"),QString(),-1);
                }
            }
        }
        else if (optype==OPTYPE_COPY_LEGEND)
        {
            SetsModified(ns2,gnos,svalues2,UNDO_APPEARANCE);
            addAditionalDescriptionToLastNode(-1,QObject::tr("Legend coppied")+QString(dummy),QString(),-1);
        }
        delete[] gnos;
        delete[] snos;
    }
    delete[] svalues1;
    delete[] svalues2;
    if (error == FALSE)
    {
        grpSource->update_number_of_entries();
        grpDestination->update_number_of_entries();
        mainWin->mainArea->completeRedraw();
        //        return RETURN_SUCCESS;
    } /*else {
        return RETURN_FAILURE;
    }*/
}

void frmSetOperations::doClose(void)
{
    hide();
}

void frmSetOperations::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

frmFeatureExtract::frmFeatureExtract(QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[32];
    int vals[32];
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Feature extraction"));
    setWindowIcon(QIcon(*GraceIcon));

    lblSourceGraph=new QLabel(tr("Features from graph:"),this);
    listSourceGraph=new uniList(GRAPHLIST,this);
    lblResultGraph=new QLabel(tr("Results to graph:"),this);
    listResultGraph=new uniList(GRAPHLIST,this);
    lblAbscissaGraph=new QLabel(tr("Abscissa from graph:"),this);
    listAbscissaGraph=new uniList(GRAPHLIST,this);
    lblSet=new QLabel(tr("set:"),this);
    listSet=new uniList(SETLIST,this);

    buttonGroup=new stdButtonGroup(this,false,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    number=28;
    entr[0]=tr("Y minimum");
    entr[1]=tr("Y maximum");
    entr[2]=tr("Y average");
    entr[3]=tr("Y std. dev.");
    entr[4]=tr("Y median");
    entr[5]=tr("X minimum");
    entr[6]=tr("X maximum");
    entr[7]=tr("X average");
    entr[8]=tr("X std. dev.");
    entr[9]=tr("X median");
    entr[10]=tr("Frequency");
    entr[11]=tr("Period");
    entr[12]=tr("Zero crossing");
    entr[13]=tr("Rise time");
    entr[14]=tr("Fall time");
    entr[15]=tr("Slope");
    entr[16]=tr("Y intercept");
    entr[17]=tr("Set length");
    entr[18]=tr("Half maximal width");
    entr[19]=tr("Barycenter X");
    entr[20]=tr("Barycenter Y");
    entr[21]=tr("X(Y max)");
    entr[22]=tr("Y(X max)");
    entr[23]=tr("Integral");
    entr[24]=tr("Y-Value crossing");
    entr[25]=tr("X-Value crossing");
    entr[26]=tr("X(Y min)");
    entr[27]=tr("Y(X min)");

    vals[0]=FEATURE_Y_MIN;
    vals[1]=FEATURE_Y_MAX;
    vals[2]=FEATURE_Y_AVG;
    vals[3]=FEATURE_Y_STD_DEV;
    vals[4]=FEATURE_Y_MEDIAN;
    vals[5]=FEATURE_X_MIN;
    vals[6]=FEATURE_X_MAX;
    vals[7]=FEATURE_X_AVG;
    vals[8]=FEATURE_X_STD_DEV;
    vals[9]=FEATURE_X_MEDIAN;
    vals[10]=FEATURE_FREQUENCY;
    vals[11]=FEATURE_PERIOD;
    vals[12]=FEATURE_ZERO_CROSSING;
    vals[13]=FEATURE_RISE_TIME;
    vals[14]=FEATURE_FALL_TIME;
    vals[15]=FEATURE_SLOPE;
    vals[16]=FEATURE_Y_INTERCEPT;
    vals[17]=FEATURE_SET_LENGTH;
    vals[18]=FEATURE_HALF_MAX_WIDTH;
    vals[19]=FEATURE_BARYCENTER_X;
    vals[20]=FEATURE_BARYCENTER_Y;
    vals[21]=FEATURE_X_OF_YMAX;
    vals[22]=FEATURE_Y_OF_XMAX;
    vals[23]=FEATURE_INTEGRAL;
    vals[24]=FEATURE_VALUE_CROSSING;
    vals[25]=FEATURE_VALUE_CROSSING2;
    vals[26]=FEATURE_X_OF_YMIN;
    vals[27]=FEATURE_Y_OF_XMIN;

    selFeature=new StdSelector(this,tr("Feature:"),number,entr);
    selFeature->setValues(vals);
    connect(selFeature->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(FeatureChanged(int)));
    ledValue=new stdLineEdit(this,tr("Value:"),false);
    //ledValue->setText(QString("0.0"));
    ledValue->setDoubleValue("%.1f",0.0);
    ledValue->setVisible(false);
    number=4;
    entr[0]=tr("Index");
    entr[1]=tr("Legends");
    entr[2]=tr("X from Set");
    entr[3]=tr("Y from Set");
    selXValue=new StdSelector(this,tr("X values from:"),number,entr);
    connect(selXValue->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(XValueChanged(int)));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(lblSourceGraph);
    layout->addWidget(listSourceGraph);
    layout->addWidget(lblResultGraph);
    layout->addWidget(listResultGraph);
    layout->addWidget(selFeature);
    layout->addWidget(ledValue);
    layout->addWidget(selXValue);
    layout->addWidget(lblAbscissaGraph);
    layout->addWidget(listAbscissaGraph);
    layout->addWidget(lblSet);
    layout->addWidget(listSet);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    lblAbscissaGraph->setEnabled(FALSE);
    listAbscissaGraph->setEnabled(FALSE);
    lblSet->setEnabled(FALSE);
    listSet->setEnabled(FALSE);
    resize(LastSize_FormFeatureExtraction);
}

frmFeatureExtract::~frmFeatureExtract()
{
    LastSize_FormFeatureExtraction=this->size();
}

void frmFeatureExtract::init(void)
{
    listSourceGraph->update_number_of_entries();
    listResultGraph->update_number_of_entries();
    listAbscissaGraph->update_number_of_entries();

    int nr_sel=1;
    int sel=get_cg();
    listSourceGraph->set_new_selection(nr_sel,&sel);
    listResultGraph->set_new_selection(nr_sel,&sel);
    listAbscissaGraph->set_new_selection(nr_sel,&sel);
    listSet->set_graph_number(sel,true);
    //listSet->update_number_of_entries();
    ledValue->ReplaceNumberContents();
}

void frmFeatureExtract::FeatureChanged(int i)
{
    (void)i;
    if (selFeature->currentValue()==FEATURE_VALUE_CROSSING)
    {
        ledValue->setVisible(true);
        ledValue->lblText->setText(tr("Y-Value:"));
    }
    else if (selFeature->currentValue()==FEATURE_VALUE_CROSSING2)
    {
        ledValue->setVisible(true);
        ledValue->lblText->setText(tr("X-Value:"));
    }
    else
    {
        ledValue->setVisible(false);
    }
}

void frmFeatureExtract::XValueChanged(int i)
{
    if (i == 2 || i == 3)
    {
        lblAbscissaGraph->setEnabled(TRUE);
        listAbscissaGraph->setEnabled(TRUE);
        lblSet->setEnabled(TRUE);
        listSet->setEnabled(TRUE);
    }
    else
    {
        lblAbscissaGraph->setEnabled(FALSE);
        listAbscissaGraph->setEnabled(FALSE);
        lblSet->setEnabled(FALSE);
        listSet->setEnabled(FALSE);
    }
}

void frmFeatureExtract::doClose(void)
{
    hide();
}

void frmFeatureExtract::doAccept(void)
{
    int gfrom, gto, feature, abs_graph = -1, abs_set = -1, abs_src;
    int n_sel,*sel=new int[2];

    feature = selFeature->currentValue();//GetOptionChoice(ui->feature_item);
    //GetSingleListChoice(ui->tograph, &gto);
    listSourceGraph->get_selection(&n_sel,&sel);
    if (n_sel<=0)
    {gfrom=get_cg();}
    else
    {gfrom=sel[0];}
    listResultGraph->get_selection(&n_sel,&sel);
    if (n_sel<=0)
    {gto=-1;}
    else
    {gto=sel[0];}
        if( !is_valid_gno(gto) )
        gto = get_cg();
    abs_src =selXValue->currentIndex();// (int) GetChoice(ui->xval_item);
    if( abs_src ==2 || abs_src==3 )
    {
        listSet->get_selection(&n_sel,&sel);
        if (n_sel<=0)
        {abs_set=-1;}
        else
        {abs_set=sel[0];}
        //abs_set = GetSelectedSet(ui->absic_set);
        listAbscissaGraph->get_selection(&n_sel,&sel);
        if (n_sel<=0)
        {abs_graph=get_cg();}
        else
        {abs_graph=sel[0];}
        //GetSingleListChoice(ui->absic_graph, &abs_graph);
    }
    new_set_no=-1;
    fext_routine(gfrom, gto, feature, abs_src, abs_set, abs_graph );

    ///Undo-Stuff
    int gnos[2]={gto,gto};
    int snos[2]={new_set_no,new_set_no};
    SetsCreated(1,gnos,snos,UNDO_COMPLETE);
    addAditionalDescriptionToLastNode(-1,QObject::tr("Feature extraction"),QString());

    update_set_lists(gto);
    mainWin->mainArea->completeRedraw();
    listResultGraph->update_number_of_entries();
    listAbscissaGraph->update_number_of_entries();
    listSet->update_number_of_entries();
    delete[] sel;
}

void frmFeatureExtract::fext_routine(int gfrom, int gto, int feature, int abs_src, int abs_set, int abs_graph )
{
    int i, cs, ns, ncurves, extract_err;
    double datum, dummy, *absy;
    char tbuf[1024];
    float *abscissa;

    abscissa = (float*)xmalloc(number_of_sets(gfrom)*sizeof(float));

    if( !is_graph_active( gto )	){
        FormConsole->errwin(tr("Graph for results must be active").toLocal8Bit().constData());
        xfree( abscissa );
        return;
    }
    if( (new_set_no=ns=nextset( gto ) )== -1 ) {
        FormConsole->errwin(tr("Choose a new graph or kill sets!").toLocal8Bit().constData());
        xfree( abscissa );
        return;
    }
    ncurves = nactive(gfrom);
    //cout << "gto=" << gto << " feature=" << feature << " abs_src=" << abs_src << " abs_set=" << abs_set << " abs_graph=" << abs_graph << " ncurves=" << ncurves << endl;
    switch( abs_src ) {
    case 0:		/* use index */
        for( i=0; i<ncurves; i++ )
            abscissa[i] = i;
        break;
    case 1:		/* use legend label */
        cs = 0;
        for( i=0; i<ncurves; i++ ){
            while( !is_set_active( gfrom, cs ) )
                cs++;
            if(!sscanf( get_legend_string(gfrom, cs), "%f", &abscissa[i]))
                break;
            cs++;
        }
        if( i != ncurves ) {
            FormConsole->errwin(tr("Bad legend label").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        break;
    case 2:     /* use X from set */
        if( !is_set_active( abs_graph, abs_set ) ){
            FormConsole->errwin(tr("Abscissa set not active").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        if( getsetlength( abs_graph, abs_set ) < ncurves ) {
            FormConsole->errwin(tr("Not enough points in set").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        absy = getx( abs_graph, abs_set );
        for( i=0; i<ncurves; i++ )
            abscissa[i] = absy[i];
        break;
    case 3:     /* use Y from set */
        if( !is_set_active( abs_graph, abs_set ) ){
            FormConsole->errwin(tr("Abscissa set not active").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        if( getsetlength( abs_graph, abs_set ) < ncurves ) {
            FormConsole->errwin(tr("Not enough points in set").toLocal8Bit().constData());
            xfree( abscissa );
            return;
        }
        absy = gety( abs_graph, abs_set );
        for( i=0; i<ncurves; i++ )
            abscissa[i] = absy[i];
        break;
    }

    cs = 0;
    tbuf[0] = '\0';

    for( i=0; i<ncurves; i++ ) {
        while( !is_set_active( gfrom, cs ) )
            cs++;
        extract_err = 0;

            if (feature==FEATURE_VALUE_CROSSING || feature==FEATURE_VALUE_CROSSING2)//a value is asked
            {
            set_parser_setno(gfrom, cs);
            int answer=xv_evalexpr(ledValue,&dummy);
                if (answer==RETURN_FAILURE)
                {
                strcpy(tbuf,tr("Unable to evaluate expression ").toLocal8Bit().constData());
                strcat(tbuf,ledValue->text().toLocal8Bit().constData());
                FormConsole->errwin(tbuf);
                xfree( abscissa );
                return;
                }
            datum=dummy;
            }

        extract_err=extract_single_feature(feature,gfrom,cs,&datum);

        if( !extract_err )
            add_point(gto, ns, abscissa[i], datum);
        cs++;
    }

    /* set comment */
    switch( feature ) {
    case 0:			/* Y minimum */
        sprintf(tbuf,"Y minima of graph %d",gfrom);
        break;
    case 1: 		/* Y maximum */
        sprintf(tbuf,"Y maxima of graph %d",gfrom);
        break;
    case 2: 		/* Y mean    */
        sprintf(tbuf,"Y means of graph %d",gfrom);
        break;
    case 3:			/* Y std dev */
        sprintf(tbuf,"Y std. dev.'s of graph %d",gfrom);
        break;
    case 4:			/* Y median  */
        sprintf(tbuf,"Y medians of graph %d",gfrom);
        break;
    case 5:			/* X minimum */
        sprintf(tbuf,"X minima of graph %d",gfrom);
        break;
    case 6: 		/* X maximum */
        sprintf(tbuf,"X maxima of graph %d",gfrom);
        break;
    case 7: 		/* X mean    */
        sprintf(tbuf,"X means of graph %d",gfrom);
        break;
    case 8:			/* X std dev */
        sprintf(tbuf,"X std. dev.'s of graph %d",gfrom);
        break;
    case 9:			/* X median  */
        sprintf(tbuf,"X medians of graph %d",gfrom);
        break;
    case 10: 		/* frequency and period */
        sprintf(tbuf,"frequencies of graph %d",gfrom);
        break;
    case 11:
        sprintf(tbuf,"periods of graph %d",gfrom);
        break;
    case 12:		/* first zero crossing */
        sprintf(tbuf,"zero crossings of graph %d",gfrom);
        break;
    case 13:		/* rise time */
        sprintf(tbuf,"rise times of graph %d",gfrom);
        break;
    case 14: 		/* fall time */
        sprintf(tbuf,"fall times of graph %d",gfrom);
        break;
    case 15: 		/* slopes     */
        sprintf(tbuf,"slopes of graph %d",gfrom);
        break;
    case 16: 		/* Y intercepts */
        sprintf(tbuf,"Y intercepts of graph %d",gfrom);
        break;
    case 17: 		/* set lengths */
        sprintf(tbuf,"set lengths of graph %d",gfrom);
        break;
    case 18: 		/* 1/2 maximal widths */
        sprintf(tbuf,"half maximal widths of graph %d",gfrom);
        break;
    case 19: 		/* barycenter X */
        sprintf(tbuf,"X barycenters of graph %d",gfrom);
        break;
    case 20: 		/* barycenter Y */
        sprintf(tbuf,"Y barycenters of graph %d",gfrom);
        break;
    case 21:		/* X of maximum Y */
        sprintf(tbuf,"X positions of maximum Y's of graph %d",gfrom);
        break;
    case 22:		/* Y of maximum X */
        sprintf(tbuf,"Y positions of maximum X's of graph %d",gfrom);
        break;
    case 23:		/* integral */
        sprintf(tbuf,"integrals of sets of graph %d",gfrom);
        break;
    case 24:		/* first crossing of specified y-value */
        sprintf(tbuf,"first y-crossing of %g of graph %d",dummy,gfrom);
        break;
    case 25:		/* first crossing of specified x-value */
        sprintf(tbuf,"first x-crossing of %g of graph %d",dummy,gfrom);
        break;
    case 26:		/* X of minimum Y */
        sprintf(tbuf,"X positions of minimum Y's of graph %d",gfrom);
        break;
    case 27:		/* X of minimum Y */
        sprintf(tbuf,"Y positions of minimum X's of graph %d",gfrom);
        break;
    }
    set_set_hidden(gto, ns, FALSE);
    setcomment( gto, ns, tbuf );
    xfree( abscissa );
}

frmAbout::frmAbout(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: About"));
    setWindowIcon(QIcon(*GraceIcon));

    char buf[1024];
    int index=0,s_index,e_index;

    grpGrace=new QGroupBox(QString(""),this);
    layout0=new QVBoxLayout();
    layout0->setMargin(STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    lblInfo[index]=new QLabel(QString(bi_version_string())+QString(" / QtGrace ") + QString(QTGRACE_VERSION_STRING),grpGrace);
    layout0->addWidget(lblInfo[index++]);
#ifdef DEBUG
    lblInfo[index]=new QLabel(tr("Debugging is enabled"),grpGrace);
    layout0->addWidget(lblInfo[index++]);
#endif
    grpGrace->setLayout(layout0);
    s_index=index;
    grpLegal=new QGroupBox(tr("Legal stuff"),this);
    layout1=new QVBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    lblInfo[index++]=new QLabel(QString(bi_version_string())+QString(":"),grpLegal);
    lblInfo[index++]=new QLabel(tr("      Copyright (c) 1991-1995 Paul J Turner"),grpLegal);
    lblInfo[index++]=new QLabel(tr("      Copyright (c) 1996-2008 Grace Development Team"),grpLegal);
    lblInfo[index++]=new QLabel(tr("      Maintained by Evgeny Stambulchik"),grpLegal);
    lblInfo[index++]=new QLabel(tr("QtGrace:"),grpLegal);
    lblInfo[index++]=new QLabel(tr("      Copyright (c) 2008-2017 Andreas Winter"),grpLegal);
    lblInfo[index++]=new QLabel(tr("      Additional code by Vadim Engelson and Nimalendiran Kailasanathan, Wolfram MathCore AB"),grpLegal);
    lblInfo[index++]=new QLabel(tr("All rights reserved"),grpLegal);
    lblInfo[index++]=new QLabel(tr("The program is distributed under the terms of the GNU General Public License"),grpLegal);
    e_index=index;
    for (int i=s_index;i<e_index;i++)
        layout1->addWidget(lblInfo[i]);

    grpLegal->setLayout(layout1);
    s_index=index;
    grpThirdParty=new QGroupBox(tr("Third party copyright"),this);
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    /*lblInfo[index++]=new QLabel(QString("Tab widget, Copyright (c) 1997 Pralay Dakua"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("Xbae widget,"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("      Copyright (c) 1991, 1992 Bell Communications Research, Inc. (Bellcore)"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("      Copyright (c) 1995-1999 Andrew Lister"),grpThirdParty);*/
    lblInfo[index++]=new QLabel(QString("FFTW3 Library,"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("      Copyright (c) 2003, 2007-14 Matteo Frigo"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("      Copyright (c) 2003, 2007-14 Massachusetts Institute of Technology"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("Haru Free PDF Library,"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("      Copyright (c) 1999-2006 Takeshi Kanno"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("      Copyright (c) 2007-2009 Antony Dovgal"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("Raster driver based on the GD-1.3 library,"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("      Portions copyright (c) 1994-1998 Cold Spring Harbor Laboratory"),grpThirdParty);
    lblInfo[index++]=new QLabel(QString("      Portions copyright (c) 1996-1998 Boutell.Com, Inc"),grpThirdParty);

    e_index=index;
    for (int i=s_index;i<e_index;i++)
        layout2->addWidget(lblInfo[i]);

#ifdef HAVE_LIBPDF
    lblInfo[index]=new QLabel(QString("PDFlib library, Copyright (c) 1997-2002 Thomas Merz");
    layout2->addWidget(lblInfo[index++]);
#endif

    grpThirdParty->setLayout(layout2);
    s_index=index;
    grpBuildInfo=new QGroupBox(tr("Build info"),this);
    layout3=new QVBoxLayout;
    layout3->setMargin(STD_MARGIN);
    layout3->setSpacing(STD_SPACING);
    sprintf(buf, "Host: %s", bi_system());
    lblInfo[index++]=new QLabel(QString(buf),grpBuildInfo);
    sprintf(buf, "Time: %s %s", bi_date(), __TIME__);
    lblInfo[index++]=new QLabel(QString(buf),grpBuildInfo);
    sprintf(buf, "GUI toolkit: %s ", bi_gui());
    lblInfo[index++]=new QLabel(QString(buf),grpBuildInfo);
    /*
    sprintf(buf, "Xbae version: %s ", bi_gui_xbae());
    lblInfo[19]=new QLabel(QString(buf),grpBuildInfo);
    */
    sprintf(buf, "Qt version: %s ", QT_VERSION_STR);
    lblInfo[index++]=new QLabel(QString(buf),grpBuildInfo);
    sprintf(buf, "T1lib: %s ", T1_GetLibIdent());
    lblInfo[index++]=new QLabel(QString(buf),grpBuildInfo);
    e_index=index;
    for (int i=s_index;i<e_index;i++)
        layout3->addWidget(lblInfo[i]);

#ifdef HAVE_LIBPNG
    sprintf(buf, "libpng: %s ", bi_pnglib());
    lblInfo[index]=new QLabel(QString(buf),grpBuildInfo);
    layout3->addWidget(lblInfo[index++]);
#endif
#ifdef HAVE_LIBJPEG
    sprintf(buf, "libjpeg: %s ", bi_libjpeg());
    lblInfo[index]=new QLabel(QString(buf),grpBuildInfo);
    layout3->addWidget(lblInfo[index++]);
#endif
#ifdef HAVE_LIBPDF
    sprintf(buf, "PDFlib: %s ", bi_libpdf());
    lblInfo[index]=new QLabel(QString(buf),grpBuildInfo);
    layout3->addWidget(lblInfo[index++]);
#endif

    grpBuildInfo->setLayout(layout3);

    grpHomePage=new QGroupBox(tr("Home page"),this);
    layout4=new QVBoxLayout;
    layout4->setMargin(0);
    layout4->setSpacing(0);
    cmdIAdr=new QPushButton(QString("http://plasma-gate.weizmann.ac.il/Grace/"),grpHomePage);
    cmdIAdr->setFlat(true);
    connect(cmdIAdr,SIGNAL(clicked()),SLOT(doShowHomepage()));
    cmdIAdr2=new QPushButton(QString("http://sourceforge.net/projects/qtgrace"),grpHomePage);
    cmdIAdr2->setFlat(true);
    connect(cmdIAdr2,SIGNAL(clicked()),SLOT(doShowHomepage2()));
    cmdIAdr3=new QPushButton(QString("http://www.qt.io/"),grpHomePage);
    cmdIAdr3->setFlat(true);
    connect(cmdIAdr3,SIGNAL(clicked()),SLOT(doShowHomepage3()));
    layout4->addWidget(cmdIAdr);
    layout4->addWidget(cmdIAdr2);
    layout4->addWidget(cmdIAdr3);
    grpHomePage->setLayout(layout4);

    cmdClose=new QPushButton(tr("Close"),this);
    connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpGrace);
    layout->addWidget(grpLegal);
    layout->addWidget(grpThirdParty);
    layout->addWidget(grpBuildInfo);
    layout->addWidget(grpHomePage);
    layout->addWidget(cmdClose);
    setLayout(layout);
    resize(LastSize_FormAbout);
}

frmAbout::~frmAbout()
{
    LastSize_FormAbout=this->size();
}

void frmAbout::doShowHomepage(void)
{
    HelpCB("http://plasma-gate.weizmann.ac.il/Grace/");
}

void frmAbout::doShowHomepage2(void)
{
    HelpCB("http://sourceforge.net/projects/qtgrace");
}

void frmAbout::doShowHomepage3(void)
{
    HelpCB("http://www.qt.io/");
}

void frmAbout::doClose(void)
{
    hide();
}

frmAgrInfos::frmAgrInfos(QWidget * parent):QDialog(parent)
{
setWindowTitle(QString("QtGrace: ")+QObject::tr("Import set(s) from agr-file"));
lblFilename=new QLabel(tr("Filename="),this);
lblFilenText=new QLabel(QString(""),this);
lblDescription=new QLabel(tr("Project description:"),this);
lblDescrText=new QLabel(QString(""),this);
lblDescrText->setWordWrap(true);

lblFilenText->setFrameStyle(QFrame::Panel | QFrame::Sunken);
lblDescrText->setFrameStyle(QFrame::Panel | QFrame::Sunken);
QPalette pal=lblFilenText->palette();
pal.setColor(QPalette::Background,Qt::white);
lblFilenText->setPalette(pal);
lblFilenText->setAutoFillBackground(true);
lblDescrText->setPalette(pal);
lblDescrText->setAutoFillBackground(true);

int nr=2;
QString * entries=new QString[8];
entries[0]=QString("G0");
entries[1]=QString("G1");
selTargetGno=new StdSelector(this,tr("Target graph:"),nr,entries);
nr=4;
entries[0]=tr("manual");
entries[1]=tr("none");
entries[2]=tr("all");
entries[3]=tr("invert");
selSelection=new StdSelector(this,tr("Selection:"),nr,entries);
connect(selSelection,SIGNAL(currentIndexChanged(int)),SLOT(changeSelection(int)));
delete[] entries;

scroll=new QScrollArea;
empty=new QWidget();
layout0=new QGridLayout;
layout0->setMargin(0);
layout0->setSpacing(0);

lblTitle=new QLabel*[5];
lblTitle[0]=new QLabel(tr("Import"));
lblTitle[1]=new QLabel(tr("Set-ID"));
lblTitle[2]=new QLabel(tr("Type"));
lblTitle[3]=new QLabel(tr("Legend"));
lblTitle[4]=new QLabel(tr("Comment"));
for (int i=0;i<5;i++)
{
layout0->addWidget(lblTitle[i],0,i,1,1);
lblTitle[i]->setMaximumHeight(20);
lblTitle[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
}
lblTitle[0]->setMaximumWidth(50);
empty->setGeometry(0,0,600,35);
empty->setLayout(layout0);
scroll->setWidget(empty);

allocated_controls=0;
chkImport=NULL;
lblID=NULL;
lblLegend=NULL;
lblComment=NULL;

cmdImport=new QPushButton(tr("Import set(s)"),this);
//connect(cmdImport,SIGNAL(clicked()),SLOT(doImport()));
cmdImport->hide();
buttons=new stdButtonGroup(this);
buttons->cmdApply->setText(tr("Open agr-file"));
buttons->cmdAccept->setText(tr("Import set(s)"));
buttons->cmdClose->setText(tr("Cancel"));
connect(buttons->cmdApply,SIGNAL(clicked()),SLOT(doOpenAgr()));
connect(buttons->cmdAccept,SIGNAL(clicked()),SLOT(doImportAgr()));
connect(buttons->cmdClose,SIGNAL(clicked()),SLOT(doCancel()));

cmdShowAgrInfo=new QPushButton(tr("Show set import options >>>"),this);
cmdShowAgrInfo->hide();
//connect(cmdShowAgrInfo,SIGNAL(clicked()),SLOT(toggleShowAgrInfo()));

shButtons=shFilename=true;

layout1=new QGridLayout;
layout1->setMargin(STD_MARGIN);
layout1->setSpacing(STD_SPACING);

layout1->addWidget(lblFilename,0,0,1,1);
layout1->addWidget(lblFilenText,0,1,1,2);
layout1->addWidget(lblDescription,1,0,1,3);
layout1->addWidget(lblDescrText,2,0,1,3);
layout1->addWidget(cmdShowAgrInfo,3,0,1,3);
layout1->addWidget(scroll,4,0,3,3);
layout1->addWidget(selSelection,7,0,1,1);
layout1->addWidget(selTargetGno,7,1,1,1);
layout1->addWidget(cmdImport,7,2,1,1);

layout1->addWidget(buttons,8,0,1,3);
for (int i=0;i<9;i++)
{
layout1->setRowStretch(i,0);
}
//layout1->setRowStretch(3,2);
layout1->setRowStretch(5,2);

setLayout(layout1);
init_agr_file_info(info);
setMinimumHeight(200);
resize(LastSize_Form_AgrInfo);
}

frmAgrInfos::~frmAgrInfos()
{
    LastSize_Form_AgrInfo=this->size();
}

void frmAgrInfos::setVisibleItems(bool showButtons,bool showFilename)
{
shButtons=showButtons;
shFilename=showFilename;
    lblFilename->setVisible(shFilename);
    lblFilenText->setVisible(shFilename);
    buttons->setVisible(shFilename);
/*
layout1->setRowMinimumHeight(0,0);
layout1->setRowMinimumHeight(8,0);
layout1->setRowStretch(0,0);
layout1->setRowStretch(8,0);
*/
if (showButtons==false) layout1->removeWidget(buttons);
if (showFilename==false)
{
layout1->removeWidget(lblFilename);
layout1->removeWidget(lblFilenText);
}

}

void frmAgrInfos::setInfoVisible(bool v)
{
    if (v==false)
    {
    cmdShowAgrInfo->setText(tr("Show set import options >>>"));
    cmdImport->setVisible(false);
    selSelection->setVisible(false);
    selTargetGno->setVisible(false);
    scroll->setVisible(false);

    layout1->removeWidget(scroll);
    layout1->removeWidget(selSelection);
    layout1->removeWidget(selTargetGno);
    layout1->removeWidget(cmdImport);
    for (int i=4;i<9;i++) layout1->setRowStretch(i,0);
    }
    else
    {
    cmdShowAgrInfo->setText(tr("Hide set import options <<<"));
    cmdImport->setVisible(true);
    selSelection->setVisible(true);
    selTargetGno->setVisible(true);
    scroll->setVisible(true);

    layout1->addWidget(scroll,4,0,3,3);
    layout1->addWidget(selSelection,7,0,1,1);
    layout1->addWidget(selTargetGno,7,1,1,1);
    layout1->addWidget(cmdImport,7,2,1,1);
    }

    layout1->update();
}
void frmAgrInfos::toggleShowAgrInfo(void)
{
    setInfoVisible(!cmdImport->isVisible());
}

void frmAgrInfos::init(char * filen)//initialize the display (not the target graph)
{
int nr=number_of_graphs();
QString * entr=new QString[nr+2];
int * vals=new int[nr+2];
char dummy[32];
sets_imported=agrs_opened=0;
for (int i=0;i<nr;i++)
{
sprintf(dummy,"G%d",i);
entr[i]=QString(dummy);
vals[i]=i;
}
selTargetGno->setNewEntries(nr,entr,vals);
delete[] entr;
delete[] vals;
read_header_from_agr(filen,info);
lblFilenText->setText(QString::fromLocal8Bit(filen));
lblDescrText->setText(info.project_description);
if (allocated_controls>0)
{
    for (int i=0;i<allocated_controls;i++)
    {
    layout0->removeWidget(chkImport[i]);
    delete chkImport[i];
    layout0->removeWidget(lblID[i]);
    delete lblID[i];
    layout0->removeWidget(lblLegend[i]);
    delete lblLegend[i];
    layout0->removeWidget(lblComment[i]);
    delete lblComment[i];
    layout0->removeWidget(lblType[i]);
    delete lblType[i];
    }
delete[] chkImport;
delete[] lblID;
delete[] lblLegend;
delete[] lblComment;
delete[] lblType;
chkImport=NULL;
lblID=NULL;
lblLegend=NULL;
lblComment=NULL;
lblType=NULL;
}
allocated_controls=info.nr_of_sets;
    if (info.nr_of_sets>0)
    {
    chkImport=new QCheckBox*[allocated_controls];
    lblID=new QLabel*[allocated_controls];
    lblLegend=new QLabel*[allocated_controls];
    lblComment=new QLabel*[allocated_controls];
    lblType=new QLabel*[allocated_controls];
        for (int i=0;i<allocated_controls;i++)
        {
        chkImport[i]=new QCheckBox();
        chkImport[i]->setMaximumWidth(25);
        chkImport[i]->setChecked(info.import.at(i));
        sprintf(dummy,"G%d.S%d",info.g_ids.at(i),info.s_ids.at(i));
        lblID[i]=new QLabel(QString(dummy));
        lblID[i]->setMaximumWidth(60);
        lblLegend[i]=new QLabel(info.set_legends.at(i));
        lblComment[i]=new QLabel(info.set_comments.at(i));
        lblType[i]=new QLabel(info.set_types.at(i));
        lblType[i]->setMaximumWidth(45);
        lblType[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
        lblID[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
        lblComment[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
        lblLegend[i]->setFrameStyle(QFrame::Box | QFrame::Raised);
        layout0->addWidget(chkImport[i],i+1,0);
        layout0->setAlignment(chkImport[i],Qt::AlignHCenter);
        layout0->addWidget(lblID[i],i+1,1);
        layout0->addWidget(lblType[i],i+1,2);
        layout0->addWidget(lblLegend[i],i+1,3);
        layout0->addWidget(lblComment[i],i+1,4);
        }
    int he=lblTitle[0]->height();
    if (he>30 || he<15) he=20;
    empty->setGeometry(0,0,(scroll->width()>600?scroll->width():600),he*(allocated_controls+1));
    }
if (info.nr_of_sets<=0)
{
selSelection->setEnabled(false);
selTargetGno->setEnabled(false);
cmdImport->setEnabled(false);
}
else
{
selSelection->setEnabled(true);
selTargetGno->setEnabled(true);
cmdImport->setEnabled(true);
}
}

void frmAgrInfos::readSettings(void)
{
    for (int i=0;i<allocated_controls;i++)
    {
    info.import.replace(i,chkImport[i]->isChecked()==true?TRUE:FALSE);
    }
    info.target_gno=selTargetGno->currentValue();
}

void frmAgrInfos::changeSelection(int index)
{
switch(index)
{
case 0://manual
break;
case 1://none
    for (int i=0;i<allocated_controls;i++) chkImport[i]->setChecked(false);
break;
case 2://all
    for (int i=0;i<allocated_controls;i++) chkImport[i]->setChecked(true);
break;
case 3://invert
    for (int i=0;i<allocated_controls;i++) chkImport[i]->setChecked(!chkImport[i]->isChecked());
break;
}
}

void frmAgrInfos::doImport(void)
{
readSettings();
read_datasets_from_agr(info);
SetsImportedFromAgr(new_set_no,new_set_nos,info,AUTOSCALE_XY);
mainWin->autoscale_proc(AUTOSCALE_XY);
sets_imported+=new_set_no;
}

void frmAgrInfos::doCancel(void)
{
hide();
done(-1);
}

void frmAgrInfos::doOpenAgr(void)
{
load_project_file(info.filename,FALSE);
agrs_opened++;
hide();
done(0);
}

void frmAgrInfos::doImportAgr(void)
{
doImport();
hide();
done(1);
}

void frmAgrInfos::reset_import_counters(void)
{
sets_imported=agrs_opened=0;
}

void frmAgrInfos::get_import_counts(int * n_o_sets,int * n_o_agrs)
{
*n_o_sets=sets_imported;
*n_o_agrs=agrs_opened;
}

frmIOForm::frmIOForm(int type,QWidget * parent):QDialog(parent)
{
    formType=type;
    frmEdBlock=NULL;
    int number;
    QString entr[32];
    int values[32];
    int number2,offset=0,offset2=0;
    QString entr2[32];
    char dummy[32];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    grpRead=new QGroupBox(QString(""),this);
    grpWrite=new QGroupBox(QString(""),this);
    grpDescription=new QGroupBox(QString(""),this);
    grpTitle=new QGroupBox(QString(""),this);
    grpParamGraph=new QGroupBox(QString(""),this);

    lblReadGraph=new QLabel(tr("Read to graph:"),grpRead);
    lblWriteSet=new QLabel(tr("Write set(s):"),grpWrite);
    lblSelection=new QLabel(tr("Selection:"),this);
    lblDataSource=new QLabel(tr("Data source:"),grpRead);
    lblDescription=new QLabel(tr("Project description:"),grpDescription);

    ledFormat=new stdLineEdit(grpWrite,tr("Format:"));
    //ledFormat->lenText->setText(QString("\%.8g"));
    ledFormat->lenText->setText(QString(sformat));
    ledFormat2=new stdLineEdit(grpWrite,tr("Data format:"));
    //ledFormat2->lenText->setText(QString("\%.8g"));
    ledFormat2->lenText->setText(QString(sformat));
    ledTitle=new stdLineEdit(grpTitle,tr("Title:"));
    ledTitle->lenText->setText(tr("A fit"));

    //ledSelection=new QLineEdit(tr(""),this);
    ledSelection=new stdLineEdit(this,tr(""));
    ledSelection->lblText->setVisible(false);
    ledSelection->layout->setMargin(0);
    ledSelection->layout->setSpacing(0);
    ledSelection->setAcceptDrops(true);
    connect(ledSelection,SIGNAL(changed()),SLOT(newFileEnteredManually()));
    connect(ledSelection->lenText,SIGNAL(returnPressed()),SLOT(newFileEnteredManually()));

    txtDescription=new QTextEdit(this);
    lblProjectContent=new QLabel(QString("--"),this);

    number=2;
    entr[0]=tr("Current");
    entr[1]=tr("All");
    selParamGraph=new StdSelector(grpRead,tr("Write parameters from graph:"),number,entr);

    number=3;
    entr[0]=tr("Single set");
    entr[1]=tr("NXY");
    entr[2]=tr("Block data");
    selLoadAs=new StdSelector(grpRead,tr("Load as:"),number,entr);

    number=4;
    entr[0]=tr("None");
    entr[1]=tr("X");
    entr[2]=tr("Y");
    entr[3]=tr("XY");
    selAutoscale=new StdSelector(grpRead,tr("Autoscale on read:"),number,entr);
    selAutoscale->setCurrentIndex(3);

    number=NUMBER_OF_SETTYPES;
    for (int i=0;i<number;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(grpRead,tr("Type:"),number,entr);

    radPipe=new QRadioButton(tr("Pipe"),grpRead);
    radDisk=new QRadioButton(tr("Disk"),grpRead);
    radDisk->setChecked(TRUE);

    graphList=new uniList(GRAPHLIST,grpRead);
    setList=new uniList(SETLIST,grpWrite);

    number=1;
    entr[0]=tr("G0");
    selExportGraph=new StdSelector(this,tr("Graph:"),number,entr);
    selExportGraph->setVisible(false);

    //Specials for Binary-File-Interaction
    if (type==READ_BINARY_FILE || type==WRITE_BINARY_FILE)
    {
        grpBinary=new QGroupBox(tr("Binary conversion"),this);
        layout6=new QGridLayout;
        layout6->setMargin(STD_MARGIN);
        chkHeader=new QCheckBox(tr("Header"),this);
        connect(chkHeader,SIGNAL(stateChanged(int)),SLOT(headerChecked(int)));
        layout6->addWidget(chkHeader,0,0,1,2);
        selHeaderLength=new stdIntSelector(this,tr("Length of header in bytes:"),0,100000);
        layout6->addWidget(selHeaderLength,1,0,1,2);
        selHeaderLength->setEnabled(false);
        selTotalColumnNumber=new stdIntSelector(this,tr("Number of data Columns:"),1,200);
        layout6->addWidget(selTotalColumnNumber,2,0,1,2);
        selector_count=5;
        selTotalColumnNumber->setValue(selector_count);
        connect(selTotalColumnNumber->spnInt,SIGNAL(valueChanged(int)),this,SLOT(columnCountChanged(int)));
        selColFormats=new StdSelector*[selector_count];
        selImportTo=new StdSelector*[selector_count];
        selColSize=new QSpinBox*[selector_count];
        number=NUMBER_OF_COLUMN_FORMATS;
        for (int i=0;i<number;i++)
        {
            entr[i]=QString(binaryImportFormatName[i]);
            values[i]=binaryImportFormat[i].format;
        }
        layout7=new QGridLayout;
        layout7->setMargin(STD_MARGIN);
        layout7->setSpacing(STD_SPACING);
        lblFormat=new QLabel(tr("Column format:"),this);
        lblBytes=new QLabel(tr("Bytes:"),this);
        lblImport=new QLabel(tr("Import to:"),this);
        layout7->addWidget(lblFormat,0,0,1,1);
        layout7->addWidget(lblBytes,0,1,1,1);
        layout7->addWidget(lblImport,0,2,1,1);
        empty=new QWidget;
        number2=3;
        entr2[0]=QString("None");
        entr2[1]=QString("X");
        entr2[2]=QString("Y");
        offset2=1;
        for (int i=0;i<selector_count;i++)
        {
            sprintf(dummy,"%d:",i);
            selColFormats[i]=new StdSelector(this,QString(dummy),number,entr);
            selColFormats[i]->setValues(values);
            selImportTo[i]=new StdSelector(this,QString(""),number2,entr2);
            selImportTo[i]->lblText->setVisible(false);
            selColSize[i]=new QSpinBox(this);
            selColSize[i]->setMinimum(1);
            selColSize[i]->setMaximum(5000);
            layout7->addWidget(selColFormats[i],offset2,0,1,1);
            layout7->addWidget(selColSize[i],offset2,1,1,1);
            layout7->addWidget(selImportTo[i],(offset2++),2,1,1);
        }
        area=new QScrollArea;
        area->setWidget(empty);
        empty->setGeometry(0,0,320,180);
        empty->setLayout(layout7);
        layout6->addWidget(area,3,0,1,2);
        chkImportToEOF=new QCheckBox(tr("Import until EOF"),this);
        connect(chkImportToEOF,SIGNAL(stateChanged(int)),SLOT(readUntilEOFChecked(int)));
        layout6->addWidget(chkImportToEOF,4,0,1,2);
        selMaxImportData=new stdIntSelector(this,tr("Max number of data sets to import:"),1,500000);
        selMaxImportData->setValue(1000);
        layout6->addWidget(selMaxImportData,5,0,1,2);
        grpBinary->setLayout(layout6);
        grpBinary->setVisible(false);
    }

    cmdOK=new QPushButton(tr("OK"),this);
    connect(cmdOK,SIGNAL(clicked()),SLOT(doOK()));
    cmdFilter=new QPushButton(tr("Filter"),this);
    connect(cmdFilter,SIGNAL(clicked()),SLOT(doFilter()));
    cmdCancel=new QPushButton(tr("Cancel"),this);
    connect(cmdCancel,SIGNAL(clicked()),SLOT(doCancel()));
    cmdHelp=new QPushButton(tr("Help"),this);
    connect(cmdHelp,SIGNAL(clicked()),SLOT(doHelp()));

    cmdOK->setDefault(false);
    cmdFilter->setDefault(false);
    cmdCancel->setDefault(false);
    cmdHelp->setDefault(false);

    cmdOK->setAutoDefault(false);
    cmdFilter->setAutoDefault(false);
    cmdCancel->setAutoDefault(false);
    cmdHelp->setAutoDefault(false);

    chkExchangeCommaPoint=new QCheckBox(tr("Use ',' instead of '.' as decimal seperator"),this);

    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(lblReadGraph,0,0,1,4);
    layout1->addWidget(graphList,1,0,1,4);
    layout1->addWidget(selLoadAs,2,0,1,2);
    layout1->addWidget(selType,2,2,1,2);
    layout1->addWidget(lblDataSource,3,0,1,2);
    layout1->addWidget(radDisk,3,2);
    layout1->addWidget(radPipe,3,3);
    layout1->addWidget(selAutoscale,4,0,1,4);
    layout1->addWidget(chkExchangeCommaPoint,5,0,1,4);
    grpRead->setLayout(layout1);

    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(lblWriteSet);
    layout2->addWidget(selExportGraph);
    layout2->addWidget(setList);
    layout2->addWidget(ledFormat);
    grpWrite->setLayout(layout2);

    layout3=new QVBoxLayout;
    layout3->setMargin(STD_MARGIN);
    layout3->addWidget(lblDescription);
    layout3->setAlignment(lblDescription,Qt::AlignHCenter);
    layout3->addWidget(txtDescription);
    layout3->addWidget(lblProjectContent);
    lblProjectContent->hide();
    layout3->addWidget(ledFormat2);
    grpDescription->setLayout(layout3);

    layout4=new QVBoxLayout;
    layout4->setMargin(STD_MARGIN);
    layout4->addWidget(ledTitle);
    grpTitle->setLayout(layout4);

    layout5=new QVBoxLayout;
    layout5->setMargin(STD_MARGIN);
    layout5->addWidget(selParamGraph);
    grpParamGraph->setLayout(layout5);

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);

    selector=new FileSelector(this);
    connect(selector,SIGNAL(newSelection(QString)),SLOT(gotNewSelection(QString)));
    connect(selector,SIGNAL(newSelectionDoubleClick(QString)),SLOT(gotNewSelectionDoubleClick(QString)));
    connect(selector,SIGNAL(newSelectionManually()),SLOT(newFileEnteredManually()));

    layout->addWidget(selector,0,0,1,4);

    switch (type)
    {
    case READ_SET_FORM:
        setWindowTitle(tr("QtGrace: Read sets"));
        stdExtension=QString("*.dat");
        layout->addWidget(grpRead,6,0,1,4);
        offset=1;
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case READ_NETCDF_FORM:
        setWindowTitle(tr("QtGrace: Select netCDF file"));
        stdExtension=QString("*.nc");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case READ_PROJECT_FORM:
        setWindowTitle(tr("QtGrace: Open project"));
        /*agrInfo=new frmAgrInfos(this);
        agrInfo->setVisibleItems(false,false);
        agrInfo->setInfoVisible(false);
        layout->addWidget(agrInfo,6,0,1,4);
        layout->setRowStretch(6,1);
        layout->setRowStretch(1,3);*/
        offset=2;
        stdExtension=QString("*.agr");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        //grpDescription->setVisible(FALSE);

lblProjectContent->setVisible(TRUE);
grpDescription->setVisible(TRUE);//I changed this!!
//grpDescription->setEnabled(FALSE);//I changed this!!
layout->addWidget(grpDescription,6,0,1,4);//I added this!!
txtDescription->setReadOnly(true);
ledFormat2->setVisible(false);

        cmdOpenSetImport=new QPushButton(tr("Open set extraction dialog"),this);
        connect(cmdOpenSetImport,SIGNAL(clicked()),SLOT(doOpenSetImport()));
        layout->addWidget(cmdOpenSetImport,6+1,0,1,4);

        cmdOpenSetImport->setDefault(false);
        cmdOpenSetImport->setAutoDefault(false);

        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case WRITE_SET_FORM:
        setWindowTitle(tr("QtGrace: Write sets"));
        stdExtension=QString("*.dat");
        layout->addWidget(grpWrite,6,0,1,4);
        offset=1;
        selExportGraph->setVisible(TRUE);
        grpRead->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=false;
        connect(selExportGraph,SIGNAL(currentIndexChanged(int)),SLOT(exportGraphChanged(int)));
        break;
    case WRITE_PROJECT_FORM:
        setWindowTitle(tr("QtGrace: Save project"));
        stdExtension=QString("*.agr");
        layout->addWidget(grpDescription,6,0,1,4);
        offset=1;
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=false;
        break;
    case SELECT_HOT_LINK_FILE:
        setWindowTitle(tr("QtGrace: Select hot link file"));
        stdExtension=QString("*.dat");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case READ_PARAMETERS:
        setWindowTitle(tr("QtGrace: Read parameters"));
        stdExtension=QString("*.par");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case WRITE_PARAMETERS:
        setWindowTitle(tr("QtGrace: Write parameters"));
        stdExtension=QString("*.par");
        layout->addWidget(grpParamGraph,6+offset,0,1,4);
        offset=1;
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(TRUE);
        selector->forRead=false;
        break;
    case SELECT_PRINT_FILE:
        setWindowTitle(tr("QtGrace: Select print file"));
        stdExtension=QString("*.dat");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=false;
        break;
    case READ_FIT_PARAM:
        setWindowTitle(tr("QtGrace: Open fit parameter file"));
        stdExtension=QString("*.fit");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        break;
    case WRITE_FIT_PARAM:
        setWindowTitle(tr("QtGrace: Save fit parameter file"));
        stdExtension=QString("*.fit");
        grpRead->setVisible(FALSE);
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        layout->addWidget(grpTitle,6+offset,0,1,4);
        grpTitle->setVisible(TRUE);
        grpParamGraph->setVisible(FALSE);
        offset=1;
        selector->forRead=false;
        break;
    case READ_BINARY_FILE:
        setWindowTitle(tr("QtGrace: Read binary file"));
        stdExtension=QString("*.dat");
        layout->addWidget(grpRead,6,0,1,2);
        layout->addWidget(grpBinary,6,2,1,2);
        grpBinary->setVisible(true);
        offset=1;
        grpWrite->setVisible(FALSE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=true;
        connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(setTypeChanged(int)));
        setTypeChanged(0);
        selTotalColumnNumber->setValue(2);
        selColFormats[0]->setCurrentIndex(10);
        selColFormats[1]->setCurrentIndex(10);
        selImportTo[0]->setCurrentIndex(1);
        selImportTo[1]->setCurrentIndex(2);
        chkImportToEOF->setChecked(true);
        break;
    case WRITE_BINARY_FILE:
        setWindowTitle(tr("QtGrace: Write binary file"));
        stdExtension=QString("*.dat");
        layout->addWidget(grpWrite,6,0,1,4);
        offset=1;
        selExportGraph->setVisible(TRUE);
        grpRead->setVisible(FALSE);
        grpBinary->setVisible(FALSE);
        ledFormat->setVisible(false);
        setList->setBehavior(true,false,false);
        grpWrite->setTitle(tr("Write set:"));
        grpWrite->setVisible(TRUE);
        grpDescription->setVisible(FALSE);
        grpTitle->setVisible(FALSE);
        grpParamGraph->setVisible(FALSE);
        selector->forRead=false;
        connect(selExportGraph,SIGNAL(currentIndexChanged(int)),SLOT(exportGraphChanged(int)));
        break;
    }
    layout->addWidget(lblSelection,6+offset,0,1,4);
    layout->addWidget(ledSelection,7+offset,0,1,4);
    layout->addWidget(cmdOK,8+offset,0);
    layout->addWidget(cmdFilter,8+offset,1);
    layout->addWidget(cmdCancel,8+offset,2);
    layout->addWidget(cmdHelp,8+offset,3);
    setLayout(layout);
    QString cdir=QString(get_workingdir());
    cdir.chop(1);
    selector->setFilterFromExtern(cdir,stdExtension);

    switch (formType)
    {
    case READ_SET_FORM:
    resize(LastSize_FormReadSets);
    break;
    case READ_NETCDF_FORM:
    resize(LastSize_FormReadNetCDF);
    break;
    case READ_PROJECT_FORM:
    resize(LastSize_FormOpenProject);
    break;
    case WRITE_SET_FORM:
    resize(LastSize_FormWriteSets);
    break;
    case WRITE_PROJECT_FORM:
    resize(LastSize_FormSaveProject);
    break;
    case SELECT_HOT_LINK_FILE:
    resize(LastSize_FormSelectHotLink);
    break;
    case READ_PARAMETERS:
    resize(LastSize_FormReadParameters);
    break;
    case WRITE_PARAMETERS:
    resize(LastSize_FormWriteParameters);
    break;
    case SELECT_PRINT_FILE:
    resize(LastSize_FormSelectOutputFile);
    break;
    case READ_FIT_PARAM:
    resize(LastSize_FormOpenFitPara);
    break;
    case WRITE_FIT_PARAM:
    resize(LastSize_FormSaveFitPara);
    break;
    case READ_BINARY_FILE:
    resize(LastSize_FormReadBinary);
    break;
    case WRITE_BINARY_FILE:
    resize(LastSize_FormWriteBinary);
    break;
    default:
    resize(LastSize_FormIOForm);
    break;
    }

}

frmIOForm::~frmIOForm()
{
    switch (formType)
    {
    case READ_SET_FORM:
    LastSize_FormReadSets=this->size();
    break;
    case READ_NETCDF_FORM:
    LastSize_FormReadNetCDF=this->size();
    break;
    case READ_PROJECT_FORM:
    LastSize_FormOpenProject=this->size();
    break;
    case WRITE_SET_FORM:
    LastSize_FormWriteSets=this->size();
    break;
    case WRITE_PROJECT_FORM:
    LastSize_FormSaveProject=this->size();
    break;
    case SELECT_HOT_LINK_FILE:
    LastSize_FormSelectHotLink=this->size();
    break;
    case READ_PARAMETERS:
    LastSize_FormReadParameters=this->size();
    break;
    case WRITE_PARAMETERS:
    LastSize_FormWriteParameters=this->size();
    break;
    case SELECT_PRINT_FILE:
    LastSize_FormSelectOutputFile=this->size();
    break;
    case READ_FIT_PARAM:
    LastSize_FormOpenFitPara=this->size();
    break;
    case WRITE_FIT_PARAM:
    LastSize_FormSaveFitPara=this->size();
    break;
    case READ_BINARY_FILE:
    LastSize_FormReadBinary=this->size();
    break;
    case WRITE_BINARY_FILE:
    LastSize_FormWriteBinary=this->size();
    break;
    default:
    LastSize_FormIOForm=this->size();
    break;
    }
}

void frmIOForm::gotNewSelection(QString selection)
{
static bool function_running=false;
QFileInfo FileInf(ledSelection->lenText->text());
QString old_filename=FileInf.fileName();
//qDebug() << "OldSelection=" << ledSelection->lenText->text();
FileInf=QFileInfo(selection);
if (FileInf.fileName().isEmpty())
ledSelection->lenText->setText(selection+old_filename);
else
ledSelection->lenText->setText(selection);
if (function_running==true) return;
function_running=true;
//qDebug() << "gotNewSelection=" << selection;
/// selector->setFileSelectionFromExtern(selection);
    if (formType!=READ_PROJECT_FORM) return;
char * filename=new char[selection.toLocal8Bit().length()+8];
strcpy(filename,selection.toLocal8Bit().constData());
//struct agr_file_info afi;
//qDebug() << "new File=" << filename << " isAGR=" << is_agr_file(filename);
    if (is_agr_file(filename))
    {
        if (Form_AgrInfo==NULL)
        {
        Form_AgrInfo=new frmAgrInfos(0);
        //Form_AgrInfo->setWindowTitle(QString("QtGrace: ")+QObject::tr("Import set(s) from agr-file"));
        Form_AgrInfo->hide();
        }
    Form_AgrInfo->init(filename);
    txtDescription->setText(Form_AgrInfo->info.project_description);
    lblProjectContent->setText(tr("Project contains: ")+QString::number(Form_AgrInfo->info.nr_of_graphs)+tr(" Graph(s) and ")+QString::number(Form_AgrInfo->info.nr_of_sets)+tr(" Set(s)"));
        if (Form_AgrInfo->info.nr_of_sets>0)
        cmdOpenSetImport->setEnabled(true);
        else
        cmdOpenSetImport->setEnabled(false);
    }
    else//not an agr-file
    {
    txtDescription->clear();
    lblProjectContent->setText(tr("No project file."));
    cmdOpenSetImport->setEnabled(false);
    }
    //newFileEnteredManually();
delete[] filename;
    function_running=false;
    /*QFileInfo fi1(selection);
    QString suffix=fi1.completeSuffix();
    QString path_only=fi1.path();
    selector->setFilterFromExtern(path_only,suffix);*/
/// selector->setFileSelectionFromExtern(selection);
}

void frmIOForm::gotNewSelectionDoubleClick(QString selection)
{
    gotNewSelection(selection);
    doOK();
}

void frmIOForm::init(char * f_name)
{
QString f_name2;
f_name2=QString::fromLocal8Bit(f_name);
/*qDebug() << "frmIOForm:    f_name =" << f_name;
qDebug() << "frmIOForm: local8bit =" << f_name2;
qDebug() << "Working dir=" << get_workingdir();*/
    ledFormat->lenText->setText(QString(sformat));
    ledFormat2->lenText->setText(QString(sformat));
        if (formType==WRITE_PROJECT_FORM)
        {
        txtDescription->setText(get_project_description());
        }
        if (formType==READ_PROJECT_FORM)
        {
        cmdOpenSetImport->setEnabled(false);
        }
selFileInfo.setFile(f_name2);
//selFileInfo.setFile(f_name);
    if (f_name==NULL)
    {
    //selFileInfo.setFile(get_workingdir());
    selFileInfo.setFile(Last_Dialog_Path[formType]);
    f_name2=Last_Dialog_Path[formType];
    }
QString a,b;
    if (f_name==NULL)
    {
    //selectedFile=QString("");
    selectedFile=Last_Dialog_Path[formType];
    }
    else
    {
    selectedFile=f_name2;
    //selectedFile=QString(f_name);
    a=selFileInfo.absoluteDir().absolutePath();
    if (!selFileInfo.suffix().isEmpty())
    b=QString("*.")+selFileInfo.suffix();
    else
    b=QString("*.agr")+selFileInfo.suffix();
    /// selector->setFilterFromExtern(a,b);
    selector->setFileSelectionFromExtern(selectedFile);
    /*qDebug() << "path=" << a.toLatin1() << endl;
    qDebug() << "extension=" << b.toLatin1() << endl;*/
    }

    selector->ledFilter->setText(QDir::toNativeSeparators(selector->currentDir).toLocal8Bit()+selector->separator+selector->filterExtension);
    ledSelection->setText(QDir::toNativeSeparators(selector->currentDir).toLocal8Bit()+selector->separator);
        if (selFileInfo.isFile())
        ledSelection->setText(QDir::toNativeSeparators(selector->currentDir).toLocal8Bit()+selector->separator+selFileInfo.fileName().toLocal8Bit());
    /*qDebug() << "Set1=" << selector->ledFilter->text() << endl;
    qDebug() << "Set2=" << ledSelection->text() << endl;*/
    graphList->update_number_of_entries();
    setList->update_number_of_entries();
    int gno=get_cg();
    graphList->set_new_selection(1,&gno);
    if (formType==WRITE_BINARY_FILE || formType==WRITE_SET_FORM)
    {
    int number=number_of_graphs();
    QString * entr=new QString[2+number];
    int *entr_v=new int[2+number];
        for (int i=0;i<number;i++)
        {
        entr[i]=QString("G")+QString::number(i);
        entr_v[i]=i;
        }
    selExportGraph->setNewEntries(number,entr,entr_v);
    selExportGraph->setCurrentValue(cg);
    delete[] entr;
    delete[] entr_v;
    }
}

void frmIOForm::exportGraphChanged(int g)
{
    (void)g;
setList->set_graph_number(selExportGraph->currentValue(),false);
setList->update_number_of_entries();
}

void frmIOForm::doOK(void)
{
    static char dummy[512];
    int gno, setno;
    int *selset=new int[5], cd, i;
    int graphno,cursource;
    char filename[2048];
    selectedFile=ledSelection->text();
    if (radPipe->isChecked()==true)
        cursource=1;
    else
        cursource=0;
    autoscale_onread = GetOptionChoice(selAutoscale);
    QFile fileTest(selectedFile);
    QFileInfo fileInfo(fileTest);
    if (fileInfo.isFile()==false)
    {
        FileExists=false;
        isWriteable=false;
        isReadable=false;
    }
    else
    {
        FileExists=fileTest.exists();
        isWriteable=fileInfo.isWritable();
        isReadable=fileInfo.isReadable();
    }

    //strcpy(filename,selectedFile.toLocal8Bit());//ascii-only
    QString encodedString(QFile::encodeName(selectedFile));//should work with unicode-characters as well
    strcpy(filename,encodedString.toLocal8Bit().constData());

    /*
QMessageBox::information(this,"selected File",selectedFile);
QString nonUniCodeFile=QString(FileCodec->fromUnicode(selectedFile));
strcpy(filename,nonUniCodeFile.toLocal8Bit().constData());
QMessageBox::information(this,"nonUniCodeFile",nonUniCodeFile);
QString recon=FileCodec->toUnicode(filename);//so geht's, wenn die richtige Kodierung eingestellt wurde!
QMessageBox::information(this,"recon",recon);
QMessageBox::information(this,"encoded",encodedString);
*/

    exchange_point_comma=chkExchangeCommaPoint->isChecked();

    //if (FileExists && (formType==WRITE_SET_FORM || formType==WRITE_BINARY_FILE))
    if (FileExists && (formType==WRITE_BINARY_FILE))//for write_set_form_ grace-function will ask for overwrite
    {
        int ret=QMessageBox::question(this,tr("Warning!"),tr("File exists!\nOverwrite?"),QMessageBox::Ok,QMessageBox::Cancel);
        if (ret==QMessageBox::Cancel)
        {
            delete[] selset;
            exchange_point_comma=false;
            return;
        }
    }
Last_Dialog_Path[formType]=fileInfo.absolutePath();
    if (formType==READ_SET_FORM)
    {
        set_wait_cursor();
        int load = GetOptionChoice(selLoadAs);
        if (cursource==1)//source=pipe
        {//we load from a pipe here
            int fd;
            if (openPipe(filename,&fd)!=RETURN_SUCCESS)
                errmsg(tr("Unable to open pipe!").toLocal8Bit().constData());
            mainWin->checkForRealTimeIO();
            goto end_fromIOFormOK;
        }

        if (GetSingleListChoice(graphList, &graphno) != RETURN_SUCCESS) {
            errmsg(tr("Please select a single graph!").toLocal8Bit().constData());
        } else {

            if (load == LOAD_SINGLE)
            {
                curtype = GetOptionChoice(selType);
            }

            if (new_set_nos!=NULL)
            {
                delete[] new_set_nos;
                new_set_nos=NULL;
            }
            new_set_no=0;
            //cout << "A3 " << graphno << " " << filename << " " << cursource << " " << load << endl;

            prepare_strings_for_saving();
            getdata(graphno, filename, cursource, load);
            resume_strings_after_load_or_save();

            if (selLoadAs->currentIndex()==2)//Block data
            {
                if (frmEdBlock==NULL)
                {
                    frmEdBlock=new frmEditBlockData(mainWin);
                }
                frmEdBlock->filename=QString(filename);
                frmEdBlock->source=cursource;
                frmEdBlock->init();
                frmEdBlock->show();
                frmEdBlock->raise();
            }
            else if (cursource==0)//source=file
            {
                ///Undo-Stuff
                if (new_set_no==1)//only one new set
                {
                    set_set_hidden(graphno,new_set_nos[0],FALSE);
                    SetImported(graphno,new_set_nos[0],filename,cursource,load,autoscale_onread);
                }
                else if (new_set_no>1)//more than one set imported
                {
                    int * gnos=new int[new_set_no+2];
                    char ** filenames=new char *[2];
                    for (int i=0;i<new_set_no;i++)
                    {
                        gnos[i]=graphno;
                        set_set_hidden(graphno,new_set_nos[i],FALSE);
                    }
                    filenames[0]=new char[2+strlen(filename)];
                    strcpy(filenames[0],filename);
                    SetsImported(new_set_no,gnos,new_set_nos,1,filenames,cursource,load,autoscale_onread);
                    delete[] filenames[0];
                    delete[] filenames;
                    delete[] gnos;
                }
                mainWin->mainArea->completeRedraw();
            }
            /*else
        {
        mainWin->checkForRealTimeIO();
        }*/
            update_default_props();
        }
    }
    else if (formType==WRITE_SET_FORM)
    {
        set_wait_cursor();
        char format[32];
        FILE *cp;

        cp = grace_openw(filename);//overwrite? yes/no
        if (cp == NULL) {
            return;
        }
        cd = GetListChoices(setList, &selset);
        if (cd < 1) {
            errmsg(tr("No set selected!").toLocal8Bit().constData());
        } else {
            gno = selExportGraph->currentValue();//get_cg();
            strncpy(format, xv_getstr(ledFormat), 31);
            for(i = 0; i < cd; i++) {
                setno = selset[i];
                write_set(gno, setno, cp, format, TRUE);
            }
        }
        grace_close(cp);
    }
    else if (formType==READ_BINARY_FILE)
    {
        set_wait_cursor();
        if (!FileExists || !isReadable)
        {
            errmsg((tr("File ")+QString(filename)+tr(" does not exist or is unreadable!")).toLocal8Bit().constData());
            unset_wait_cursor();
            return;
        }
        struct BinReadInstructions inst;

        autoscale_onread = GetOptionChoice(selAutoscale);

        if (GetSingleListChoice(graphList, &graphno) != RETURN_SUCCESS) {
            errmsg(tr("Please select a single graph!").toLocal8Bit().constData());
        }else{
            setno=nextset(graphno);
            int curtype = GetOptionChoice(selType);
            int number_of_cols = settype_cols(curtype);

            if (chkHeader->isChecked())
                inst.length_of_header=selHeaderLength->value();
            else
                inst.length_of_header=0;

            inst.column_count=selTotalColumnNumber->value();
            inst.read_until_end_is_reached=chkImportToEOF->isChecked();
            inst.datasets_to_read=selMaxImportData->value();

            inst.col_numbers_to_read=new int[number_of_cols];
            for (int i=0;i<number_of_cols;i++)
                inst.col_numbers_to_read[i]=-1;//invalid number
            inst.column_type=new struct ColumnFormat[inst.column_count];//format of all columns
            inst.n_columns_to_read=number_of_cols;

            for (unsigned int i=0;i<inst.column_count;i++)
            {
                inst.column_type[i].format=selColFormats[i]->currentValue();
                inst.column_type[i].size=selColSize[i]->value();
                if (selImportTo[i]->currentValue()>=0 && selImportTo[i]->currentValue()<number_of_cols)
                    inst.col_numbers_to_read[selImportTo[i]->currentValue()]=i;
            }
            //checking entries
            int ok=-1;
            for (int i=0;i<number_of_cols;i++)
            {
                //cout << dataset_colname(i) << "=" << inst.col_numbers_to_read[i] << endl;
                if (inst.col_numbers_to_read[i]==-1){ok=i;break;}
            }
            if (ok>-1)
            {
                sprintf(dummy,"%s%s%s",tr("Please select an import-column for every set-column! Column ").toLocal8Bit().constData(),dataset_colname(ok),tr(" is missing!").toLocal8Bit().constData());
                errmsg(dummy);
            }
            else
            {
                ok=-1;
                for (unsigned int i=0;i<inst.column_count;i++)
                {
                    if (selImportTo[i]->currentValue()==-1) continue;
                    for (unsigned int j=i+1;j<inst.column_count;j++)
                    {
                        if (selImportTo[i]->currentValue()==selImportTo[j]->currentValue())
                        {
                            ok=selImportTo[i]->currentValue();
                            i=inst.column_count;
                            break;
                        }
                    }
                }
                if (ok>-1)
                {
                    sprintf(dummy,"%s%s%s",tr("Import-column for ").toLocal8Bit().constData(),dataset_colname(ok),tr(" is ambiguous! Binary import aborted!").toLocal8Bit().constData());
                    errmsg(dummy);
                }
                else
                {
                    LoadBinaryData(graphno,setno,selType->currentValue(),filename,inst);
                    autoscale_graph(graphno, autoscale_onread);
                    mainWin->mainArea->completeRedraw();
                }
            }
            delete[] inst.column_type;
            delete[] inst.col_numbers_to_read;
        }
    }
    else if (formType==WRITE_BINARY_FILE)
    {
        set_wait_cursor();
        cd = GetListChoices(setList, &selset);
        if (cd < 1) {
            errmsg(tr("No set selected!").toLocal8Bit().constData());
        } else {
            //gno = get_cg();
            gno = selExportGraph->currentValue();
            plotarr pa;
            get_graph_plotarr(gno, selset[0], &pa);
            ofstream ofi;
            ofi.open(filename,ios::binary);
            unsigned int channels=dataset_cols(gno,selset[0]);
            unsigned int len=pa.data.len;
            ofi.write((char*)((void*)&channels),sizeof(unsigned int));
            ofi.write((char*)((void*)&len),sizeof(unsigned int));
            for (unsigned int i=0;i<channels;i++)
            {
                for (unsigned int j=0;j<len;j++)
                {
                    ofi.write((char*)((void*)(pa.data.ex[i]+j)),sizeof(double));
                }
            }
            ofi.close();
        }
    }
    else
    {
        if (formType==WRITE_PROJECT_FORM)
        {
            strncpy(sformat, xv_getstr(ledFormat2), 31);
            QString nDescr=txtDescription->toPlainText();
            char * neDescr=new char[2+nDescr.length()];
            strcpy(neDescr,nDescr.toLocal8Bit().constData());
            set_project_description(neDescr);
            delete[] neDescr;
        }
        emit(newFileSelectedForIO(formType,selectedFile,FileExists,isWriteable,isReadable));
    }
end_fromIOFormOK:
    exchange_point_comma=false;
    unset_wait_cursor();
    doFilter();
    delete[] selset;
}

void frmIOForm::doFilter(void)
{
/// cout << "Filter pressed" << endl;
    selector->newFilterEntered();
}

void frmIOForm::doCancel(void)
{
    hide();
}

void frmIOForm::doHelp(void)
{
    HelpCB("doc/UsersGuide.html#FS-dialog");
}

void frmIOForm::doOpenSetImport(void)
{
    if (Form_AgrInfo==NULL)
    {
    Form_AgrInfo=new frmAgrInfos(0);
    Form_AgrInfo->hide();
    }
char * filename=new char[ledSelection->text().length()+8];
strcpy(filename,ledSelection->text().toLocal8Bit().constData());
    if (is_agr_file(filename)==TRUE)
    {
    Form_AgrInfo->init(filename);
    /*Form_AgrInfo->show();
    Form_AgrInfo->raise();
    Form_AgrInfo->activateWindow();*/
    Form_AgrInfo->exec();
    }
    else
    {
    errmsg(tr("Selected file is not a project file.").toLocal8Bit().constData());
    }
delete[] filename;
}

void frmIOForm::newFileEnteredManually(void)
{
QString text=ledSelection->lenText->text();
QFileInfo fi(text);
//qDebug() << "New File Selected Manually=#" << text << "#";
if (fi.exists()==false) return;
//QString name_only=fi.completeBaseName();
QString path_only=fi.absolutePath()+QDir::separator();
QString suffix_only=fi.suffix();
/*qDebug() << "Name  =#" << name_only << "#";
qDebug() << "Path  =#" << path_only << "#";
qDebug() << "Suffix=#" << suffix_only << "#";*/
selector->ledFilter->setText(path_only+QString("*.")+suffix_only);
selector->setFilterFromExtern(path_only,suffix_only);
selector->setFileSelectionFromExtern(text);
//qDebug() << "NewFileEnteredManually=" << text;
gotNewSelection(text);
}

void frmIOForm::headerChecked(int c)
{
    selHeaderLength->setEnabled((bool)c);
}

void frmIOForm::readUntilEOFChecked(int c)
{
    selMaxImportData->setEnabled(!((bool)c));
}

void frmIOForm::setTypeChanged(int c)
{
    int curtype = GetOptionChoice(selType);
    int number_of_cols = settype_cols(curtype),index;
    int * values=new int[number_of_cols+2];
    QString * entries=new QString[number_of_cols+2];
    (void)c;
    values[0]=-1;
    entries[0]=tr("None");
    for (int i=0;i<number_of_cols;i++)
    {
        entries[i+1]=QString(dataset_colname(i));
        values[i+1]=i;
    }
    for (int i=0;i<selector_count;i++)
    {
        index=selImportTo[i]->currentIndex();
        selImportTo[i]->setNewEntries(number_of_cols+1,entries,values);
        selImportTo[i]->setCurrentIndex(index);
    }
    delete[] values;
    delete[] entries;
}

void frmIOForm::columnCountChanged(int c)
{
    int * sel_ind=new int[selector_count];
    int * sel_ind2=new int[selector_count];
    int * sel_ind3=new int[selector_count];
    for (int i=0;i<selector_count;i++)
    {
        sel_ind[i]=selColFormats[i]->currentIndex();
        sel_ind2[i]=selImportTo[i]->currentIndex();
        sel_ind3[i]=selColSize[i]->value();
        delete selColFormats[i];
        delete selImportTo[i];
        delete selColSize[i];
    }
    delete[] selColFormats;
    delete[] selImportTo;
    delete[] selColSize;
    selColFormats=new StdSelector*[c];
    selImportTo=new StdSelector*[c];
    selColSize=new QSpinBox*[c];

    empty->setGeometry(0,0,empty->width(),(int)(empty->height()*c*1.0/selector_count));

    int number=NUMBER_OF_COLUMN_FORMATS;
    char dummy[128];
    QString entr[NUMBER_OF_COLUMN_FORMATS];
    int vals[NUMBER_OF_COLUMN_FORMATS];
    for (int i=0;i<number;i++)
    {
        entr[i]=QString(binaryImportFormatName[i]);
        vals[i]=binaryImportFormat[i].format;
    }

    int offset=1;
    for (int i=0;i<c;i++)
    {
        sprintf(dummy,"%d:",i);
        selColFormats[i]=new StdSelector(this,QString(dummy),number,entr);
        selColFormats[i]->setValues(vals);
        selImportTo[i]=new StdSelector(this,QString(""),number,entr);
        selImportTo[i]->lblText->setVisible(false);
        selColSize[i]=new QSpinBox(this);
        selColSize[i]->setMinimum(1);
        selColSize[i]->setMaximum(5000);
        layout7->addWidget(selColFormats[i],offset,0,1,1);
        layout7->addWidget(selColSize[i],offset,1,1,1);
        layout7->addWidget(selImportTo[i],offset++,2,1,1);
    }

    int curtype = GetOptionChoice(selType);
    int number_of_cols = settype_cols(curtype);
    int * values=new int[number_of_cols+2];
    QString * entries=new QString[number_of_cols+2];
    values[0]=-1;
    entries[0]=tr("None");
    for (int i=0;i<number_of_cols;i++)
    {
        entries[i+1]=QString(dataset_colname(i));
        values[i+1]=i;
    }
    for (int i=0;i<c;i++)
    {
        selImportTo[i]->setNewEntries(number_of_cols+1,entries,values);
        connect(selColFormats[i]->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(columnSizeChanged(int)));
        if (i<selector_count)
        {
            selColFormats[i]->setCurrentIndex(sel_ind[i]);
            selImportTo[i]->setCurrentIndex(sel_ind2[i]);
            selColSize[i]->setValue(sel_ind3[i]);
            if (selColFormats[i]->currentValue())
                selColSize[i]->setEnabled(false);
            else
                selColSize[i]->setEnabled(true);
        }
        else
        {
            selColSize[i]->setValue(1);
            selColSize[i]->setEnabled(true);
        }
    }

    selector_count=c;
    delete[] sel_ind;
    delete[] sel_ind2;
}

void frmIOForm::columnSizeChanged(int c)
{
    (void)c;
    for (int i=0;i<selector_count;i++)
    {
        if (selColFormats[i]->currentValue())
        {
            selColSize[i]->setEnabled(false);
            selColSize[i]->setValue(binaryImportFormat[selColFormats[i]->currentValue()].size);
            selImportTo[i]->setEnabled(true);
        }
        else
        {
            selColSize[i]->setEnabled(true);
            selImportTo[i]->setEnabled(false);
            selImportTo[i]->setCurrentIndex(0);
        }
    }
}

GlyphPanel::GlyphPanel(QWidget * parent):QLabel(parent)
{
    number=-1;
    marked=false;
    pix=new QPixmap(25,25);
    pix->fill(QApplication::palette().window().color());
    setPixmap(*pix);
    setFrameStyle(QFrame::Box | QFrame::Raised);
    setMinimumSize(25,25);
    setMaximumSize(32,32);
}

void GlyphPanel::setMarked(bool mark)
{
    marked=mark;
    if (mark==true)
    {
        setFrameStyle(QFrame::WinPanel | QFrame::Raised);
    }
    else
    {
        setFrameStyle(QFrame::Box | QFrame::Raised);
    }
}

void GlyphPanel::setCurrentPixmap(int font_nr,int char_nr)
{
    number=char_nr;
    font=font_nr;

    if (useQtFonts!=true)
    {
        *pix=DrawCB((unsigned char)number,font,valid_char);
    }
    else
    {
        pix=new QPixmap(25,25);
        pix->fill(QApplication::palette().window().color());
        QChar car(char_nr);
        QPainter paint1;
        QFont dfont=getFontFromDatabase(font_nr);
        dfont.setPixelSize(15);
        paint1.begin(pix);
        paint1.setFont(dfont);
        paint1.drawText(5,20,QString(car));
        paint1.end();
        valid_char=true;
    }

    setPixmap(*pix);
}

void GlyphPanel::mousePressEvent(QMouseEvent *event)
{
    (void)event;
    emit(panelClicked(number));
}

QPixmap GlyphPanel::DrawCB(unsigned char c,int FontID,bool & valid_char)
{
    float Size = 16.8;//who knows where this value comes from?
    BBox bbox;
    GLYPH *glyph;
    int height, width;// hshift, vshift;
    QPixmap tmpBitmap;
    QColor bg;
    QPainter paint1;
    QPainter paint2;
    height=width=0;

    bg=QApplication::palette().window().color();

    if (FontID == BAD_FONT_ID) {
        glyph = NULL;
    } else {
        glyph = T1_SetChar(FontID, c, Size, &UNITY_MATRIX);
    }

    bbox = T1_GetFontBBox(FontID);
    /* check if bbox is zero or invalid and then calculate it ourselves */
    if (bbox.llx >= bbox.urx || bbox.lly >= bbox.ury) {
        int c;
        memset(&bbox, 0, sizeof(bbox));
        for (c = 0; c < 256; c++) {
            BBox bbox_tmp = T1_GetCharBBox(FontID, c);
            bbox.llx = MIN2(bbox.llx, bbox_tmp.llx);
            bbox.lly = MIN2(bbox.lly, bbox_tmp.lly);
            bbox.urx = MAX2(bbox.urx, bbox_tmp.urx);
            bbox.ury = MAX2(bbox.ury, bbox_tmp.ury);
        }
    }

    if (glyph != NULL && glyph->bits != NULL) {
        valid_char = TRUE;
        height = glyph->metrics.ascent - glyph->metrics.descent;
        width = glyph->metrics.rightSideBearing - glyph->metrics.leftSideBearing;
        /*hshift = MAX2(glyph->metrics.leftSideBearing - bbox.llx, 0);
        vshift = MAX2(bbox.ury - glyph->metrics.ascent, 0);*/

        /*XtVaGetValues(w, XmNbackground, &bg, XmNforeground, &fg, NULL);
     XSetForeground(disp, gc, bg);*/

        tmpBitmap=QPixmap(width,height);
        tmpBitmap.fill(bg);
        paint2.begin(&tmpBitmap);
        char kkk;
        char s;
        int c_counter;
        int nr_of_bytes= 8*(width/8)==width ? width/8 : width/8+1;
        for (int jjj=0;jjj<height;jjj++)
        {
            c_counter=0;
            for (int iii=0;iii<nr_of_bytes;iii++)//bytes
            {
                kkk=glyph->bits[jjj*nr_of_bytes+iii];
                for (int lll=0;lll<8;lll++)//8bits per byte
                {
                    s=1<<lll;
                    if (kkk&s)
                        paint2.drawPoint(c_counter,jjj);
                    c_counter++;
                    if (c_counter>=width) break;
                }
            }
        }
        paint2.end();

        /*ptmp = XCreateBitmapFromData(disp, root,(char *) glyph->bits, width, height);
     XSetBackground(disp, gc, bg);
        pixmap = XCreatePixmap(disp, root, bbox.urx - bbox.llx, bbox.ury - bbox.lly, depth);
        XFillRectangle(disp, pixmap, gc, 0, 0, bbox.urx - bbox.llx, bbox.ury - bbox.lly);
     XSetForeground(disp, gc, fg);
        XCopyPlane(disp, ptmp, pixmap, gc, 0, 0, width, height, hshift, vshift, 1);
        XFreePixmap(disp, ptmp);*/

    } else {
        if (c == ' ') {
            valid_char = TRUE;
        } else {
            valid_char = FALSE;
        }
        //        pixmap =  XCreateBitmapFromData(disp, root,dummy_bits, 1, 1);
    }
    if (width<=0)
        width=25;
    if (height<=0)
        height=25;

    QPixmap pixmap(25,25);
    pixmap.fill(bg);

    if (glyph != NULL && glyph->bits != NULL)
    {
        paint1.begin(&pixmap);
        paint1.drawPixmap((25-width)/2+glyph->metrics.leftSideBearing,(25-height)/2-glyph->metrics.descent,QPixmap(tmpBitmap));
        paint1.end();
    }

    /* Assign it a pixmap */
    //    cbs->pixmap = pixmap;
    //    cbs->type = XbaePixmap;
    //    XbaeMatrixSetCellUserData(w, cbs->row, cbs->column, (XtPointer) valid_char);
    return pixmap;
}

frmFontTool::frmFontTool(QWidget * parent):QDialog(parent)
{
    //0x152f   = 338 * 16 = 5423
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Font tool"));
    setWindowIcon(QIcon(*GraceIcon));

    selFont=new FontSelector(this);
    scroll=new QScrollArea(this);
    background=new QWidget(scroll);
    layout0=new QGridLayout;
    layout0->setMargin(0);
    layout0->setSpacing(0);
    int r=0,c=0;
    tileCount=16*338;//we always generate all glyph-panels
    for (int i=0;i<tileCount;i++)
    {
        panel[i]=new GlyphPanel(background);
        panel[i]->number=i;
        layout0->addWidget(panel[i],r,c);
        c++;
        if (c>=16)
        {
            r++;
            c=0;
        }
        connect(panel[i],SIGNAL(panelClicked(int)),SLOT(newClick(int)));
    }
    tileCount=16*16;
    if (useQtFonts==true)
        tileCount=16*338;
    background->setLayout(layout0);
    scroll->setWidget(background);

    ledString=new stdLineEdit(this,tr("CString:"));
    connect(ledString->lenText,SIGNAL(textEdited(QString)),SLOT(characterInserted(QString)));

    ledAscii=new stdLineEdit(this,tr("Ascii:"));
    ledAscii->setText("");
    ledAscii->lenText->setEnabled(false);
    ledUnicode=new stdLineEdit(this,tr("Unicode:"));
    ledUnicode->setText("");
    ledUnicode->lenText->setEnabled(false);

    /*cmdUseSymbolValue=new QPushButton(tr("Use ascii-value for symbol-character"),this);
    cmdUseSymbolValue->setToolTip(tr("Transfer the ascii-value of the last selected character\nas symbol to the current set-appearance.\nThis dialog is closed afterwards."));
    connect(cmdUseSymbolValue,SIGNAL(clicked(bool)),SLOT(doUseSymbolValue()));*/

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout->addWidget(selFont,0,0,1,2);
    layout->addWidget(scroll,1,0,2,2);
    layout->addWidget(ledString,3,0,1,2);
    layout->addWidget(ledAscii,4,0,1,1);
    layout->addWidget(ledUnicode,4,1,1,1);
    //layout->addWidget(cmdUseSymbolValue,4,2,1,1);
    layout->addWidget(buttonGroup,5,0,1,2);

        for (int i=0;i<6;i++)
        layout->setRowStretch(i,1);
        layout->setRowStretch(1,30);
        layout->setRowStretch(2,30);

    setLayout(layout);
    connect(selFont->cmbFontSelect,SIGNAL(currentIndexChanged(int)),SLOT(FontChanged(int)));
    FontChanged(0);
    marked=-1;
    ledString->setText(QString(""));
    textString=QString("");
    resize(LastSize_FormFontTool);
}

frmFontTool::~frmFontTool()
{
    LastSize_FormFontTool=this->size();
}

void frmFontTool::FontChanged(int i)
{
    if (i<0) return;

    if (useQtFonts==false)
    {
        tileCount=16*16;
        for (int j=0;j<tileCount;j++)
            panel[j]->setCurrentPixmap(i,j);
        for (int j=tileCount;j<16*338;j++)
            panel[j]->setVisible(false);
        background->resize(QSize(16*panel[0]->width(),16*panel[0]->height()));
    }
    else
    {
        tileCount=16*338;
        QPainter paint1;
        QFont dfont=getFontFromDatabase(i);
        QChar car;
        dfont.setPixelSize(15);
        car=QChar(0);
        panel[0]->valid_char=car.isPrint();
        paint1.begin(panel[0]->pix);
        panel[0]->pix->fill(QApplication::palette().window().color());
        paint1.setFont(dfont);
        paint1.setPen(Qt::black);
        paint1.drawText(5,20,QString(car));
        paint1.end();
        panel[0]->number=0;
        panel[0]->setPixmap(*(panel[0]->pix));
        panel[0]->valid_char=false;
        for (int j=1;j<tileCount;j++)
        {
                if (i==get_QtFontID_from_Grace_Name("Symbol",0) && symbol_font_is_special==true)
                car=QChar(key_for_greek.value(j,j));//new_ascii=key_for_greek.value(ascii,ascii);
                else
                car=QChar(j);
            paint1.begin(panel[j]->pix);
            panel[j]->pix->fill(QApplication::palette().window().color());
            paint1.setFont(dfont);
            paint1.drawText(5,20,QString(car));
            paint1.end();
            panel[j]->setPixmap(*(panel[j]->pix));
            panel[j]->valid_char=car.isPrint();
            panel[j]->number=j;
            panel[j]->setVisible(true);
        }
        background->resize(QSize(16*panel[0]->width(),338*panel[0]->height()));
    }
    layout0->update();
    char * buf;
    buf = copy_string(NULL, "\\f{");
    buf = concat_strings(buf, get_fontalias(i));
    buf = concat_strings(buf, "}");
    textString=ledString->text();
    QString charText=QString(buf);
    insertAtCursor(charText);
    xfree(buf);
}

void frmFontTool::newClick(int i)
{
    QString charText;
    unsigned char c;
    char s[7];
    //cout << "marked=" << marked << " clicked=" << i << endl;
    if (marked>=0 && marked<16*338)
    {
        panel[marked]->setMarked(false);
    }
    marked=i;
    if (marked>=0 && marked<16*338)
    {
        panel[marked]->setMarked(true);
    }
    last_character=i;
    /// cout << "char-number=" << i << endl;
    if (panel[i]->valid_char==false)
    {
        QApplication::beep();
    }
    else if (useQtFonts==true)
    {
        textString=ledString->text();
        charText=QString(QChar(i));
        //ledString->lenText->insert(charText);
        insertAtCursor(charText);
        return;
        //char t2(i);
        //charText=FileCodec->toUnicode(&t2);
        /// cout << i << " #" << charText.toLocal8Bit().constData() << "# " << sizeof(char) << endl;
        //insertAtCursor(charText);
    }
    else
    {
        textString=ledString->text();
        c = panel[i]->number;
        /* TODO: check for c being displayable in the _X_ font */
        if (c > 31)
        {
            s[0] = (char) c;
            s[1] = '\0';
        }
        else
        {
            sprintf(s, "\\#{%02x}", c);
        }
        if (c<128)
        {
            charText=QString(s);
        }
        else
        {
            charText=QString("\\c")+QString((char)(c-128))+QString("\\C");
        }
        insertAtCursor(charText);
    }
}

void frmFontTool::doUseSymbolValue(void)
{
int val=atoi(ledAscii->text().toLocal8Bit().constData());

//if (!QChar::isPrint(val))
if (!isprint(val))
{
errmsg(tr("No printable ascii-character selected.").toLocal8Bit().constData());
return;
}
if (FormSetAppearance==NULL)
{
errmsg(tr("No set appearance dialog opened.").toLocal8Bit().constData());
return;
}
else if (FormSetAppearance->isVisible()==false)
{
errmsg(tr("No set appearance dialog opened.").toLocal8Bit().constData());
return;
}

FormSetAppearance->flp->tabMa->selSymbChar->setCurrentValue(val);
//FormSetAppearance->flp->tabMa->ledSymbChar->setText(ledAscii->text());
FormSetAppearance->flp->tabMa->cmbSymbType->setCurrentIndex(SYM_CHAR);

//qDebug() << "val=" << val << " last_char=" << last_character << " printable=" << QChar::isPrint(last_character);

hide();
FormSetAppearance->show();
FormSetAppearance->raise();
FormSetAppearance->activateWindow();
FormSetAppearance->setFocus();
}

void frmFontTool::insertAtCursor(QString c)
{
    //if(last_character>=0 && last_character<256)
    ledAscii->setText(QString::number(last_character));
    /*else
    ledAscii->setText(QString("-"));*/
    ledUnicode->setText(QString::number(last_character));

    int position=ledString->lenText->cursorPosition();
    textString=textString.insert(position,c);
    ledString->lenText->setText(textString);
    ledString->lenText->setCursorPosition(position+c.length());
}

void frmFontTool::characterInserted(QString text)
{
    int i;
    char c='\0';
    int len1=textString.length(),len2=text.length();
    int minlength= len1<len2 ? len1 : len2;
    if (text.length()>0)
    {
    QChar l_c=text.at(text.length()-1);
    ledUnicode->setText(QString::number(l_c.unicode()));
    if (l_c.unicode()<256) ledAscii->setText(QString::number(l_c.unicode()));
    else ledAscii->setText(QString("-"));
    }
    for (i=0;i<minlength;i++)
    {
        if (text.at(i)!=textString.at(i)) break;
    }
    if (i==minlength)
    {//the new character is the last character
        if (len1>len2)
        {
            c=textString.at(i).toLatin1();
        }
        else
        {
            c=text.at(i).toLatin1();
        }
    }
    else
    {
        c=text.at(i).toLatin1();
    }
    textString=text;
    /*if (c>=0 && c<256)//Ascii-Character
        {*/
    if (marked>=0 && marked<16*338)
    {
        panel[marked]->setMarked(false);
    }
    marked=(int) c;
    if (marked>=0 && marked<16*16)
    {
        panel[marked]->setMarked(true);
    }
    last_character=marked;
    /*}*/
}

void frmFontTool::doApply(void)
{
    /* I don't know what this widget should do when Apply is pressed!??? */
}

void frmFontTool::doClose(void)
{
    hide();
}

void frmFontTool::doAccept(void)
{
    doApply();
    doClose();
}

frmFourier::frmFourier(QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[7];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr("QtGrace: Fourier transforms"));

    lblApplyTo=new QLabel(tr("Apply to set:"),this);
    sel=new uniList(SETCHOICE,this);

    buttonGroup=new stdButtonGroup(this,true,true,true);
    buttonGroup->cmdAccept->setText(tr("FFT"));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doFFT()));
    buttonGroup->cmdApply->setText(tr("DFT"));
    buttonGroup->cmdApply->setDefault(TRUE);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doDFT()));
    buttonGroup->cmdClose->setText(tr("Window only"));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doWindowOnly()));
    buttonGroup->cmdHelp->setText(tr("Close"));
    connect(buttonGroup->cmdHelp,SIGNAL(clicked()),this,SLOT(doClose()));

    chk_scale=new QCheckBox(tr("Divide magnitude by set-length"),this);
    chk_scale->setChecked(true);

    number=7;
    entr[0]=tr("None (Rectangular)");
    entr[1]=tr("Triangular");
    entr[2]=tr("Hanning");
    entr[3]=tr("Welch");
    entr[4]=tr("Hamming");
    entr[5]=tr("Blackman");
    entr[6]=tr("Parzen");
    selectors[0]=new StdSelector(this,tr("Data window:"),number,entr);
    number=3;
    entr[0]=tr("Magnitude");
    entr[1]=tr("Phase");
    entr[2]=tr("Coefficients");
    selectors[1]=new StdSelector(this,tr("Load result as:"),number,entr);
    number=3;
    entr[0]=tr("Index");
    entr[1]=tr("Frequency");
    entr[2]=tr("Period");
    selectors[2]=new StdSelector(this,tr("Let result X="),number,entr);
    number=2;
    entr[0]=tr("Transform");
    entr[1]=tr("Inverse transform");
    selectors[3]=new StdSelector(this,tr("Perform:"),number,entr);
    number=2;
    entr[0]=tr("Real");
    entr[1]=tr("Complex");
    selectors[4]=new StdSelector(this,tr("Data is:"),number,entr);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(lblApplyTo);
    layout->addWidget(sel);
    layout->addWidget(selectors[0]);
    layout->addWidget(selectors[1]);
    layout->addWidget(selectors[2]);
    layout->addWidget(selectors[3]);
    layout->addWidget(selectors[4]);
    layout->addWidget(chk_scale);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormFourier);
}

frmFourier::~frmFourier()
{
    LastSize_FormFourier=this->size();
}

void frmFourier::init(void)
{
    sel->update_number_of_entries();
}

void frmFourier::doDFT(void)
/*
 * DFT
 */
{
    int gno = get_cg();
    int *selsets=new int[5];
    int i, cnt;
    int setno, load, loadx, invflag, type, wind;
    cnt = GetSelectedSets(sel, &selsets);
    if (cnt == SET_SELECT_ERROR)
    {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        return;
    }
    wind = GetChoice(selectors[0]);
    load = GetChoice(selectors[1]);
    loadx = GetChoice(selectors[2]);
    invflag = GetChoice(selectors[3]);
    type = GetChoice(selectors[4]);
    set_wait_cursor();
    int *gnos=new int[cnt];
    int *snos=new int[cnt];
    int counter=0;//,resno;
    char dummy[64];
    //double factor;
    for (i = 0; i < cnt; i++)
    {
        setno = selsets[i];
        new_set_no=-1;
        do_fourier(gno, setno, 0, load, loadx, invflag, type, wind);
        if (new_set_no>=0)
        {
            gnos[counter]=gno;
            snos[counter++]=new_set_no;
        }
        if (chk_scale->isChecked()==true && wind>0 && load==0)
        {
            sprintf(dummy,"y=y*2.0");
            //factor=2.0/getsetlength(gno,new_set_no);
            //sprintf(dummy,"Y=Y*%lf",1.0/factor);
            //resno = do_compute(gno, new_set_no, gno, new_set_no, NULL, dummy);
            (void)do_compute(gno, new_set_no, gno, new_set_no, NULL, dummy);
        }
    }
    if (counter>0)
    {
        ///Undo-Stuff
        SetsCreated(counter,gnos,snos,UNDO_COMPLETE);
        if (counter==1)
        {
            sprintf(dummy,"[G%d.S%d]",gno,selsets[0]);
            addAditionalDescriptionToLastNode(-1,QObject::tr("Fourier transformation (DFT)")+QString(dummy),QString());
        }
        else
        {
            addAditionalDescriptionToLastNode(-1,QObject::tr("Fourier transformation (DFT)"),QString());
        }
    }
    delete[] snos;
    delete[] gnos;
    update_set_lists(gno);
    delete[] selsets;
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
}

void frmFourier::doFFT(void)
/*
 * DFT by FFT
 */
{
    int gno = get_cg();
    int *selsets=new int[5];
    int i, cnt;
    int setno, load, loadx, invflag, type, wind;
    cnt = GetSelectedSets(sel, &selsets);
    if (cnt == SET_SELECT_ERROR)
    {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        return;
    }
    wind = GetChoice(selectors[0]);
    load = GetChoice(selectors[1]);
    loadx = GetChoice(selectors[2]);
    invflag = GetChoice(selectors[3]);
    type = GetChoice(selectors[4]);
    set_wait_cursor();
    int *gnos=new int[cnt+2];
    int *snos=new int[cnt+2];
    int counter=0;//,resno;
    double factor;
    char dummy[64];
    for (i = 0; i < cnt; i++)
    {
        setno = selsets[i];
        new_set_no=-1;
        do_fourier(gno, setno, 1, load, loadx, invflag, type, wind);
        if (new_set_no>=0)
        {
            gnos[counter]=gno;
            snos[counter++]=new_set_no;
            if (chk_scale->isChecked()==true && load==0 && !(use_fftw3==TRUE && have_fftw3==TRUE))
            {
                if (wind==0)
                factor=2.0;
                else
                factor=1.0;
            factor*=getsetlength(gno,new_set_no);
            factor=1.0/factor;
                for (int k=0;k<g[gno].p[new_set_no].data.len;k++)
                {
                g[gno].p[new_set_no].data.ex[1][k]*=factor;
                }
            //sprintf(dummy,"Y=Y*%lf",factor);
            //cout << "Umrechnungsfaktor: " << dummy << endl;
            //resno = do_compute(gno, new_set_no, gno, new_set_no, NULL, dummy);
            }
        }
    }
    if (counter>0)
    {
        ///Undo-Stuff
        SetsCreated(counter,gnos,snos,UNDO_COMPLETE);
        if (counter==1)
        {
            sprintf(dummy,"[G%d.S%d]",gno,selsets[0]);
            addAditionalDescriptionToLastNode(-1,QObject::tr("Fourier transformation (FFT)")+QString(dummy),QString());
        }
        else
        {
            addAditionalDescriptionToLastNode(-1,QObject::tr("Fourier transformation (FFT)"),QString());
        }
    }
    delete[] snos;
    delete[] gnos;
    update_set_lists(gno);
    delete[] selsets;
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
}

void frmFourier::doWindowOnly(void)
/*
 * Apply data window only
 */
{
    int *selsets=new int[5];
    int i, cnt;
    int setno, type, wind;
    //Four_ui *ui = (Four_ui *) client_data;
    cnt = GetSelectedSets(sel, &selsets);
    if (cnt == SET_SELECT_ERROR) {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        return;
    }
    wind = GetChoice(selectors[0]);
    type = GetChoice(selectors[4]);
    set_wait_cursor();
    for (i = 0; i < cnt; i++) {
        setno = selsets[i];
        do_window(setno, type, wind);
    }
    update_set_lists(get_cg());
    delete[] selsets;
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
}

void frmFourier::doClose(void)
{
    hide();
}

void generateLowPass_Brickwall(double * f,int n,double f_cutoff,double * cutoff_Function_r,double * cutoff_Function_i)
{
    for (int i=0;i<n;i++)
        cutoff_Function_i[i]=cutoff_Function_r[i]=((fabs(f[i])<f_cutoff)?1.0:(fabs(f[i])==f_cutoff?0.5:0.0));
}

void generateLowPass_Butterworth_simple(double * f,int n,double f_cutoff,int order,double * cutoff_Function_r,double * cutoff_Function_i)
{
    for (int i=0;i<n;i++)
        cutoff_Function_i[i]=cutoff_Function_r[i]=1.0/sqrt(1.0+pow(f[i]/f_cutoff,2.0*order));
}

void generateLowPass_Butterworth(double * f,int n,double f_cutoff,int order,double * cutoff_Function_r,double * cutoff_Function_i)
{
    struct komplex * ko=new struct komplex[n];
    struct komplex help1;
    double help2;
    double ai,bi;
    for (int i=0;i<n;i++)
        ko[i]=one;
    for (int j=1;j<=(order+1)/2;j++)
    {
        if (1-(order%2))//even
        {
            if (j>order/2) continue;
            bi=1.0;
            ai=2.0*cos((2.0*j-1.0)*M_PI/order*0.5);
        }
        else//odd
        {
            if (j==1)
            {
                bi=0.0;
                ai=1.0;
            }
            else
            {
                bi=1.0;
                ai=2.0*cos((j-1.0)*M_PI/order);
            }
        }
        for (int i=0;i<n;i++)
        {
            help2=f[i]/f_cutoff;
            help1.real=1.0-bi*help2*help2;
            help1.imag=-ai*help2;//ACHTUNG: '-' hinzugefügt
            ko[i]=mult_komplex(ko[i],help1);
        }
    }
    for (int i=0;i<n;i++)
    {
        ko[i]=div_komplex(one,ko[i]);
        cutoff_Function_r[i]=ko[i].real;
        cutoff_Function_i[i]=ko[i].imag;
    }
    delete[] ko;
}

void generateLowPass_Bessel(double * f,int n,double f_cutoff,int order,double * cutoff_Function_r,double * cutoff_Function_i)
{
    struct komplex * ko=new struct komplex[n];
    struct komplex help1=zero;
    struct komplex help2=zero;
    double ci=1.0;
    for (int i=0;i<n;i++)
    {
        ko[i].real=1.0;
        ko[i].imag=ci*f[i]/f_cutoff;
    }
    for (int j=2;j<=order;j++)
    {
        ci*=(2.0*(order-j+1.0))/(j*(2.0*order-j+1.0));
        for (int i=0;i<n;i++)
        {
            help2.imag=f[i]/f_cutoff;
            help1=pow_komplex(help2,j);
            help1.real*=ci;
            help1.imag*=ci;
            ko[i]=add_komplex(ko[i],help1);
        }
    }
    for (int i=0;i<n;i++)
    {
        ko[i]=div_komplex(one,ko[i]);
        cutoff_Function_r[i]=ko[i].real;
        cutoff_Function_i[i]=-ko[i].imag;//ACHTUNG: '-' hinzugefügt
    }
    delete[] ko;
}

void generateLowPass_Chebychev(double * f,int n,double f_cutoff,int order,double ripple,double * cutoff_Function_r,double * cutoff_Function_i)
{
    struct komplex help1;
    struct komplex * ko=new struct komplex[n];
    double gamma=asinh(ripple)/order;//ripples are in dB
    double ai,bi;
    double help;
    for (int i=0;i<n;i++)
        ko[i]=one;
    for (int j=1;j<=order;j++)
    {
        if (1-(order%2))//even
        {
            help=cos((2.0*j-1.0)*M_PI*0.5/order);
            bi=1.0/(cosh(gamma)*cosh(gamma)-help*help);
            ai=2.0*bi*sinh(gamma)*help;
        }
        else//odd
        {
            if (j==1)
            {
                bi=0.0;
                ai=1.0/sinh(gamma);
            }
            else
            {
                help=cos((j-1.0)*M_PI/order);
                bi=1.0/(cosh(gamma)*cosh(gamma)-help*help);
                ai=2.0*bi*sinh(gamma)*help;
            }
        }
        for (int i=0;i<n;i++)
        {
            help=f[i]/f_cutoff;
            help1.real=1.0-bi*help*help;
            help1.imag=ai*help;
            ko[i]=mult_komplex(ko[i],help1);
        }
    }
    for (int i=0;i<n;i++)
    {
        ko[i]=div_komplex(one,ko[i]);
        cutoff_Function_r[i]=ko[i].real;
        cutoff_Function_i[i]=ko[i].imag;
    }
    delete[] ko;
}

void generateLowPass_Chebychev2(double * f,int n,double f_cutoff,int order,double ripple,double * cutoff_Function_r,double * cutoff_Function_i)
{
    double epsilon=1.0/sqrt(pow(10.0,0.1*ripple)-1.0);
    komplex t1={1.0,0.0};
    komplex t2={1.0,0.0};
    komplex T;
    komplex x;
    for (int i=0;i<n;i++)
    {
        x.imag=t2.imag=f[i]/f_cutoff;
        x.real=t2.real=0.0;
        if (order==1)
            T=t1;//order=1
        else
            T=t2;//order=2 or greater
        for (int j=3;j<order;j++)
        {
            T=mult_komplex(t2,x);
            T.real*=2.0;
            T.imag*=2.0;
            T=sub_komplex(T,t1);
            ///T=2.0*x*t2-t1;//order=3 --> T=T3=2*x*T2-t1
            t1=t2;
            t2=T;
        }
        x=T;
        x.real*=epsilon;
        x.imag*=epsilon;
        ///x=epsilon*T;
        x=mult_komplex(x,x);
        x.real+=1.0;
        T=pow_komplex(x,-0.5);
        cutoff_Function_r[i]=T.real;
        cutoff_Function_i[i]=T.imag;
        //cutoff_Function_r[i]=cutoff_Function_i[i]=1.0/sqrt(1.0+x);
    }
}

void generateLowPass_Gaussian(double * f,int n,double f_cutoff,int order,double * cutoff_Function_r,double * cutoff_Function_i)
{
    static double alpha=M_PI/sqrt(log(2.0));
/// Order of Gaussian is missing!? Is there a order in gaussian?
    (void)order;
    for (int i=0;i<n;i++)
        cutoff_Function_r[i]=cutoff_Function_i[i]=exp(-f[i]*f[i]/(2.0*alpha*f_cutoff*f_cutoff))/sqrt(2.0);
}

frmFourier2::frmFourier2(QWidget * parent):QDialog(parent)
{
    int rowcount=0;
    int number;
    char dummy[128];
    QString entr[9];
    int values[9];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr("QtGrace: Filters"));

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    buttonGroup->cmdApply->setDefault(TRUE);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doFilter()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    grpSource=new grpSelect(tr("Source"),this);
    grpDestination=new grpSelect(tr("Destination"),this);
    grpDestination->enable_sync(grpSource->listSet);

    entr[0]=tr("Low-Pass");
    values[0]=FILTER_LOW_PASS;
    entr[1]=tr("High-Pass");
    values[1]=FILTER_HIGH_PASS;
    entr[2]=tr("Band-Pass");
    values[2]=FILTER_BAND_PASS;
    entr[3]=tr("Band-Stop");
    values[3]=FILTER_BAND_STOP;
    number=4;
    selType=new StdSelector(this,tr("Filter type:"),number,entr);
    selType->setValues(values);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(filterTypeChanged(int)));

    entr[0]=tr("Brickwall");
    values[0]=FILTER_BRICKWALL;
    entr[1]=tr("Butterworth");
    values[1]=FILTER_BUTTERWORTH;
    entr[2]=tr("Bessel");
    values[2]=FILTER_BESSEL;
    entr[3]=tr("Chebychev");
    values[3]=FILTER_CHEBYCHEV;
    entr[4]=tr("Gaussian");
    values[4]=FILTER_GAUSSIAN;
    entr[5]=tr("Butterworth-simple");
    values[5]=FILTER_BUTTERWORTH_SIMPLE;
    number=5;//Number 5 is not used/not accessible here
    selKind=new StdSelector(this,tr("Realization:"),number,entr);
    selKind->setValues(values);
    connect(selKind->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(filterKindChanged(int)));

    entr[0]=tr("No");
    for (int i=1;i<=7;i++)
    {
        sprintf(dummy,"%dx",1<<i);
        entr[i]=QString(dummy);
    }
    number=8;
    selOversampling=new StdSelector(this,tr("Oversampling:"),number,entr);
    chkAbsValue=new QCheckBox(tr("use absolute value of transfer-function"),this);
    chkDebug=new QCheckBox(tr("Debug"),this);
    lenRipple=new stdLineEdit(this,tr("Ripples in transfer-function in dB:"));

    gpbLow=new QGroupBox(tr("First Cut-Off"),this);
    gpbHigh=new QGroupBox(tr("Second Cut-Off"),this);
    layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout2=new QHBoxLayout;
    layout2->setMargin(STD_MARGIN);

    lenLowFrequency=new stdLineEdit(gpbLow,tr("Frequency (kHz):"));
    selLowOrder=new stdIntSelector(gpbLow,tr("Order:"),1,30);
    layout1->addWidget(lenLowFrequency);
    layout1->addWidget(selLowOrder);

    lenHighFrequency=new stdLineEdit(gpbHigh,tr("Frequency (kHz):"));
    selHighOrder=new stdIntSelector(gpbHigh,tr("Order:"),1,30);
    layout2->addWidget(lenHighFrequency);
    layout2->addWidget(selHighOrder);

    gpbLow->setLayout(layout1);
    gpbHigh->setLayout(layout2);

    gpbProcessing=new QGroupBox(tr("FFT-processing options"),this);
    layout3=new QGridLayout;
    layout3->setMargin(STD_MARGIN);
    lenTimeFormula=new stdLineEdit(this,tr("conversion-factor for x-axis to time(s): X=X*"));
    entr[0]=tr("Interpolation");
    values[0]=PROCESSING_INTERPOLATION;
    entr[1]=tr("Zero Padding");
    values[1]=PROCESSING_ZERO_PADDING;
    entr[2]=tr("Pad first and last value");
    values[2]=PROCESSING_FIRST_LAST_PADDING;
    number=3;
    selPoints=new StdSelector(this,tr("Point extension:"),number,entr);
    selPoints->setValues(values);
    connect(selPoints->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(selPointsChanged(int)));

    layout3->addWidget(lenTimeFormula,0,0,1,2);
    layout3->addWidget(selPoints,1,0,1,1);
    layout3->addWidget(selOversampling,1,1,1,1);
    layout3->addWidget(chkAbsValue,2,0,1,1);
    layout3->addWidget(chkDebug,2,1,1,1);
    layout3->addWidget(lenRipple,3,0,1,2);
    gpbProcessing->setLayout(layout3);

    fraSourceDatFilt=new QGroupBox(tr("Source data filtering"),this);
    number=7;
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRestriction=new StdSelector(fraSourceDatFilt,tr("Restriction:"),number,entr);
    chkNeg=new QCheckBox(tr("Negated"),fraSourceDatFilt);
    chkNeg->setChecked(FALSE);
    layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(selRestriction);
    layout0->addWidget(chkNeg);
    fraSourceDatFilt->setLayout(layout0);

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpSource,rowcount,0,1,1);
    layout->addWidget(grpDestination,rowcount++,1,1,1);
    layout->addWidget(selType,rowcount,0,1,1);
    layout->addWidget(selKind,rowcount++,1,1,1);

    layout->addWidget(gpbLow,rowcount++,0,1,2);
    layout->addWidget(gpbHigh,rowcount++,0,1,2);
    layout->addWidget(gpbProcessing,rowcount++,0,1,2);

    layout->addWidget(fraSourceDatFilt,rowcount++,0,1,2);
    layout->addWidget(buttonGroup,rowcount++,0,1,2);
    setLayout(layout);
    chkAbsValue->setChecked(true);
    resize(LastSize_FormFourier2);
}

frmFourier2::~frmFourier2()
{
    LastSize_FormFourier2=this->size();
}

void frmFourier2::init(void)
{
    lenLowFrequency->setText(QString("50"));
    lenHighFrequency->setText(QString("100"));
    lenTimeFormula->setText(QString("1"));
    lenRipple->setText(QString("10"));
    selOversampling->setCurrentIndex(0);
    selLowOrder->setValue(2);
    selHighOrder->setValue(2);
    selPoints->setCurrentValue(PROCESSING_ZERO_PADDING);
    selKind->setCurrentValue(FILTER_BUTTERWORTH);
    filterKindChanged(FILTER_BUTTERWORTH);
    selType->setCurrentValue(FILTER_LOW_PASS);
    filterTypeChanged(FILTER_LOW_PASS);
    grpSource->update_number_of_entries();
    grpDestination->update_number_of_entries();
}

void frmFourier2::doAccept(void)
{
    doFilter();
    if (ApplyError==false)
        doClose();
}

void frmFourier2::doFilter(void)
{
    ApplyError=false;
    double f1,f2,ripple;
    int order1,order2;
    double factor=1.0;
    if (selKind->currentValue()==FILTER_BRICKWALL && chkAbsValue->isChecked())
    {
        factor=1.0/sqrt(2.0);
    }
    int error, resno;
    int g1_ok, g2_ok, ns1, ns2, * svalues1=new int[2], * svalues2=new int[2],gno1, gno2, setno1, setno2;
    char fstr[256];
    int restr_type, restr_negate;
    char * rarray;
    int * sel_graphs=new int[2];
    int setlen;
    int n_setlen;
    double xspace;
    bool mono;
    int * o_snos=NULL,*o_gnos=NULL;
    int * snos=NULL,*gnos=NULL;
    int n_n_sets=0;
    int workset1,workset2,workset3,workset4,workset5;
    double * mesh = NULL;
    char old_comment[MAX_STRING_LENGTH],old_orig_comment[MAX_STRING_LENGTH];

    set_wait_cursor();
    setno1=setno2=-1;
    gno1=gno2=0;
    error=xv_evalexpr(lenLowFrequency,&f1);
    f1*=1000.0;//input is in kHz, calculation in Hz
    if ((selType->currentValue()==FILTER_LOW_PASS || selType->currentValue()==FILTER_BAND_PASS || selType->currentValue()==FILTER_BAND_STOP) && error==RETURN_FAILURE)
    {
        errmsg(tr("Invalid low pass cut-off-frequency entered!").toLocal8Bit().constData());
        ApplyError=true;
        goto end_of_filter_function;
    }
    error=xv_evalexpr(lenHighFrequency,&f2);
    f2*=1000.0;
    if ((selType->currentValue()==FILTER_HIGH_PASS || selType->currentValue()==FILTER_BAND_PASS || selType->currentValue()==FILTER_BAND_STOP) && error==RETURN_FAILURE)
    {
        errmsg(tr("Invalid high pass cut-off-frequency entered!").toLocal8Bit().constData());
        ApplyError=true;
        goto end_of_filter_function;
    }
    order1=selLowOrder->value();
    order2=selHighOrder->value();
    error=xv_evalexpr(lenRipple,&ripple);
    if (selKind->currentValue()==FILTER_CHEBYCHEV && error==RETURN_FAILURE)
    {
        errmsg(tr("Invalid ripple-value entered for Chebychev filter!").toLocal8Bit().constData());
        ApplyError=true;
        goto end_of_filter_function;
    }
    switch (selRestriction->currentIndex())
    {
    case 0:
    default:
        restr_type=RESTRICT_NONE;
        break;
    case 1:
        restr_type=RESTRICT_REG0;
        break;
    case 2:
        restr_type=RESTRICT_REG1;
        break;
    case 3:
        restr_type=RESTRICT_REG2;
        break;
    case 4:
        restr_type=RESTRICT_REG3;
        break;
    case 5:
        restr_type=RESTRICT_REG4;
        break;
    case 6:
        restr_type=RESTRICT_WORLD;
        break;
    }

    restr_negate = chkNeg->isChecked()==TRUE?1:0;
    grpSource->listGraph->get_selection(&g1_ok,&sel_graphs);
    if (g1_ok==1)
    {
        gno1=sel_graphs[0];
        g1_ok=RETURN_SUCCESS;
    }
    else
        g1_ok=RETURN_FAILURE;

    grpDestination->listGraph->get_selection(&g2_ok,&sel_graphs);
    if (g2_ok==1)
    {
        gno2=sel_graphs[0];
        g2_ok=RETURN_SUCCESS;
    }
    else
        g2_ok=RETURN_FAILURE;

    grpSource->listSet->get_selection(&ns1,&svalues1);
    grpDestination->listSet->get_selection(&ns2,&svalues2);

    error = FALSE;
    if (g1_ok == RETURN_FAILURE || g2_ok == RETURN_FAILURE) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Please select single source and destination graphs").toLocal8Bit().constData());
    } else if (ns1 == 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("No source sets selected").toLocal8Bit().constData());
    } else if (ns1 != ns2 && ns2 != 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Different number of source and destination sets").toLocal8Bit().constData());
    } else {
        o_snos=new int[ns1];
        o_gnos=new int[ns1];
        snos=new int[ns1];
        gnos=new int[ns1];
        for (int i=0;i<ns1;i++)
        {
            o_gnos[i]=gno1;
            o_snos[i]=svalues1[i];
            gnos[i]=gno2;
        }
        n_n_sets=ns2;
        for (int i=0;i<ns2;i++)
            snos[i]=svalues2[i];
        SaveSetStatesPrevious(n_n_sets,gnos,snos,UNDO_COMPLETE);
        n_n_sets=0;
        //actually do the filtering
        for (int i = 0; i < ns1; i++)//go through all source-sets
        {
            strcpy(old_comment,g[gno1].p[svalues1[i]].comments);
            strcpy(old_orig_comment,g[gno1].p[svalues1[i]].orig_comments);

            sprintf(fstr,"X=X*(%s)",lenTimeFormula->text().toLatin1().constData());
            ReplaceDecimalSeparator(fstr);//replacing wrong decimal separators in the formula
            setno1 = svalues1[i];
            setno2 = -1;
            if (ns2 != 0)//do replace existing sets
            {
                setno2 = svalues2[i];
                snos[n_n_sets++]=setno2;
            }
            else
            {
                setno2 = nextset(gno2);
                set_set_hidden(gno2, setno2, FALSE);
                snos[n_n_sets++]=setno2;
            }
            workset5=-1;
            /*if (setno2==setno1 && gno2==gno1)//source and destination are the same
            {
            workset5=setno2;
            setno2=nextset(gno2);//we need an extra set here!
            }*/

            /*
            sprintf(dummy,"Original: factor=%f",factor);
            qDebug(dummy);
            */

            strcpy(fstr,lenTimeFormula->text().toLatin1().constData());
            if (do_filter_on_one_set(gno2,setno2,gno1,setno1,selType->currentValue(),selKind->currentValue(),restr_type,restr_negate,chkAbsValue->isChecked()==true?1:0,chkDebug->isChecked(),fstr,selPoints->currentValue(),selOversampling->currentIndex(),ripple,order1,order2,f1,f2)==RETURN_FAILURE)
            {
                strcpy(g[gno1].p[svalues1[i]].comments,old_comment);
                strcpy(g[gno1].p[svalues1[i]].orig_comments,old_orig_comment);
                ApplyError=true;
                break;
            }
            else
            {
                strcpy(g[gno1].p[svalues1[i]].comments,old_comment);
                strcpy(g[gno1].p[svalues1[i]].orig_comments,old_orig_comment);
                continue;
            }
/// warning: for loop ends here!
            //first set to be created is setno2 which will be the set number for the result
            resno = get_restriction_array(gno1, setno1,restr_type, restr_negate, &rarray);//generate restriction array
            if (resno != RETURN_SUCCESS)
            {
                errmsg(tr("Error in evaluation of restriction").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            set_parser_setno(gno1,setno1);
            ///STEPS TO DO:
            //Calculate the real X-values (has to be time in seconds) and save them in new set (using the restriction) --> setno2
            resno = do_compute(gno1, setno1, gno2, setno2, rarray, fstr);
            //-->setno2 not interpolated yet! --> x-values will be needed at the end
            if (resno != RETURN_SUCCESS)
            {
                errmsg(tr("Error in evaluation of x-axis conversion").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            setlen=getsetlength(gno2, setno2);
            n_setlen=1<<((int)ceil(log((double)setlen)/log(2.0)));//get next power of two for interpolation
            //interpolate or add zeros (get min_x and max_x first) --> n_setlen will be new setlength
            workset1= nextset(gno2);
            if (create_padded_set(gno2,workset1,gno2,setno2,n_setlen,selPoints->currentValue())==RETURN_FAILURE)
            {
                errmsg(tr("Error! Unable to raise set length to power of 2!").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }

            /*
            resno = getsetminmax(gno2, setno2,&xmin,&xmax,&ymin,&ymax);

            bool mono=monospaced_v6(g[gno2].p[setno2].data.ex[0], setlen, &xspace);
                if (!mono && selPoints->currentValue()==PROCESSING_ZERO_PADDING)
                {
                errmsg(tr("Error! Set not monospaced in x! Switching to interpolation!").toLocal8Bit().constData());
                ApplyError=true;
                }
            if (selPoints->currentValue()==PROCESSING_ZERO_PADDING && mono==TRUE)
            {
            //zero padding
            do_copyset(gno2, setno2,gno2, workset1);
                for (int i=setlen;i<n_setlen;i++)
                add_point(gno2,workset1,xmax+xspace*(i-setlen+1),0.0);
            }
            else
            {
            //interpolation
            n_setlen*=(1<<selOversampling->currentIndex());//Oversampling
                if (resno != RETURN_SUCCESS)
                {
                errmsg(tr("Error in computation of min and max").toLocal8Bit().constData());
                ApplyError=true;
                break;
                }
            mesh = allocate_mesh(xmin, xmax, n_setlen);
            resno = do_interp(gno2, setno2, gno2, workset1, mesh, n_setlen, 0, 0);
                if (resno != RETURN_SUCCESS)
                {
                errmsg(tr("Error in generation of interpolated set").toLocal8Bit().constData());
                ApplyError=true;
                break;
                }
            }
            */

            //-->workset1 is a set with the points selected and the length a power of 2
            /*
               real_data ... ptr. to real part of data to be transformed
               imag_data ... ptr. to imag  "   "   "   "  "      "
               inv ..... Switch to flag normal or inverse transform
               n_pts ... Number of real data points
               nu ...... logarithm in base 2 of n_pts e.g. nu = 5 if n_pts = 32.
               int fft_v6(double *real_data, double *imag_data, int n_pts, int nu, int inv);
            */
            workset2= nextset(gno2);
            do_copyset(gno2, workset1, gno2, workset2);
            workset3= nextset(gno2);
            do_copyset(gno2, workset1, gno2, workset3);
            workset4= nextset(gno2);
            do_copyset(gno2, workset1, gno2, workset4);
            int n_pts=n_setlen;
            int nu=(int)(ceil(log((double)n_setlen)/log(2.0)));
            double * real_data=new double[n_pts];
            double * imag_data=new double[n_pts];
            double * cutoff_function=new double[n_pts];
            double * cut_r=new double[n_pts];
            double * cut_i=new double[n_pts];
            //copy data into real part for fft
            memset(imag_data,0,sizeof(double)*n_pts);
            memcpy(real_data,g[gno2].p[workset1].data.ex[1],sizeof(double)*n_pts);
            mono=monospaced_v6(g[gno2].p[workset1].data.ex[0], n_pts, &xspace);
            if (!mono)
            {
                errmsg(tr("Error! Set not monospaced in x!").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            //do fft
            resno = fft_v6(real_data,imag_data,n_pts,nu,0);
            if (resno != RETURN_SUCCESS) {
                errmsg(tr("Error in forward fft").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            //generate cutoff function --> according to Filter-parameters set
            /* amplitude correction due to the zero padding etc */
            double amp_correction = 1.0/sqrt((double)n_pts);
            for (int i=0;i<n_pts;i++)
            {
                g[gno2].p[workset2].data.ex[0][i]=((double)i)/(xspace*n_pts);//x-values in frequency-space
                g[gno2].p[workset2].data.ex[1][i]=amp_correction*hypot(real_data[i], imag_data[i]);
            }
            for (int i=n_pts/2;i<n_pts;i++)
                g[gno2].p[workset2].data.ex[0][i]=-g[gno2].p[workset2].data.ex[0][n_pts-i-1];
            ///order=n*20dB/Dekade
            ///--> 1.order = decrease by factor 10 at frequency*10
            ///--> 2.order = decrease by factor 100 at frequency*10
            ///--> n-th Order= decrease by factor 10^n at frequency*10
            ///LowPass-cutoff-function:
            ///V(f) = 1.0/sqrt( 1.0 + (f/f_cut)^(2.0*n) )
            //We always generate a low pass at the beginning
            switch (selKind->currentValue())
            {
            case FILTER_BRICKWALL:
                generateLowPass_Brickwall(g[gno2].p[workset2].data.ex[0],n_pts,f1,cut_r,cut_i);
                break;
            case FILTER_BUTTERWORTH:
                generateLowPass_Butterworth(g[gno2].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
                break;
            case FILTER_BUTTERWORTH_SIMPLE:
                generateLowPass_Butterworth_simple(g[gno2].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
                break;
            case FILTER_BESSEL:
                generateLowPass_Bessel(g[gno2].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
                break;
            case FILTER_CHEBYCHEV:
                generateLowPass_Chebychev(g[gno2].p[workset2].data.ex[0],n_pts,f1,order1,ripple,cut_r,cut_i);
                break;
            case FILTER_GAUSSIAN:
                //generateLowPass_Butterworth_simple(g[gno2].p[workset2].data.ex[0],n_pts/2,f1,order1,cut_r,cut_i);
                generateLowPass_Gaussian(g[gno2].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
                //generateLowPass_Gaussian(double * f,int n,double f_cutoff,int order,double * cutoff_Function)
                break;
            }
            if (selType->currentValue()==FILTER_BAND_PASS || selType->currentValue()==FILTER_BAND_STOP)
            {//in this case we have to generate another cut-off-function for the second filter frequency
                //At first we always generate a band-pass-filter
                double * cut_r2=new double[n_pts];
                double * cut_i2=new double[n_pts];
                switch (selKind->currentValue())
                {
                case FILTER_BRICKWALL:
                    generateLowPass_Brickwall(g[gno2].p[workset2].data.ex[0],n_pts,f2,cut_r2,cut_i2);
                    break;
                case FILTER_BUTTERWORTH:
                    generateLowPass_Butterworth(g[gno2].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
                    break;
                case FILTER_BUTTERWORTH_SIMPLE:
                    generateLowPass_Butterworth_simple(g[gno2].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
                    break;
                case FILTER_BESSEL:
                    generateLowPass_Bessel(g[gno2].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
                    break;
                case FILTER_CHEBYCHEV:
                    generateLowPass_Chebychev(g[gno2].p[workset2].data.ex[0],n_pts,f2,order2,ripple,cut_r2,cut_i2);
                    break;
                case FILTER_GAUSSIAN:
                    generateLowPass_Gaussian(g[gno2].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
                    break;
                }
                for(int i=0;i<n_pts;i++)
                {
                    cut_r[i]=(1.0-cut_r[i])*cut_r2[i];
                    cut_i[i]=(1.0-cut_i[i])*cut_i2[i];
                }
                delete[] cut_r2;
                delete[] cut_i2;
            }
            for(int i=0;i<n_pts;i++)//fft-spectra symetrical --> fill the second half
            {
                cutoff_function[i]=hypot(cut_r[i],cut_i[i]);
            }
            for(int i=0;i<n_pts;i++)
                g[gno2].p[workset4].data.ex[0][i]=g[gno2].p[workset2].data.ex[0][i];
            switch (selType->currentValue())
            {
            case FILTER_LOW_PASS:
            case FILTER_BAND_PASS:
                for(int i=0;i<n_pts;i++)
                    g[gno2].p[workset4].data.ex[1][i]=cutoff_function[i];
                break;
            case FILTER_HIGH_PASS:
            case FILTER_BAND_STOP:
                for(int i=0;i<n_pts;i++)
                {
                    cut_r[i]=1.0-cut_r[i];
                    cut_i[i]=1.0-cut_i[i];
                    cutoff_function[i]=1.0-cutoff_function[i];
                    g[gno2].p[workset4].data.ex[1][i]=cutoff_function[i];
                }
                break;
            }
            //multiply fft-coefficients by cutoff function
            if (chkAbsValue->isChecked())
            {
                for (int i=0;i<n_pts;i++)
                {
                    real_data[i]*=amp_correction*cutoff_function[i]*factor;
                    imag_data[i]*=amp_correction*cutoff_function[i]*factor;
                }
            }
            else
            {
                struct komplex tmp_ko,tmp_ko2;
                for (int i=0;i<n_pts;i++)
                {
                    tmp_ko.real=real_data[i];
                    tmp_ko.imag=imag_data[i];
                    tmp_ko2.real=cut_r[i];
                    tmp_ko2.imag=cut_i[i];
                    tmp_ko=mult_komplex(tmp_ko,tmp_ko2);
                    real_data[i]=amp_correction*tmp_ko.real*factor;
                    imag_data[i]=amp_correction*tmp_ko.imag*factor;
                }
            }
            //do inverse-fft
            resno = fft_v6(real_data,imag_data,n_pts,nu,1);
            if (resno != RETURN_SUCCESS)
            {
                errmsg(tr("Error in forward fft").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            //copy result to workset3
            for (int i=0;i<n_pts;i++)
            {
                g[gno2].p[workset3].data.ex[1][i]=amp_correction*real_data[i];//-->workset3 ist das zuruecktransormierte
            }
            //interpolate result to original X-values
            //delete worksets if necessary
            do_copyset(gno2, workset2, gno2, workset1);//save workset2 to workset1
            sprintf(fstr,"X=X/(%s)",lenTimeFormula->text().toLatin1().constData());
            ReplaceDecimalSeparator(fstr);
            set_parser_setno(gno2,workset3);
            resno = do_compute(gno2, workset3, gno2, workset2, NULL, fstr);//transform X-axis back to original scale-->resulting data present in workset2 but probably to many points
            xfree(mesh);
            mesh = getcol(gno1, setno1, DATA_X);//get original x-values
            resno = do_interp(gno2, workset2, gno2, setno2, mesh, setlen, 0, 0);//interpolate back to original set axis
            if (resno != RETURN_SUCCESS)
            {
                errmsg(tr("Error in generation of interpolated set").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            if (!chkDebug->isChecked())
            {
                killset(gno2,workset2);
                killset(gno2,workset3);
                killset(gno2,workset1);
                killset(gno2,workset4);
            }
            if (workset5==setno1)//source and destination are the same
            {
                copysetdata(gno2, setno2, gno2, workset5);
                killset(gno2,setno2);
            }
            resno=RETURN_SUCCESS;
            XCFREE(rarray);
            delete[] real_data;
            delete[] imag_data;
            delete[] cutoff_function;
            delete[] cut_r;
            delete[] cut_i;
            if (resno != RETURN_SUCCESS) {
                errmsg(tr("Error in do_compute(), check formula").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
        }//end of for-loop
    }//end of if-condition
end_of_filter_function:
    if (error == FALSE && ApplyError==false)
    {
        if (gno1 != gno2)
        {
            update_set_lists(gno1);
            update_set_lists(gno2);
        }
        else
        {
            update_set_lists(gno1);
        }
        /// replaced!
        /// SetsModified(n_n_sets,gnos,snos,UNDO_COMPLETE);
        ///do_filter_on_one_set(gno2,setno2,gno1,setno1,selType->currentValue(),selKind->currentValue(),restr_type,restr_negate,chkAbsValue->isChecked()==true?1:0,chkDebug->isChecked(),fstr,selPoints->currentValue(),selOversampling->currentIndex(),ripple,order1,order2,f1,f2);
        int orders[2]={order1,order2};
        double limits[2]={f1,f2};
        SetFilter(ns1,o_gnos,o_snos,n_n_sets,gnos,snos,selType->currentValue(),selKind->currentValue(),limits,orders,fstr,ripple,chkAbsValue->isChecked()==true?1:0,chkDebug->isChecked(),selPoints->currentValue(),selOversampling->currentIndex(),restr_type,restr_negate);
        mainWin->mainArea->completeRedraw();
        grpSource->mark_multiple_sets(gno1,ns1,svalues1);
        if (ns2==0)
        {
            ns2=1;
            svalues2[0]=setno2;
        }
        if (n_n_sets>0)
            grpDestination->mark_multiple_sets(gno2,n_n_sets,snos);
    }
    unset_wait_cursor();
    if (sel_graphs!=NULL)
        delete[] sel_graphs;
    if (svalues1!=NULL)
        delete[] svalues1;
    if (svalues2!=NULL)
        delete[] svalues2;
    if (o_snos!=NULL)
        delete[] o_snos;
    if (o_gnos!=NULL)
        delete[] o_gnos;
    if (snos!=NULL)
        delete[] snos;
    if (gnos!=NULL)
        delete[] gnos;
    if (mesh!=NULL)
        xfree(mesh);
}

void frmFourier2::selPointsChanged(int i)
{
    (void)i;
    switch (selPoints->currentIndex())
    {
    case 0:
        selOversampling->setEnabled(true);
        break;
    case 1:
    case 2:
        selOversampling->setEnabled(false);
        break;
    }
}

void frmFourier2::filterKindChanged(int i)
{
    (void)i;
    if (selKind->currentValue()==FILTER_CHEBYCHEV)
    {
        lenRipple->setVisible(true);
    }
    else
    {
        lenRipple->setVisible(false);
    }
    switch (selKind->currentIndex())
    {
    case FILTER_BRICKWALL:
        selLowOrder->setEnabled(false);
        selHighOrder->setEnabled(false);
        break;
    default:
        selLowOrder->setEnabled(true);
        selHighOrder->setEnabled(true);
        break;
    }
}

void frmFourier2::filterTypeChanged(int i)
{
    (void)i;
    switch (selType->currentValue())
    {
    case FILTER_LOW_PASS:
        gpbLow->setVisible(true);
        gpbHigh->setVisible(false);
        gpbLow->setTitle(tr("Cut-Off"));
        break;
    case FILTER_HIGH_PASS:
        gpbLow->setVisible(true);
        gpbHigh->setVisible(false);
        gpbLow->setTitle(tr("Cut-Off"));

        break;
    case FILTER_BAND_PASS:
        gpbLow->setVisible(true);
        gpbHigh->setVisible(true);
        gpbLow->setTitle(tr("High Pass Cut-Off"));
        gpbHigh->setTitle(tr("Low Pass Cut-Off"));
        break;
    case FILTER_BAND_STOP:
        gpbLow->setVisible(true);
        gpbHigh->setVisible(true);
        gpbLow->setTitle(tr("Low Pass Cut-Off"));
        gpbHigh->setTitle(tr("High Pass Cut-Off"));
        break;
    }
}

void frmFourier2::doClose(void)
{
    hide();
}

frmHotLinks::frmHotLinks(QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[8];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr("QtGrace: Hot links"));
    lblLinkSet=new QLabel(tr("Link set:"),this);
    hotlink_set_item=new uniList(SETCHOICE,this);
    hotlink_set_item->setBehavior(false,true,false);
    hotlink_list_item=new uniList(TEXTLIST,this);

    hotlink_file_item=new stdLineEdit(this,tr("To file or SOURCE_PIPE:"));
    hotlink_file_item->setText(QString(""));
    number=2;
    entr[0]=tr("Disk file");
    entr[1]=tr("Pipe");
    hotlink_source_item=new StdSelector(this,tr("Source:"),number,entr);
    number=6;
    entr[0]=tr("Never");
    entr[1]=tr("Every 1 sec");
    entr[2]=tr("Every 5 sec");
    entr[3]=tr("Every 10 sec");
    entr[4]=tr("Every 30 sec");
    entr[5]=tr("Every 60 sec");
    auto_hotlink_update=new StdSelector(this,tr("Autoupdate hotlinks:"),number,entr);
    connect(auto_hotlink_update->cmbSelect,SIGNAL(activated(int)),SLOT(autoupdatechanged(int)));
    buttons[0]=new QPushButton(tr("Link"),this);
    buttons[0]->setDefault(TRUE);
    connect(buttons[0],SIGNAL(clicked()),SLOT(doLink()));
    buttons[1]=new QPushButton(tr("Files..."),this);
    connect(buttons[1],SIGNAL(clicked()),SLOT(doFiles()));
    buttons[2]=new QPushButton(tr("Unlink"),this);
    connect(buttons[2],SIGNAL(clicked()),SLOT(doUnlink()));
    buttons[3]=new QPushButton(tr("Update"),this);
    connect(buttons[3],SIGNAL(clicked()),SLOT(do_hotupdate_proc()));
    buttons[4]=new QPushButton(tr("Close"),this);
    connect(buttons[4],SIGNAL(clicked()),SLOT(doClose()));

    autoupdatetimer=new QTimer(this);
    connect(autoupdatetimer,SIGNAL(timeout()),SLOT(do_hotupdate_proc()));

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(hotlink_list_item,0,0,1,5);
    layout->addWidget(lblLinkSet,1,0,1,5);
    layout->addWidget(hotlink_set_item,2,0,1,5);
    layout->addWidget(hotlink_file_item,3,0,1,5);
    layout->addWidget(hotlink_source_item,4,0,1,5);
    layout->addWidget(auto_hotlink_update,5,0,1,5);
    layout->addWidget(buttons[0],6,0);
    layout->addWidget(buttons[1],6,1);
    layout->addWidget(buttons[2],6,2);
    layout->addWidget(buttons[3],6,3);
    layout->addWidget(buttons[4],6,4);
    setLayout(layout);
    resize(LastSize_FormHotLinks);
}

frmHotLinks::~frmHotLinks()
{
    LastSize_FormHotLinks=this->size();
}

void frmHotLinks::init(void)
{
    hotlink_set_item->update_number_of_entries();
    /*hotlink_list_item->update_number_of_entries();*/
    update_hotlinks();
}

void frmHotLinks::doLink(void)
/*
 * establish hotlinks by associating a set with a column in a file
 * or the stdout of a process
 */
{
    int i, numset, src, *sets=new int[5];
    int * gnos;
    char fname[256];
    char buf[256];
    QString xms;

    set_wait_cursor();

    numset = GetSelectedSets(hotlink_set_item, &sets);
    src = GetChoice(hotlink_source_item);
    //strcpy(fname, xv_getstr(hotlink_file_item));
    strcpy(fname,hotlink_file_item->text().toLocal8Bit());

    if (numset <= 0){//if (numset == SET_SELECT_ERROR) {
        errwin(tr("No set selected").toLocal8Bit().constData());
        goto end_doLink;
    }
    if (fname[0] == '\0') {
        errwin(tr("No source selected").toLocal8Bit().constData());
        goto end_doLink;
    }
    gnos=new int[numset+1];
    for (int i=0;i<numset;i++) gnos[i]=cg;
    SaveHotlinkData(numset,gnos,sets);
    for( i=0; i<numset; i++ ) {
        if( numset == 1 )
            sprintf(buf, "G%d.S%d -> %s -> %s", cg, sets[i],src==0 ? "DISK" : "PIPE", fname );
        else
            sprintf(buf, "G%d.S%d -> %s -> %s:%d", cg, sets[i],src == 0 ? "DISK" : "PIPE", fname, i+1);
        xms=QString(buf);
        //xms = XmStringCreateLocalized(buf);
        ///XmListAddItemUnselected(hotlink_list_item, xms, 0);
        hotlink_list_item->add_Item(xms);
        //XmStringFree(xms);
        set_hotlink(cg, sets[i], i+1, fname, src==0?SOURCE_DISK:SOURCE_PIPE);
        if( numset == 1 )
            setcomment( cg, sets[i], fname );
        else {
            sprintf( buf, "%s:%d", fname, i+1 );
            setcomment( cg, sets[i], buf );
        }
    }
    HotlinkModified(numset,gnos,sets);
    delete[] gnos;
end_doLink:
    delete[] sets;
    unset_wait_cursor();
}

void frmHotLinks::do_hotupdate_proc(void)
/*
 * update the sets in the current graph
 */
{
    int gno, setno;
    set_wait_cursor();
    /* do links */
    int nr;
    int *gnos=new int[2];
    int *snos=new int[2];
    getHotlinkedSets(&nr,&gnos,&snos);
    SaveSetStatesPrevious(nr,gnos,snos,UNDO_DATA);
    for (gno = 0; gno < number_of_graphs(); gno++)
    {
        for (setno = 0; setno < number_of_sets(gno); setno++)
        {
            do_update_hotlink(gno, setno);
        }
    }
    SetsModified(nr,gnos,snos,UNDO_DATA);
    addAditionalDescriptionToLastNode(-1,QObject::tr("Update sets by hotlink"),QString(),-1);
    delete[] gnos;
    delete[] snos;
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
}

void frmHotLinks::autoupdatechanged(int a)
{
    if (autoupdatetimer->isActive()==true) autoupdatetimer->stop();
    switch (a)
    {
    default:
    case 0://never
    break;
    case 1://1sec
        autoupdatetimer->start(1000);
    break;
    case 2://5sec
        autoupdatetimer->start(5000);
    break;
    case 3://10sec
        autoupdatetimer->start(10000);
    break;
    case 4://30sec
        autoupdatetimer->start(30000);
    break;
    case 5://60sec
        autoupdatetimer->start(60000);
    break;
    }
}

void frmHotLinks::doFiles(void)
{
    if (FormSelectHotLink==NULL)
    {
        FormSelectHotLink=new frmIOForm(SELECT_HOT_LINK_FILE,this);
        connect(FormSelectHotLink,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(newLinkFileSelected(int,QString,bool,bool,bool)));
    }
    FormSelectHotLink->init();
    FormSelectHotLink->show();
    FormSelectHotLink->raise();
}

void frmHotLinks::doUnlink(void)
/*
 * unlink sets
 */
{
    ///XmString *s, cs;
    QString *s=new QString[3], cs;
    int  cnt, setno;
    char *cstr=new char[256];

    set_wait_cursor();

    ///XtVaGetValues(hotlink_list_item, XmNselectedItemCount, &cnt,XmNselectedItems, &s,NULL);
    hotlink_list_item->get_selection(&cnt,&s);
    ///hotlink_list_item
    if( cnt ) {
        for( ; cnt; cnt-- ) {
            ///cs = XmStringCopy(s[cnt-1]);
            cs=s[cnt-1];
            //if ((cstr = GetStringSimple(cs)))
            if ( strcpy(cstr,cs.toLocal8Bit()) )
            {
                sscanf(cstr, "G%*d.S%d", &setno);
                if (setno >= 0 && setno < number_of_sets(get_cg())) {
                    set_hotlink(get_cg(), setno, FALSE, NULL, 0);
                }
            }
            ///XmStringFree(cs);
            ///XtFree(cstr);
        }
        update_hotlinks();
    }
    delete[] s;
    delete[] cstr;
    unset_wait_cursor();
}

void frmHotLinks::update_hotlinks(void)
/*
 * update hot links displayed in scrolled list
 */
{
    int j;
    char buf[256];
    QString xms;

    //if (hotlink_frame != NULL) {
    set_wait_cursor();
    hotlink_list_item->clear();
    hotlink_list_item->number_of_entries=0;
    for (j = 0; j < number_of_sets(get_cg()); j++) {
//cout << "hotlinks: setnr=" << j << " ";
        if (is_hotlinked(get_cg(), j)) {
            sprintf(buf, "G%d.S%d -> %s -> %s:%d", get_cg(), j,
                    get_hotlink_src(get_cg(), j) == SOURCE_DISK ? "DISK" : "PIPE",
                    get_hotlink_file(get_cg(), j), is_hotlinked(get_cg(),j) );
//cout << "buf=" << buf << endl;
            xms=QString(buf);
            hotlink_list_item->add_Item(xms);
        }
    }
//cout << "number_f_entries=" << hotlink_list_item->number_of_entries << " count=" << hotlink_list_item->count() << endl;
    /// hotlink_list_item->update_number_of_entries_preserve_selection();
    unset_wait_cursor();
    //}
}

void frmHotLinks::doClose(void)
{
    hide();
}

void frmHotLinks::newLinkFileSelected(int type,QString file,bool exists,bool writeable,bool readable)
{
    (void)type;
    (void)exists;
    (void)writeable;
    (void)readable;
    char * dummy=new char[file.length()+1];
    strcpy(dummy,file.toLocal8Bit());
    /*//for testing -- maybe some tests needed (readable files...)
cout << "type=" << type << endl;
cout << "file=" << dummy << endl;
cout << "exists=" << exists << endl;
cout << "writeable=" << writeable << endl;
cout << "readable=" << readable << endl;*/
    FormSelectHotLink->hide();
    hotlink_file_item->setText(file);
    delete[] dummy;
}

frmMasterRegionOperator_Style::frmMasterRegionOperator_Style(QWidget * parent):QWidget(parent)
{
    layout=new QGridLayout(this);
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING*2);
int line;

//QSignalMapper * mapColor,*mapLineW,*mapLineW;
line=0;
for (int i=0;i<MAXREGION;i++)
{
selCol[i]=new ColorSelector(this);
selWidth[i]=new LineWidthSelector(this);
selStyle[i]=new LineStyleSelector(this);
lblRegion[i]=new QLabel(tr("Region ")+QString::number(i)+QString(": "),this);

layout->addWidget(lblRegion[i],line,0);
layout->addWidget(selCol[i],line,1);
layout->addWidget(selWidth[i],line,2);
layout->addWidget(selStyle[i],line,3);
line++;
}

layout->setColumnStretch(0,1);
layout->setColumnStretch(1,3);
layout->setColumnStretch(2,3);
layout->setColumnStretch(3,3);

cmdButtons=new stdButtonGroup(this);
connect(cmdButtons->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(cmdButtons->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(cmdButtons->cmdClose,SIGNAL(clicked()),SLOT(doClose()));
layout->addWidget(cmdButtons,line,0,1,4);

setLayout(layout);
}

void frmMasterRegionOperator_Style::init(void)
{
    for (int i=0;i<MAXREGION;i++)
    {
    selCol[i]->setCurrentIndex(rg[i].color);
    selWidth[i]->setValue(rg[i].linew);
    selStyle[i]->setCurrentIndex(rg[i].lines);
    }
}

void frmMasterRegionOperator_Style::doApply(void)
{
    for (int i=0;i<MAXREGION;i++)
    {
    rg[i].color=selCol[i]->currentIndex();
    rg[i].linew=selWidth[i]->value();
    rg[i].lines=selStyle[i]->currentIndex();
    }
    mainWin->mainArea->completeRedraw();
}

void frmMasterRegionOperator_Style::doAccept(void)
{
ApplyError=false;
doApply();
    if (ApplyError==false)
    doClose();
}

void frmMasterRegionOperator_Style::doClose(void)
{
emit(closeWish());
}

frmMasterRegionOperator_Edit::frmMasterRegionOperator_Edit(QWidget * parent):QWidget(parent)
{
int line=0;
    layout=new QGridLayout();
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);

    layout0=new QGridLayout();
    layout0->setMargin(STD_MARGIN);
    layout0->setSpacing(STD_SPACING);

int number=5;
QString entr[5];
entr[0]=tr("Region 0");
entr[1]=tr("Region 1");
entr[2]=tr("Region 2");
entr[3]=tr("Region 3");
entr[4]=tr("Region 4");
selRegion=new StdSelector(this,tr("Edit:"),number,entr);
connect(selRegion->cmbSelect,SIGNAL(activated(int)),SLOT(regionChanged(int)));

regType=new QLabel(tr(""),this);

scroll=new QScrollArea(this);
Empty=new QWidget(scroll);

cmdButtons=new stdButtonGroup(this);
connect(cmdButtons->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(cmdButtons->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(cmdButtons->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

lblTitle[0]=new QLabel(tr("# | X"),Empty);
lblTitle[1]=new QLabel(tr("Y"),Empty);

layout0->addWidget(lblTitle[0],0,0,1,1);
layout0->addWidget(lblTitle[1],0,1,1,1);

Empty->setLayout(layout0);
nr_of_lines=0;
ledCoords[0]=NULL;
ledCoords[1]=NULL;
lblCoords=NULL;

scroll->setWidget(Empty);
layout->addWidget(selRegion,line,0,1,1);
layout->addWidget(regType,line++,1,1,1);
layout->addWidget(lblTitle[0],line,0,1,1);
layout->addWidget(lblTitle[1],line++,1,1,1);
layout->addWidget(scroll,line++,0,1,2);
layout->addWidget(cmdButtons,line++,0,1,2);

setLayout(layout);
}

void frmMasterRegionOperator_Edit::init(void)
{

}

void frmMasterRegionOperator_Edit::showEvent(QShowEvent * event)
{
    (void)event;
regionChanged(0);
}

void frmMasterRegionOperator_Edit::regionChanged(int re)
{
char dummy23[GR_MAXPATHLEN];
QString dsp_text;
    regType->setText(regtypes[rg[re].type]);
if (nr_of_lines>0)
{
    for (int i=0;i<nr_of_lines;i++)
    {
    layout0->removeWidget(lblCoords[i]);
    layout0->removeWidget(ledCoords[0][i]);
    layout0->removeWidget(ledCoords[1][i]);
    delete lblCoords[i];
    delete ledCoords[0][i];
    delete ledCoords[1][i];
    }
delete[] lblCoords;
delete[] ledCoords[0];
delete[] ledCoords[1];
    ledCoords[0]=NULL;
    ledCoords[1]=NULL;
    lblCoords=NULL;
    nr_of_lines=0;
}
    if (rg[re].active==false) return;

nr_of_lines=2;
    if (rg[re].type==REGION_POLYI || rg[re].type==REGION_POLYO)
    {
    nr_of_lines=rg[re].n;
    }
lblCoords=new QLabel*[nr_of_lines];
ledCoords[0]=new QLineEdit*[nr_of_lines];
ledCoords[1]=new QLineEdit*[nr_of_lines];
    for (int i=0;i<nr_of_lines;i++)
    {
        lblCoords[i]=new QLabel(QString::number(i)+QString(":"),Empty);
        if (rg[re].type==REGION_POLYI || rg[re].type==REGION_POLYO)
        {
        sprintf(dummy23,sformat,rg[re].x[i]);
        dsp_text=QString(dummy23);
        if (DecimalPointToUse!='.') dsp_text.replace(QString("."),QString(DecimalPointToUse));
        ledCoords[0][i]=new QLineEdit(dsp_text,Empty);
        sprintf(dummy23,sformat,rg[re].y[i]);
        dsp_text=QString(dummy23);
        if (DecimalPointToUse!='.') dsp_text.replace(QString("."),QString(DecimalPointToUse));
        ledCoords[1][i]=new QLineEdit(dsp_text,Empty);
        //ledCoords[0][i]=new QLineEdit(QString::number(rg[re].x[i]),Empty);
        //ledCoords[1][i]=new QLineEdit(QString::number(rg[re].y[i]),Empty);
        }
        else
        {
            if (i==0)
            {
            sprintf(dummy23,sformat,rg[re].x1);
            dsp_text=QString(dummy23);
            if (DecimalPointToUse!='.') dsp_text.replace(QString("."),QString(DecimalPointToUse));
            ledCoords[0][i]=new QLineEdit(dsp_text,Empty);
            sprintf(dummy23,sformat,rg[re].y1);
            dsp_text=QString(dummy23);
            if (DecimalPointToUse!='.') dsp_text.replace(QString("."),QString(DecimalPointToUse));
            ledCoords[1][i]=new QLineEdit(dsp_text,Empty);
            }
            else
            {
            sprintf(dummy23,sformat,rg[re].x2);
            dsp_text=QString(dummy23);
            if (DecimalPointToUse!='.') dsp_text.replace(QString("."),QString(DecimalPointToUse));
            ledCoords[0][i]=new QLineEdit(dsp_text,Empty);
            sprintf(dummy23,sformat,rg[re].y2);
            dsp_text=QString(dummy23);
            if (DecimalPointToUse!='.') dsp_text.replace(QString("."),QString(DecimalPointToUse));
            ledCoords[1][i]=new QLineEdit(dsp_text,Empty);
            }
        }
    layout0->addWidget(lblCoords[i],1+i,0);
    layout0->addWidget(ledCoords[0][i],1+i,1);
    layout0->addWidget(ledCoords[1][i],1+i,2);
    }
    Empty->resize(2*lblTitle[0]->width()*0.95,lblTitle[0]->height()*nr_of_lines*1.3);
//cout << "Size= " << Empty->width() << " x " << Empty->height() << endl;
}

void frmMasterRegionOperator_Edit::doApply(void)
{
double d_tmp;
int re=selRegion->currentIndex();
if (rg[re].active==false) return;
    if (rg[re].type==REGION_POLYI || rg[re].type==REGION_POLYO)
    {
        for (int i=0;i<nr_of_lines;i++)
        {
        xv_evalexpr(ledCoords[0][i],&d_tmp);
        rg[re].x[i]=d_tmp;
        xv_evalexpr(ledCoords[1][i],&d_tmp);
        rg[re].y[i]=d_tmp;
        }
    }
    else
    {
    strcpy(dummy,ledCoords[0][0]->text().toLocal8Bit().constData());
    xv_evalexpr(ledCoords[0][0],&d_tmp);
    rg[re].x1=d_tmp;
    xv_evalexpr(ledCoords[1][0],&d_tmp);
    rg[re].y1=d_tmp;
    xv_evalexpr(ledCoords[0][1],&d_tmp);
    rg[re].x2=d_tmp;
    xv_evalexpr(ledCoords[1][1],&d_tmp);
    rg[re].y2=d_tmp;
    }
mainWin->mainArea->completeRedraw();
}

void frmMasterRegionOperator_Edit::doAccept(void)
{
ApplyError=false;
doApply();
    if (ApplyError==false)
    doClose();
}

void frmMasterRegionOperator_Edit::doClose(void)
{
emit(closeWish());
}

frmMasterRegionOperator_Operations::frmMasterRegionOperator_Operations(QWidget * parent):QWidget(parent)
{
int line=0;
layout=new QGridLayout();
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);

lblGraph=new QLabel(tr("Source graph:"));
lblSet=new QLabel(tr("Source set:"));

graphList=new uniList(GRAPHLIST,this);
graphList->setBehavior(true,true,true);
setList=new uniList(SETLIST,this);
setList->setBehavior(true,true,true);
connect(graphList,SIGNAL(new_selection(int)),SLOT(newGraphSelection(int)));

int number=7;
QString entr[7];
entr[0]=tr("None");
entr[1]=tr("Region 0");
entr[2]=tr("Region 1");
entr[3]=tr("Region 2");
entr[4]=tr("Region 3");
entr[5]=tr("Region 4");
entr[6]=tr("Inside graph");
selRestriction=new StdSelector(this,tr("Restriction:"),number,entr);

chkNegRes=new QCheckBox(tr("Negated"),this);
chkNegRes->setChecked(FALSE);
number=3;
entr[0]=tr("No new set(s)");
entr[1]=tr("All in one new set");
entr[2]=tr("Several new set(s)");
selNewSets=new StdSelector(this,tr("New set(s):"),number,entr);

number=4;
entr[0]=tr("Delete sets in region");
entr[1]=tr("Delete points in region");
entr[2]=tr("Extract sets in region");
entr[3]=tr("Extract points in region");
selOperation=new StdSelector(this,tr("Operation:"),number,entr);
connect(selOperation->cmbSelect,SIGNAL(activated(int)),SLOT(OperationChanged(int)));

number=3;
entr[0]=tr("Current graph");
entr[1]=tr("Source graph");
entr[2]=tr("G0");
selTargetGraph=new StdSelector(this,tr("Target graph:"),number,entr);

cmdButtons=new stdButtonGroup(this);
connect(cmdButtons->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(cmdButtons->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(cmdButtons->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

layout->addWidget(lblGraph,line,0,1,1);
layout->addWidget(lblSet,line++,1,1,1);
layout->addWidget(graphList,line,0,1,1);
layout->addWidget(setList,line++,1,1,1);
layout->addWidget(selOperation,line++,0,1,2);
layout->addWidget(selRestriction,line,0,1,1);
layout->addWidget(chkNegRes,line++,1,1,1);
layout->addWidget(selTargetGraph,line,0,1,1);
layout->addWidget(selNewSets,line++,1,1,1);
layout->addWidget(cmdButtons,line++,0,1,2);
setLayout(layout);
OperationChanged(0);
}

void frmMasterRegionOperator_Operations::init(void)
{
graphList->update_number_of_entries_preserve_selection();
setList->update_number_of_entries_preserve_selection();
int cur_gr[2]={cg,cg};
graphList->set_new_selection(1,cur_gr);
int number=number_of_graphs()+2;
QString * entries=new QString[number+2];
entries[0]=tr("Current graph");
entries[1]=tr("Source graph");
for (int i=0;i<number_of_graphs();i++)
{
entries[i+2]=QString("G")+QString::number(i);
}
selTargetGraph->setNewEntries(number,entries);
delete[] entries;
}

void frmMasterRegionOperator_Operations::newGraphSelection(int r)
{
    if (r-1<0)
    setList->set_graph_number(cg,true);
    else
    setList->set_graph_number(r-1,true);
}

void frmMasterRegionOperator_Operations::OperationChanged(int op)
{
int number=0;
QString entries[5];
    switch (op)
    {
    case 0://Delete sets in Region
    selTargetGraph->setVisible(false);
    selNewSets->setVisible(false);
    break;
    case 1://Delete points in Region
    selTargetGraph->setVisible(true);
    selNewSets->setVisible(true);
    number=2;
    entries[0]=tr("Operate on source set(s)");
    entries[1]=tr("Create new set(s)");
    selNewSets->setNewEntries(number,entries);
    break;
    case 2://Extract sets in Region
    selTargetGraph->setVisible(true);
    selNewSets->setVisible(true);
    number=3;
    entries[0]=tr("Copy set(s)");
    entries[1]=tr("Copy data into one new set");
    entries[2]=tr("Move set(s)");
    selNewSets->setNewEntries(number,entries);
    break;
    case 3://Extract points in Region
    selTargetGraph->setVisible(true);
    selNewSets->setVisible(true);
    number=4;
    entries[0]=tr("Copy points into new set(s)");
    entries[1]=tr("Copy points into one new set");
    entries[2]=tr("Move points into new set(s)");
    entries[3]=tr("Move points into one new set");
    selNewSets->setNewEntries(number,entries);
    break;
    }
}

void frmMasterRegionOperator_Operations::doApply(void)
{
int reg=RESTRICT_NONE;
    switch (selRestriction->currentIndex())
    {
    case 0:
    reg=RESTRICT_NONE;
    break;
    case 1:
    reg=RESTRICT_REG0;
    break;
    case 2:
    reg=RESTRICT_REG1;
    break;
    case 3:
    reg=RESTRICT_REG2;
    break;
    case 4:
    reg=RESTRICT_REG3;
    break;
    case 5:
    reg=RESTRICT_REG4;
    break;
    case 6:
    reg=RESTRICT_WORLD;
    break;
    }
    if (reg==RESTRICT_NONE)
    {
    errmsg(tr("Please select a region to operate with!").toLocal8Bit().data());
    return;
    }

int negate=(chkNegRes->isChecked()==true)?1:0;
int n_set_type=selNewSets->currentIndex();
int op=selOperation->currentIndex();
int target=selTargetGraph->currentIndex();
int tmp_target_graph,tmp_new_set;
int * g_sel=NULL,* s_sel=NULL;
int n_g_sel,n_s_sel;
bool allGraphsSelected,allSetsSelected;
graphList->get_selection(&n_g_sel,&g_sel);
setList->get_selection(&n_s_sel,&s_sel);
allGraphsSelected=graphList->all_entries_option_selected;
allSetsSelected=setList->all_entries_option_selected;
/*
    for (int i=0;i<n_g_sel;i++)
    {
    cout << "Graph: G" << g_sel[i] << endl;
    }
    cout << "all Graph entries=" << allGraphsSelected << endl;
    for (int i=0;i<n_s_sel;i++)
    {
    cout << "Set: S" << s_sel[i] << endl;
    }
    cout << "all Set entries=" << allSetsSelected << endl;
*/
int * source_graphs1=NULL;//just the graphs
int n_source_graphs1=0;

int * source_graphs=NULL;//source graphs and sets
int n_source_graphs=0;
int * source_sets=NULL;
int n_source_sets=0;
int * target_graphs=NULL;//target graphs and sets
int n_target_graphs=0;
int * target_sets=NULL;
int n_target_sets=0;

//first: determine all source sets that are part of the region
if (allGraphsSelected==true)
{
n_source_graphs1=number_of_graphs();
    source_graphs1=new int[n_source_graphs1];
    for (int i=0;i<n_source_graphs1;i++)
    {
    source_graphs1[i]=i;
    }
}
else
{
n_source_graphs1=n_g_sel;
    source_graphs1=new int[n_source_graphs1];
    for (int i=0;i<n_source_graphs1;i++)
    {
    source_graphs1[i]=g_sel[i];
    }
}
int contained,tmp_nr;
for (int i=0;i<n_source_graphs1;i++)
{
    if (allSetsSelected==true)
    {
        for (int j=0;j<number_of_sets(source_graphs1[i]);j++)//go through all sets in the graph --> j=set-id
        {
        contained=is_set_in_region(source_graphs1[i],j,reg,negate);
            if (contained==TRUE)
            {
            tmp_nr=source_graphs1[i];
            append_to_storage(&n_source_graphs,&source_graphs,1,&tmp_nr);
            tmp_nr=j;
            append_to_storage(&n_source_sets,&source_sets,1,&tmp_nr);
            }
        }
    }
    else
    {
        for (int j=0;j<n_s_sel;j++)//go through all selected sets in the current graph --> s_sel[j]=set-id
        {
        contained=is_set_in_region(source_graphs1[i],s_sel[j],reg,negate);
            if (contained==TRUE)
            {
            tmp_nr=source_graphs1[i];
            append_to_storage(&n_source_graphs,&source_graphs,1,&tmp_nr);
            tmp_nr=s_sel[j];
            append_to_storage(&n_source_sets,&source_sets,1,&tmp_nr);
            }
        }
    }
}

if (n_source_graphs>0)
{
/*cout << "SETS to operate on:" << endl;
for (int i=0;i<n_source_graphs;i++)
{
cout << "G" << source_graphs[i] << ".S" << source_sets[i] << endl;
}*/
ListOfChanges.clear();
//second: do the actual changes
    switch (op)
    {
    case 0://Delete sets in Region (the whole sets)
        for (int i=0;i<n_source_graphs;i++)
        {
            sprintf(dummy,"kill G%d.S%d",source_graphs[i],source_sets[i]);
            ListOfChanges << QString(dummy);
        }
        SetsDeleted(n_source_graphs,source_graphs,source_sets,UNDO_COMPLETE);//UndoStuff
        for (int i=0;i<n_source_graphs;i++)
        {
            killset(source_graphs[i],source_sets[i]);
        }
    break;
    case 2://Extract sets in Region (the whole sets)
        if (n_set_type==0)//"Copy set(s)"
        {
            for (int i=0;i<n_source_graphs;i++)
            {
                if (target==0) tmp_target_graph=cg;
                else if (target==1) tmp_target_graph=source_graphs[i];
                else tmp_target_graph=target-2;
                tmp_new_set=nextset(tmp_target_graph);
                do_copyset(source_graphs[i],source_sets[i],tmp_target_graph,tmp_new_set);
            append_to_storage(&n_target_graphs,&target_graphs,1,&tmp_target_graph);
            append_to_storage(&n_target_sets,&target_sets,1,&tmp_new_set);
            }
        if (n_target_graphs>0)
        SetsCreated(n_target_graphs,target_graphs,target_sets,UNDO_COMPLETE);
        }
        else if (n_set_type==1)//"Copy data into one new set"
        {
            if (target==0) tmp_target_graph=cg;
            else if (target==1) tmp_target_graph=source_graphs[0];
            else tmp_target_graph=target-2;
            tmp_new_set=nextset(tmp_target_graph);
            do_copyset(source_graphs[0],source_sets[0],tmp_target_graph,tmp_new_set);
            append_to_storage(&n_target_graphs,&target_graphs,1,&tmp_target_graph);
            append_to_storage(&n_target_sets,&target_sets,1,&tmp_new_set);
            if (source_graphs1!=NULL) delete[] source_graphs1;
            source_graphs1=new int[2];
            source_graphs1[0]=tmp_new_set;
            tmp_new_set=nextset(tmp_target_graph);
            source_graphs1[1]=tmp_new_set;
            for (int i=1;i<n_source_graphs;i++)
            {
                if (target==1 && tmp_target_graph!=source_graphs[i])//a new graph has started, but we want a new set in every graph
                {
                killsetdata(tmp_target_graph,tmp_new_set);
                tmp_target_graph=source_graphs[i];
                tmp_new_set=nextset(tmp_target_graph);
                do_copyset(source_graphs[i],source_sets[i],tmp_target_graph,tmp_new_set);
                append_to_storage(&n_target_graphs,&target_graphs,1,&tmp_target_graph);
                append_to_storage(&n_target_sets,&target_sets,1,&tmp_new_set);
                source_graphs1[0]=tmp_new_set;
                tmp_new_set=nextset(tmp_target_graph);
                source_graphs1[1]=tmp_new_set;
                continue;
                }
            do_copyset(source_graphs[i],source_sets[i],tmp_target_graph,tmp_new_set);
            join_sets(tmp_target_graph,source_graphs1,2);
            }
            killsetdata(tmp_target_graph,tmp_new_set);
        SetsCreated(n_target_graphs,target_graphs,target_sets,UNDO_COMPLETE);
        }
        else//"Move set(s)"
        {
        //first: copy sets
            for (int i=0;i<n_source_graphs;i++)
            {
                if (target==0) tmp_target_graph=cg;
                else if (target==1) tmp_target_graph=source_graphs[i];
                else tmp_target_graph=target-2;
                tmp_new_set=nextset(tmp_target_graph);
                do_copyset(source_graphs[i],source_sets[i],tmp_target_graph,tmp_new_set);
            append_to_storage(&n_target_graphs,&target_graphs,1,&tmp_target_graph);
            append_to_storage(&n_target_sets,&target_sets,1,&tmp_new_set);
            }
        if (n_target_graphs>0)
        SetsCreated(n_target_graphs,target_graphs,target_sets,UNDO_COMPLETE);
        //then: delete old sets
        SetsDeleted(n_source_graphs,source_graphs,source_sets,UNDO_COMPLETE);
            for (int i=0;i<n_source_graphs;i++)
            {
            killset(source_graphs[i],source_sets[i]);
            }
        }
    break;
    case 1://Delete points in Region
        //n_set_type==0 --> tr("Operate on source set(s)");
        //n_set_type==1 --> tr("Create new set(s)");
        if (n_set_type==0)//"Operate on source set(s)"
        {
        SaveSetStatesPrevious(n_source_graphs,source_graphs,source_sets,UNDO_DATA);
            for (int i=0;i<n_source_graphs;i++)
            {
            restrict_set_to_region(source_graphs[i],source_sets[i],reg,!negate);//!negate because we restrict the sets to the points outside the region (delete inside)
            }
        SetsModified(n_source_graphs,source_graphs,source_sets,UNDO_DATA);
        }
        else//"Create new set(s)"
        {
            for (int i=0;i<n_source_graphs;i++)
            {
                if (target==0) tmp_target_graph=cg;
                else if (target==1) tmp_target_graph=source_graphs[i];
                else tmp_target_graph=target-2;
                tmp_new_set=nextset(tmp_target_graph);
                do_copyset(source_graphs[i],source_sets[i],tmp_target_graph,tmp_new_set);
                restrict_set_to_region(tmp_target_graph,tmp_new_set,reg,!negate);
            append_to_storage(&n_target_graphs,&target_graphs,1,&tmp_target_graph);
            append_to_storage(&n_target_sets,&target_sets,1,&tmp_new_set);
            }
        if (n_target_graphs>0)
        SetsCreated(n_target_graphs,target_graphs,target_sets,UNDO_COMPLETE);
        }
    break;
    case 3://Extract points in Region
        if (n_set_type==0 || n_set_type==2)//"Copy points into new set(s)"
        {
            for (int i=0;i<n_source_graphs;i++)
            {
                if (target==0) tmp_target_graph=cg;
                else if (target==1) tmp_target_graph=source_graphs[i];
                else tmp_target_graph=target-2;
                tmp_new_set=nextset(tmp_target_graph);
                do_copyset(source_graphs[i],source_sets[i],tmp_target_graph,tmp_new_set);
                restrict_set_to_region(tmp_target_graph,tmp_new_set,reg,negate);//only take points inside region
            append_to_storage(&n_target_graphs,&target_graphs,1,&tmp_target_graph);
            append_to_storage(&n_target_sets,&target_sets,1,&tmp_new_set);
            }
        if (n_target_graphs>0)
        SetsCreated(n_target_graphs,target_graphs,target_sets,UNDO_COMPLETE);
        }
        else if (n_set_type==1 || n_set_type==3)//"Copy points into one new set"
        {
            if (target==0) tmp_target_graph=cg;
            else if (target==1) tmp_target_graph=source_graphs[0];
            else tmp_target_graph=target-2;
            tmp_new_set=nextset(tmp_target_graph);
            do_copyset(source_graphs[0],source_sets[0],tmp_target_graph,tmp_new_set);
            restrict_set_to_region(tmp_target_graph,tmp_new_set,reg,negate);
            append_to_storage(&n_target_graphs,&target_graphs,1,&tmp_target_graph);
            append_to_storage(&n_target_sets,&target_sets,1,&tmp_new_set);
            if (source_graphs1!=NULL) delete[] source_graphs1;
            source_graphs1=new int[2];
            source_graphs1[0]=tmp_new_set;
            tmp_new_set=nextset(tmp_target_graph);
            source_graphs1[1]=tmp_new_set;
            for (int i=1;i<n_source_graphs;i++)
            {
                if (target==1 && tmp_target_graph!=source_graphs[i])//a new graph has started, but we want a new set in every graph
                {
                killsetdata(tmp_target_graph,tmp_new_set);
                tmp_target_graph=source_graphs[i];
                tmp_new_set=nextset(tmp_target_graph);
                do_copyset(source_graphs[i],source_sets[i],tmp_target_graph,tmp_new_set);
                restrict_set_to_region(tmp_target_graph,tmp_new_set,reg,negate);
                append_to_storage(&n_target_graphs,&target_graphs,1,&tmp_target_graph);
                append_to_storage(&n_target_sets,&target_sets,1,&tmp_new_set);
                source_graphs1[0]=tmp_new_set;
                tmp_new_set=nextset(tmp_target_graph);
                source_graphs1[1]=tmp_new_set;
                continue;
                }
                do_copyset(source_graphs[i],source_sets[i],tmp_target_graph,tmp_new_set);
                restrict_set_to_region(tmp_target_graph,tmp_new_set,reg,negate);//only take points inside region
                join_sets(tmp_target_graph,source_graphs1,2);
            }
            killsetdata(tmp_target_graph,tmp_new_set);
        if (n_target_graphs>0)
        SetsCreated(n_target_graphs,target_graphs,target_sets,UNDO_COMPLETE);
        }

        if (n_set_type==2 || n_set_type==4)//"Move points into new set(s)" || "Move points into one new set" --> restrict old sets
        {
        SaveSetStatesPrevious(n_source_graphs,source_graphs,source_sets,UNDO_DATA);
            for (int i=0;i<n_source_graphs;i++)
            {
            restrict_set_to_region(source_graphs[i],source_sets[i],reg,!negate);//!negate because we restrict the sets to the points outside the region (delete inside)
            }
        SetsModified(n_source_graphs,source_graphs,source_sets,UNDO_DATA);
        }
    break;
    }
ListOfChanges.clear();
}
else
{
errmsg(tr("No data inside selected region found!").toLocal8Bit().data());
}
if (g_sel!=NULL) delete[] g_sel;
if (s_sel!=NULL) delete[] s_sel;
if (source_graphs1!=NULL) delete[] source_graphs1;
if (source_graphs!=NULL) delete[] source_graphs;
if (source_sets!=NULL) delete[] source_sets;
if (target_graphs!=NULL) delete[] target_graphs;
if (target_sets!=NULL) delete[] target_sets;
mainWin->mainArea->completeRedraw();
init();
}

void frmMasterRegionOperator_Operations::doAccept(void)
{
ApplyError=false;
doApply();
    if (ApplyError==false)
    doClose();
}

void frmMasterRegionOperator_Operations::doClose(void)
{
emit(closeWish());
}

frmMasterRegionOperator::frmMasterRegionOperator(QWidget * parent):QDialog(parent)
{
    setWindowTitle(tr("Regions"));
    setWindowIcon(QIcon(*GraceIcon));
tab_Main=new frmMasterRegionOperator_Main(this);
tab_Style=new frmMasterRegionOperator_Style(this);
tab_Edit=new frmMasterRegionOperator_Edit(this);
tab_Operations=new frmMasterRegionOperator_Operations(this);
    tabs=new QTabWidget(this);
    tabs->addTab(tab_Main,tr("Main"));
    tabs->addTab(tab_Style,tr("Appearance"));
    tabs->addTab(tab_Edit,tr("Edit"));
    tabs->addTab(tab_Operations,tr("Operations"));
connect(tab_Main,SIGNAL(closeWish()),SLOT(doClose()));
connect(tab_Style,SIGNAL(closeWish()),SLOT(doClose()));
connect(tab_Edit,SIGNAL(closeWish()),SLOT(doClose()));
connect(tab_Operations,SIGNAL(closeWish()),SLOT(doClose()));

layout=new QVBoxLayout();
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);
layout->addWidget(tabs);
setLayout(layout);
resize(LastSize_FormRegionMaster);
}

frmMasterRegionOperator::~frmMasterRegionOperator()
{
    LastSize_FormRegionMaster=this->size();
}

void frmMasterRegionOperator::init(void)
{
tab_Main->init();
tab_Style->init();
tab_Edit->init();
tab_Operations->init();
updateDecimalSeparator();
}

void frmMasterRegionOperator::updateDecimalSeparator(void)
{
QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
    for (int i=0;i<MAXREGION;i++)
    {
    tab_Style->selWidth[i]->spnLineWidth->setLocale(newLocale);
    }
tab_Edit->regionChanged(tab_Edit->selRegion->currentIndex());
}

void frmMasterRegionOperator::doClose(void)
{
hide();
}

void frmMasterRegionOperator::number_of_graphs_changed(void)
{
tab_Main->init();
tab_Operations->selOperation->setCurrentIndex(tab_Operations->selOperation->currentIndex());
}

frmMasterRegionOperator_Main::frmMasterRegionOperator_Main(QWidget * parent):QWidget(parent)
{
mapActive=new QSignalMapper(this);
mapType=new QSignalMapper(this);
mapDefine=new QSignalMapper(this);
mapReportSet=new QSignalMapper(this);
mapReportPoints=new QSignalMapper(this);

connect(mapActive,SIGNAL(mapped(int)),this,SLOT(clickActive(int)));
//connect(mapType,SIGNAL(mapped(int)),this,SLOT(changeType(int)));
connect(mapDefine,SIGNAL(mapped(int)),this,SLOT(clickDefine(int)));
connect(mapReportSet,SIGNAL(mapped(int)),this,SLOT(clickReportSets(int)));
connect(mapReportPoints,SIGNAL(mapped(int)),this,SLOT(clickReportPoints(int)));

layout=new QGridLayout();
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);
for (int i=0;i<6;i++)
lblTitles[i]=new QLabel(QString("_"),this);

lblTitles[0]->setText(tr("Region"));
lblTitles[1]->setText(tr("Graph"));
lblTitles[2]->setText(tr("Active"));
lblTitles[3]->setText(tr("Type"));
lblTitles[4]->setText(tr("Define"));
lblTitles[5]->setText(tr("Report on"));
layout->addWidget(lblTitles[0],0,0,1,1,Qt::AlignCenter);
layout->addWidget(lblTitles[1],0,1,1,1,Qt::AlignCenter);
layout->addWidget(lblTitles[2],0,2,1,1,Qt::AlignCenter);
layout->addWidget(lblTitles[3],0,3,1,1,Qt::AlignCenter);
layout->addWidget(lblTitles[4],0,4,1,1,Qt::AlignCenter);
layout->addWidget(lblTitles[5],0,5,1,2,Qt::AlignCenter);

for (int i=0;i<7;i++)
{
lblRegions[i]=new QLabel(QString::number(i),this);
layout->addWidget(lblRegions[i],1+i,0,1,1,Qt::AlignCenter);
spnLink[i]=new QSpinBox(this);
spnLink[i]->setRange(0,8);
layout->addWidget(spnLink[i],1+i,1,1,1,Qt::AlignCenter);
    connect(spnLink[i],SIGNAL(valueChanged(int)),SLOT(changeLink(int)));
cmdActive[i]=new QPushButton(tr("On"),this);
cmdActive[i]->setCheckable(true);
    connect(cmdActive[i], SIGNAL(clicked()), mapActive, SLOT(map()));
    mapActive->setMapping(cmdActive[i],i);
layout->addWidget(cmdActive[i],1+i,2,1,1,Qt::AlignCenter);
cmbType[i]=new QComboBox(this);
    for (int j=0;j<10;j++)
    cmbType[i]->addItem(regtypes[reg_order[j]]);
    connect(cmbType[i],SIGNAL(activated(int)),SLOT(changeType(int)));
layout->addWidget(cmbType[i],1+i,3,1,1,Qt::AlignCenter);
cmdDefine[i]=new QPushButton(tr("Define"),this);
    connect(cmdDefine[i], SIGNAL(clicked()), mapDefine, SLOT(map()));
    mapDefine->setMapping(cmdDefine[i],i);
layout->addWidget(cmdDefine[i],1+i,4,1,1,Qt::AlignCenter);
cmdReportSet[i]=new QPushButton(tr("Sets"),this);
    connect(cmdReportSet[i], SIGNAL(clicked()), mapReportSet, SLOT(map()));
    mapReportSet->setMapping(cmdReportSet[i],i);
layout->addWidget(cmdReportSet[i],1+i,5,1,1,Qt::AlignCenter);
cmdReportPoints[i]=new QPushButton(tr("Points"),this);
    connect(cmdReportPoints[i], SIGNAL(clicked()), mapReportPoints, SLOT(map()));
    mapReportPoints->setMapping(cmdReportPoints[i],i);
layout->addWidget(cmdReportPoints[i],1+i,6,1,1,Qt::AlignCenter);
}

lblRegions[MAXREGION]->setText(tr("Inside World"));
lblRegions[MAXREGION+1]->setText(tr("Outside World"));

cmdActive[MAXREGION]->setVisible(false);
cmbType[MAXREGION]->setVisible(false);
cmdDefine[MAXREGION]->setVisible(false);
spnLink[MAXREGION]->setVisible(false);
cmdActive[MAXREGION+1]->setVisible(false);
cmbType[MAXREGION+1]->setVisible(false);
cmdDefine[MAXREGION+1]->setVisible(false);
spnLink[MAXREGION+1]->setVisible(false);

cmdClearARegion=new QPushButton(tr("Clear one region"),this);
connect(cmdClearARegion,SIGNAL(clicked()),SLOT(doClearARegion()));
cmdClearAllRegions=new QPushButton(tr("Clear all regions"),this);
connect(cmdClearAllRegions,SIGNAL(clicked()),SLOT(doClearAllRegions()));
cmdClose=new QPushButton(tr("Close"),this);
cmdClose->setDefault(true);
connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
layout->addWidget(cmdClearARegion,8,0,1,3);
layout->addWidget(cmdClearAllRegions,8,3,1,2);
layout->addWidget(cmdClose,8,5,1,2);

setLayout(layout);
}

void frmMasterRegionOperator_Main::init(void)
{
static bool init_running=false;
if (init_running==true) return;
init_running=true;
for (int i=0;i<7;i++)
{
disconnect(spnLink[i],SIGNAL(valueChanged(int)),this,SLOT(changeLink(int)));
disconnect(cmbType[i],SIGNAL(activated(int)),this,SLOT(changeType(int)));
}
    for (int i=0;i<MAXREGION;i++)
    {
    spnLink[i]->setRange(0,number_of_graphs()-1);
    //cout << "number_o_graphs=" << number_of_graphs() << endl;
        if (rg[i].type==0 && rg[i].x1==0.0 && rg[i].x2==0.0 && rg[i].y1==0.0 && rg[i].y2==0.0)
        {//region not defined
        cmdActive[i]->setText(tr("---"));
        cmdActive[i]->setChecked(false);
        cmdActive[i]->setEnabled(false);
        lblRegions[i]->setText(QString::number(i));
        spnLink[i]->setValue(cg);
        }
        else//region defined
        {
        //lblRegions[i]->setText(QString::number(i)+QString(" (G")+QString::number(rg[i].linkto)+QString(")"));
        lblRegions[i]->setText(QString::number(i));
        cmdActive[i]->setEnabled(true);
        spnLink[i]->setValue(rg[i].linkto);
            if (rg[i].active==true)
            {
            cmdActive[i]->setText(tr("On"));
            cmdActive[i]->setChecked(true);
            }
            else
            {
            cmdActive[i]->setText(tr("Off"));
            cmdActive[i]->setChecked(false);
            }
        }
        if (reg_order[cmbType[i]->currentIndex()]!=rg[i].type)
        {
            for (int j=0;j<10;j++)
                if (reg_order[j]==rg[i].type)
                    cmbType[i]->setCurrentIndex(j);
        }
    }
for (int i=0;i<7;i++)
{
connect(spnLink[i],SIGNAL(valueChanged(int)),SLOT(changeLink(int)));
connect(cmbType[i],SIGNAL(activated(int)),SLOT(changeType(int)));
}
init_running=false;
}

void frmMasterRegionOperator_Main::doClearARegion(void)
{
bool ok;
int regno = QInputDialog::getInt(this, tr("Clear region"),tr("# of region to be cleared:"), 0, 0, 4, 1, &ok);
    if (ok)
    {
    //cout << "Clear Region " << regno << endl;
    RegionModified(regno,NULL,1);
    kill_region(regno);
    mainWin->mainArea->completeRedraw();
    init();
    }
}

void frmMasterRegionOperator_Main::doClearAllRegions(void)
{
    int i;
    int ret=QMessageBox::question(this,tr("Clear all regions"),tr("Do you really want to clear all regions?"),QMessageBox::Yes,QMessageBox::No);
    if (ret==QMessageBox::Yes)
    {
    //cout << "killing all" << endl;
    RegionModified(MAXREGION,NULL,1);
    for (i = 0; i < MAXREGION; i++)
    kill_region(i);
    mainWin->mainArea->completeRedraw();
    init();
    }
    else
    {
    ;//cout << "killing aborted" << endl;
    }
}

void frmMasterRegionOperator_Main::doClose(void)
{
emit(closeWish());
}

void frmMasterRegionOperator_Main::clickActive(int regno)
{
    rg[regno].active=(!rg[regno].active);
    init();
    mainWin->mainArea->completeRedraw();
}

void frmMasterRegionOperator_Main::changeType(int reg_no)
{
    (void)reg_no;
int regno=0;
    for (int i=0;i<5;i++)
    {
        if (rg[i].type!=reg_order[cmbType[i]->currentIndex()])
        {
        regno=i;
        break;
        }
    }
if ((reg_order[cmbType[regno]->currentIndex()]==REGION_POLYI || reg_order[cmbType[regno]->currentIndex()]==REGION_POLYO) && rg[regno].n<=0)
{//we want to have a polygon, but only have x1,y1 and x2,y2

    rg[regno].n = 4;
    rg[regno].x = (double*)xcalloc(4, sizeof(double));
    rg[regno].y = (double*)xcalloc(4, sizeof(double));

        rg[regno].x[0] = rg[regno].x1;
        rg[regno].y[0] = rg[regno].y1;
        rg[regno].x[1] = rg[regno].x2;
        rg[regno].y[1] = rg[regno].y1;
        rg[regno].x[2] = rg[regno].x2;
        rg[regno].y[2] = rg[regno].y2;
        rg[regno].x[3] = rg[regno].x1;
        rg[regno].y[3] = rg[regno].y2;
}
else if ((rg[regno].x1==0.0 && rg[regno].x2==0.0 && rg[regno].y1==0.0 && rg[regno].y2==0.0) && (rg[regno].type==REGION_POLYI || rg[regno].type==REGION_POLYO) && !(reg_order[cmbType[regno]->currentIndex()]==REGION_POLYI || reg_order[cmbType[regno]->currentIndex()]==REGION_POLYO))
{//we had a polygon so far, but now want something else
rg[regno].x1=rg[regno].x[0];
rg[regno].x2=rg[regno].x[0];
rg[regno].y1=rg[regno].y[0];
rg[regno].y2=rg[regno].y[0];
    for (int i=1;i<rg[regno].n;i++)
    {
    if (rg[regno].x[i]<rg[regno].x1) rg[regno].x1=rg[regno].x[i];
    if (rg[regno].x[i]>rg[regno].x2) rg[regno].x2=rg[regno].x[i];
    if (rg[regno].y[i]<rg[regno].y1) rg[regno].y1=rg[regno].y[i];
    if (rg[regno].y[i]>rg[regno].y2) rg[regno].y2=rg[regno].y[i];
    }
}
    rg[regno].type=reg_order[cmbType[regno]->currentIndex()];
    init();
//cout << "TypeChanged regno=" << regno << " type=" << rg[regno].type << endl;
mainWin->mainArea->completeRedraw();
}

void frmMasterRegionOperator_Main::changeLink(int reg_no)
{
    (void)reg_no;
static bool changeRunning=false;
if (changeRunning==true) return;
int regno=0;
changeRunning=true;
    for (int i=0;i<MAXREGION;i++)
    {
        if (rg[i].linkto!=spnLink[i]->value())
        {
        regno=i;
        break;
        }
    }
//cout << "regno=" << regno << " reg_no=" << reg_no << " value=" << spnLink[regno]->value() << endl;
rg[regno].linkto=spnLink[regno]->value();
init();
mainWin->mainArea->completeRedraw();
changeRunning=false;
}

void frmMasterRegionOperator_Main::clickDefine(int regno)
{
//cout << "define region: " << regno << endl;
define_region(regno,reg_order[cmbType[regno]->currentIndex()]);
}

void frmMasterRegionOperator_Main::clickReportSets(int regno)
{
//cout << "ReportSets: " << regno << endl;
reporton_region(get_cg(), regno, 0);
}

void frmMasterRegionOperator_Main::clickReportPoints(int regno)
{
//cout << "ReportPoints: " << regno << endl;
reporton_region(get_cg(), regno, 1);
}

frmRegionStatus::frmRegionStatus(QWidget * parent):QDialog(parent)
{
    background=new QWidget(this);
    setWindowTitle(tr("Status"));
    lblHeader=new QLabel(tr("Region # Active Type"),background);
    char dummy[16];
    QString nr;
    QString info;
    active=tr("on");
    inactive=tr("off");

    for (int i=0;i<MAXREGION;i++)
    {
        sprintf(dummy,"%i",i);
        nr=QString(dummy);
        info=QString("   ")+nr+QString("   ")+inactive+QString("   ")+regtypes[2];
        lblStatus[i]=new QLabel(info,background);
    }

    cmdClose=new QPushButton(tr("Close"),this);
    connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    cmdUpdate=new QPushButton(tr("Update"),this);
    connect(cmdUpdate,SIGNAL(clicked()),SLOT(doUpdate()));

    layout0=new QVBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(lblHeader);
    for (int i=0;i<MAXREGION;i++)
        layout0->addWidget(lblStatus[i]);

    background->setLayout(layout0);

    scroll=new QScrollArea(this);
    scroll->setWidget(background);

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(scroll,0,0,1,2);
    layout->addWidget(cmdClose,1,0);
    layout->addWidget(cmdUpdate,1,1);
    setLayout(layout);
    resize(LastSize_FormRegionStatus);
}

frmRegionStatus::~frmRegionStatus()
{
    LastSize_FormRegionStatus=this->size();
}

void frmRegionStatus::init(void)
{
    doUpdate();
}

void frmRegionStatus::doUpdate(void)
{
    char dummy[16];
    QString nr;
    QString info;
    for (int rno=0;rno<MAXREGION;rno++)
    {
        sprintf(dummy,"%i",rno);
        nr=QString(dummy);
        info=QString("   ")+nr+QString("   ");
        if (rg[rno].active==true)
            info=info+active+QString("   ")+regtypes[rg[rno].type];
        else
            info=info+inactive+QString("   ")+regtypes[rg[rno].type];
        lblStatus[rno]->setText(info);
    }
}

void frmRegionStatus::doClose(void)
{
    hide();
}

frmRegions::frmRegions(int type,QWidget * parent):QDialog(parent)
{
    char dummy[16];
    int number;
    QString entr[MAXREGION>12?MAXREGION+2:12];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr(""));
    windowtype=type;

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);

    buttonGroup=new stdButtonGroup(this,false,true,false);
    buttonGroup->cmdAccept->setDefault(TRUE);
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    switch (type)
    {
    case DEFINEREGIONWINDOW:
        setWindowTitle(tr("Define region"));
        buttonGroup->cmdAccept->setText(tr("Define"));
        number=MAXREGION;
        for (int i=0;i<MAXREGION;i++)
        {
            sprintf(dummy,"%i",i);
            entr[i]=QString(dummy);
        }
        selector0=new StdSelector(this,tr("Define region:"),number,entr);
        number=10;
        entr[0]=tr("Inside polygon");
        entr[1]=tr("Outside polygon");
        entr[2]=tr("Above line");
        entr[3]=tr("Below line");
        entr[4]=tr("Left of line");
        entr[5]=tr("Right of line");
        entr[6]=tr("In Horiz. Range");
        entr[7]=tr("In Vert. Range");
        entr[8]=tr("Out of Horiz. Range");
        entr[9]=tr("Out of Vert. Range");
        selector1=new StdSelector(this,tr("Region type:"),number,entr);
        connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doDefine()));
        layout->addWidget(selector0);
        layout->addWidget(selector1);
        break;
    case REPORTREGIONWINDOW:
        setWindowTitle(tr("Report on sets in region"));
        number=MAXREGION+2;
        for (int i=0;i<MAXREGION;i++)
        {
            sprintf(dummy,"%i",i);
            entr[i]=QString(dummy);
        }
        entr[MAXREGION]=tr("Inside world");
        entr[MAXREGION+1]=tr("Outside world");
        selector0=new StdSelector(this,tr("Report on sets in region:"),number,entr);
        number=2;
        entr[0]=tr("Sets");
        entr[1]=tr("Points");
        selector1=new StdSelector(this,tr("Report type:"),number,entr);
        connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
        layout->addWidget(selector0);
        layout->addWidget(selector1);
        break;
    case CLEARREGIONWINDOW:
        setWindowTitle(tr("Clear region"));
        number=MAXREGION+1;
        for (int i=0;i<MAXREGION;i++)
        {
            sprintf(dummy,"%i",i);
            entr[i]=QString(dummy);
        }
        entr[MAXREGION]=tr("All");
        selector0=new StdSelector(this,tr("Clear region:"),number,entr);
        selector1=new StdSelector(this,QString("dummy"),number,entr);
        connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
        layout->addWidget(selector0);
        selector1->setVisible(FALSE);
        break;
    }
    layout->addWidget(buttonGroup);
    setLayout(layout);
    switch (windowtype)
    {
    case DEFINEREGIONWINDOW:
    resize(LastSize_FormDefineRegion);
    break;
    case REPORTREGIONWINDOW:
    resize(LastSize_FormReportRegion);
    break;
    case CLEARREGIONWINDOW:
    resize(LastSize_FormClearRegion);
    break;
    }
}

frmRegions::~frmRegions()
{
    switch (windowtype)
    {
    case DEFINEREGIONWINDOW:
    LastSize_FormDefineRegion=this->size();
    break;
    case REPORTREGIONWINDOW:
    LastSize_FormReportRegion=this->size();
    break;
    case CLEARREGIONWINDOW:
    LastSize_FormClearRegion=this->size();
    break;
    }
}

void frmRegions::init(void)
{
    ;//Nothing to do here !(?)
}

void frmRegions::doAccept(void)
{
    int regno,type,i;
    switch (windowtype)
    {
    case CLEARREGIONWINDOW:
        regno=GetChoice(selector0);
        RegionModified(regno,NULL,1);
        if (regno == MAXREGION)
        {
            for (i = 0; i < MAXREGION; i++)
                kill_region(i);
        }
        else
        {
            kill_region(regno);
        }
        mainWin->mainArea->completeRedraw();
        break;
    case REPORTREGIONWINDOW:
        regno = GetChoice(selector0);
        type = GetChoice(selector1);
        reporton_region(get_cg(), regno, type);
        break;
    }

}

void frmRegions::doDefine(void)
{
    int rtype = GetChoice(selector1);
    nr = GetChoice(selector0);
    define_region(nr, reg_order[rtype]);
}

void define_region(int c_nr, int rtype)
{
    CopyRegion(rg+c_nr,&undo_region);//copy old region into temporary memory
    CopyRegion(rg+c_nr,&undo_region2);
    kill_region(c_nr);
    nr=c_nr;
    switch (rtype) {
    case REGION_POLYI:
        regiontype = REGION_POLYI;
        do_select_region();
        break;
    case REGION_POLYO:
        regiontype = REGION_POLYO;
        do_select_region();
        break;
    case REGION_ABOVE:
        regiontype = REGION_ABOVE;
        set_action(DO_NOTHING);
        set_action(DEF_REGION1ST);
        break;
    case REGION_BELOW:
        regiontype = REGION_BELOW;
        set_action(DO_NOTHING);
        set_action(DEF_REGION1ST);
        break;
    case REGION_TOLEFT:
        regiontype = REGION_TOLEFT;
        set_action(DO_NOTHING);
        set_action(DEF_REGION1ST);
        break;
    case REGION_TORIGHT:
        regiontype = REGION_TORIGHT;
        set_action(DO_NOTHING);
        set_action(DEF_REGION1ST);
        break;
    case REGION_HORIZI:
        regiontype= REGION_HORIZI;
        set_action(DO_NOTHING);
        set_action(DEF_REGION1ST);
        break;
    case REGION_VERTI:
        regiontype= REGION_VERTI;
        set_action(DO_NOTHING);
        set_action(DEF_REGION1ST);
        break;
    case REGION_HORIZO:
        regiontype= REGION_HORIZO;
        set_action(DO_NOTHING);
        set_action(DEF_REGION1ST);
        break;
    case REGION_VERTO:
        regiontype= REGION_VERTO;
        set_action(DO_NOTHING);
        set_action(DEF_REGION1ST);
        break;
    }
}

void frmRegions::doClose(void)
{
    hide();
}

frmEditBlockData::frmEditBlockData(QWidget * parent):QDialog(parent)
{
    char dummy[96];
    int number;
    QString entr[NUMBER_OF_SETTYPES>20?NUMBER_OF_SETTYPES:20];
    QString ending=tr(" from column:");
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    setWindowTitle(tr("QtGrace: Edit block data"));

    block_curtype = SET_XY;
    begining=tr("Block data: ");
    middle=tr(" column(s) of length ");

    grpLoadTo=new grpSelect(tr("Load to:"),this);
    grpLoadTo->listSet->setSelectionMode(QAbstractItemView::SingleSelection);
    lblData=new QLabel(QString(""),this);
    lblData->setFrameStyle(QFrame::Box | QFrame::Sunken);
    grpColumns=new QGroupBox(QString(""),this);
    number=5;
    entr[0]=QString("Index");
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i+1);
        entr[i+1]=QString(dummy);
    }
    for (int i=0;i<6;i++)
        columnSelector[i]=new StdSelector(grpColumns,QString(""),number,entr);
    columnSelector[0]->lblText->setText(QString("X")+ending);
    columnSelector[1]->lblText->setText(QString("Y")+ending);
    columnSelector[2]->lblText->setText(QString("Y1")+ending);
    columnSelector[3]->lblText->setText(QString("Y2")+ending);
    columnSelector[4]->lblText->setText(QString("Y3")+ending);
    columnSelector[5]->lblText->setText(QString("Y4")+ending);
    number=NUMBER_OF_SETTYPES;
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    selType=new StdSelector(grpColumns,tr("Set type:"),number,entr);
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(setTypeChanged(int)));
    number=5;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i]=QString(dummy);
    }
    entr[0]=tr("None");
    selStringColumn=new StdSelector(grpColumns,tr("Strings from column:"),number,entr);
    number=4;
    entr[1]=QString("X");
    entr[2]=QString("Y");
    entr[3]=QString("XY");
    selAutoscale=new StdSelector(this,tr("Autoscale graph on load:"),number,entr);
    selAutoscale->setCurrentIndex(3);
    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout0=new QVBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(selType);
    for (int i=0;i<6;i++)
        layout0->addWidget(columnSelector[i]);
    layout0->addWidget(selStringColumn);
    grpColumns->setLayout(layout0);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(lblData);
    layout->addWidget(grpLoadTo);
    layout->addWidget(grpColumns);
    layout->addWidget(selAutoscale);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    setTypeChanged(0);
    resize(LastSize_FormEditBlockData);
}

frmEditBlockData::~frmEditBlockData()
{
    LastSize_FormEditBlockData=this->size();
}

void frmEditBlockData::setCompleteData(int columns,int length)
{
    char dummy[32],dummy2[32];
    sprintf(dummy,"%d",columns);
    sprintf(dummy2,"%d",length);
    lblData->setText(begining+QString(dummy)+middle+QString(dummy2));
}

void frmEditBlockData::setTypeChanged(int i)
{
    int ncols=settype_cols(i);
    block_curtype = i;
    for (int i=0;i<ncols;i++)
        columnSelector[i]->setEnabled(TRUE);
    for (int i=ncols;i<6;i++)
        columnSelector[i]->setEnabled(FALSE);
}

void frmEditBlockData::init(void)
{
    grpLoadTo->listGraph->update_number_of_entries();
    grpLoadTo->listSet->update_number_of_entries();
    update_eblock(get_cg());
}

void frmEditBlockData::update_eblock(int gno)
{
    //init();
    int number;
    QString * entr1,*entr2;
    int * values1,*values2;
    int blocklen, blockncols;
    int *blockformats;
    int i, nncols, nscols;//ncols
    char buf[128];

    blockncols = get_blockncols();
    if (blockncols == 0) {
        QString err=tr("Need to read block data first");
        char * dummy_err=new char[err.length()+1];
        strcpy(dummy_err,err.toLocal8Bit());
        errmsg(dummy_err);
        delete[] dummy_err;
        return;
    }
    blocklen = get_blocknrows();
    blockformats = get_blockformats();
    if (is_valid_gno(gno))
    {
        ///SelectListChoice(eblock_graphset_item->graph_sel, gno);
        int selection[2]={gno,0};
        grpLoadTo->listGraph->set_new_selection(1,selection);
        grpLoadTo->listSet->set_graph_number(gno,false);
    }
    setCompleteData(blockncols,blocklen);
    ///sprintf(buf, "Block data: %d column(s) of length %d",blockncols, blocklen);
    ///SetLabel(eblock_ncols_item, buf);
    /* TODO: check if new data arrived */
    if (1) {
        number=blockncols+1;
        entr1=new QString[number];
        values1=new int[number];
        entr2=new QString[number];
        values2=new int[number];
        entr1[0]=tr("Index");
        entr2[0]=tr("None");
        values1[0]=values2[0]=-1;

        /*blockitems  = xmalloc((blockncols + 1)*sizeof(OptionItem));
        sblockitems = xmalloc((blockncols + 1)*sizeof(OptionItem));
        blockitems[0].value = -1;
        blockitems[0].label = copy_string(NULL, "Index");
        sblockitems[0].value = -1;
        sblockitems[0].label = copy_string(NULL, "None");*/
        nncols = 0;
        nscols = 0;

        for (i = 0; i < blockncols; i++) {
            sprintf(buf, "%d", i + 1);
            if (blockformats[i] != FFORMAT_STRING) {
                nncols++;
                values1[nncols]=i;
                entr1[nncols]=QString(buf);
                /*blockitems[nncols].value = i;
                blockitems[nncols].label = copy_string(NULL, buf);*/
            } else {
                nscols++;
                values2[nncols]=i;
                entr2[nncols]=QString(buf);
                /*sblockitems[nscols].value = i;
                sblockitems[nscols].label = copy_string(NULL, buf);*/
            }
        }

        for (i = 0; i < MAX_SET_COLS; i++)
        {
            int oldchoice = columnSelector[i]->currentValue();///GetOptionChoice(eblock_nchoice_items[i]);
            ///UpdateOptionChoice(eblock_nchoice_items[i],nncols + 1, blockitems);
            columnSelector[i]->setNewEntries(nncols+1,entr1,values1);
            if (oldchoice < blockncols){
                ///SetOptionChoice(eblock_nchoice_items[i], oldchoice);
                columnSelector[i]->setCurrentValue(oldchoice);
            } else if (i < blockncols) {
                ///SetOptionChoice(eblock_nchoice_items[i], i);
                columnSelector[i]->setCurrentValue(i);
            }
        }
        ///UpdateOptionChoice(eblock_schoice_item, nscols + 1, sblockitems);
        selStringColumn->setNewEntries(nscols+1,entr2,values2);

        /*for (i = 0; i < nncols + 1; i++) {
            xfree(blockitems[i].label);
        }
        xfree(blockitems);
        for (i = 0; i < nscols + 1; i++) {
            xfree(sblockitems[i].label);
        }
        xfree(sblockitems);*/
        delete[] entr1;
        delete[] values1;
        delete[] entr2;
        delete[] values2;
    }

    //ncols = settype_cols(block_curtype);
    setTypeChanged(block_curtype);
    /*for (i = 0; i < MAX_SET_COLS; i++) {
        SetSensitive(eblock_nchoice_items[i]->menu, (i < ncols));
    }*/
}


void frmEditBlockData::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmEditBlockData::doApply(void)
{
    ApplyError=false;
    int i, gno, setno;
    int cs[MAX_SET_COLS], nncols, scol, autoscale;
    int * graphs=new int[2];
    int anz_graphs;
    int * sets=new int[2];
    int anz_sets;
    set_wait_cursor();
    //get current selection
    grpLoadTo->listGraph->get_selection(&anz_graphs,&graphs);
    grpLoadTo->listSet->get_selection(&anz_sets,&sets);
    if (anz_graphs==0)
    {
        errmsg(tr("Please select a single graph").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }
    else
    {
        gno=graphs[0];
    }
    if (anz_sets==0)
    {
        setno = NEW_SET;
    }
    else
    {
        setno=sets[0];
    }

    /*if (GetSingleListChoice(eblock_graphset_item->graph_sel, &gno)
        != RETURN_SUCCESS) {
        errmsg(tr("Please select a single graph").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }*/
    /*if (GetSingleListChoice(eblock_graphset_item->set_sel, &setno) !=
        RETURN_SUCCESS) {
        // no set selected; allocate new one
        setno = NEW_SET;
    }*/
    
    nncols = settype_cols(block_curtype);
    for (i = 0; i < nncols; i++)
    {
        cs[i] = columnSelector[i]->currentValue();//-1 means "Index"
    }
    scol = selStringColumn->currentValue();
    autoscale = selAutoscale->currentValue();

    char * filen=new char[filename.length()+2];
    strcpy(filen,filename.toLocal8Bit());
    SetImportBlockData(gno,setno,filen,source,nncols, cs, scol,block_curtype,autoscale);
    new_set_no=-1;
    create_set_fromblock(gno, setno, block_curtype, nncols, cs, scol, autoscale);
    SetNewSetNo(new_set_no);
    mainWin->mainArea->completeRedraw();
    delete[] filen;
    delete[] graphs;
    delete[] sets;
    unset_wait_cursor();
}

void frmEditBlockData::doClose(void)
{
    hide();
}

frmLoadEval::frmLoadEval(QWidget * parent):QDialog(parent)
{
    QString entr[MAX_SET_COLS];
    entr[0]=QString("X =");
    entr[1]=QString("Y =");
    entr[2]=QString("Y1 =");
    entr[3]=QString("Y2 =");
    entr[4]=QString("Y3 =");
    entr[5]=QString("Y4 =");
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Load & evaluate"));
    setWindowIcon(QIcon(*GraceIcon));
    grpParameterMesh=new QGroupBox(tr("Parameter mesh ($t)"),this);
    ststst=new stdStartStop(this);
    ststst->lblStart->setText(tr("Start at:"));
    ststst->lblStop->setText(tr("Stop at:"));
    ststst->lblLength->setText(tr("Length:"));
    layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(ststst);
    grpParameterMesh->setLayout(layout0);
    selType=new stdSetTypeSelector(this);
    selType->setShowAll(true);
    selType->lblText->setText(tr("Set type:"));
    connect(selType->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(typeChanged(int)));
    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout->addWidget(grpParameterMesh,0,0,1,6);
    layout->addWidget(selType,1,0,1,3);
    for (int i=0;i<MAX_SET_COLS;i++)
    {
        lblText[i]=new QLabel(entr[i],this);
        ledText[i]=new QLineEdit(QString(""),this);
        layout->addWidget(lblText[i],i+2,0,1,1);
        layout->addWidget(ledText[i],i+2,1,1,5);
        if (i>1)
        {
            lblText[i]->setVisible(false);
            ledText[i]->setVisible(false);
        }
        else
        {
            lblText[i]->setVisible(true);
            ledText[i]->setVisible(true);
        }
    }
    ledText[0]->setText(QString("$t"));
    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    layout->addWidget(buttonGroup,MAX_SET_COLS+2,0,1,6);
    setLayout(layout);
    parentList=NULL;
    resize(LastSize_FormLoadAndEvaluate);
//qDebug() << "LastSize_FormLoadAndEvaluate=" << LastSize_FormLoadAndEvaluate;
}

frmLoadEval::~frmLoadEval()
{
    LastSize_FormLoadAndEvaluate=this->size();
//qDebug() << "Destructor: " << LastSize_FormLoadAndEvaluate;
}

void frmLoadEval::Redisplay(void)
{
//qDebug() << "Redisplay";
    if (OldDecimalPoint==DecimalPointToUse) return;
    QString te;
    ststst->Redisplay();
    for (int i=0;i<MAX_SET_COLS;i++)
    {
        te=ledText[i]->text();
        if (OldDecimalPoint=='.')//.-->,
        {
        te.replace(QChar(','),QChar('|'));
        te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
        }
        else//,-->.
        {
        te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
        te.replace(QChar('|'),QChar(','));
        }
        ledText[i]->setText(te);
    }
}

void frmLoadEval::typeChanged(int i)
{
qDebug() << "TypeChanged";
    (void)i;
int cols=selType->getColumnCount();
    for (int i=0;i<cols;i++)
    {
        lblText[i]->setVisible(true);
        ledText[i]->setVisible(true);
    }
    for (int i=cols;i<MAX_SET_COLS;i++)
    {
        lblText[i]->setVisible(false);
        ledText[i]->setVisible(false);
    }
}

void frmLoadEval::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmLoadEval::doApply(void)
{
    ApplyError=false;
    double start=ststst->start();
    if (ststst->error==true)
    {
        errmsg(tr("Start item undefined").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }
    double stop=ststst->stop();
    if (ststst->error==true)
    {
        errmsg(tr("Stop item undefined").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }
    long npts=ststst->length();
    int res;
    if (ststst->error==true)
    {
        errmsg(tr("Number of points undefined").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }

    char * formula[MAX_SET_COLS];
    char * c_dummy;
    QString dummy;
    int cols=selType->getColumnCount();
    int type=selType->currentValue();
    bool conv_error=false;//error during conversion?
    grarr *t;
    int setno, gno=get_cg();
    setno=0;
    for (int i=0;i<cols;i++)//load all formulas
    {
        dummy=ledText[i]->text();
        dummy=dummy.trimmed();
        if (dummy.isEmpty())
        {
            conv_error=true;
            formula[i]=new char[2];
        }
        else
        {
            formula[i]=new char[dummy.length()*2+8];
            strcpy(formula[i],ledText[i]->text().toLatin1());
            ReplaceDecimalSeparator(formula[i]);//We assume the user has entered decimal separators as set in the Extra-preference --> replace them with '.'
            setno+=strlen(formula[i]);
        }
    }
    c_dummy=new char[setno+8];

    if (conv_error==true)
    {
        errmsg(tr("Formula not recognized!").toLocal8Bit().constData());
        ApplyError=true;
        return;
    }

    t = get_parser_arr_by_name(dollar_t);
    if (t == NULL)
    {
        t = define_parser_arr(dollar_t);
        if (t == NULL)
        {
            errmsg(tr("Internal error").toLocal8Bit().constData());
            ApplyError=true;
            for (int i=0;i<cols;i++)
                delete[] formula[i];
            delete[] c_dummy;
            return;
        }
    }
    
    if (t->length != 0)
    {
        xfree(t->data);
        t->length = 0;
    }
    t->data = allocate_mesh(start, stop, npts);
    if (t->data == NULL)
    {
        errmsg(tr("Internal error").toLocal8Bit().constData());
        ApplyError=true;
        for (int i=0;i<cols;i++)
            delete[] formula[i];
        delete[] c_dummy;
        return;
    }
    t->length = npts;
    
    setno = nextset(gno);
    set_dataset_type(gno, setno, type);
    set_set_hidden(gno, setno, FALSE);
    if (setlength(gno, setno, npts) != RETURN_SUCCESS)
    {
        killset(gno, setno);
        XCFREE(t->data);
        t->length = 0;
        errmsg(tr("Internal error").toLocal8Bit().constData());
        ApplyError=true;
        for (int i=0;i<cols;i++)
            delete[] formula[i];
        delete[] c_dummy;
        return;
    }
    
    set_parser_setno(gno, setno);

    strcpy(c_dummy,"");
    for (int i = 0; i < cols; i++)
    {
        char buf[32], *expr;
        /* preparing the expression */
        sprintf(buf, "GRAPH[%d].SET[%d].%s = ", gno, setno, dataset_colname(i));
        expr = copy_string(NULL, buf);
        expr = concat_strings(expr, formula[i]);
        strcat(c_dummy,dataset_colname(i));
        strcat(c_dummy,"=");
        strcat(c_dummy,formula[i]);
        if (i<cols-1) strcat(c_dummy,";");

        /* evaluate the expression */

        res = scanner(expr);

        xfree(expr);
        
        if (res != RETURN_SUCCESS) {
            killset(gno, setno);
            XCFREE(t->data);
            t->length = 0;
            errmsg(tr("Internal error").toLocal8Bit().constData());
            ApplyError=true;
            for (int i=0;i<cols;i++)
                delete[] formula[i];
            delete[] c_dummy;
            return;
        }
    }
    
    setcomment(gno,setno,c_dummy);
    delete[] c_dummy;

    XCFREE(t->data);
    t->length = 0;

    //Undo-Stuff
    int gnos[2]={gno,gno};
    int snos[2]={setno,setno};
    SetsCreated(1,gnos,snos,UNDO_COMPLETE);
    QString str;
    for (int i=0;i<cols;i++)
    {
        str+=QString(dataset_colname(i))+QString("=")+QString(formula[i]);
        if (i<cols-1)
            str+=QString("; ");
    }
    addAditionalDescriptionToLastNode(-1,QString(),str);
    mainWin->mainArea->completeRedraw();
    for (int i=0;i<cols;i++)
        delete[] formula[i];
    if (parentList!=NULL)
    {
    parentList->set_new_selection(1,snos);
    emit(parentList->new_selection());
    }

}

void frmLoadEval::doClose(void)
{
//qDebug() << "Close";
    hide();
}

grpSelect::grpSelect(QString title,QWidget *parent):QGroupBox( parent )
{
//setFont(*stdFont);
int minheight=10;
    titleString=title;
    setTitle(title);

    lblGraph=new QLabel(tr("Graph:"),this);
    minheight=minheight>lblGraph->height()?minheight:lblGraph->height();
    listGraph=new uniList(GRAPHLIST,this);
    connect(listGraph,SIGNAL(itemSelectionChanged()),listGraph,SLOT(new_selection()));

    lblSet=new QLabel(tr("Set:"),this);
    listSet=new uniList(SETLIST,this);
    connect(listGraph,SIGNAL(new_selection(int)),this,SLOT(set_graph_nr(int)));
    listSet->partner=listGraph;
    listGraph->partner=listSet;

    chkSyncSelection=new QCheckBox(tr("Sync. selection"),this);
    chkSyncSelection->setToolTip(tr("Always make Source=Destination"));
    minheight=minheight>chkSyncSelection->height()?minheight:chkSyncSelection->height();
    syncSource=NULL;
    chkSyncSelection->setVisible(false);
    connect(chkSyncSelection,SIGNAL(toggled(bool)),SLOT(syncToggled(bool)));

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(lblGraph,0,0);
    layout->addWidget(chkSyncSelection,0,1);
    layout->addWidget(listGraph,1,0,1,2);
    layout->addWidget(lblSet,2,0,1,2);
    layout->addWidget(listSet,3,0,3,2);
    layout->setRowMinimumHeight(0,minheight);
    layout->setRowStretch(1,1);
    layout->setRowStretch(3,5);
    setLayout(layout);

    listGraph->set_graph_number(get_cg(),false);
    listSet->set_graph_number(get_cg(),false);
    listGraph->item(get_cg())->setSelected(TRUE);
}

void grpSelect::set_graph_nr(int gno)
{
    if (gno<0)//no selction
    {
    listSet->clear();
    }
    else
    listSet->set_graph_number(gno,true);
}

void grpSelect::enable_sync(uniList * sync_partner)
{
chkSyncSelection->setVisible(true);
syncSource=sync_partner;
connect(syncSource,SIGNAL(new_selection(int)),SLOT(source_got_new_selection(int)));
}

void grpSelect::syncToggled(bool s)
{
    (void)s;
if (chkSyncSelection->isVisible()==false)return;
    if (chkSyncSelection->isChecked()==true)
    {
        listGraph->setEnabled(false);
        listSet->setEnabled(false);
        source_got_new_selection(0);
    }
    else
    {
        listGraph->setEnabled(true);
        listSet->setEnabled(true);
    }
}

void grpSelect::source_got_new_selection(int a)
{
    (void)a;
if (chkSyncSelection->isVisible()==false || syncSource==NULL || chkSyncSelection->isChecked()==false) return;
int gno=syncSource->gr_no;
int nsets,*setnos=new int[2];
syncSource->get_selection(&nsets,&setnos);
mark_multiple_sets(gno,nsets,setnos);
if (setnos) delete[] setnos;
}

void grpSelect::update_number_of_entries(void)
{
    int nr,*sel=new int[2];
    listSet->get_selection(&nr,&sel);
    listGraph->update_number_of_entries_preserve_selection();
    listSet->update_number_of_entries();
    listSet->set_new_selection(nr,sel);
    if (sel) delete[] sel;
}

void grpSelect::mark_single_set(int gno,int setno)
{
    int dummy=gno;
    listGraph->update_number_of_entries();
    listGraph->set_new_selection(1,&dummy);
    dummy=setno;
    listSet->gr_no=gno;
    listSet->update_number_of_entries();
    listSet->set_new_selection(1,&setno);
}

void grpSelect::mark_multiple_sets(int gno,int nsets,int * setnos)
{
    int dummy=gno;
    update_number_of_entries();
    listGraph->set_new_selection(1,&dummy);
    listSet->set_graph_number(gno,false);
    listSet->set_new_selection(nsets,setnos);
}

frmEvalExpr::frmEvalExpr(MainWindow * parWind,QWidget *parent):QDialog( parent )
{
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    parentWindow=parWind;
    setWindowTitle(tr("QtGrace: Evaluate expression"));

    grpSource=new grpSelect(tr("Source"),this);
    grpDestination=new grpSelect(tr("Destination"),this);
    grpDestination->enable_sync(grpSource->listSet);

    lblFormula=new QLabel(tr("Formula:"),this);
    ledFormula=new QTextEdit("",this);

    fraSourceDatFilt=new QGroupBox(tr("Source data filtering"),this);
    fraSourceDatFilt->setGeometry(ledFormula->x(),ledFormula->y()+ledFormula->height(),width(),64);

    int number=7;
    QString entr[7];
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRestriction=new StdSelector(fraSourceDatFilt,tr("Restriction:"),number,entr);

    chkNeg=new QCheckBox(tr("Negated"),fraSourceDatFilt);
    chkNeg->setChecked(FALSE);

    layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(selRestriction);
    layout0->addWidget(chkNeg);
    fraSourceDatFilt->setLayout(layout0);

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    /*connect(grpSource->listSet,SIGNAL(syncSelection()),SLOT(takeSourceToDest()));
    connect(grpDestination->listSet,SIGNAL(syncSelection()),SLOT(takeDestToSource()));*/

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpSource,0,0);
    layout->addWidget(grpDestination,0,1);
    layout->addWidget(lblFormula,1,0,1,2);
    layout->addWidget(ledFormula,2,0,1,2);
    layout->addWidget(fraSourceDatFilt,3,0,1,2);
    layout->addWidget(buttonGroup,4,0,1,2);
    layout->setAlignment(lblFormula,Qt::AlignHCenter);
    setLayout(layout);
    resize(LastSize_FormEvalExpr);
}

frmEvalExpr::~frmEvalExpr()
{
    LastSize_FormEvalExpr=this->size();
}

void frmEvalExpr::doApply(void)
{
    compute_aac();
}

void frmEvalExpr::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmEvalExpr::doClose(void)
{
    hide();
}

void frmEvalExpr::update(void)
{
    grpSource->listGraph->update_number_of_entries();
    grpSource->listSet->update_number_of_entries();
    grpDestination->listGraph->update_number_of_entries();
    grpDestination->listSet->update_number_of_entries();
}

void frmEvalExpr::init(void)
{
    update();
    int nr=1;
    int n_gr[2]={cg,cg};
    grpSource->set_graph_nr(cg);
    grpSource->listGraph->set_new_selection(nr,n_gr);
    grpDestination->set_graph_nr(cg);
    grpDestination->listGraph->set_new_selection(nr,n_gr);
        //grpSource->listGraph->setCurrentItem(grpSource->listGraph->item(0));
        //grpDestination->listGraph->setCurrentRow(0);
    //grpSource->listGraph->setCurrentIndex(0);
}

void frmEvalExpr::takeSourceToDest(void)
{
//qDebug() << "Source To Destination";
int nr_of_sel_sets;
int current_graph;
int * sel_sets=new int[2];
    grpSource->listSet->get_selection(&nr_of_sel_sets,&sel_sets);
    current_graph=grpSource->listSet->gr_no;
grpDestination->set_graph_nr(current_graph);
grpDestination->listSet->blockSignals(true);
grpDestination->listSet->set_new_selection(nr_of_sel_sets,sel_sets);
grpDestination->listSet->blockSignals(false);
if (sel_sets!=NULL) delete[] sel_sets;
}

void frmEvalExpr::takeDestToSource(void)
{
//qDebug() << "Destination To Source";
int nr_of_sel_sets;
int current_graph;
int * sel_sets=new int[2];
    grpDestination->listSet->get_selection(&nr_of_sel_sets,&sel_sets);
    current_graph=grpDestination->listSet->gr_no;
grpSource->set_graph_nr(current_graph);
grpSource->listSet->blockSignals(true);
grpSource->listSet->set_new_selection(nr_of_sel_sets,sel_sets);
grpSource->listSet->blockSignals(false);
if (sel_sets!=NULL) delete[] sel_sets;
}

/*
 * evaluate a formula
 */
void frmEvalExpr::compute_aac(void)
{
    int error, resno;
    int i, g1_ok, g2_ok, ns1, ns2, *svalues1=new int[2], *svalues2=new int[2],gno1, gno2, setno1, setno2;
    char fstr[512];
    char fstr2[512];
    int restr_type, restr_negate;
    char *rarray;
    int * sel_graphs=new int[2];
    char dummy[128];
    set_wait_cursor();
    ApplyError=false;
    switch (selRestriction->currentIndex())
    {
    case 0:
    default:
        restr_type=RESTRICT_NONE;
        break;
    case 1:
        restr_type=RESTRICT_REG0;
        break;
    case 2:
        restr_type=RESTRICT_REG1;
        break;
    case 3:
        restr_type=RESTRICT_REG2;
        break;
    case 4:
        restr_type=RESTRICT_REG3;
        break;
    case 5:
        restr_type=RESTRICT_REG4;
        break;
    case 6:
        restr_type=RESTRICT_WORLD;
        break;
    }
    restr_negate = chkNeg->isChecked()==TRUE?1:0;
    //get the source and destiantion graphs
    grpSource->listGraph->get_selection(&g1_ok,&sel_graphs);
    gno1=gno2=0;
    if (g1_ok==1)
    {
        gno1=sel_graphs[0];
        g1_ok=RETURN_SUCCESS;
    }
    else
        g1_ok=RETURN_FAILURE;
    grpDestination->listGraph->get_selection(&g2_ok,&sel_graphs);
    if (g2_ok==1)
    {
        gno2=sel_graphs[0];
        g2_ok=RETURN_SUCCESS;
    }
    else
        g2_ok=RETURN_FAILURE;
    //get the source and destiantion sets
    grpSource->listSet->get_selection(&ns1,&svalues1);
    grpDestination->listSet->get_selection(&ns2,&svalues2);
    error = FALSE;
    if (g1_ok == RETURN_FAILURE || g2_ok == RETURN_FAILURE) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Please select single source and destination graphs").toLocal8Bit().constData());
    } else if (ns1 == 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("No source sets selected").toLocal8Bit().constData());
    } else if (ns1 != ns2 && ns2 != 0) {
        error = TRUE;
        ApplyError=true;
        errmsg(tr("Different number of source and destination sets").toLocal8Bit().constData());
    } else {
        ///Undo-Stuff: only save destination sets, because only they are modified!
        int * gnos=new int[ns2>0?ns2:ns1];
        if (ns2==0)
        {
            delete[] svalues2;
            svalues2=new int[ns1];
        }
        for (i=0;i<ns1;i++)//ns1==ns2 || ns2==0
        {
            gnos[i]=grpDestination->listSet->gr_no;
        }
        SaveSetStatesPrevious(ns2,gnos,svalues2,UNDO_DATA);//it is possible that there are no sets to be saved here!

        QString tmp_formula=ledFormula->toPlainText();
        tmp_formula.replace("\n",";");
        strcpy(fstr, tmp_formula.toLatin1());

        PrepareFormula(fstr);
        /*
        remove_whitespaces(last_formula,fstr);
        strcpy(fstr,last_formula);
        */
        remove_beginning_whitespaces2(fstr);
        strcpy(last_formula,fstr);
        //cout << "Evaluate Expression: Last Formula=" << last_formula << endl;
        clear_new_set_ids();//prepare for the generation of new set-ids
        ListOfChanges.clear();
        ListOfOldStates.clear();
        for (i = 0; i < ns1; i++)//go through all source-sets
        {
            setno1 = svalues1[i];
            if (ns2 != 0) {//ns2==ns1
                setno2 = svalues2[i];
            } else {
                setno2 = nextset(gno2);
                //new set --> copy command needed for commands-window
                sprintf(fstr2,"COPY G%d.S%d TO G%d.S%d",gno1, setno1, gno2, setno2);
                ListOfChanges << QString(fstr2);
                set_set_hidden(gno2, setno2, FALSE);
                svalues2[i]=setno2;//because I need this for Undo-function!
            }
            resno = get_restriction_array(gno1, setno1,restr_type, restr_negate, &rarray);
            if (resno != RETURN_SUCCESS) {
                errmsg(tr("Error in evaluation restriction").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            strcpy(fstr2,fstr);
            //the replacing will now be done in do_compute
            /*
qDebug() << "Orig Formula=" << fstr2;
            prependSetID(fstr2,setno2,gno2,setno1,gno1);//modify formula for use with commands-window
qDebug() << "Mod. Formula=" << fstr2;
            */
            current_target_graph=gno2;
            current_target_set=setno2;
            current_origin_graph=gno1;
            current_origin_set=setno1;
            /// set_parser_setno(gno1,setno1);
            //qDebug() << "converted formula:" << fstr2;
//QTime evaltim;
//evaltim.start();
            resno = do_compute(gno1, setno1, gno2, setno2, rarray, fstr2);//fstr replaced by fstr2
//qDebug() << "computation takes=" << evaltim.restart() << "ms";
            XCFREE(rarray);
            if (resno != RETURN_SUCCESS) {
                errwin(tr("Error in do_compute(), check formula").toLocal8Bit().constData());
                ApplyError=true;
                break;
            }
            ListOfChanges << QString(fstr2);
        }
        if (ApplyError==false)
        {
            SetsModified(ns1,gnos,svalues2,UNDO_DATA);//the new sets
            if (ns1==1)
            {
                sprintf(dummy,"[G%d.S%d]",gnos[0],svalues2[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_SET_MODIFIED,tr("Evaluate expression")+QString(dummy),QString(fstr),0);//usefull for adding a formula
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_SET_MODIFIED,tr("Evaluate expression"),QString(fstr),-1);//usefull for adding a formula
            }
            CheckActive();
        }
        delete[] gnos;
    }
    
    if (error == FALSE)
    {
        if (gno1 != gno2)
        {
            update_set_lists(gno1);
            update_set_lists(gno2);
        } else {
            update_set_lists(gno1);
        }
        mainWin->mainArea->completeRedraw();
        //grpSource->mark_multiple_sets(gno1,ns1,svalues1);//selection of source-sets should not be changed!
        //cout << "select new sets: " << gno2 << " ns1=" << ns1 << endl;
        ///Deactivated the autoselection for v0.2.6
        ///grpDestination->mark_multiple_sets(gno2,ns1,svalues2);//I changed this to ns1, because svalues2 now contains the new set-ids
    }
    unset_wait_cursor();
    delete[] sel_graphs;
    delete[] svalues1;
    delete[] svalues2;
}

nlcfTabMain::nlcfTabMain(QWidget * parent):QWidget(parent)
{
    int number;
    char dummy[MAXPARM+2];
    QString entr[MAXPARM+2];
    ledFormula=new stdLineEdit(this,tr("Formula:"));
    ledFormula->lenText->setText(QString("y = "));
    ledTolerance=new stdLineEdit(this,tr("Tolerance:"));

    if (DecimalPointToUse==',')
        ledTolerance->lenText->setText(QString("0,01"));
    else
        ledTolerance->lenText->setText(QString("0.01"));

    number=MAXPARM+1;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i]=QString(dummy);
    }
    selParameters=new StdSelector(this,tr("Parameters:"),number,entr);
    connect(selParameters->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(paraNumberChanged(int)));
    selIterations=new stdIntSelector(this,tr("Iterations:"),0,500);
    selIterations->spnInt->setSingleStep(5);
    selIterations->setValue(5);
    scroll=new QScrollArea;
    spreadParameters=new spreadSheet(scroll,1,1,3);
    scroll->setWidget(spreadParameters);

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(ledFormula,0,0,1,3);
    layout->addWidget(selParameters,1,0);
    layout->addWidget(ledTolerance,1,1);
    layout->addWidget(selIterations,1,2);
    layout->addWidget(scroll,2,0,3,3);
    setLayout(layout);
    paraNumberChanged(0);
}

void nlcfTabMain::paraNumberChanged(int i)
{
    spreadParameters->setGeometry(0,0,width()-10,30*i);
    spreadParameters->resize(i,3);
}

nlcfTabAdvanced::nlcfTabAdvanced(QWidget * parent):QWidget(parent)
{
    int number;
    QString entr[10];

    grpSourceDataFilter=new QGroupBox(tr("Source data filtering"),this);
    number=7;
    entr[0]=tr("None");
    entr[1]=tr("Region 0");
    entr[2]=tr("Region 1");
    entr[3]=tr("Region 2");
    entr[4]=tr("Region 3");
    entr[5]=tr("Region 4");
    entr[6]=tr("Inside graph");
    selRestrictions=new StdSelector(this,tr("Restriction:"),number,entr);
    chkNegated=new QCheckBox(tr("Negated"),this);
    layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(selRestrictions);
    layout0->addWidget(chkNegated);
    grpSourceDataFilter->setLayout(layout0);

    grpWeighting=new QGroupBox(tr("Weighting"),this);
    number=5;
    entr[0]=tr("None");
    entr[1]=tr("1/Y");
    entr[2]=tr("1/Y^2");
    entr[3]=tr("1/dY^2");
    entr[4]=tr("Custom");
    selWeights=new StdSelector(grpWeighting,tr("Weights:"),number,entr);
    connect(selWeights->cmbSelect, SIGNAL(currentIndexChanged(int)), this, SLOT(weights_changed(int)));
    ledFunction=new stdLineEdit(grpWeighting,tr("Function:"));
    ledFunction->setText(QString(""));
    layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(selWeights);
    layout1->addWidget(ledFunction);
    grpWeighting->setLayout(layout1);

    grpLoadOptions=new QGroupBox(tr("Load options"),this);
    number=3;
    entr[0]=tr("Fitted values");
    entr[1]=tr("Residuals");
    entr[2]=tr("Function");
    selLoad=new StdSelector(grpLoadOptions,tr("Load:"),number,entr);
    connect(selLoad->cmbSelect, SIGNAL(currentIndexChanged(int)), this, SLOT(load_changed(int)));
    ledStartLoadAt=new stdLineEdit(grpLoadOptions,tr("Start $t at:"));
    ledStopLoadAt=new stdLineEdit(grpLoadOptions,tr("Stop $t at:"));
    ledNumberOfPoints=new stdLineEdit(grpLoadOptions,tr("# of points:"));
    ledXFunction=new stdLineEdit(grpLoadOptions,tr("Load x as "));
    ledXFunction->setText(QString("$t"));
    layout2=new QGridLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selLoad,0,0);
    layout2->addWidget(ledXFunction,0,1,1,2);
    layout2->addWidget(ledStartLoadAt,1,0);
    layout2->addWidget(ledStopLoadAt,1,1);
    layout2->addWidget(ledNumberOfPoints,1,2);
    grpLoadOptions->setLayout(layout2);

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpSourceDataFilter);
    layout->addWidget(grpWeighting);
    layout->addWidget(grpLoadOptions);
    setLayout(layout);
    load_changed(0);
}

void nlcfTabAdvanced::weights_changed(int i)
{
    if (i==WEIGHT_CUSTOM)
    {
        ledFunction->setEnabled(true);
    }
    else
    {
        ledFunction->setEnabled(false);
    }
}

void nlcfTabAdvanced::load_changed(int i)
{
    if (i==LOAD_FUNCTION)
    {
        ledStartLoadAt->setEnabled(true);
        ledStopLoadAt->setEnabled(true);
        ledNumberOfPoints->setEnabled(true);
        ledXFunction->setEnabled(true);
    }
    else
    {
        ledStartLoadAt->setEnabled(false);
        ledStopLoadAt->setEnabled(false);
        ledNumberOfPoints->setEnabled(false);
        ledXFunction->setEnabled(false);
    }
}

frmNonlinCurveFit::frmNonlinCurveFit(QWidget * parent):QDialog(parent)
{
    frmOpenFitPara=NULL;
    frmSaveFitPara=NULL;
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Non-linear curve fitting"));
    setWindowIcon(QIcon(*GraceIcon));

    CreateActions();

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu(tr("&File"));
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actOpen);
    mnuFile->addAction(actSave);
    mnuFile->addSeparator();
    mnuFile->addAction(actClose);
    mnuEdit=new QMenu(tr("&Edit"));
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actResetFit);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actLoadFit);
    mnuView=new QMenu(tr("&View"));
    mnuView->setTearOffEnabled(TRUE);
    mnuView->addAction(actAutoLoad);
    mnuView->addSeparator();
    mnuView->addAction(actUpdate);
    mnuHelp=new QMenu(tr("&Help"));
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpOnFit);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addMenu(mnuView);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    empty=new QWidget(this);
    grpSource=new grpSelect(tr("Source"),empty);
    grpDestination=new grpSelect(tr("Destination"),empty);

    lblAFit=new QLineEdit(tr("A fit"),this);
    QPalette pal=lblAFit->palette();
    pal.setColor(QPalette::Base,mainWin->palette().window().color());
    pal.setColor(QPalette::Window,mainWin->palette().window().color());
    lblAFit->setPalette(pal);
    //lblAFit->setFrameStyle(QFrame::Box | QFrame::Raised);
    tabs=new QTabWidget(this);
    tabMain=new nlcfTabMain(tabs);
    tabAdvanced=new nlcfTabAdvanced(tabs);
    tabs->addTab(tabMain,tr("Main"));
    tabs->addTab(tabAdvanced,tr("Advanced"));

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout0=new QHBoxLayout;
    layout0->setMargin(0);
    layout0->addWidget(grpSource);
    layout0->addWidget(grpDestination);
    empty->setLayout(layout0);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    /*
layout->addWidget(menuBar,0,0,1,2);
layout->addWidget(grpSource,1,0);
layout->addWidget(grpDestination,1,1);
layout->addWidget(lblAFit,2,0,1,2);
layout->setAlignment(lblAFit,Qt::AlignHCenter);
layout->addWidget(tabs,3,0,1,2);
layout->addWidget(buttonGroup,4,0,1,2);
*/
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(empty);
    layout->addWidget(lblAFit);
    lblAFit->setAlignment(Qt::AlignHCenter);
    ///layout->setAlignment(lblAFit,Qt::AlignHCenter);
    layout->addWidget(tabs);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    initialize_nonl();
    resize(LastSize_FormNonlinCurveFit);
}

frmNonlinCurveFit::~frmNonlinCurveFit()
{
    LastSize_FormNonlinCurveFit=this->size();
}

void frmNonlinCurveFit::CreateActions(void)
{
    actClose = new QAction(tr("&Close"), this);
    //actClose->setShortcut(tr("Esc"));
    actClose->setStatusTip(tr("Close this Window"));
    connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
    actOpen= new QAction(tr("&Open..."), this);
    actOpen->setShortcut(tr("Ctrl+O"));
    connect(actOpen, SIGNAL(triggered()), this, SLOT(doOpen()));
    actSave= new QAction(tr("&Save"), this);
    actSave->setShortcut(tr("Ctrl+S"));
    connect(actSave, SIGNAL(triggered()), this, SLOT(doSave()));
    actResetFit= new QAction(tr("&Reset fit parameters"), this);
    connect(actResetFit, SIGNAL(triggered()), this, SLOT(doResetFit()));
    actLoadFit= new QAction(tr("&Load current fit"), this);
    connect(actLoadFit, SIGNAL(triggered()), this, SLOT(doLoadFit()));
    actAutoLoad= new QAction(tr("&Autoload"), this);
    actAutoLoad->setCheckable(TRUE);
    actAutoLoad->setChecked(TRUE);
    connect(actAutoLoad, SIGNAL(triggered()), this, SLOT(doAutoLoad()));
    actUpdate= new QAction(tr("&Update"), this);
    connect(actUpdate, SIGNAL(triggered()), this, SLOT(doUpdate()));
    actHelpOnContext= new QAction(tr("&On context"), this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext, SIGNAL(triggered()), this, SLOT(doHelpContext()));
    actHelpOnFit = new QAction(tr("&On fit"), this);
    connect(actHelpOnFit, SIGNAL(triggered()), this, SLOT(doHelpFit()));
}

void frmNonlinCurveFit::update_nonl_frame(void)
{
    int i;
    //XmString str = XmStringCreateLocalized(nonl_opts.title);
    //XtVaSetValues(nonl_title_item, XmNlabelString, str, NULL);
    lblAFit->setText(QString(nonl_opts.title));
    /*
 * If I define only XmALIGNMENT_CENTER (default!) then it's ignored - bug in Motif???
 */
    //XtVaSetValues(nonl_title_item, XmNalignment, XmALIGNMENT_BEGINNING, NULL);
    //XtVaSetValues(nonl_title_item, XmNalignment, XmALIGNMENT_CENTER, NULL);
    //XmStringFree(str);

    strcpy(buf,nonl_opts.formula);
    SetDecimalSeparatorToUserValue(buf);
    SetTextString(tabMain->ledFormula, buf);
    sprintf(buf, "%g", nonl_opts.tolerance);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(tabMain->ledTolerance, buf);
    SetOptionChoice(tabMain->selParameters, nonl_opts.parnum);
    tabMain->paraNumberChanged(nonl_opts.parnum);//to rescale the parameter-entries
    for (i = 0; i < MAXPARM; i++)
    {
        sprintf(buf, "%g", nonl_parms[i].value);
        SetDecimalSeparatorToUserValue(buf);
        //tabMain->spreadParameters->fitlines[i]->ledValue
        xv_setstr(tabMain->spreadParameters->fitlines[i]->ledValue, buf);
        SetToggleButtonState(tabMain->spreadParameters->fitlines[i]->chkBonds, nonl_parms[i].constr);
        sprintf(buf, "%g", nonl_parms[i].min);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(tabMain->spreadParameters->fitlines[i]->ledLowerBound, buf);
        SetSensitive(tabMain->spreadParameters->fitlines[i]->ledLowerBound, nonl_parms[i].constr);
        sprintf(buf, "%g", nonl_parms[i].max);
        SetDecimalSeparatorToUserValue(buf);
        xv_setstr(tabMain->spreadParameters->fitlines[i]->ledHighterBound, buf);
        SetSensitive(tabMain->spreadParameters->fitlines[i]->ledHighterBound, nonl_parms[i].constr);
        /*if (i < nonl_opts.parnum) {
                if (!XtIsManaged (nonl_parm_item[i])) {
                    ManageChild(nonl_parm_item[i]);
                }
            } else {
                if (XtIsManaged (nonl_parm_item[i])) {
                    UnmanageChild(nonl_parm_item[i]);
                }
            }*/
    }

    actAutoLoad->setChecked(nonl_prefs.autoload);
    SetOptionChoice(tabAdvanced->selLoad, nonl_prefs.load);

    if (nonl_prefs.load == LOAD_FUNCTION) {
        SetSensitive(tabAdvanced->ledStartLoadAt, true);
        SetSensitive(tabAdvanced->ledStopLoadAt, true);
        SetSensitive(tabAdvanced->ledNumberOfPoints, true);
    } else {
        SetSensitive(tabAdvanced->ledStartLoadAt, false);
        SetSensitive(tabAdvanced->ledStopLoadAt, false);
        SetSensitive(tabAdvanced->ledNumberOfPoints, false);
    }

    if (GetOptionChoice(tabAdvanced->selWeights) == WEIGHT_CUSTOM) {
        SetSensitive(tabAdvanced->ledFunction, true);
    } else {
        SetSensitive(tabAdvanced->ledFunction, false);
    }

    sprintf(buf, "%g", nonl_prefs.start);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(tabAdvanced->ledStartLoadAt, buf);
    sprintf(buf, "%g", nonl_prefs.stop);
    SetDecimalSeparatorToUserValue(buf);
    xv_setstr(tabAdvanced->ledStopLoadAt, buf);
    sprintf(buf, "%d", nonl_prefs.npoints);
    xv_setstr(tabAdvanced->ledNumberOfPoints, buf);

    grpSource->update_number_of_entries();
    grpDestination->update_number_of_entries();
}

void frmNonlinCurveFit::init(void)
{
    update_nonl_frame();
    int nr=1,sel=get_cg();
    grpSource->listGraph->set_new_selection(nr,&sel);
    grpSource->listSet->set_graph_number(sel,false);
    grpDestination->listGraph->set_new_selection(nr,&sel);
    grpDestination->listSet->set_graph_number(sel,false);
}

bool frmNonlinCurveFit::read_fit_options(void)
{
bool erro=false;
    reset_nonl();
    nonl_opts.formula = copy_string(nonl_opts.formula,tabMain->ledFormula->text().toLatin1());// GetTextString(nonl_formula_item));
    ReplaceDecimalSeparator(nonl_opts.formula);
    nonl_opts.nsteps = (int) GetSpinChoice(tabMain->selIterations);//nonl_nsteps_item);
    if (xv_evalexpr(tabMain->ledTolerance,&nonl_opts.tolerance)==RETURN_FAILURE)
    {
        stufftext(tr("Invalid tolerance entered; tolerance set to 0.01!").toLocal8Bit().constData());
        nonl_opts.tolerance=0.01;
    }
    //nonl_opts.tolerance = atof(xv_getstr(tabMain->ledTolerance));
    nonl_opts.parnum = GetOptionChoice(tabMain->selParameters);
    for (int i = 0; i < nonl_opts.parnum; i++) {
        strcpy(buf, xv_getstr(tabMain->spreadParameters->fitlines[i]->ledValue));// nonl_value_item[i]));
        ReplaceDecimalSeparator(buf);
        if (sscanf(buf, "%lf", &nonl_parms[i].value) != 1) {
            errmsg(tr("Invalid input in parameter field").toLocal8Bit().constData());
            erro=true;
        }
        nonl_parms[i].constr = GetToggleButtonState(tabMain->spreadParameters->fitlines[i]->chkBonds);// nonl_constr_item[i]);
        if (nonl_parms[i].constr) {
            strcpy(buf, xv_getstr(tabMain->spreadParameters->fitlines[i]->ledLowerBound));// nonl_lowb_item[i]));
            ReplaceDecimalSeparator(buf);
            if (sscanf(buf, "%lf", &nonl_parms[i].min) != 1) {
                errmsg(tr("Invalid input in low-bound field").toLocal8Bit().constData());
                erro=true;
            }
            strcpy(buf, xv_getstr(tabMain->spreadParameters->fitlines[i]->ledHighterBound));// nonl_uppb_item[i]));
            ReplaceDecimalSeparator(buf);
            if (sscanf(buf, "%lf", &nonl_parms[i].max) != 1) {
                errmsg(tr("Invalid input in upper-bound field").toLocal8Bit().constData());
                erro=true;
            }
            if ((nonl_parms[i].value < nonl_parms[i].min) || (nonl_parms[i].value > nonl_parms[i].max)) {
                errmsg(tr("Initial values must be within bounds").toLocal8Bit().constData());
                erro=true;
            }
        }
    }//end i-loop (load all parameters)
return erro;
}

void frmNonlinCurveFit::doApply(void)
{
static int ApplyRunning=false;
if (ApplyRunning==true) return;
ApplyRunning=true;
    int i,itmp;
    int src_gno,dest_gno, src_setno;
    int resno,newset;
    char *fstr;
    int nlen, wlen;
    int weight_method;
    double *ytmp, *warray;
    int restr_type, restr_negate;
    char *rarray;
    int ns1,*svalues1=new int[2];
    int ns2,*svalues2=new int[2];
    QString save_formula,a1,v1;
    svalues1[0]=svalues2[0]=svalues1[1]=svalues2[1]=-1;
    ApplyError=false;
    if (GetSingleListChoice(grpSource->listGraph, &src_gno) != RETURN_SUCCESS)
    {
        errmsg(tr("No source graph selected").toLocal8Bit().constData());
        ApplyError=true;
        ApplyRunning=false;
        return;
    }
    grpSource->listSet->get_selection(&ns1,&svalues1);
    //if (GetSingleListChoice(grpSource->listSet, &src_setno) != RETURN_SUCCESS)
    if (ns1<1)
    {
        errmsg(tr("No source set selected").toLocal8Bit().constData());
        ApplyError=true;
        ApplyRunning=false;
        return;
    }
    newset=-1;
    GetSingleListChoice(grpDestination->listGraph, &dest_gno);
    grpDestination->listSet->get_selection(&ns2,&svalues2);
    if (ns1>1)//nr of source sets > 1 --> combine to one new temporary set
    {
        resno=0;
        ApplyError=false;
        nonl_opts.nsteps=dataset_cols(src_gno,svalues1[0]);
        for (int i=0;i<ns1;i++)
        {
            resno+=getsetlength(src_gno,svalues1[i]);
            if (nonl_opts.nsteps!=dataset_cols(src_gno,svalues1[i])) ApplyError=true;
        }
        if (ApplyError==true)
        {
            errmsg(tr("Please select source sets with the same column-count.").toLocal8Bit().constData());
            ApplyRunning=false;
            return;
        }
        ApplyError=false;
        newset=nextset(src_gno);
        copyset(src_gno,svalues1[0],src_gno,newset);
        setlength(src_gno,newset,resno);
//cout << "new combined temporary set generated=" << src_gno << "." << newset << endl;
        set_legend_string(src_gno,newset,QString("").toLocal8Bit().data());
        resno=0;
        for (int i=0;i<ns1;i++)//go through all selected sets
        {
            for (int j=0;j<nonl_opts.nsteps;j++)//go through all columns
            {
                memcpy(g[src_gno].p[newset].data.ex[j]+resno,g[src_gno].p[svalues1[i]].data.ex[j],getsetlength(src_gno,svalues1[i])*sizeof(double));
            }
            resno+=getsetlength(src_gno,svalues1[i]);
        }
        sortset(src_gno,newset,DATA_X,dataset_type(src_gno,newset));
        src_setno=newset;
    }
    else
        src_setno=svalues1[0];

    ApplyError=read_fit_options();

    if (ApplyError==true)
    {
        ApplyRunning=false;
        return;
    }
    save_formula=QString(nonl_opts.formula);

    ///Undo-Stuff
    SaveFitSettings();
    ListOfOldStates.clear();
    ListOfChanges.clear();

    save_formula=save_formula.toUpper();

    if (nonl_opts.nsteps) {
        /* apply weigh function */
        nlen = getsetlength(src_gno, src_setno);
        weight_method = GetOptionChoice(tabAdvanced->selWeights);// nonl_weigh_item);
        switch (weight_method) {
        case WEIGHT_Y:
        case WEIGHT_Y2:
            ytmp = getcol(src_gno, src_setno, DATA_Y);
            for (i = 0; i < nlen; i++) {
                if (ytmp[i] == 0.0) {
                    errmsg(tr("Divide by zero while calculating weights").toLocal8Bit().constData());
                    ApplyError=true;
                    ApplyRunning=false;
                    return;// RETURN_FAILURE;
                }
            }
            warray = (double*) xmalloc(nlen*sizeof(double));//SIZEOF_DOUBLE);
            if (warray == NULL) {
                errmsg(tr("xmalloc failed in do_nonl_proc()").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            for (i = 0; i < nlen; i++) {
                if (weight_method == WEIGHT_Y) {
                    warray[i] = 1.0/ytmp[i];
                } else {
                    warray[i] = 1.0/(ytmp[i]*ytmp[i]);
                }
            }
            break;
        case WEIGHT_DY:
            ytmp = getcol(src_gno, src_setno, DATA_Y1);
            if (ytmp == NULL) {
                errmsg(tr("The set doesn't have dY data column").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            for (i = 0; i < nlen; i++) {
                if (ytmp[i] == 0.0) {
                    errmsg(tr("Divide by zero while calculating weights").toLocal8Bit().constData());
                    ApplyError=true;
                    ApplyRunning=false;
                    return;// RETURN_FAILURE;
                }
            }
            warray = (double*)xmalloc(nlen*sizeof(double));//SIZEOF_DOUBLE);
            if (warray == NULL) {
                errmsg(tr("xmalloc failed in do_nonl_proc()").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;
            }
            for (i = 0; i < nlen; i++) {
                warray[i] = 1/(ytmp[i]*ytmp[i]);
            }
            break;
        case WEIGHT_CUSTOM:
            if (set_parser_setno(src_gno, src_setno) != RETURN_SUCCESS) {
                errmsg(tr("Bad set").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            fstr = xv_getstr(tabAdvanced->ledFunction);// nonl_wfunc_item);
            ReplaceDecimalSeparator(fstr);
            if (v_scanner(fstr, &wlen, &warray) != RETURN_SUCCESS) {
                errmsg(tr("Error evaluating expression for weights").toLocal8Bit().constData());
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            if (wlen != nlen) {
                errmsg(tr("The array of weights has different length").toLocal8Bit().constData());
                xfree(warray);
                ApplyError=true;
                ApplyRunning=false;
                return;// RETURN_FAILURE;
            }
            break;
        default:
            warray = NULL;
            break;
        }
        /* apply restriction */
        //restr_type = GetOptionChoice(tabAdvanced->selRestrictions);//restr_item->r_sel);
        switch (tabAdvanced->selRestrictions->currentIndex())//special type for restrictions
        {
        case 0:
        default:
            restr_type=RESTRICT_NONE;
            break;
        case 1:
            restr_type=RESTRICT_REG0;
            break;
        case 2:
            restr_type=RESTRICT_REG1;
            break;
        case 3:
            restr_type=RESTRICT_REG2;
            break;
        case 4:
            restr_type=RESTRICT_REG3;
            break;
        case 5:
            restr_type=RESTRICT_REG4;
            break;
        case 6:
            restr_type=RESTRICT_WORLD;
            break;
        }
        restr_negate = GetToggleButtonState(tabAdvanced->chkNegated);// restr_item->negate);
        resno = get_restriction_array(src_gno, src_setno,restr_type, restr_negate, &rarray);
        if (resno != RETURN_SUCCESS) {
            errmsg(tr("Error in restriction evaluation").toLocal8Bit().constData());
            xfree(warray);
            ApplyError=true;
            ApplyRunning=false;
            return;// RETURN_FAILURE;
        }
        sprintf(dummy,"with G%d",src_gno);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"fit formula \"%s\"",nonl_opts.formula);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"fit with %d parameters",nonl_opts.parnum);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"fit prec %f",nonl_opts.tolerance);
        ListOfChanges << QString(dummy);
        for (i=0;i<nonl_opts.parnum;i++)
        {
            sprintf(dummy,"a%d = %f",i,nonl_parms[i].value);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"a%d constraints %s",i,nonl_parms[i].constr==true?"on":"off");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"a%dmin = %f",i,nonl_parms[i].min);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"a%dmax = %f",i,nonl_parms[i].max);
            ListOfChanges << QString(dummy);
        }
        sprintf(dummy,"nonlfit (s%d, %d)",src_setno,nonl_opts.nsteps);
        ListOfChanges << QString(dummy);

        /* The fit itself! */
        resno = do_nonlfit(src_gno, src_setno, warray, rarray, nonl_opts.nsteps);

        xfree(warray);
        xfree(rarray);

        if (resno != RETURN_SUCCESS) {
            errmsg(tr("Fatal error in do_nonlfit()").toLocal8Bit().constData());
            ApplyError=true;
            ApplyRunning=false;
            return;// RETURN_FAILURE;
        }

        for (i = 0; i < nonl_opts.parnum; i++)
        {
            sprintf(buf, "%g", nonl_parms[i].value);
            SetDecimalSeparatorToUserValue(buf);
            xv_setstr(tabMain->spreadParameters->fitlines[i]->ledValue, buf);
        }
    }

    /*//deleted, because the formula is saved automatically in "do_nonlfit()" - in this way it will also work scripts
    for (i = 0; i < nonl_opts.parnum; i++)
    {
        sprintf(buf,"A%d",i);
        a1=QString(buf);
        sprintf(buf, "%g", nonl_parms[i].value);
        v1=QString(buf);
        save_formula.replace(a1,v1);
    }

strcpy(last_formula,save_formula.toLatin1().constData());
for (i=0;i<nonl_opts.parnum;i++)
last_fit_falues[i]=nonl_parms[i].value;*/

/*
 * Select & activate a set to load results to
 */
    load_nonl_fit(src_gno, src_setno, FALSE);
    /*if (GetSingleListChoice(grpDestination->listSet, &dest_setno) != RETURN_SUCCESS))
    {

    }*/

    //cout << "newset=" << newset << " last formula=#" << last_formula << "#" << endl;
    GetSingleListChoice(grpDestination->listGraph, &itmp);
    if (newset!=-1)//we have created a new set for the fit --> delete it
    {
        /*cout << "originally selected:" << endl;
        for (int i=0;i<ns1;i++)
        {
        cout << "G" << src_gno << ".S" << svalues1[i] << endl;
        }
    */

        GetSingleListChoice(grpDestination->listSet,&resno);

        //cout << "src: G" << src_gno << ".S" << src_setno << ", newset=" << newset << endl;
        //cout << "Destination: G" << nsteps << ".S" << resno << " oder doch " << svalues2[0] << endl;
        //cout << "dest_graph=" << fit_destination_graph << " dest_set=" << fit_destination_set << endl;

        //grpSource->listSet->set_new_selection(ns1,svalues1);
        ns2=1;
        if (itmp==src_gno && src_setno<resno)
        {
            do_swapset(src_gno,src_setno,itmp,resno);
            killsetdata(itmp,resno);
            svalues2[0]=src_setno;
            //cout << "musste tauschen: G" << src_gno << ".S" << src_setno << " <-> G" << nsteps << ".S" << resno << endl;
        }
        else
        {
            killsetdata(src_gno,src_setno);
            svalues2[0]=resno;
        }
        //cout << "Killed G" << nsteps << ".S" << resno << endl;
        //cout << "Marking G" << nsteps << ".S" << svalues2[0] << endl;
        fit_destination_graph=itmp;
        fit_destination_set=svalues2[0];
        grpDestination->mark_single_set(itmp,svalues2[0]);
        grpSource->update_number_of_entries();

        //grpDestination->listSet->set_new_selection(ns1,svalues1);
        //update_set_lists(src_gno);
        //if (src_gno!=nsteps) update_set_lists(nsteps);
        //y = a0*exp(-((x-a1)/a2)^2)+a3*exp(-((x-a4)/a5)^2)
    }

    mainWin->mainArea->completeRedraw();

    update_set_lists(src_gno);//necessary to show sets that have just been generated (or have changed setlengths)
    if (src_gno!=itmp) update_set_lists(itmp);//necessary to show sets that have just been generated (or have changed setlengths)
    grpSource->listSet->set_new_selection(ns1,svalues1);
    grpDestination->set_graph_nr(dest_gno);
    //cout << "ns2=" << ns2 << endl;

    if (fit_destination_set!=-1)
    {
        ns2=1;
        svalues2[0]=fit_destination_set;
    }

    grpDestination->listSet->set_new_selection(ns2,svalues2);
    ///Undo-Stuff
    SaveFitAfter();
    ApplyRunning=false;
    return;// RETURN_SUCCESS;
}

void frmNonlinCurveFit::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmNonlinCurveFit::doClose(void)
{
    hide();
}

void frmNonlinCurveFit::doOpen(void)
{
if (should_open_grace_file_dialog())
{
    if (frmOpenFitPara==NULL)
    {
        frmOpenFitPara=new frmIOForm(READ_FIT_PARAM,this);
        connect(frmOpenFitPara,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    frmOpenFitPara->init();
    frmOpenFitPara->show();
    frmOpenFitPara->raise();
}
else
{
mainWin->UseOperatingSystemFileDialog(READ_FIT_PARAM,tr("QtGrace: Open fit parameter file"),Last_Dialog_Path[READ_FIT_PARAM],tr("Fit parameters (*.fit);;All files (*)"));
}
}

void frmNonlinCurveFit::doSave(void)
{
if (should_open_grace_file_dialog())
{
    if (frmSaveFitPara==NULL)
    {
        frmSaveFitPara=new frmIOForm(WRITE_FIT_PARAM,this);
        connect(frmSaveFitPara,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    frmSaveFitPara->init();
    frmSaveFitPara->show();
    frmSaveFitPara->raise();
}
else
{
mainWin->UseOperatingSystemFileDialog(WRITE_FIT_PARAM,tr("QtGrace: Save fit parameter file"),Last_Dialog_Path[WRITE_FIT_PARAM],tr("Fit parameters (*.fit);;All files (*)"));
}
}

void frmNonlinCurveFit::doResetFit(void)
{
    reset_nonl();
    update_nonl_frame();
}

void frmNonlinCurveFit::doLoadFit(void)
{
    int src_gno, src_setno;
    if (GetSingleListChoice(grpSource->listGraph, &src_gno) !=
            RETURN_SUCCESS) {
        errmsg(tr("No source graph selected").toLocal8Bit().constData());
        return;
    }
    if (GetSingleListChoice(grpSource->listSet, &src_setno) !=
            RETURN_SUCCESS) {
        errmsg(tr("No source set selected").toLocal8Bit().constData());
        return;
    }
    load_nonl_fit(src_gno, src_setno, TRUE);
}

void frmNonlinCurveFit::doAutoLoad(void)
{}

void frmNonlinCurveFit::doUpdate(void)
{
    update_nonl_frame();
}

void frmNonlinCurveFit::doHelpContext(void)
{
    setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmNonlinCurveFit::doHelpFit(void)
{
    HelpCB("doc/UsersGuide.html#non-linear-fit");
}

void frmNonlinCurveFit::load_nonl_fit(int src_gno, int src_setno, int force)
{
    int dest_gno, dest_setno;
    int i, npts = 0;
    double delx, *xfit, *y, *yfit;
    fit_destination_graph=-1;
    fit_destination_set=-1;
    if (GetSingleListChoice(grpDestination->listGraph, &dest_gno) != RETURN_SUCCESS)
    {
        errmsg(tr("No destination graph selected").toLocal8Bit().constData());
        return;// RETURN_FAILURE;
    }
    if (GetSingleListChoice(grpDestination->listSet, &dest_setno) != RETURN_SUCCESS)
    {
        /* no dest sel selected; allocate new one */
        dest_setno = nextset(dest_gno);
        //newset=dest_setno;
        if (dest_setno == -1)
        {
            return;// RETURN_FAILURE;
        }
        else
        {
            activateset(dest_gno, dest_setno);
        }
    }

    nonl_prefs.autoload = actAutoLoad->isChecked()==true?1:0;
    nonl_prefs.load = GetOptionChoice(tabAdvanced->selLoad);

    if (nonl_prefs.load == LOAD_FUNCTION)
    {
        if (xv_evalexpr(tabAdvanced->ledStartLoadAt, &nonl_prefs.start) != RETURN_SUCCESS) {
            errmsg(tr("Invalid input in start field").toLocal8Bit().constData());
            return;// RETURN_FAILURE;
        }
        if (xv_evalexpr(tabAdvanced->ledStopLoadAt, &nonl_prefs.stop) != RETURN_SUCCESS) {
            errmsg(tr("Invalid input in start field").toLocal8Bit().constData());
            return;// RETURN_FAILURE;
        }
        if (xv_evalexpri(tabAdvanced->ledNumberOfPoints, &nonl_prefs.npoints) != RETURN_SUCCESS) {
            errmsg(tr("Invalid input in start field").toLocal8Bit().constData());
            return;// RETURN_FAILURE;
        }
        if (nonl_prefs.npoints <= 1) {
            errmsg(tr("Number of points must be > 1").toLocal8Bit().constData());
            return;// RETURN_FAILURE;
        }
    }

    if (force || nonl_prefs.autoload)
    {
        switch (nonl_prefs.load) {
        case LOAD_VALUES:
        case LOAD_RESIDUALS:
            npts = getsetlength(src_gno, src_setno);
            setlength(dest_gno, dest_setno, npts);
            copycol2(src_gno, src_setno, dest_gno, dest_setno, DATA_X);
            break;
        case LOAD_FUNCTION:
            npts  = nonl_prefs.npoints;

            setlength(dest_gno, dest_setno, npts);

            delx = (nonl_prefs.stop - nonl_prefs.start)/(npts - 1);
            xfit = getx(dest_gno, dest_setno);
            for (i = 0; i < npts; i++) {
                xfit[i] = nonl_prefs.start + i * delx;
            }
            sprintf(dummy,"%s",tabAdvanced->ledXFunction->text().toLatin1().constData());
            if (dummy[0]=='$' && dummy[1]=='t' && dummy[2]=='\0') break;//nothing more to do here
            sprintf(dummy,"X=%s",tabAdvanced->ledXFunction->text().toLatin1().constData());//we have to calculate the real x-values using the $t-parameter
            QString f1(dummy);
            f1.replace("$t","X");//replace $t by X, because we loaded the $t-values into the X-column
            strcpy(dummy,f1.toLatin1().constData());
            (void)do_compute(dest_gno, dest_setno, dest_gno, dest_setno, NULL, dummy);//transform X-values
            break;
        }

        setcomment(dest_gno, dest_setno, nonl_opts.formula);
        if (do_compute(dest_gno, dest_setno, dest_gno, dest_setno, NULL, nonl_opts.formula)!=RETURN_SUCCESS)//evaluate formula for y-values
        killset(dest_gno, dest_setno);

        if (nonl_prefs.load == LOAD_RESIDUALS)
        { /* load residuals */
            y = gety(src_gno, src_setno);
            yfit = gety(dest_gno, dest_setno);
            for (i = 0; i < npts; i++)
            {
                yfit[i] -= y[i];
            }
        }
        /// mainWin->mainArea->completeRedraw();
        grpSource->mark_single_set(src_gno, src_setno);
        grpDestination->mark_single_set(dest_gno,dest_setno);

        //update_set_lists(dest_gno);
        //cout << "destination= G" << dest_gno << ".S" << dest_setno << endl;
        fit_destination_graph=dest_gno;
        fit_destination_set=dest_setno;
    }
    return;// RETURN_SUCCESS;
}

void frmNonlinCurveFit::IOrequested(int type,QString file,bool exists,bool writeable,bool readable)
{
    char filename[1024];
//int res;
    FILE *pp;
    (void)exists;
    (void)writeable;
    (void)readable;
    strcpy(filename,file.toLocal8Bit());
    /*//for testing -- maybe tests needed (file readable ...)
    cout << "file=" << buf << endl;
    cout << "type=" << type << endl;
    cout << "exists=" << exists << endl;
    cout << "writeable=" << writeable << endl;
    cout << "readable=" << readable << endl;*/
    if (type==WRITE_FIT_PARAM)
    {
        if (frmSaveFitPara)
        frmSaveFitPara->hide();
        ApplyError=read_fit_options();
            if (ApplyError==true)
            {
            errmsg(tr("Saving of fit parameters aborted").toLocal8Bit().constData());
            return;
            }
        pp = grace_openw(filename);
        if (pp != NULL)
        {
            if (frmSaveFitPara)
            nonl_opts.title = copy_string(nonl_opts.title, xv_getstr(frmSaveFitPara->ledTitle));
            else
            nonl_opts.title = copy_string(nonl_opts.title, xv_getstr(lblAFit));
            put_fitparms(pp, 0);
            grace_close(pp);
        }
    }
    else//read fit parameters
    {
        if (frmOpenFitPara)
        frmOpenFitPara->hide();
        reset_nonl();
        //res = getparms(filename);
        (void)getparms(filename);
        update_nonl_frame();
    }
}

frmInterpolation::frmInterpolation(int type,QWidget * parent):QDialog(parent)
{
    int number;
    char dummy[128];
    WindowType=type;
    QString * entr=new QString[maxgraph>4?maxgraph+1:5];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    if (type==INTERPOLATIONWINDOW)
        setWindowTitle(tr("QtGrace: Interpolation"));
    else
        setWindowTitle(tr("QtGrace: Histograms"));

    grpSource=new grpSelect(tr("Source"),this);
    grpDestination=new grpSelect(tr("Destination"),this);
    grpDestination->enable_sync(grpSource->listSet);

    grpSampling=new QGroupBox(QString(""),this);

    sampSet=new uniList(SETLIST,grpSampling);

    chkStrict=new QCheckBox(tr("Strict (within source set bounds)"),grpSampling);
    chkNextPowerOfTwo=new QCheckBox(tr("to next power of 2"),grpSampling);
    chkCumulHist=new QCheckBox(tr("Cumulative histogram"),grpSampling);
    chkNormalize=new QCheckBox(tr("Normalize"),grpSampling);

    number=3;
    entr[0]=tr("Linear");
    entr[1]=tr("Cubic spline");
    entr[2]=tr("Akima spline");
    selMethod=new StdSelector(grpSampling,tr("Method:"),number,entr);
    number=4;
    entr[0]=tr("Linear mesh");
    entr[1]=tr("Abscissa of another set");
    entr[2]=tr("Linear in original bounds");//new option added with v0.2.4
    entr[3]=tr("Expand bounds, keep stepping");//new option added with v0.2.4
    selSampling=new StdSelector(grpSampling,tr("Sampling:"),number,entr);
    connect(selSampling->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(selSamplingChanged(int)));
    number=maxgraph;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"G%d",i);
        entr[i]=QString(dummy);
    }
    selSamplingGraph=new StdSelector(grpSampling,tr("Graph:"),number,entr);
    selSamplingGraph->setEnabled(FALSE);
    connect(selSamplingGraph->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(selSamplGraphChanged(int)));

    lenStart=new stdLineEdit(grpSampling,tr("Start at:"));
    lenStop=new stdLineEdit(grpSampling,tr("Stop at:"));
    lenLength=new stdLineEdit(grpSampling,tr("Length:"));
    lenStart->lenText->setText(QString(""));
    lenStop->lenText->setText(QString(""));
    lenLength->lenText->setText(QString(""));

    lblSamplSet=new QLabel(tr("Sampling set:"),grpSampling);

    sampSet->setEnabled(FALSE);
    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));

    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);

    if (type==INTERPOLATIONWINDOW)
    {
        layout1->addWidget(selMethod,0,0,1,2);
        layout1->addWidget(chkStrict,0,2,1,2);
        layout1->addWidget(chkNextPowerOfTwo,0,4,1,2);
        chkCumulHist->setVisible(FALSE);
        chkNormalize->setVisible(FALSE);
        chkNextPowerOfTwo->setVisible(true);
        connect(chkNextPowerOfTwo,SIGNAL(toggled(bool)),SLOT(toggleNextPowerOfTwo(bool)));
    }
    else//HISTOGRAMSWINDOW
    {
        layout1->addWidget(chkCumulHist,0,0,1,3);
        layout1->addWidget(chkNormalize,0,3,1,2);
        selMethod->setVisible(FALSE);
        chkStrict->setVisible(FALSE);
        chkNextPowerOfTwo->setVisible(false);
        selSampling->lblText->setText(tr("Bin sampling:"));
        lenLength->lblText->setText(tr("# of bins:"));
    }

    layout1->addWidget(selSampling,1,0,1,3);
    layout1->addWidget(selSamplingGraph,1,3,1,2);
    layout1->addWidget(lenStart,2,0,1,2);
    layout1->addWidget(lenStop,2,2,1,2);
    layout1->addWidget(lenLength,2,4);
    layout1->addWidget(lblSamplSet,3,0);
    layout1->addWidget(sampSet,4,0,3,5);
    grpSampling->setLayout(layout1);

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpSource,0,0);
    layout->addWidget(grpDestination,0,1);
    layout->addWidget(grpSampling,1,0,1,2);
    layout->addWidget(buttonGroup,2,0,1,2);
    setLayout(layout);
    delete[] entr;
    if (WindowType==INTERPOLATIONWINDOW)
    resize(LastSize_FormInterpolation);
    else
    resize(LastSize_FormHistograms);
}

frmInterpolation::~frmInterpolation()
{
    if (WindowType==INTERPOLATIONWINDOW)
    LastSize_FormInterpolation=this->size();
    else
    LastSize_FormHistograms=this->size();
}

void frmInterpolation::init(void)
{
    int nr=1,sel=get_cg();
    grpSource->listGraph->update_number_of_entries();
    grpSource->listGraph->set_new_selection(nr,&sel);
    grpSource->listSet->set_graph_number(sel,false);
    //grpSource->listSet->update_number_of_entries();
    grpDestination->listGraph->update_number_of_entries();
    grpDestination->listGraph->set_new_selection(nr,&sel);
    grpDestination->listSet->set_graph_number(sel,false);
    //grpDestination->listSet->update_number_of_entries();
    sampSet->update_number_of_entries();
    selSamplingGraph->cmbSelect->clear();
    char dummy[128];
    for (int i=0;i<maxgraph;i++)
    {
        sprintf(dummy,"G%d",i);
        selSamplingGraph->cmbSelect->addItem(QString(dummy));
    }

}

void frmInterpolation::selSamplingChanged(int i)
{
    bool poweroftwo=chkNextPowerOfTwo->isChecked();

    if (i==0)
    {
        sampSet->setEnabled(FALSE);
        selSamplingGraph->setEnabled(FALSE);
        lenStart->setEnabled(TRUE);
        lenStop->setEnabled(TRUE);
        lenLength->setEnabled(!poweroftwo);
    }
    else if (i==1)
    {
        sampSet->setEnabled(TRUE);
        selSamplingGraph->setEnabled(TRUE);
        lenStart->setEnabled(FALSE);
        lenStop->setEnabled(FALSE);
        lenLength->setEnabled(FALSE);
    }
    else if (i==2 || i==3)//keep bounds, just change number of points || expand bounds
    {
        sampSet->setEnabled(FALSE);
        selSamplingGraph->setEnabled(FALSE);
        lenStart->setEnabled(FALSE);
        lenStop->setEnabled(FALSE);
        lenLength->setEnabled(!poweroftwo);
    }

}

void frmInterpolation::selSamplGraphChanged(int i)
{
    sampSet->set_graph_number(i,false);
    //sampSet->update_number_of_entries();
}

void frmInterpolation::toggleNextPowerOfTwo(bool i)
{
    (void)i;
    lenLength->setEnabled(!(chkNextPowerOfTwo->isChecked()));
}

void frmInterpolation::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmInterpolation::doApply(void)
{
    ApplyError=false;
    int error, res;
    int nssrc, nsdest, *svaluessrc=new int[5], *svaluesdest=new int[5], gsrc, gdest;
    int method, sampling, strict;
    int cumulative, normalize, nextPowerOf2;
    int i, meshlen,nbins;
    int l_d_x,r_d_x;
    double start, stop,ymin,ymax,xspace;
    bool readerror=false;
    double *bins = NULL;
    double *mesh = NULL;
    int allocate_type_bins=-1;//not allocated, 0=old-style(malloc), 1=new-style(new)
    int allocate_type_mesh=-1;//not allocated, 0=old-style(malloc), 1=new-style(new)
    bool mono;
    int count,*selection=new int[5];
    grpSource->listGraph->get_selection(&count,&selection);
    nbins=1;
    normalize=0;
    cumulative=0;
    strict=0;
    method=0;
    if (count!=1)
    {
        errmsg(tr("Please select single source graph").toLocal8Bit().constData());
        ApplyError=true;
        delete[] svaluessrc;
        delete[] svaluesdest;
        delete[] selection;
        return;
    }
    else
    {
        gsrc=selection[0];
    }
    grpDestination->listGraph->get_selection(&count,&selection);
    if (count!=1)
    {
        errmsg(tr("Please select single destination graph").toLocal8Bit().constData());
        ApplyError=true;
        delete[] svaluessrc;
        delete[] svaluesdest;
        delete[] selection;
        return;
    }
    else
    {
        gdest=selection[0];
    }
    grpSource->listSet->get_selection(&nssrc,&svaluessrc);
    grpDestination->listSet->get_selection(&nsdest,&svaluesdest);
    delete[] selection;
    if (nssrc!=nsdest && nsdest!=0)
    {
        errmsg(tr("Number of destination sets does not match number of source sets").toLocal8Bit().constData());
        ApplyError=true;
        delete[] svaluessrc;
        delete[] svaluesdest;
        return;
    }

    error = FALSE;
    nextPowerOf2 = FALSE;
    if (WindowType==INTERPOLATIONWINDOW)
    {
        method = GetOptionChoice(selMethod);
        sampling = GetOptionChoice(selSampling);
        strict = GetToggleButtonState(chkStrict);
        nextPowerOf2 = GetToggleButtonState(chkNextPowerOfTwo);
    }
    else
    {
        cumulative = GetToggleButtonState(chkCumulHist);
        normalize  = GetToggleButtonState(chkNormalize);
        sampling   = GetOptionChoice(selSampling);
    }

    if (sampling == SAMPLING_SET) {
        int gsampl, setnosampl;
        gsampl = selSamplingGraph->currentIndex();//get_cg();
        res = GetSingleListChoice(sampSet, &setnosampl);
        if (res != RETURN_SUCCESS) {
            errmsg(tr("Please select single sampling set").toLocal8Bit().constData());
            ApplyError=true;
            error = TRUE;
        } else {
            if (WindowType==INTERPOLATIONWINDOW)
            {
                meshlen = getsetlength(gsampl, setnosampl);
                mesh = getcol(gsampl, setnosampl, DATA_X);
            }
            else
            {
                nbins = getsetlength(gsampl, setnosampl) - 1;
                bins = getcol(gsampl, setnosampl, DATA_X);
            }
        }
    } else {//do not sample on a specific set, but on a predefined range of values

        if (nextPowerOf2==false)//we need to read the new number of points
        {
            if (xv_evalexpri(lenLength, &meshlen) != RETURN_SUCCESS)//can not read a value
                readerror=true;
        }//if true --> the setlength will not be read!
        if (sampling==SAMPLING_MESH || WindowType!=INTERPOLATIONWINDOW)//the user entered limits for the interpolation and we have to read them
        {
            if (xv_evalexpr(lenStart, &start)     != RETURN_SUCCESS ||
                    xv_evalexpr(lenStop,  &stop)      != RETURN_SUCCESS )
                readerror=true;
        }

        /*if (xv_evalexpr(lenStart, &start)     != RETURN_SUCCESS ||
            xv_evalexpr(lenStop,  &stop)      != RETURN_SUCCESS ||
            xv_evalexpri(lenLength, &meshlen) != RETURN_SUCCESS ) {*/
        if (readerror==true)
        {
            errmsg(tr("Can't parse mesh settings").toLocal8Bit().constData());
            ApplyError=true;
            error = TRUE;
        }
        else
        {
            if (WindowType==INTERPOLATIONWINDOW)
            {
                if (sampling==SAMPLING_MESH)
                {
                    mesh = allocate_mesh(start, stop, meshlen);
                    allocate_type_mesh=0;
                    if (mesh == NULL)
                    {
                        errmsg(tr("Can't allocate mesh").toLocal8Bit().constData());
                        ApplyError=true;
                        error = TRUE;
                    }
                }
            }
            else
            {
                nbins=meshlen;
                bins = allocate_mesh(start, stop, nbins + 1);
                allocate_type_bins=0;
                if (bins == NULL)
                {
                    errmsg(tr("Can't allocate mesh").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                }
            }
        }
    }

    if (error)
    {
        delete[] svaluessrc;
        if (nsdest > 0)
        {
            delete[] svaluesdest;
        }
        return;// RETURN_FAILURE;
    }

    int * gnos=new int[nssrc];//nssrc is either greater than nsdest or equal
    int * snos=new int[nssrc];
    char dummy[256];
    int set_no=0;

    if (nsdest>0)//no new sets will be created --> old sets will be modified
    {
        for (int i=0;i<nsdest;i++)
        {
            gnos[i]=gdest;
            snos[i]=svaluesdest[i];
        }
        SaveSetStatesPrevious(nsdest,gnos,snos,UNDO_DATA);
    }

    for (i = 0; i < nssrc && error==FALSE ; i++)//do interpolation for all selected sets
    {
    int setnosrc, setnodest;
        setnosrc = svaluessrc[i];
        if (nsdest != 0) {
            setnodest = svaluesdest[i];
        } else {
            setnodest = SET_SELECT_NEXT;
        }

        if (WindowType==INTERPOLATIONWINDOW)
        {
            if (nextPowerOf2==true)
            {
                meshlen=1<<((int)ceil(log((double)getsetlength(gsrc, setnosrc))/log(2.0)));
            }
            if (sampling==2)//keep limits
            {
                getsetminmax(gsrc, setnosrc,&start,&stop,&ymin,&ymax, FALSE);
            }
            else if (sampling==3)
            {
                getsetminmax(gsrc, setnosrc,&start,&stop,&ymin,&ymax, FALSE);
                mono=monospaced_v6(g[gsrc].p[setnosrc].data.ex[0], getsetlength(gsrc, setnosrc), &xspace);
                if (mono==false)
                {
                    errmsg(QObject::tr("Error! Set not monospaced in x!").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                    break;
                }
                l_d_x=meshlen-getsetlength(gsrc, setnosrc);//the amount of points to add (or remove)
                r_d_x=l_d_x/2;
                l_d_x=(meshlen-getsetlength(gsrc, setnosrc))-r_d_x;
                start-=l_d_x*xspace;
                stop+=r_d_x*xspace;
            }
            //cout << "allocate start=" << start << " stop=" << stop << " len=" << meshlen << endl;
            if (sampling>1)
            {
                mesh = allocate_mesh(start, stop, meshlen);
                allocate_type_mesh=0;
                if (mesh == NULL)
                {
                    errmsg(tr("Can't allocate mesh").toLocal8Bit().constData());
                    ApplyError=true;
                    error = TRUE;
                }
            }

            res = do_interp(gsrc, setnosrc, gdest, setnodest, mesh, meshlen, method, strict);
        }
        else
        {
            res = do_histo(gsrc, setnosrc, gdest, setnodest, bins, nbins, cumulative, normalize);
        }

        if (new_set_no!=-1)
        {
            gnos[set_no]=gdest;
            snos[set_no]=new_set_no;
            set_no++;
        }

        if (res != RETURN_SUCCESS)
        {
            errmsg(tr("Error in do_interp()").toLocal8Bit().constData());
            error = TRUE;
            ApplyError=true;
            break;
        }
    }

    if (allocate_type_mesh==1 && mesh!=NULL) {delete[] mesh;mesh=NULL;}
    if (allocate_type_mesh==0 && mesh!=NULL) {xfree(mesh);mesh=NULL;}
    if (allocate_type_bins==1 && bins!=NULL) {delete[] bins;bins=NULL;}
    if (allocate_type_bins==0 && bins!=NULL) {xfree(bins);bins=NULL;}
    /*if (sampling == SAMPLING_MESH)
    {
        if (mesh!=NULL)
            delete[] mesh;
        if (bins!=NULL)
            delete[] bins;
    }*/
    if (set_no>0)
    {
        if (nsdest > 0)//old sets modified
        {
            SetsModified(set_no,gnos,snos,UNDO_DATA);
        }
        else//new sets
        {
            SetsCreated(set_no,gnos,snos,UNDO_COMPLETE);
        }
        if (set_no==1)
        {
            sprintf(dummy," [G%d.S%d]",gsrc, svaluessrc[0]);
            if (WindowType==INTERPOLATIONWINDOW)
                addAditionalDescriptionToLastNode(-1,QObject::tr("Interpolation of")+QString(dummy),QString());
            else
                addAditionalDescriptionToLastNode(-1,QObject::tr("Histogram of")+QString(dummy),QString());
        }
        else
        {
            if (WindowType==INTERPOLATIONWINDOW)
                addAditionalDescriptionToLastNode(-1,QObject::tr("Interpolation"),QString());
            else
                addAditionalDescriptionToLastNode(-1,QObject::tr("Histogram"),QString());
        }
    }
    update_set_lists(gdest);
    grpSource->listSet->update_number_of_entries_preserve_selection();
    //grpDestination->listSet->update_number_of_entries_preserve_selection();
    grpDestination->set_graph_nr(gdest);
    grpDestination->listSet->set_new_selection(set_no,snos);
    mainWin->mainArea->completeRedraw();
    delete[] svaluessrc;
    if (nsdest > 0)
    {
        delete[] svaluesdest;
    }
    delete[] snos;
    delete[] gnos;
}

void frmInterpolation::doClose(void)
{
    hide();
}

frmSmallCalc::frmSmallCalc(int type,QWidget * parent):QDialog(parent)
{
    int number,index=0;
    QString entr[15];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    layout=new QGridLayout;
    layout->setSpacing(STD_SPACING);
    layout->setMargin(STD_MARGIN);

    WindowType=type;
    lblApplyTo=new QLabel(tr("Apply to set:"),this);
    listSets=new uniList(SETCHOICE,this);
    //listSets->show_all_sets_marker=true;
    lenText=new stdLineEdit(this,QString(""));
    lenText->lenText->setText(QString(""));
    chkInvert=new QCheckBox(tr("Invert region"),this);
    chkInvert->setVisible(FALSE);
    buttonGroup=new stdButtonGroup(this,false,true,false);
    buttonGroup->cmdAccept->setDefault(TRUE);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    StartStop=new stdStartStop(this);
    StartStop->setVisible(FALSE);
    layout->addWidget(lblApplyTo,index++,0,1,2);
    layout->addWidget(listSets,index++,0,1,2);

    switch (type)
    {
    case INTEGRATIONWINDOW:
        setWindowTitle(tr("QtGrace: Integration"));
        number=2;
        entr[0]=tr("Cumulative sum");
        entr[1]=tr("Sum only");
        selector1=new StdSelector(this,tr("Load:"),number,entr);
        layout->addWidget(selector1,index++,0,1,2);
        lenText->lblText->setText(tr("Sum:"));
        layout->addWidget(lenText,index++,0,1,2);
        selector2=new StdSelector(this,QString(""),number,entr);
        selector3=new StdSelector(this,QString(""),number,entr);
        selector2->setVisible(FALSE);
        selector3->setVisible(FALSE);
        break;
    case SEASONALWINDOW:
        setWindowTitle(tr("QtGrace: Seasonal differences"));
        number=1;
        entr[0]=QString("dummy");
        selector1=new StdSelector(this,QString(""),number,entr);
        selector2=new StdSelector(this,QString(""),number,entr);
        selector3=new StdSelector(this,QString(""),number,entr);
        selector1->setVisible(FALSE);
        selector2->setVisible(FALSE);
        selector3->setVisible(FALSE);
        lenText->lblText->setText(tr("Period:"));
        layout->addWidget(lenText,index++,0,1,2);
        break;
    case DIFFERENCESWINDOW:
        setWindowTitle(tr("QtGrace: Differences"));
        number=3;
        entr[0]=tr("Forward difference");
        entr[1]=tr("Backward difference");
        entr[2]=tr("Centered difference");
        selector1=new StdSelector(this,tr("Method:"),number,entr);
        selector2=new StdSelector(this,QString(""),number,entr);
        selector3=new StdSelector(this,QString(""),number,entr);
        selector2->setVisible(FALSE);
        selector3->setVisible(FALSE);
        layout->addWidget(selector1,index++,0,1,2);
        lenText->setVisible(FALSE);
        break;
    case AVERAGESWINDOW:
        setWindowTitle(tr("QtGrace: Running averages"));
        number=5;
        entr[0]=tr("Average");
        entr[1]=tr("Median");
        entr[2]=tr("Minimum");
        entr[3]=tr("Maximum");
        entr[4]=tr("Std. dev.");
        selector1=new StdSelector(this,tr("Running:"),number,entr);
        number=8;
        entr[0]=tr("None");
        entr[1]=tr("Region 0");
        entr[2]=tr("Region 1");
        entr[3]=tr("Region 2");
        entr[4]=tr("Region 3");
        entr[5]=tr("Region 4");
        entr[6]=tr("Inside graph");
        entr[7]=tr("Outside graph");
        selector2=new StdSelector(this,tr("Restrictions:"),number,entr);
        selector3=new StdSelector(this,QString(""),number,entr);
        selector3->setVisible(FALSE);
        chkInvert->setVisible(TRUE);
        lenText->lblText->setText(tr("Length of average:"));
        layout->addWidget(selector1,index++,0,1,2);
        layout->addWidget(lenText,index++,0,1,2);
        layout->addWidget(selector2,index++,0,1,2);
        layout->addWidget(chkInvert,index++,0,1,2);
        break;
    case REGRESSIONWINDOW:
        setWindowTitle(tr("QtGrace: Regression"));
        lenText->lenText->setText(QString("$t"));
        lenText->lblText->setText(tr("Load x as "));
        StartStop->lblStart->setText(tr("Start $t at:"));
        StartStop->lblStop->setText(tr("Stop $t at:"));
        lenText->setVisible(TRUE);
        number=15;
        entr[0]=tr("Linear");
        entr[1]=tr("Quadratic");
        entr[2]=tr("Cubic");
        entr[3]=tr("4th degree");
        entr[4]=tr("5th degree");
        entr[5]=tr("6th degree");
        entr[6]=tr("7th degree");
        entr[7]=tr("8th degree");
        entr[8]=tr("9th degree");
        entr[9]=tr("10th degree");
        entr[10]=tr("1-10");
        entr[11]=tr("Power y=A*x^B");
        entr[12]=tr("Exponential y=A*exp(B*x)");
        entr[13]=tr("Logarithmic y=A+B*ln(x)");
        entr[14]=tr("Inverse y=1/(A+B*x)");
        selector1=new StdSelector(this,tr("Type of fit:"),number,entr);
        number=4;
        entr[0]=tr("Fitted values");
        entr[1]=tr("Residuals");
        entr[2]=tr("Function");
        entr[3]=tr("None");
        selector2=new StdSelector(this,tr("Load:"),number,entr);
        connect(selector2->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(loadChanged(int)));
        number=8;
        entr[0]=tr("None");
        entr[1]=tr("Region 0");
        entr[2]=tr("Region 1");
        entr[3]=tr("Region 2");
        entr[4]=tr("Region 3");
        entr[5]=tr("Region 4");
        entr[6]=tr("Inside graph");
        entr[7]=tr("Outside graph");
        selector3=new StdSelector(this,tr("Restrictions:"),number,entr);
        chkInvert->setVisible(TRUE);
        StartStop->setVisible(TRUE);
        lenText->setEnabled(FALSE);
        StartStop->setEnabled(FALSE);
        layout->addWidget(selector1,index++,0,1,2);
        layout->addWidget(selector2,index++,0,1,2);
        layout->addWidget(selector3,index++,0,1,2);
        layout->addWidget(chkInvert,index,0,1,1);
        layout->addWidget(lenText,index++,1,1,1);
        layout->addWidget(StartStop,index++,0,1,2);
        layout->setColumnMinimumWidth(0,230);
        layout->setColumnMinimumWidth(1,230);
        break;
    }
    layout->addWidget(buttonGroup,index++,0,1,2);
    setLayout(layout);
    switch (WindowType)
    {
    case AVERAGESWINDOW:
    resize(LastSize_FormAverages);
    break;
    case REGRESSIONWINDOW:
    resize(LastSize_FormRegression);
    break;
    case DIFFERENCESWINDOW:
    resize(LastSize_FormDifferences);
    break;
    case SEASONALWINDOW:
    resize(LastSize_FormSeasonDiff);
    break;
    case INTEGRATIONWINDOW:
    resize(LastSize_FormIntegration);
    break;
    }
}

frmSmallCalc::~frmSmallCalc()
{
    switch (WindowType)
    {
    case AVERAGESWINDOW:
    LastSize_FormAverages=this->size();
    break;
    case REGRESSIONWINDOW:
    LastSize_FormRegression=this->size();
    break;
    case DIFFERENCESWINDOW:
    LastSize_FormDifferences=this->size();
    break;
    case SEASONALWINDOW:
    LastSize_FormSeasonDiff=this->size();
    break;
    case INTEGRATIONWINDOW:
    LastSize_FormIntegration=this->size();
    break;
    }
}

void frmSmallCalc::loadChanged(int i)
{
    if (i==2)
    {
        lenText->setEnabled(TRUE);
        StartStop->setEnabled(TRUE);
    }
    else
    {
        lenText->setEnabled(FALSE);
        StartStop->setEnabled(FALSE);
    }
}

void frmSmallCalc::init(void)
{
    listSets->set_graph_number(get_cg(),false);
    listSets->update_number_of_entries();
}

void frmSmallCalc::doAccept(void)
{
    int gno = get_cg();
    int *selsets=new int[5];
    int i, cnt,ideg, iresid, j;
    int setno, itype,period;
    int runlen, runtype, rno, invr;
    int nstep = 0, rx, rset = 0;
    double sum;
    double xstart, xstop;//, stepsize = 0.0;
    set_wait_cursor();
    cnt = GetSelectedSets(listSets, &selsets);
    if (cnt == SET_SELECT_ERROR || cnt <=0)
    {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        delete[] selsets;
        return;
    }
    int * gnos=new int[cnt>1?cnt:2];
    int * snos=new int[cnt>1?cnt:2];
    int new_sets=0;
    char dummy[MAX_STRING_LENGTH];
    switch (WindowType)
    {
    case INTEGRATIONWINDOW:
        itype = GetChoice(selector1);
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            sum = do_int(gno, setno, itype);
            if (new_set_no!=-1)
            {
                gnos[new_sets]=gno;
                snos[new_sets]=new_set_no;
                new_sets++;
            }
            lenText->setDoubleValue("%g",sum);
        }
        if (new_sets>0)
        {
            SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
            if (new_sets==1)
            {
                sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Integration of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Integration"),QString());
            }
        }
        break;
    case SEASONALWINDOW:
        if(xv_evalexpri(lenText, &period ) != RETURN_SUCCESS)
            return;
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_seasonal_diff(setno, period);
            if (new_set_no!=-1)
            {
                gnos[new_sets]=gno;
                snos[new_sets]=new_set_no;
                new_sets++;
            }
        }
        if (new_sets>0)
        {
            SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
            if (new_sets==1)
            {
                sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Seasonal differences of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Seasonal differences"),QString());
            }
        }
        break;
    case DIFFERENCESWINDOW:
        itype = (int) GetChoice(selector1);
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_differ(gno, setno, itype);
            if (new_set_no!=-1)
            {
                gnos[new_sets]=gno;
                snos[new_sets]=new_set_no;
                new_sets++;
            }
        }
        if (new_sets>0)
        {
            SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
            if (new_sets==1)
            {
                sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Differences of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Differences"),QString());
            }
        }
        break;
    case AVERAGESWINDOW:
        if (xv_evalexpri(lenText, &runlen ) != RETURN_SUCCESS)
        {

            return;
        }
        runtype = GetChoice(selector1);
        rno = GetChoice(selector2) - 1;
        invr = GetToggleButtonState(chkInvert);
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_runavg(gno, setno, runlen, runtype, rno, invr);
            if (new_set_no!=-1)
            {
                gnos[new_sets]=gno;
                snos[new_sets]=new_set_no;
                new_sets++;
            }
        }
        if (new_sets>0)
        {
            SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
            if (new_sets==1)
            {
                sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Averages of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Averages"),QString());
            }
        }
        break;
    case REGRESSIONWINDOW:
        rno = GetChoice(selector3) - 1;
        invr = GetToggleButtonState(chkInvert);
        ideg = (int) GetChoice(selector1) + 1;

        if (ideg==11)
        {
            delete[] gnos;
            delete[] snos;
            gnos=new int[11*(cnt>0?cnt:2)];
            snos=new int[11*(cnt>0?cnt:2)];
        }
        gnos[0]=gno;
        dummy[0]='\0';
        switch( rx = GetChoice(selector2) )
        {
        case 3:             /* do not evaluate the function at all - just calculate the formula */
            iresid = 2;
            rset = -1;
            break;
        case 0:				/* evaluate fitted function at original x's */
            iresid = 0;
            rset = -1;
            break;
        case 1:				/* load residue at original x points */
            iresid = 1;
            rset = -1;
            break;
        case 2:		/* evaluate fitted function at new x points */
            iresid = 0;
            if(xv_evalexpri(StartStop->ledLength, &nstep) != RETURN_SUCCESS || nstep < 2 )
            {
                errwin(tr("Number points < 2").toLocal8Bit().constData());
                return;
            }
            if(xv_evalexpr(StartStop->ledStart, &xstart ) != RETURN_SUCCESS)
            {
                errwin(tr("Specify starting value").toLocal8Bit().constData());
                return;
            }
            if(xv_evalexpr(StartStop->ledStop, &xstop) != RETURN_SUCCESS)
            {
                errwin(tr("Specify stopping value").toLocal8Bit().constData());
                return;
            }
            /*else
            {
                stepsize = (xstop - xstart)/(nstep-1);
            }*/
            strcpy(dummy,lenText->text().toLatin1().constData());
            //cout << "conversion-formula=#" << dummy << "#" << endl;
            if (strlen(dummy)<1)
            {
                errwin(tr("Specify formula for x-values as a function of $t").toLocal8Bit().constData());
                return;
            }
            else
            {
                ReplaceDecimalSeparator(dummy,true);
            }
            //cout << "conversion-formula=#" << dummy << "#" << endl;
            break;
        default:
            errwin(tr("Internal error").toLocal8Bit().constData());
            return;
        }
        new_set_no=-1;
        for (i = (ideg==11?1:ideg); i <= (ideg==11?10:ideg); i++)
        {
            for (j = 0; j < cnt; j++)
            {
                setno = selsets[j];
                if( rx == 2 )
                {
                    if( (rset = nextset( gno )) == -1 )
                    {
                        errwin(tr("Not enough sets").toLocal8Bit().constData());
                        return;
                    }
                    /*activateset( gno, rset );
                    setlength( gno, rset, nstep);
                    xr = getx( gno, rset );
                    for( k=0; k<nstep; k++ )
                    xr[k] = xstart+k*stepsize;*/
                    if (generate_x_mesh_from_formula(gno,rset,xstart,xstop,nstep,dummy,SET_XY)==RETURN_FAILURE)
                    {
                        errwin(tr("Not enough sets").toLocal8Bit().constData());
                        return;
                    }
                }
                //cout << "Regression on G" << gno << ".S" << setno << endl;
                do_regress(gno, setno, i, iresid, rno, invr, rset);
                if (!is_set_active(gno,new_set_no)) new_set_no=-1;
                if (new_set_no!=-1)
                {
                    //cout << "new_set_no=" << new_set_no << endl;
                    gnos[new_sets]=gno;
                    snos[new_sets]=new_set_no;
                    new_sets++;
                }
            }
        }
        if (new_sets>=0)//Warning: '=0' may be problematic
        {
        /*SetsCreated(new_sets,gnos,snos,UNDO_COMPLETE);
        if (new_sets==1)
        {
        sprintf(dummy," [G%d.S%d]",gno, selsets[0]);
        addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Regression of")+QString(dummy),QString());
        }
        else
        {
        addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Regression"),QString());
        }*/
            SetRegression(cnt,gnos,selsets,new_sets,gnos,snos,ideg,iresid,rno,invr,xstart,xstop,nstep,rx,dummy);
        }
        break;
    }
    //update_set_lists(gno);
    //listSets->update_number_of_entries_preserve_selection();
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();

    listSets->set_graph_number(get_cg(),false);
    listSets->set_new_selection(cnt,selsets);

    delete[] selsets;
    delete[] snos;
    delete[] gnos;
}

void frmSmallCalc::doClose(void)
{
    hide();
}

frmCorrelation::frmCorrelation(int type,QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    WindowType=type;

    lblSelect1=new QLabel(QString(""),this);
    listSet1=new uniList(SETCHOICE,this);
    listSet1->setBehavior(true,false,false);
    lblSelect2=new QLabel(QString(""),this);
    listSet2=new uniList(SETCHOICE,this);
    listSet2->setBehavior(true,false,false);
    lenLag=new stdLineEdit(this,tr("Maximum lag:"));
    lenLag->lenText->setText(QString(""));
    chkCovariance=new QCheckBox(tr("Calculate covariance"),this);
    buttonGroup=new stdButtonGroup(this,false,true,false);
    buttonGroup->cmdAccept->setDefault(TRUE);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(lblSelect1);
    layout->addWidget(listSet1);
    layout->addWidget(lblSelect2);
    layout->addWidget(listSet2);
    switch (type)
    {
    case CORRELATIONWINDOW:
        setWindowTitle(tr("QtGrace: Correlation/Covariance"));
        lblSelect1->setText(tr("Select set:"));
        lblSelect2->setText(tr("Select set:"));
        layout->addWidget(lenLag);
        layout->addWidget(chkCovariance);
        break;
    case CONVOLUTIONWINDOW:
        setWindowTitle(tr("QtGrace: Linear convolution"));
        lblSelect1->setText(tr("Convolve set:"));
        lblSelect2->setText(tr("With set:"));
        chkCovariance->setVisible(FALSE);
        lenLag->setVisible(FALSE);
        break;
    case FILTERWINDOW:
        setWindowTitle(tr("QtGrace: Digital Filter"));
        lblSelect1->setText(tr("Filter set:"));
        lblSelect2->setText(tr("With weights from set:"));
        chkCovariance->setVisible(FALSE);
        lenLag->setVisible(FALSE);
        break;
    }
    layout->addWidget(buttonGroup);
    setLayout(layout);
    switch (WindowType)
    {
    case CORRELATIONWINDOW:
    resize(LastSize_FormCorrelation);
    break;
    case CONVOLUTIONWINDOW:
    resize(LastSize_FormConvolution);
    break;
    case FILTERWINDOW:
    resize(LastSize_FormDigitalFilter);
    break;
    }
}

frmCorrelation::~frmCorrelation()
{
    switch (WindowType)
    {
    case CORRELATIONWINDOW:
    LastSize_FormCorrelation=this->size();
    break;
    case CONVOLUTIONWINDOW:
    LastSize_FormConvolution=this->size();
    break;
    case FILTERWINDOW:
    LastSize_FormDigitalFilter=this->size();
    break;
    }
}

void frmCorrelation::init(void)
{
    listSet1->update_number_of_entries();
    listSet2->update_number_of_entries();
}

void frmCorrelation::doAccept(void)
{
    int set1, set2, maxlag, covar;
    set_wait_cursor();
    set1 = GetSelectedSet(listSet1);
    set2 = GetSelectedSet(listSet2);
    if (set1 == SET_SELECT_ERROR || set2 == SET_SELECT_ERROR) {
        errwin(tr("Select 2 sets").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
    int * gnos=new int[2];
    int * snos=new int[2];
    gnos[0]=gnos[1]=get_cg();
    char dummy[256];
    switch (WindowType)
    {
    case CORRELATIONWINDOW:
        if(xv_evalexpri(lenLag, &maxlag) != RETURN_SUCCESS) {
            unset_wait_cursor();
            delete[] gnos;
            delete[] snos;
            return;
        }
        covar = GetToggleButtonState(chkCovariance);
        do_xcor(get_cg(), set1, get_cg(), set2, maxlag, covar);
        break;
    case CONVOLUTIONWINDOW:
        do_linearc(get_cg(), set1, get_cg(), set2);
        break;
    case FILTERWINDOW:
        do_digfilter(set1, set2);
        break;
    }
    snos[0]=snos[1]=new_set_no;
    if (new_set_no!=-1)
    {
        SetsCreated(1,gnos,snos,UNDO_COMPLETE);
        sprintf(dummy," [G%d S%d<->S%d]",get_cg(),set1,set2);
        addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,this->windowTitle().mid(9,-1)+QString(dummy),QString());
    }
    update_set_lists(get_cg());
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
    delete[] gnos;
    delete[] snos;
}

void frmCorrelation::doClose(void)
{
    hide();
}

frmTransform::frmTransform(int type,QWidget * parent):QDialog(parent)
{
    int number;
    QString entr[6];
//setFont(*stdFont);
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    WindowType=type;
    lblApplyTo=new QLabel(tr("Apply to sets:"),this);
    layout->addWidget(lblApplyTo);
    listSets=new uniList(SETCHOICE,this);
    listSets->setBehavior(false,true,true);
    layout->addWidget(listSets);

    for (int i=0;i<7;i++)
        lenText[i]=new stdLineEdit(this,QString(""));

    switch (type)
    {
    case PRUNEWINDOW:
        setWindowTitle(tr("QtGrace: Prune data"));
        number=4;
        entr[0]=tr("Interpolation");
        entr[1]=tr("Circle");
        entr[2]=tr("Ellipse");
        entr[3]=tr("Rectangle");
        selector[0]=new StdSelector(this,tr("Prune type:"),number,entr);
        connect(selector[0]->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(PruneTypeChanged(int)));
        layout->addWidget(selector[0]);
        lenText[0]->lblText->setText(tr("Delta X:"));
        lenText[0]->lenText->setText(QString(""));
        layout->addWidget(lenText[0]);
        lenText[1]->lblText->setText(tr("Delta Y:"));
        lenText[1]->lenText->setText(QString(""));
        layout->addWidget(lenText[1]);
        for (int i=2;i<7;i++)
            lenText[i]->setVisible(FALSE);
        lenText[0]->setEnabled(FALSE);
        lenText[1]->setEnabled(TRUE);
        number=2;
        entr[0]=tr("Viewport");
        entr[1]=tr("World");
        selector[1]=new StdSelector(this,tr("Type of Delta coordinates:"),number,entr);
        connect(selector[1]->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(CoordsChanged(int)));
        layout->addWidget(selector[1]);
        number=2;
        entr[0]=tr("Linear");
        entr[1]=tr("Logarithmic");
        selector[2]=new StdSelector(this,tr("Scaling of Delta X:"),number,entr);
        selector[3]=new StdSelector(this,tr("Scaling of Delta Y:"),number,entr);
        layout->addWidget(selector[2]);
        layout->addWidget(selector[3]);
        selector[2]->setEnabled(FALSE);
        selector[3]->setEnabled(FALSE);
        break;
    case SAMPLEPOINTSWINDOW:
        setWindowTitle(tr("QtGrace: Sample points"));
        number=2;
        entr[0]=tr("Start/step");
        entr[1]=tr("Expression");
        selector[0]=new StdSelector(this,tr("Sample type:"),number,entr);
        layout->addWidget(selector[0]);
        for (int i=1;i<4;i++)
        {
            selector[i]=new StdSelector(this,QString("dummy"),number,entr);
            selector[i]->setVisible(FALSE);
        }
        lenText[0]->lblText->setText(tr("Start:"));
        lenText[0]->lenText->setText(QString(""));
        layout->addWidget(lenText[0]);
        lenText[1]->lblText->setText(tr("Step:"));
        lenText[1]->lenText->setText(QString(""));
        layout->addWidget(lenText[1]);
        lenText[2]->lblText->setText(tr("Logical expression:"));
        lenText[2]->lenText->setText(QString(""));
        lenText[2]->setEnabled(false);
        layout->addWidget(lenText[2]);
        for (int i=3;i<7;i++)
            lenText[i]->setVisible(FALSE);
        connect(selector[0]->cmbSelect,SIGNAL(currentIndexChanged(int)),SLOT(selectorChanged(int)));
        break;
    case GEOMETRICWINDOW:
        setWindowTitle(tr("QtGrace: Geometric transformations"));
        lenText[0]->lblText->setText(tr("Rotation (degrees):"));
        lenText[1]->lblText->setText(tr("Rotate about X = :"));
        lenText[2]->lblText->setText(tr("Rotate about Y = :"));
        lenText[3]->lblText->setText(tr("Scale X:"));
        if (DecimalPointToUse=='.')
            lenText[3]->lenText->setText(QString("1.0"));
        else
            lenText[3]->lenText->setText(QString("1,0"));
        lenText[4]->lblText->setText(tr("Scale Y:"));
        if (DecimalPointToUse=='.')
            lenText[4]->lenText->setText(QString("1.0"));
        else
            lenText[4]->lenText->setText(QString("1,0"));
        lenText[5]->lblText->setText(tr("Translate X:"));
        lenText[6]->lblText->setText(tr("Translate Y:"));
        for (int i=0;i<7;i++)
            layout->addWidget(lenText[i]);
        number=6;
        entr[0]=tr("Rotate, translate, scale");
        entr[1]=tr("Rotate, scale, translate");
        entr[2]=tr("Translate, scale, rotate");
        entr[3]=tr("Translate, rotate, scale");
        entr[4]=tr("Scale, translate, rotate");
        entr[5]=tr("Scale, rotate, translate");
        selector[0]=new StdSelector(this,tr("Apply in order:"),number,entr);
        for (int i=1;i<4;i++)
        {
            selector[i]=new StdSelector(this,QString("dummy"),number,entr);
            selector[i]->setVisible(FALSE);
        }
        layout->addWidget(selector[0]);
        break;
    }
    if (type!=GEOMETRICWINDOW)
    {
        buttonGroup=new stdButtonGroup(this,false,true,false);
        buttonGroup->cmdAccept->setDefault(TRUE);
        connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
        connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    }
    else
    {
        buttonGroup=new stdButtonGroup(this,true,true,false);
        buttonGroup->cmdAccept->setText(tr("Reset"));
        connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doAccept()));
        connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doReset()));
        connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    }
    layout->addWidget(buttonGroup);
    setLayout(layout);
    switch (WindowType)
    {
    case PRUNEWINDOW:
    resize(LastSize_FormPruneData);
    break;
    case GEOMETRICWINDOW:
    resize(LastSize_FormGeometricTransform);
    break;
    case SAMPLEPOINTSWINDOW:
    resize(LastSize_FormSamplePoints);
    break;
    }
}

frmTransform::~frmTransform()
{
    switch (WindowType)
    {
    case PRUNEWINDOW:
    LastSize_FormPruneData=this->size();
    break;
    case GEOMETRICWINDOW:
    LastSize_FormGeometricTransform=this->size();
    break;
    case SAMPLEPOINTSWINDOW:
    LastSize_FormSamplePoints=this->size();
    break;
    }
}

void frmTransform::CoordsChanged(int i)
{
    if (i==0)//Viewport
    {
        selector[2]->setEnabled(FALSE);
        selector[3]->setEnabled(FALSE);
    }
    else//World
    {
        switch (selector[0]->currentIndex())
        {
        case 0:
            selector[2]->setEnabled(FALSE);
            selector[3]->setEnabled(TRUE);
            break;
        case 1:
            selector[2]->setEnabled(TRUE);
            selector[3]->setEnabled(FALSE);
            break;
        case 2:
        case 3:
            selector[2]->setEnabled(TRUE);
            selector[3]->setEnabled(TRUE);
            break;
        }
    }
}

void frmTransform::PruneTypeChanged(int i)
{
    switch (i)
    {
    case 0:
        lenText[0]->setEnabled(FALSE);
        lenText[1]->setEnabled(TRUE);
        break;
    case 1:
        lenText[0]->setEnabled(TRUE);
        lenText[1]->setEnabled(FALSE);
        break;
    case 2:
    case 3:
        lenText[0]->setEnabled(TRUE);
        lenText[1]->setEnabled(TRUE);
        break;
    }
    CoordsChanged(selector[1]->currentIndex());
}

void frmTransform::init(void)
{
    listSets->update_number_of_entries();
}

void frmTransform::doAccept(void)
{
    int i, j, k, cnt, order[3], ord;
    double degrees, sx, sy, rotx, roty, tx, ty, xtmp, ytmp, *x, *y;
    double cosd, sind;
    int *selsets=new int[5];
    int setno, typeno, deltatypeno;
    int dxtype, dytype;
    double deltax, deltay;
    const char *exprstr;
    char * exprstr2;
    int startno, stepno;
    set_wait_cursor();
    cnt = GetSelectedSets(listSets, &selsets);
    if (cnt<=0){// == SET_SELECT_ERROR) {
        errwin(tr("No sets selected").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
    int * gnos=new int[cnt>0?cnt:2];
    int * snos=new int[cnt>0?cnt:2];
    int set_no=0;
    char dummy[256];
    switch (WindowType)
    {
    case PRUNEWINDOW:
        typeno = (int) GetChoice(selector[0]);
        deltatypeno = (int) GetChoice(selector[1]);
        dxtype = (int) GetChoice(selector[2]);
        dytype = (int) GetChoice(selector[3]);
        if(lenText[0]->isEnabled() == true )
        {
            if(xv_evalexpr(lenText[0], &deltax) != RETURN_SUCCESS)
            {
                errmsg(tr("Invalid Delta X!").toLocal8Bit().constData());
                unset_wait_cursor();
                return;
            }
        }
        else
            deltax = 0;

        if( lenText[1]->isEnabled() == true )
        {
            if(xv_evalexpr(lenText[1], &deltay) != RETURN_SUCCESS )
            {
                errmsg(tr("Invalid Delta Y!").toLocal8Bit().constData());
                unset_wait_cursor();
                return;
            }
        }
        else
            deltay = 0;

        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_prune(setno, typeno, deltatypeno, deltax, deltay, dxtype, dytype);
            if (new_set_no!=-1)
            {
                gnos[set_no]=get_cg();
                snos[set_no]=new_set_no;
                set_no++;
            }
        }
        update_set_lists(get_cg());
        if (set_no>0)
        {
            SetsCreated(set_no,gnos,snos,UNDO_COMPLETE);
            if (set_no==1)
            {
                sprintf(dummy," [G%d.S%d]",get_cg(), selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Prune data")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Prune data"),QString());
            }
        }
        break;
    case SAMPLEPOINTSWINDOW:
        typeno = GetChoice(selector[0]);
        if (typeno == 0) {
            exprstr =  "";
            if (xv_evalexpri(lenText[0], &startno) != RETURN_SUCCESS ||
                    xv_evalexpri(lenText[1], &stepno)   != RETURN_SUCCESS) {
                errmsg(tr("Please select start and step values").toLocal8Bit().constData());
                unset_wait_cursor();
                return;
            }
        } else {
            exprstr = xv_getstr(lenText[2]);
            startno = stepno = 1;
        }
        exprstr2=new char[strlen(exprstr)+2];
        strcpy(exprstr2,exprstr);
        for (i = 0; i < cnt; i++)
        {
            setno = selsets[i];
            do_sample(setno, typeno, exprstr2, startno, stepno);
            if (new_set_no!=-1 && is_set_active(get_cg(),new_set_no))
            {
                gnos[set_no]=get_cg();
                snos[set_no]=new_set_no;
                set_no++;
            }
        }
        delete[] exprstr2;
        update_set_lists(get_cg());
        if (set_no>0)
        {
            SetsCreated(set_no,gnos,snos,UNDO_COMPLETE);
            if (set_no==1)
            {
                sprintf(dummy," [G%d.S%d]",get_cg(), selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Sample points")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Sample points"),QString());
            }
        }
        break;
    case GEOMETRICWINDOW:
        ord = (int) GetChoice(selector[0]);
        switch (ord)
        {
        case 0:
            order[0] = 0;		/* rotate */
            order[1] = 1;		/* translate */
            order[2] = 2;		/* scale */
            break;
        case 1:
            order[0] = 0;
            order[1] = 2;
            order[2] = 1;
            break;
        case 2:
            order[0] = 1;
            order[1] = 2;
            order[2] = 0;
            break;
        case 3:
            order[0] = 1;
            order[1] = 0;
            order[2] = 2;
            break;
        case 4:
            order[0] = 2;
            order[1] = 1;
            order[2] = 0;
            break;
        case 5:
            order[0] = 2;
            order[1] = 0;
            order[2] = 1;
            break;
        }
        /* check input fields */
        if (xv_evalexpr(lenText[0], &degrees) != RETURN_SUCCESS ||
                xv_evalexpr(lenText[1], &rotx)    != RETURN_SUCCESS ||
                xv_evalexpr(lenText[2], &roty)    != RETURN_SUCCESS ||
                xv_evalexpr(lenText[5], &tx)      != RETURN_SUCCESS ||
                xv_evalexpr(lenText[6], &ty)      != RETURN_SUCCESS ||
                xv_evalexpr(lenText[3], &sx)      != RETURN_SUCCESS ||
                xv_evalexpr(lenText[4], &sy)      != RETURN_SUCCESS )
            return;
        degrees = M_PI / 180.0 * degrees;
        cosd = cos(degrees);
        sind = sin(degrees);

        for (i=0;i<cnt;i++)
            gnos[i]=get_cg();

        SaveSetStatesPrevious(cnt,gnos,selsets,UNDO_DATA);
        for (k = 0; k < cnt; k++) {
            setno = selsets[k];
            if (is_set_active(get_cg(), setno)) {
                x = getx(get_cg(), setno);
                y = gety(get_cg(), setno);
                for (j = 0; j < 3; j++) {
                    switch (order[j]) {
                    case 0:			/* rotate */
                        if (degrees == 0.0) {
                            break;
                        }
                        for (i = 0; i < getsetlength(get_cg(), setno); i++) {
                            xtmp = x[i] - rotx;
                            ytmp = y[i] - roty;
                            x[i] = rotx + cosd * xtmp - sind * ytmp;
                            y[i] = roty + sind * xtmp + cosd * ytmp;
                        }
                        break;
                    case 1:			/* translate */
                        for (i = 0; i < getsetlength(get_cg(), setno); i++) {
                            x[i] += tx;
                            y[i] += ty;
                        }
                        break;
                    case 2:					/* scale */
                        for (i = 0; i < getsetlength(get_cg(), setno); i++) {
                            x[i] *= sx;
                            y[i] *= sy;
                        }
                        break;
                    }		/* end case */
                }			/* end for j */
                update_set_lists(get_cg());
            }			/* end if */
        }				/* end for k */
        if (cnt>0)
        {
            SetsModified(cnt,gnos,selsets,UNDO_DATA);
            if (cnt==1)
            {
                sprintf(dummy," [G%d.S%d]",get_cg(), selsets[0]);
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Geometric transformation of")+QString(dummy),QString());
            }
            else
            {
                addAditionalDescriptionToLastNode(UNDO_TYPE_NEW_SET,QObject::tr("Geometric transformation"),QString());
            }
        }
        set_dirtystate();
        break;
    }
    delete[] selsets;
    listSets->update_number_of_entries_preserve_selection();
    unset_wait_cursor();
    mainWin->mainArea->completeRedraw();
    delete[] gnos;
    delete[] snos;
}

void frmTransform::doReset(void)
{
    if (DecimalPointToUse=='.')
    {
        xv_setstr(lenText[0], "0.0");
        xv_setstr(lenText[1], "0.0");
        xv_setstr(lenText[2], "0.0");
        xv_setstr(lenText[3], "1.0");
        xv_setstr(lenText[4], "1.0");
        xv_setstr(lenText[5], "0.0");
        xv_setstr(lenText[6], "0.0");
    }
    else
    {
        xv_setstr(lenText[0], "0,0");
        xv_setstr(lenText[1], "0,0");
        xv_setstr(lenText[2], "0,0");
        xv_setstr(lenText[3], "1,0");
        xv_setstr(lenText[4], "1,0");
        xv_setstr(lenText[5], "0,0");
        xv_setstr(lenText[6], "0,0");
    }
}

void frmTransform::doClose(void)
{
    hide();
}

void frmTransform::selectorChanged(int i)
{
    if (WindowType==SAMPLEPOINTSWINDOW)
    {
        if (i==0)//start/stop
        {
            lenText[0]->setEnabled(true);
            lenText[1]->setEnabled(true);
            lenText[2]->setEnabled(false);
        }
        else//expression
        {
            lenText[0]->setEnabled(false);
            lenText[1]->setEnabled(false);
            lenText[2]->setEnabled(true);
        }
    }
}

tabMain::tabMain(QWidget * parent):QWidget(parent)
{
    int number=NUMBER_OF_SETTYPES;
    QString entr[NUMBER_OF_SETTYPES];

    char dummy[2000];
    fraSetPres=new QGroupBox(tr("Set presentation"),this);

    number_of_Type_entries=NUMBER_OF_SETTYPES;
    Type_entries=new int[NUMBER_OF_SETTYPES];
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
    {
        strToUpper(dummy,set_types(i));
        entr[i]=QString(dummy);
    }
    cmbType=new StdSelector(fraSetPres,tr("Type:"),number,entr);
    layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(cmbType);
    fraSetPres->setLayout(layout0);

    fraSymbProp=new QGroupBox(tr("Symbol properties"),this);
    layout1=new QVBoxLayout;
    layout1->setMargin(STD_MARGIN);
    entr[0]=tr("None");
    entr[1]=tr("Circle");
    entr[2]=tr("Square");
    entr[3]=tr("Diamond");
    entr[4]=tr("Triangle up");
    entr[5]=tr("Triangle left");
    entr[6]=tr("Triangle down");
    entr[7]=tr("Triangle right");
    entr[8]=tr("Plus");
    entr[9]=tr("X");
    entr[10]=tr("Star");
    entr[11]=tr("Char");
    number=12;
    cmbSymbType=new StdSelector(fraSymbProp,tr("Type:"),number,entr);
    layout1->addWidget(cmbSymbType);
    /* symbol-icons */
    QIcon * symb_icons=new QIcon[12];
    QPixmap map1(12,12);
    QPainter paint1(&map1);
    paint1.setBrush(Qt::white);
    paint1.setPen(Qt::white);
    paint1.drawRect(0,0,13,13);
    paint1.setPen(Qt::black);
    paint1.setBrush(Qt::black);
    QFont dFont=getFontFromDatabase(0);
    dFont.setPixelSize(10*1.8);
    paint1.setFont(dFont);
    paint1.end();
    symb_icons[0]=QIcon(map1);
        for (int i=1;i<12;i++)
        {
        paint1.begin(&map1);
        paint1.setBrush(Qt::white);
        paint1.setPen(Qt::white);
        paint1.drawRect(0,0,13,13);
        paint1.setPen(Qt::black);
        paint1.setBrush(Qt::black);
            if (i==11)
            drawSimpleSymbol(paint1,12,2,10,i,65);
            else
            drawSimpleSymbol(paint1,6,6,10,i,65);
        paint1.end();
        symb_icons[i]=QIcon(map1);
        }
    cmbSymbType->setIcons(symb_icons);
    delete[] symb_icons;
    sldSymbSize=new stdSlider(fraSymbProp,tr("Size"),0,1000);
    layout1->addWidget(sldSymbSize);
    cmbSymbColor=new ColorSelector(fraSymbProp);
    layout1->addWidget(cmbSymbColor);
    connect(cmbSymbColor,SIGNAL(currentIndexChanged(int)),SLOT(SymbColorChanged(int)));

    ///addition for v0.2.6
    int nr_of_char_entries=0;
    int char_entry_values[256];
    QString char_entries[256];
    for (int i=0;i<256;i++)
    {
        if (isprint(i))
        {
        char_entry_values[nr_of_char_entries]=i;
        char_entries[nr_of_char_entries]=QChar(i);
        nr_of_char_entries++;
        }
    }
    selSymbChar=new StdSelector(this,tr("Symbol char:"),nr_of_char_entries,char_entries);
    selSymbChar->setValues(char_entry_values);
    layout1->addWidget(selSymbChar);

    //ledSymbChar=new stdLineEdit(fraSymbProp,tr("Symbol char:"));
    //ledSymbChar->lenText->setText(QString(""));
    //layout1->addWidget(ledSymbChar);
    fraSymbProp->setLayout(layout1);

    fraLineProp=new QGroupBox(tr("Line properties"),this);
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    entr[0]=tr("None");
    entr[1]=tr("Straight");
    entr[2]=tr("Left stairs");
    entr[3]=tr("Right stairs");
    entr[4]=tr("Segments");
    entr[5]=tr("3-Segments");
    entr[6]=tr("Increasing X only");
    entr[7]=tr("Decreasing X only");
    number=8;
    cmbLineType=new StdSelector(fraLineProp,tr("Type:"),number,entr);
    layout2->addWidget(cmbLineType);
    cmbLineStyle=new LineStyleSelector(fraLineProp);
    cmbLineStyle->lblText->setText(tr("Style:"));
    layout2->addWidget(cmbLineStyle);
    spnLineWidth=new LineWidthSelector(fraLineProp);
    spnLineWidth->lblText->setText(tr("Width:"));
    layout2->addWidget(spnLineWidth);
    cmbLineColor=new ColorSelector(fraLineProp);
    layout2->addWidget(cmbLineColor);
    connect(cmbLineColor,SIGNAL(currentIndexChanged(int)),SLOT(LineColorChanged(int)));
    fraLineProp->setLayout(layout2);

    fraLegend=new QGroupBox(tr("Legend"),this);
    layout3=new QHBoxLayout;
    layout3->setMargin(STD_MARGIN);
    ledString=new stdLineEdit(fraLegend,tr("String:"),true);
    ledString->lenText->setText(QString(""));
    layout3->addWidget(ledString);
    fraLegend->setLayout(layout3);

    fraDispOpt=new QGroupBox(tr("Display options"),this);
    layout4=new QHBoxLayout;
    layout4->setMargin(STD_MARGIN);
    chkAnnVal=new QCheckBox(tr("Annotate values"),fraDispOpt);
    layout4->addWidget(chkAnnVal);
    chkDispErrBars=new QCheckBox(tr("Display error bars"),fraDispOpt);
    layout4->addWidget(chkDispErrBars);
    chkIgnoreInAutoscale=new QCheckBox(tr("Ignore during autoscale"),fraDispOpt);;
    layout4->addWidget(chkIgnoreInAutoscale);
    fraDispOpt->setLayout(layout4);
    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(fraSetPres,0,0,1,2);
    layout->addWidget(fraSymbProp,1,0);
    layout->addWidget(fraLineProp,1,1);
    layout->addWidget(fraLegend,2,0,1,2);
    layout->addWidget(fraDispOpt,3,0,1,2);
    setLayout(layout);
    connect(cmbSymbType,SIGNAL(currentIndexChanged(int)),SLOT(SymbTypeChanged(int)));
}

tabMain::~tabMain()
{
    delete[] Type_entries;
}

void tabMain::SymbTypeChanged(int val)
{
    if (val!=SYM_CHAR)
    {
    selSymbChar->setEnabled(false);
    }
    else
    {
    selSymbChar->setEnabled(true);
    }
}

void tabMain::LineColorChanged(int val)
{
    emit(colorChanged(val));
}

void tabMain::SymbColorChanged(int val)
{
    emit(colorChanged2(val));
}

tabSymbol::tabSymbol(QWidget * parent):QWidget(parent)
{
    fraSymbOutl=new QGroupBox(tr("Symbol outline"),this);
    layout0=new QGridLayout;
    layout0->setMargin(STD_MARGIN);
    cmbSymbStyle=new LineStyleSelector(this);
    cmbSymbStyle->lblText->setText(tr("Style:"));
    layout0->addWidget(cmbSymbStyle,0,0);
    cmbSymbPattern=new FillPatternSelector(this);
    cmbSymbPattern->lblText->setText(tr("Pattern:"));
    layout0->addWidget(cmbSymbPattern,1,0);
    spnSymbWidth=new LineWidthSelector(this);
    spnSymbWidth->lblText->setText(tr("Width:"));
    layout0->addWidget(spnSymbWidth,0,1);
    fraSymbOutl->setLayout(layout0);
    fraSymbFill=new QGroupBox(tr("Symbol fill"),this);
    layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    cmbFillColor=new ColorSelector(this);
    cmbFillColor->lblText->setText(tr("Color:"));
    layout1->addWidget(cmbFillColor);
    cmbFillPattern=new FillPatternSelector(this);
    cmbFillPattern->lblText->setText(tr("Pattern:"));
    layout1->addWidget(cmbFillPattern);
    fraSymbFill->setLayout(layout1);
    fraExtra=new QGroupBox(tr("Extra"),this);
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    spnSymbSkip=new stdIntSelector(this,tr("Symbol skip:"),0,100000);
    layout2->addWidget(spnSymbSkip);
    cmbSymbFont=new FontSelector(this);
    cmbSymbFont->setLabelText(tr("Font for char symbol:"));
    //cmbSymbFont->lblText->setText(tr("Font for char symbol:"));
    layout2->addWidget(cmbSymbFont);
    fraExtra->setLayout(layout2);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(fraSymbOutl);
    layout->addWidget(fraSymbFill);
    layout->addWidget(fraExtra);
    empty=new QWidget(this);
    layout->addWidget(empty);
    setLayout(layout);
}

tabLine::tabLine(QWidget * parent):QWidget(parent)
{
    int number=3;
    QString entr[6];
    fraLineProp=new QGroupBox(tr("Line properties"),this);
    //fraLineProp->setGeometry(2,2,parent->width()-8,63);
    layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    cmbPattern=new FillPatternSelector(this);
    cmbPattern->lblText->setText(tr("Pattern:"));
    layout0->addWidget(cmbPattern);
    chkDrawDropLines=new QCheckBox(tr("Draw drop lines"),fraLineProp);
    layout0->addWidget(chkDrawDropLines);
    fraLineProp->setLayout(layout0);
    fraFillProp=new QGroupBox(tr("Fill properties"),this);
    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    number=3;
    entr[0]=tr("None");
    entr[1]=tr("As polygon");
    entr[2]=tr("To baseline");
    cmbType=new StdSelector(this,tr("Type:"),number,entr);
    layout1->addWidget(cmbType,0,0);
    number=2;
    entr[0]=tr("Winding");
    entr[1]=tr("Even-Odd");
    cmbRule=new StdSelector(this,tr("Rule:"),number,entr);
    layout1->addWidget(cmbRule,0,1);
    cmbFillPattern=new FillPatternSelector(this);
    cmbFillPattern->lblText->setText(tr("Pattern:"));
    layout1->addWidget(cmbFillPattern,1,0);
    cmbFillColor=new ColorSelector(this);
    layout1->addWidget(cmbFillColor,1,1);
    cmbSet=new SetSelectorCombo(tr("Polygon base set:"),this);
    layout1->addWidget(cmbSet,2,0);
    fraFillProp->setLayout(layout1);
    fraBaseLine=new QGroupBox(tr("Base line"),this);
    layout2=new QHBoxLayout;
    layout2->setMargin(STD_MARGIN);
    number=6;
    entr[0]=tr("Zero");
    entr[1]=tr("Set min");
    entr[2]=tr("Set max");
    entr[3]=tr("Graph min");
    entr[4]=tr("Graph max");
    entr[5]=tr("Set average");
    cmbBaseType=new StdSelector(this,tr("Type:"),number,entr);
    layout2->addWidget(cmbBaseType);
    chkDrawLine=new QCheckBox(tr("Draw line"),fraBaseLine);
    layout2->addWidget(chkDrawLine);
    fraBaseLine->setLayout(layout2);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(fraLineProp);
    layout->addWidget(fraFillProp);
    layout->addWidget(fraBaseLine);
    empty=new QWidget(this);
    layout->addWidget(empty);
    setLayout(layout);
}

tabAnnVal::tabAnnVal(QWidget * parent):QWidget(parent)
{
    int number=6;
    QString entr[NUM_FMT_OPTION_ITEMS+2];
    char dummy[500];
    fraTextProp=new QGroupBox(tr("Text properties"),this);
    layout0=new QGridLayout;
    layout0->setMargin(STD_MARGIN);
    cmbFont=new FontSelector(this);
    layout0->addWidget(cmbFont,0,0);
    sldFontSize=new stdSlider(this,tr("Char size"),0,1000);
    layout0->addWidget(sldFontSize,0,1);
    cmbColor=new ColorSelector(this);
    layout0->addWidget(cmbColor,1,0);
    sldFontAngle=new stdSlider(this,tr("Angle"),0,360);
    layout0->addWidget(sldFontAngle,1,1);
    ledPrepend=new stdLineEdit(this,tr("Prepend:"),true);
    ledPrepend->lenText->setText(QString(""));
    layout0->addWidget(ledPrepend,2,0);
    ledAppend=new stdLineEdit(this,tr("Append:"),true);
    ledAppend->lenText->setText(QString(""));
    layout0->addWidget(ledAppend,2,1);
    fraTextProp->setLayout(layout0);
    fraFormatOpt=new QGroupBox(tr("Format options"),this);
    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    number=6;
    entr[0]=tr("None");
    entr[1]=tr("X");
    entr[2]=tr("Y");
    entr[3]=tr("X,Y");
    entr[4]=tr("String");
    entr[5]=tr("Z");
    cmbType=new StdSelector(this,tr("Type:"),number,entr);
    layout1->addWidget(cmbType,0,0);
    number=10;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i]=QString(dummy);
    }
    cmbPrecision=new StdSelector(this,tr("Precision:"),number,entr);
    layout1->addWidget(cmbPrecision,0,1);
    for (int i=0;i<NUM_FMT_OPTION_ITEMS;i++)
        entr[i]=QString(fmt_option_items[i].label);
    number=NUM_FMT_OPTION_ITEMS;
    cmbFormat=new StdSelector(this,tr("Format:"),number,entr);
    layout1->addWidget(cmbFormat,1,0,1,2);
    fraFormatOpt->setLayout(layout1);
    fraPlacement=new QGroupBox(tr("Placement"),this);
    layout2=new QHBoxLayout;
    layout2->setMargin(STD_MARGIN);
    ledXOffs=new stdLineEdit(this,tr("X offset:"));
    ledXOffs->lenText->setText(QString(""));
    layout2->addWidget(ledXOffs);
    ledYOffs=new stdLineEdit(this,tr("Y offset:"));
    ledYOffs->lenText->setText(QString(""));
    layout2->addWidget(ledYOffs);
    fraPlacement->setLayout(layout2);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(fraTextProp);
    layout->addWidget(fraFormatOpt);
    layout->addWidget(fraPlacement);
    setLayout(layout);
}

tabErrorBars::tabErrorBars(QWidget * parent):QWidget(parent)
{
    int number=3;
    QString entr[33];
    fraCommon=new QGroupBox(tr("Common"),this);
    layout0=new QVBoxLayout;
    layout0->setMargin(STD_MARGIN);
    number=3;
    entr[0]=tr("Normal");
    entr[1]=tr("Opposite");
    entr[2]=tr("Both");
    cmbPlacement=new StdSelector(this,tr("Placement:"),number,entr);
    layout0->addWidget(cmbPlacement);
    cmbColor=new ColorSelector(this);
    layout0->addWidget(cmbColor);
    cmbPattern=new FillPatternSelector(this);
    cmbPattern->lblText->setText(tr("Pattern:"));
    layout0->addWidget(cmbPattern);
    entr[0]=tr("None");
    entr[1]=tr("X- and Y-bars");
    entr[2]=tr("Y-bars only");
    entr[3]=tr("X-bars only");
    entr[4]=tr("Fill Y-bars as polygon");
    entr[5]=tr("Fill X-bars as polygon");
    entr[6]=tr("Fill X- and Y-bars as polygons");
    number=7;
    chkConnectErrorBars=new StdSelector(this,tr("Connect errorbars:"),number,entr);
    layout0->addWidget(chkConnectErrorBars);
    chkShowInLegend=new QCheckBox(tr("Show error bars in legend"),this);
    layout0->addWidget(chkShowInLegend);
    fraCommon->setLayout(layout0);
    fraClipping=new QGroupBox(tr("Clipping"),this);
    layout1=new QVBoxLayout;
    layout1->setMargin(STD_MARGIN);
    chkArrowClip=new QCheckBox(tr("Arrow clip"),fraClipping);
    layout1->addWidget(chkArrowClip);
    spnMaxLength=new LineWidthSelector(this);
    spnMaxLength->lblText->setText(tr("Max length:"));
    layout1->addWidget(spnMaxLength);
    fraClipping->setLayout(layout1);
    fraBarLine=new QGroupBox(tr("Bar line"),this);
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    sldBarSize=new stdSlider(this,tr("Size"),0,1000);
    layout2->addWidget(sldBarSize);
    spnbarWidth=new LineWidthSelector(this);
    spnbarWidth->lblText->setText(tr("Width:"));
    layout2->addWidget(spnbarWidth);
    cmbBarStyle=new LineStyleSelector(this);
    cmbBarStyle->lblText->setText(tr("Style:"));
    layout2->addWidget(cmbBarStyle);
    fraBarLine->setLayout(layout2);
    fraRiserLine=new QGroupBox(tr("Riser line"),this);
    layout3=new QVBoxLayout;
    layout3->setMargin(STD_MARGIN);
    spnRiserWidth=new LineWidthSelector(this);
    spnRiserWidth->lblText->setText(tr("Width:"));
    layout3->addWidget(spnRiserWidth);
    cmbRiserStyle=new LineStyleSelector(this);
    cmbRiserStyle->lblText->setText(tr("Style:"));
    layout3->addWidget(cmbRiserStyle);
    empty=new QWidget(this);
    empty->setMinimumHeight(30);
    fraRiserLine->setLayout(layout3);
    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(fraCommon,0,0);
    layout->addWidget(fraClipping,1,0);
    layout->addWidget(fraBarLine,0,1);
    layout->addWidget(fraRiserLine,1,1);
    layout->addWidget(empty,2,0,1,2);
    setLayout(layout);
}

frmSet_Appearance::frmSet_Appearance(QWidget * parent):QWidget(parent)
{
    //setFont(*stdFont);
    //setWindowTitle(tr("QtGrace: Set Appearance"));
    //setWindowIcon(QIcon(*GraceIcon));
    CreateActions();
    updating=false;
    cset=0;

    menuBar=new QMenuBar(this);

    mnuFile=new QMenu(tr("&File"),this);
    mnuFile->setTearOffEnabled(TRUE);
    /*mnuFile->addAction(actOpenFontTool);
    mnuFile->addSeparator();*/
    mnuFile->addAction(actclose);

    mnuEdit=new QMenu(tr("&Edit"),this);
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actsetdiffcolors);
    mnuEdit->addAction(actsetdiffsymbols);
    mnuEdit->addAction(actsetdifflinestyles);
    mnuEdit->addAction(actsetdifflinewidths);
    mnuEdit->addAction(actsetbaw);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actloadcoments);
    mnuEdit->addAction(actstriplegends);

    mnuOptions=new QMenu(tr("&Options"),this);
    mnuOptions->setTearOffEnabled(TRUE);
    mnuOptions->addAction(actdupllegends);
    mnuOptions->addAction(actcolorsync);
    mnuOptions->addAction(actapplyall);

    mnuHelp=new QMenu(tr("&Help"),this);
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(acthelponcontext);
    mnuHelp->addAction(acthelponsetappearance);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addMenu(mnuOptions);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);

    lblSelSet=new QLabel(tr("Select set:"),this);
    listSet=new uniList(SETLIST,this);
    connect(listSet,SIGNAL(new_selection(int)),SLOT(newListSelection(int)));

    tabs=new QTabWidget(this);
    tabMa=new tabMain(tabs);
    connect(tabMa,SIGNAL(colorChanged(int)),SLOT(SyncColors(int)));
    connect(tabMa,SIGNAL(colorChanged2(int)),SLOT(SyncColors2(int)));
    tabSy=new tabSymbol(tabs);
    tabLi=new tabLine(tabs);
    tabAnVa=new tabAnnVal(tabs);
    tabErBa=new tabErrorBars(tabs);

    tabs->addTab(tabMa, tr("Main"));
    tabs->addTab(tabSy, tr("Symbols"));
    tabs->addTab(tabLi, tr("Line"));
    tabs->addTab(tabAnVa, tr("Ann. values"));
    tabs->addTab(tabErBa, tr("Error bars"));

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));

    //tabMain
    connect(tabMa->chkAnnVal,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabMa->chkDispErrBars,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabMa->cmbType,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMa->cmbLineColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMa->cmbLineColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabMa->cmbLineStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMa->cmbLineType,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMa->cmbSymbColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMa->cmbSymbColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabMa->cmbSymbType,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMa->ledString,SIGNAL(changed()),SLOT(update0()));
    connect(tabMa->sldSymbSize,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabMa->spnLineWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    //tabSymbol
    connect(tabSy->cmbFillColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabSy->cmbFillColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabSy->cmbFillPattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabSy->cmbSymbFont,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabSy->cmbSymbPattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabSy->cmbSymbStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabSy->spnSymbSkip,SIGNAL(currentValueChanged(int)),SLOT(update1(int)));
    connect(tabSy->spnSymbWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    //tabLine
    connect(tabLi->cmbBaseType,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLi->cmbFillColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLi->cmbFillColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabLi->cmbFillPattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLi->cmbPattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLi->cmbRule,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLi->cmbType,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLi->chkDrawDropLines,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabLi->chkDrawLine,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabLi->cmbSet->cmb,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    //tabtabAnnVal
    connect(tabAnVa->cmbColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabAnVa->cmbColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabAnVa->cmbFont,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabAnVa->cmbFormat,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabAnVa->cmbPrecision,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabAnVa->cmbType,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabAnVa->ledAppend,SIGNAL(changed()),SLOT(update0()));
    connect(tabAnVa->ledPrepend,SIGNAL(changed()),SLOT(update0()));
    connect(tabAnVa->ledXOffs,SIGNAL(changed()),SLOT(update0()));
    connect(tabAnVa->ledYOffs,SIGNAL(changed()),SLOT(update0()));
    connect(tabAnVa->sldFontAngle,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabAnVa->sldFontSize,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    //tabErrorBars
    connect(tabErBa->cmbBarStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabErBa->cmbColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabErBa->cmbColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabErBa->cmbPattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabErBa->cmbPlacement,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabErBa->cmbRiserStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabErBa->chkArrowClip,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabErBa->spnbarWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(tabErBa->spnMaxLength,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(tabErBa->spnRiserWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(tabErBa->sldBarSize,SIGNAL(valueChanged(int)),SLOT(update1(int)));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(lblSelSet);
    layout->addWidget(listSet);
    layout->addWidget(tabs);
    layout->addWidget(buttonGroup);
    setLayout(layout);
}

frmSet_Appearance::~frmSet_Appearance()
{
}

void frmSet_Appearance::ApplyListOfChanges(void)
{
static int i,nr;//,errpos;
    nr=nr_of_true_changes(ListOfChanges);
    //errpos=0;
    if (nr>0)
    {
        for (i=0;i<ListOfChanges.size();i++)
        {
            strcpy(command,ListOfChanges.at(i).toLocal8Bit().constData());
            //qDebug() << "command=" << command;
            //errpos = scanner(command);
            if (command[0]=='#')
            parse_qtGrace_Additions(command);
            else
            (void)scanner(command);
        }
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
        //undo-Stuff
        SetsModified(nr_of_set_concerned,sets_concerned_g,sets_concerned_s,UNDO_APPEARANCE);
    }
    ListOfChanges.clear();
    ListOfOldStates.clear();
}

void frmSet_Appearance::update0(void)
{
bool sav_imm_iupd;
static bool cur_update_running=false;
int nr_sets,*selset=new int[2];
this->listSet->get_selection(&nr_sets,&selset);
    if (!immediateUpdate || cur_update_running==true || nr_sets<=0)
    {
    if (selset) delete[] selset;
    return;
    }
cur_update_running=true;
    GlobalInhibitor=true;
    sav_imm_iupd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
//qDebug() << "update0 before doApply";
    blockSignals(true);

        doApply();//do this without actually doing something
//qDebug() << "update0 after doApply";
//qDebug() << "update0/Before: l=" << g[this->listSet->gr_no].p[this->cset].lstr << " --- orig_l=" << g[this->listSet->gr_no].p[this->cset].orig_lstr;
        ApplyListOfChanges();
//qDebug() << "update0/After : l=" << g[this->listSet->gr_no].p[this->cset].lstr << " --- orig_l=" << g[this->listSet->gr_no].p[this->cset].orig_lstr;
//qDebug() << "update0 after ApplyListOfChanges";
            for(int i = 0; i < nr_sets; i++)
            {
            strcpy(g[this->listSet->gr_no].p[selset[i]].orig_lstr,g[this->listSet->gr_no].p[selset[i]].lstr);
            convert_single_string_from_encoding_to_UTF8_static(g[this->listSet->gr_no].p[selset[i]].lstr);
            update_grace_string_from_UTF8_static(g[this->listSet->gr_no].p[selset[i]].lstr);
            }
        //tabMa->ledString->SetTextToMemory(g[this->listSet->gr_no].p[this->cset].lstr,g[this->listSet->gr_no].p[this->cset].orig_lstr);
if (selset) delete[] selset;

    GlobalInhibitor=false;
    immediateUpdate=sav_imm_iupd;
    updateRunning=false;
//qDebug() << "update0 before updateSetAppearance";
    updateSetAppearance(this->listSet->gr_no,cset);
//qDebug() << "update0 after updateSetAppearance";
    blockSignals(false);
cur_update_running=false;
}

void frmSet_Appearance::update1(int v)
{
    (void)v;
    update0();
}

void frmSet_Appearance::update2(QString v)
{
    (void)v;
    update0();
}

void frmSet_Appearance::update3(bool v)
{
    (void)v;
    update0();
}

void frmSet_Appearance::update4(double v)
{
    (void)v;
    update0();
}

void frmSet_Appearance::init(void)
{
    bool old_upd;
    old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    listSet->update_number_of_entries();
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmSet_Appearance::CreateActions(void)
{
    //Actions for File menu
    actclose = new QAction(tr("&Close"), this);
    actclose->setShortcut(tr("Esc"));
    actclose->setStatusTip(tr("Close this Window"));
    connect(actclose, SIGNAL(triggered()), this, SLOT(doClose()));
    actOpenFontTool = new QAction(tr("&Open font tool"), this);
    actOpenFontTool->setStatusTip(tr("Open the font tool to select a charater for the symbols"));
    connect(actOpenFontTool, SIGNAL(triggered()), this, SLOT(doOpenFontTool()));
    acthelponcontext= new QAction(tr("On onte&xt"), this);
    acthelponcontext->setShortcut(tr("Crtl+F1"));
    connect(acthelponcontext, SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    acthelponsetappearance= new QAction(tr("On set appearance"), this);
    connect(acthelponsetappearance, SIGNAL(triggered()), this, SLOT(doHelpOnSetAppearance()));
    actdupllegends= new QAction(tr("&Duplicate legends"), this);
    actdupllegends->setToolTip(tr("If Apply is clicked with more than one\nselected set the legend will also be\napplied to all selected sets."));
    actdupllegends->setCheckable(TRUE);
    actdupllegends->setChecked(FALSE);
    connect(actdupllegends, SIGNAL(triggered()), this, SLOT(doDuplLegends()));
    actcolorsync= new QAction(tr("Color &sync"), this);
    actcolorsync->setToolTip(tr("Changing the line-color will also change\nthe color of symbols and error-bars."));
    actcolorsync->setCheckable(TRUE);
    actcolorsync->setChecked(TRUE);
    connect(actcolorsync, SIGNAL(triggered()), this, SLOT(doColorSync()));
    actapplyall= new QAction(tr("Apply &all settings"), this);
    actapplyall->setToolTip(tr("If this is activated, all settings will be\napplied to all sets, otherwise only\nmodified settings are applied."));
    actapplyall->setCheckable(TRUE);
    actapplyall->setChecked(TRUE);
    connect(actapplyall, SIGNAL(triggered()), this, SLOT(doApplyAll()));
    actsetdiffcolors= new QAction(tr("Set different &colors"), this);
    connect(actsetdiffcolors, SIGNAL(triggered()), this, SLOT(doSetDiffColors()));
    actsetdifflinestyles= new QAction(tr("Set different line st&yles"), this);
    connect(actsetdifflinestyles, SIGNAL(triggered()), this, SLOT(doSetDiffLineStyles()));
    actsetdifflinewidths= new QAction(tr("Set different line &widths"), this);
    connect(actsetdifflinewidths, SIGNAL(triggered()), this, SLOT(doSetDiffLineWidths()));
    actsetdiffsymbols= new QAction(tr("Set different &symbols"), this);
    connect(actsetdiffsymbols, SIGNAL(triggered()), this, SLOT(doSetDiffSymbols()));
    actsetbaw= new QAction(tr("Set black && white"), this);
    connect(actsetbaw, SIGNAL(triggered()), this, SLOT(doSetBlackAndWhite()));
    actloadcoments= new QAction(tr("Load co&mments"), this);
    connect(actloadcoments, SIGNAL(triggered()), this, SLOT(doLoadComments()));
    actstriplegends= new QAction(tr("Strip &legends"), this);
    connect(actstriplegends, SIGNAL(triggered()), this, SLOT(doStripLegends()));
}

void frmSet_Appearance::doApply(void)
{
static bool apply_running=false;
if (apply_running==true) return;
apply_running=true;
    char dummy[MAX_STRING_LENGTH];
    char dummy2[MAX_STRING_LENGTH];
    ApplyError=false;
    int i;
    int duplegs;
    int type;
    int sym, symskip, symlines;
    double symlinew;
    int line, linet, color, alpha, pattern;
    double wid;
    int dropline, filltype, fillrule, fillpat, fillcol, fillalpha, polybase;
    int symcolor, symalpha, sympattern, symfillcolor, symfillalpha, symfillpattern;
    double symsize;
    int baseline, baselinetype, ignore_autoscale;
    Errbar errbar;
    AValue avalue;
    char symchar;
    int charfont;
    plotarr p;
    int setno,grano,probeset;
    int *selset=new int[2], cd;
    listSet->get_selection(&cd,&selset);//you get the actual set-id (G0.S2 --> 2), not the entry number in the list (e.g. 0 if S0 and S1 have been deleted)
    if (cd < 1)
    {
        if (immediateUpdate==false)
        errmsg(tr("No set selected").toLocal8Bit().constData());
        ApplyError=true;
        delete[] selset;
        apply_running=false;
        return;
    }
    int * gnos=NULL;
    int * snos=NULL;
    grano=listSet->gr_no;
    if (cd>0)
    {
        gnos=new int[cd];
        snos=new int[cd];
        for (int i=0;i<cd;i++)
        {
            gnos[i]=grano;
            snos[i]=selset[i];
        }
        nr_of_set_concerned=cd;
        if (sets_concerned_g!=NULL) delete[] sets_concerned_g;
        if (sets_concerned_s!=NULL) delete[] sets_concerned_s;
        sets_concerned_g=new int[cd];
        sets_concerned_s=new int[cd];
        memcpy(sets_concerned_g,gnos,sizeof(int)*cd);
        memcpy(sets_concerned_s,snos,sizeof(int)*cd);
        SaveSetStatesPrevious(cd,gnos,snos,UNDO_APPEARANCE);
    }
    else
    {
        nr_of_set_concerned=0;
    }

    duplegs=actdupllegends->isChecked()==true?1:0;

    type = tabMa->Type_entries[tabMa->cmbType->currentIndex()];
    symsize =tabMa->sldSymbSize->value()/100.0;
    sym = tabMa->cmbSymbType->currentIndex();
    color = tabMa->cmbLineColor->currentIndex();
    alpha = tabMa->cmbLineColor->alpha();

    pattern = tabLi->cmbPattern->currentIndex();
    wid = tabMa->spnLineWidth->value();
    baseline = tabLi->chkDrawLine->isChecked()==true?1:0;
    baselinetype = tabLi->cmbBaseType->currentIndex();
    dropline = tabLi->chkDrawDropLines->isChecked()==true?1:0;
    line = tabMa->cmbLineStyle->currentIndex();
    linet = tabMa->cmbLineType->currentIndex();

    filltype = tabLi->cmbType->currentIndex();
    fillrule = tabLi->cmbRule->currentIndex();
    fillpat = tabLi->cmbFillPattern->currentIndex();
    fillcol = tabLi->cmbFillColor->currentIndex();
    fillalpha = tabLi->cmbFillColor->alpha();
    polybase = tabLi->cmbSet->value();
    symskip = tabSy->spnSymbSkip->value();
    symcolor = tabMa->cmbSymbColor->currentIndex();
    symalpha = tabMa->cmbSymbColor->alpha();
    sympattern = tabSy->cmbSymbPattern->currentIndex();
    symfillcolor = tabSy->cmbFillColor->currentIndex();
    symfillalpha = tabSy->cmbFillColor->alpha();
    symfillpattern = tabSy->cmbFillPattern->currentIndex();
    symlinew = tabSy->spnSymbWidth->value();
    symlines = tabSy->cmbSymbStyle->currentIndex();
    symchar = tabMa->selSymbChar->currentValue();
    //symchar = atoi(tabMa->ledSymbChar->text().toLatin1().constData());
    charfont = tabSy->cmbSymbFont->currentIndex();

    errbar.active = tabMa->chkDispErrBars->isChecked()==true?1:0;
    avalue.active = tabMa->chkAnnVal->isChecked()==true?1:0;
    ignore_autoscale = tabMa->chkIgnoreInAutoscale->isChecked()==true?1:0;

    avalue.font = tabAnVa->cmbFont->currentIndex();
    avalue.size = tabAnVa->sldFontSize->value()/100.0;
    avalue.color = tabAnVa->cmbColor->currentIndex();
    avalue.alpha = tabAnVa->cmbColor->alpha();
    avalue.angle = tabAnVa->sldFontAngle->value();
    avalue.format = tabAnVa->cmbFormat->currentIndex();
    avalue.type = tabAnVa->cmbType->currentIndex();
    avalue.prec = tabAnVa->cmbPrecision->currentIndex();

    tabAnVa->ledPrepend->SetMemoryToText(avalue.prestr,avalue.orig_prestr);
    tabAnVa->ledAppend->SetMemoryToText(avalue.appstr,avalue.orig_appstr);

    xv_evalexpr(tabAnVa->ledXOffs,&avalue.offset.x);
    xv_evalexpr(tabAnVa->ledYOffs,&avalue.offset.y);

    errbar.pen.color = tabErBa->cmbColor->currentIndex();
    errbar.pen.alpha = tabErBa->cmbColor->alpha();
    switch (tabErBa->cmbPlacement->currentIndex())
    {
    case 1:
        errbar.ptype = PLACEMENT_OPPOSITE;
        break;
    case 2:
        errbar.ptype = PLACEMENT_BOTH;
        break;
    default:
        errbar.ptype = PLACEMENT_NORMAL;
        break;
    }
    errbar.show_in_legend = tabErBa->chkShowInLegend->isChecked()==true?1:0;
    errbar.connect_bars = tabErBa->chkConnectErrorBars->currentValue();
    errbar.pen.pattern = tabErBa->cmbPattern->currentIndex();
    errbar.arrow_clip = tabErBa->chkArrowClip->isChecked()==true?1:0;
    errbar.cliplen = tabErBa->spnMaxLength->value();
    errbar.barsize = tabErBa->sldBarSize->value()/100.0;
    errbar.linew = tabErBa->spnbarWidth->value();
    errbar.riser_linew = tabErBa->spnRiserWidth->value();
    errbar.lines = tabErBa->cmbBarStyle->currentIndex();
    errbar.riser_lines = tabErBa->cmbRiserStyle->currentIndex();

    ListOfChanges.clear();
    ListOfOldStates.clear();

    sprintf(dummy,"with g%d",grano);
    ListOfChanges << QString(dummy);
    ListOfOldStates << QString(dummy);

    if (cd < 1)
    {
        if (immediateUpdate==false)
        errmsg(tr("No set selected").toLocal8Bit().constData());
        ApplyError=true;
    }
    else
    {
    for (int kkk=0;kkk<cd;kkk++)
    {
        //compare changes with previous states
        setno=selset[kkk];
        /// setno = -1111111;//selset[0];//first set selected --> NO, WE USE AN INVALID NUMBER HERE
        // the following is to obtain the previous settings
        if (actapplyall->isChecked()==true)//we compare before and after for every set
        {
        probeset=selset[kkk];
        get_graph_plotarr(grano, selset[kkk], &p);
        }
        else//we compare every time with the settings in the first set (the one that is displayed)
        {
        probeset=selset[0];
        get_graph_plotarr(grano, selset[0], &p);
        }

//qDebug() << "G" << grano << ".S" << selset[kkk] << ".type=" << dataset_type(grano, selset[kkk]) << " type =" << type;

        if (dataset_type(grano, probeset) != type)
        {
            sprintf(dummy,"    s%d type %s",setno,set_types(type));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d type %s",setno,set_types(dataset_type(grano, selset[kkk])));
            ListOfOldStates << QString(dummy);
        }
        if (p.symskip != symskip)
        {
            sprintf(dummy,"    s%d symbol skip %d",setno,symskip);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol skip %d",setno,p.symskip);
            ListOfOldStates << QString(dummy);
        }
        if (p.symsize != symsize)
        {
            sprintf(dummy,"    s%d symbol size %f",setno,symsize);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol size %f",setno,p.symsize);
            ListOfOldStates << QString(dummy);
        }
//qDebug() << "p.symsize=" << p.symsize << " symsize=" << symsize;
        if (p.symlinew != symlinew)
        {
            sprintf(dummy,"    s%d symbol linewidth %f",setno,symlinew);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol linewidth %f",setno,p.symlinew);
            ListOfOldStates << QString(dummy);
        }
        if (p.symlines != symlines)
        {
            sprintf(dummy,"    s%d symbol linestyle %d",setno,symlines);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol linestyle %d",setno,p.symlines);
            ListOfOldStates << QString(dummy);
        }
        if (p.symchar != symchar)
        {
            sprintf(dummy,"    s%d symbol char %d",setno,(int)symchar);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol char %d",setno,(int)(p.symchar));
            ListOfOldStates << QString(dummy);
        }
        if (p.charfont != charfont)
        {
            sprintf(dummy,"    s%d symbol char font %d",setno,charfont);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol char font %d",setno,p.charfont);
            ListOfOldStates << QString(dummy);
        }
        if (p.filltype != filltype)
        {
            sprintf(dummy,"    s%d fill type %d",setno,filltype);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d fill type %d",setno,p.filltype);
            ListOfOldStates << QString(dummy);
        }
        if (p.fillrule != fillrule)
        {
            sprintf(dummy,"    s%d fill rule %d",setno,fillrule);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d fill rule %d",setno,p.fillrule);
            ListOfOldStates << QString(dummy);
        }
        if (p.setfillpen.pattern != fillpat)
        {
            sprintf(dummy,"    s%d fill pattern %d",setno,fillpat);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d fill pattern %d",setno,p.setfillpen.pattern);
            ListOfOldStates << QString(dummy);
        }
        if (p.setfillpen.color != fillcol)
        {
            sprintf(dummy,"    s%d fill color %d",setno,fillcol);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d fill color %d",setno,p.setfillpen.color);
            ListOfOldStates << QString(dummy);
        }
        if (p.sym != sym)
        {
            sprintf(dummy,"    s%d symbol %d",setno,sym);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol %d",setno,p.sym);
            ListOfOldStates << QString(dummy);
        }
        if (p.linet != linet)
        {
            sprintf(dummy,"    s%d line type %d",setno,linet);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d line type %d",setno,p.linet);
            ListOfOldStates << QString(dummy);
        }
        if (p.lines != line)
        {
            sprintf(dummy,"    s%d line linestyle %d",setno,line);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d line linestyle %d",setno,p.lines);
            ListOfOldStates << QString(dummy);
        }
        if (p.linew != wid)
        {
            sprintf(dummy,"    s%d line linewidth %f",setno,wid);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d line linewidth %f",setno,p.linew);
            ListOfOldStates << QString(dummy);
        }
        if (p.linepen.color != color)
        {
            sprintf(dummy,"    s%d line color %d",setno,color);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d line color %d",setno,p.linepen.color);
            ListOfOldStates << QString(dummy);
        }
        if (p.linepen.pattern != pattern)
        {
            sprintf(dummy,"    s%d line pattern %d",setno,pattern);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d line pattern %d",setno,p.linepen.pattern);
            ListOfOldStates << QString(dummy);
        }
        if (p.sympen.color != symcolor)
        {
            sprintf(dummy,"    s%d symbol color %d",setno,symcolor);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol color %d",setno,p.sympen.color);
            ListOfOldStates << QString(dummy);
        }
        if (p.sympen.pattern != sympattern)
        {
            sprintf(dummy,"    s%d symbol pattern %d",setno,sympattern);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol pattern %d",setno,p.sympen.pattern);
            ListOfOldStates << QString(dummy);
        }
        if (p.symfillpen.color != symfillcolor)
        {
            sprintf(dummy,"    s%d symbol fill color %d",setno,symfillcolor);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol fill color %d",setno,p.symfillpen.color);
            ListOfOldStates << QString(dummy);
        }
        if (p.symfillpen.pattern != symfillpattern)
        {
            sprintf(dummy,"    s%d symbol fill pattern %d",setno,symfillpattern);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d symbol fill pattern %d",setno,p.symfillpen.pattern);
            ListOfOldStates << QString(dummy);
        }
        if (p.dropline != dropline)
        {
            sprintf(dummy,"    s%d dropline %s",setno,dropline?"on":"off");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d dropline %s",setno,p.dropline?"on":"off");
            ListOfOldStates << QString(dummy);
        }
        if (p.baseline != baseline)
        {
            sprintf(dummy,"    s%d baseline %s",setno,baseline?"on":"off");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d baseline %s",setno,p.baseline?"on":"off");
            ListOfOldStates << QString(dummy);
        }
        if (p.baseline_type != baselinetype)
        {
            sprintf(dummy,"    s%d baseline type %d",setno,baselinetype);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d baseline type %d",setno,p.baseline_type);
            ListOfOldStates << QString(dummy);
        }

        strcpy(dummy2,tabMa->ledString->text().toLocal8Bit());
        if (actapplyall->isChecked()==false && GlobalInhibitor==false)//only apply the changes
        {
        strcpy(dummy2,tabMa->ledString->text().toUtf8());
        convert_single_string_from_UTF8_to_encoding_static(dummy2);
        }
        if (strcmp(p.orig_lstr,dummy2) && (cd == 1 || duplegs))
        {
            sprintf(dummy,"    s%d legend  \"%s\"",setno,dummy2);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d legend  \"%s\"",setno,p.orig_lstr);
            ListOfOldStates << QString(dummy);
        }
        //Annotated-values-properties
        if (p.avalue.active!=avalue.active)
        {
            sprintf(dummy,"    s%d avalue %s",setno,avalue.active?"on":"off");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue %s",setno,p.avalue.active?"on":"off");
            ListOfOldStates << QString(dummy);
        }
        if (p.avalue.font!=avalue.font)
        {
            sprintf(dummy,"    s%d avalue font %d",setno,avalue.font);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue font %d",setno,p.avalue.font);
            ListOfOldStates << QString(dummy);
        }
        if (p.avalue.size!=avalue.size)
        {
            sprintf(dummy,"    s%d avalue char size %f",setno,avalue.size);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue char size %f",setno,p.avalue.size);
            ListOfOldStates << QString(dummy);
        }
        if (p.avalue.color!=avalue.color)
        {
            sprintf(dummy,"    s%d avalue color %d",setno,avalue.color);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue color %d",setno,p.avalue.color);
            ListOfOldStates << QString(dummy);
        }
        if (p.avalue.angle!=avalue.angle)
        {
            sprintf(dummy,"    s%d avalue rot %d",setno,avalue.angle);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue rot %d",setno,p.avalue.angle);
            ListOfOldStates << QString(dummy);
        }
        if (p.avalue.format!=avalue.format)
        {
            strcpy(dummy2,fmt_option_items[avalue.format].label);
            for (unsigned int j=0;j<strlen(dummy2);j++)
                dummy2[j]=tolower(dummy2[j]);
            sprintf(dummy,"    s%d avalue format %s",setno,dummy2);
            ListOfChanges << QString(dummy);
            strcpy(dummy2,fmt_option_items[p.avalue.format].label);
            for (unsigned int j=0;j<strlen(dummy2);j++)
                dummy2[j]=tolower(dummy2[j]);
            sprintf(dummy,"    s%d avalue format %s",setno,dummy2);
            ListOfOldStates << QString(dummy);
        }
        if (p.avalue.type!=avalue.type)
        {
            sprintf(dummy,"    s%d avalue type %d",setno,avalue.type);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue type %d",setno,p.avalue.type);
            ListOfOldStates << QString(dummy);
        }
        if (p.avalue.prec!=avalue.prec)
        {
            sprintf(dummy,"    s%d avalue prec %d",setno,avalue.prec);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue prec %d",setno,p.avalue.prec);
            ListOfOldStates << QString(dummy);
        }
        if (strcmp(p.avalue.prestr,avalue.prestr))
        {
            sprintf(dummy,"    s%d avalue prepend \"%s\"",setno,avalue.prestr);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue prepend \"%s\"",setno,p.avalue.prestr);
            ListOfOldStates << QString(dummy);
        }
        if (strcmp(p.avalue.appstr,avalue.appstr))
        {
            sprintf(dummy,"    s%d avalue append \"%s\"",setno,avalue.appstr);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue append \"%s\"",setno,p.avalue.appstr);
            ListOfOldStates << QString(dummy);
        }
        if (p.avalue.offset.x!=avalue.offset.x || p.avalue.offset.y!=avalue.offset.y)
        {
            sprintf(dummy,"    s%d avalue offset %f , %f",setno,avalue.offset.x,avalue.offset.y);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d avalue offset %f , %f",setno,p.avalue.offset.x,p.avalue.offset.y);
            ListOfOldStates << QString(dummy);
        }
        if (p.ignore_in_autoscale!=ignore_autoscale)
        {
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d IGNOREINAUTOSCALE %d",grano,setno,ignore_autoscale);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d IGNOREINAUTOSCALE %d",grano,setno,p.ignore_in_autoscale);
            ListOfOldStates << QString(dummy);
        }
        //errorbar-properties
        if (p.errbar.active!=errbar.active)
        {
            sprintf(dummy,"    s%d errorbar %s",setno,errbar.active?"on":"off");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar %s",setno,p.errbar.active?"on":"off");
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.pen.color!=errbar.pen.color)
        {
            sprintf(dummy,"    s%d errorbar color %d",setno,errbar.pen.color);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar color %d",setno,p.errbar.pen.color);
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.ptype!=errbar.ptype)
        {
            sprintf(dummy,"    s%d errorbar place %s",setno,errbar.ptype==PLACEMENT_BOTH?"both":(errbar.ptype==PLACEMENT_NORMAL?"normal":"opposite"));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar place %s",setno,p.errbar.ptype==PLACEMENT_BOTH?"both":(p.errbar.ptype==PLACEMENT_NORMAL?"normal":"opposite"));
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.pen.pattern!=errbar.pen.pattern)
        {
            sprintf(dummy,"    s%d errorbar pattern %d",setno,errbar.pen.pattern);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar pattern %d",setno,p.errbar.pen.pattern);
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.arrow_clip!=errbar.arrow_clip)
        {
            sprintf(dummy,"    s%d errorbar riser clip %s",setno,errbar.arrow_clip?"on":"off");
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar riser clip %s",setno,p.errbar.arrow_clip?"on":"off");
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.cliplen!=errbar.cliplen)
        {
            sprintf(dummy,"    s%d errorbar riser clip length %f",setno,errbar.cliplen);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar riser clip length %f",setno,p.errbar.cliplen);
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.barsize!=errbar.barsize)
        {
            sprintf(dummy,"    s%d errorbar size %f",setno,errbar.barsize);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar size %f",setno,p.errbar.barsize);
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.linew!=errbar.linew)
        {
            sprintf(dummy,"    s%d errorbar linewidth %f",setno,errbar.linew);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar linewidth %f",setno,p.errbar.linew);
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.riser_linew!=errbar.riser_linew)
        {
            sprintf(dummy,"    s%d errorbar riser linewidth %f",setno,errbar.riser_linew);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar riser linewidth %f",setno,p.errbar.riser_linew);
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.lines!=errbar.lines)
        {
            sprintf(dummy,"    s%d errorbar linestyle %d",setno,errbar.lines);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar linestyle %d",setno,p.errbar.lines);
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.riser_lines!=errbar.riser_lines)
        {
            sprintf(dummy,"    s%d errorbar riser linestyle %d",setno,errbar.riser_lines);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    s%d errorbar riser linestyle %d",setno,p.errbar.riser_lines);
            ListOfOldStates << QString(dummy);
        }
        //alpha-channels
        if (alpha!=p.linepen.alpha || fillalpha!=p.setfillpen.alpha || symalpha!=p.sympen.alpha || symfillalpha!=p.symfillpen.alpha || avalue.alpha!=p.avalue.alpha || errbar.pen.alpha!=p.errbar.pen.alpha)
        {
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d ALPHA_CHANNELS %s",grano,setno,create_list_of_arguments(6, alpha,fillalpha,symalpha,symfillalpha,avalue.alpha,errbar.pen.alpha));
            ListOfChanges << QString(dummy);
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d ALPHA_CHANNELS %s",grano,setno,create_list_of_arguments(6, p.linepen.alpha,p.setfillpen.alpha,p.sympen.alpha,p.symfillpen.alpha,p.avalue.alpha,p.errbar.pen.alpha));
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.show_in_legend!=errbar.show_in_legend)
        {
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d SHOWERRORBARINLEGEND %d",grano,setno,errbar.show_in_legend);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d SHOWERRORBARINLEGEND %d",grano,setno,p.errbar.show_in_legend);
            ListOfOldStates << QString(dummy);
        }
        if (p.errbar.connect_bars!=errbar.connect_bars)
        {
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d CONNECTERRORBARS %d",grano,setno,errbar.connect_bars);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d CONNECTERRORBARS %d",grano,setno,p.errbar.connect_bars);
            ListOfOldStates << QString(dummy);
        }
        if (p.polygone_base_set!=polybase)
        {
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d POLYGONEBASESET %d\n",grano,setno,polybase);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: G %d S %d POLYGONEBASESET %d\n",grano,setno,p.polygone_base_set);
            ListOfOldStates << QString(dummy);
        }
    }//end loop over all selected sets
        //end comparison
        /*qDebug() << "Commands:";
        for (i=0;i<ListOfChanges.size();i++)
        qDebug() << ListOfChanges.at(i);*/
        /// the following has been deleted because all commands are written for all sets! (not only one)
        /*
        QStringList help_list1=ListOfChanges;
        QStringList help_list2=help_list1;
        ListOfChanges.clear();
        for (i = 0; i < cd; i++)
        {
            sprintf(dummy,"s%d",selset[i]);
            help_list2.replaceInStrings("s-1111111",dummy);//-1111111 does not exist --> I use this to replace it by different set-ids
            sprintf(dummy,"S %d",selset[i]);
            help_list2.replaceInStrings("S -1111111",dummy);
            ListOfChanges << help_list2;
            help_list2=help_list1;
        }
        */

        /*
        for(i = 0; i < cd; i++)
            g[grano].p[selset[i]].avalue=avalue;//necessary
        */
        if (GlobalInhibitor==false && actapplyall->isChecked()==true)//if GlobalInhibitor==true --> do nothing for real
        {
            blockSignals(true);
            //start update
            for(i = 0; i < cd; i++)
            {
                setno = selset[i];
                get_graph_plotarr(grano, setno, &p);
                p.symskip = symskip;
                p.symsize = symsize;
                p.symlinew = symlinew;
                p.symlines = symlines;
                p.symchar = symchar;
                p.charfont = charfont;
                p.filltype = filltype;
                p.fillrule = fillrule;
                p.setfillpen.pattern = fillpat;
                p.setfillpen.color = fillcol;
                p.setfillpen.alpha = fillalpha;
                if (cd == 1 || duplegs)
                {
                    //strcpy(p.lstr,tabMa->ledString->text().toLocal8Bit());
                    tabMa->ledString->SetMemoryToText(p.lstr,p.orig_lstr);
                    //setting a string
                }
                p.sym = sym;
                p.linet = linet;
                p.lines = line;
                p.linew = wid;
                p.linepen.color = color;
                p.linepen.alpha = alpha;
                p.linepen.pattern = pattern;
                p.sympen.color = symcolor;
                p.sympen.alpha = symalpha;
                p.sympen.pattern = sympattern;
                p.symfillpen.color = symfillcolor;
                p.symfillpen.alpha = symfillalpha;
                p.symfillpen.pattern = symfillpattern;
                p.dropline = dropline;
                p.baseline = baseline;
                p.baseline_type = baselinetype;
                p.polygone_base_set = polybase;
                p.errbar = errbar;
                p.avalue = avalue;
                p.ignore_in_autoscale = ignore_autoscale;

                set_graph_plotarr(grano, setno, &p);
                set_dataset_type(grano, setno, type);

                if (cd == 1 || duplegs)//with dynamic strings-->we have to reload from the NEW address
                {
                    tabMa->ledString->SetTextToMemory(g[grano].p[setno].lstr,g[grano].p[setno].orig_lstr);
                }

            }
            SetsModified(cd,gnos,snos,UNDO_APPEARANCE);
            ListOfChanges.clear();
            ListOfOldStates.clear();
            blockSignals(false);
        }//end global_inhibitor
        /// the following removed in QtGrace v0.2.6
        /*else if (p.polygone_base_set!=polybase)//a special addition for filling the area between different sets
        {
        /// this should be inside the other if-clause
            for(i = 0; i < cd; i++)
            {
                setno = selset[i];
                get_graph_plotarr(grano, setno, &p);
                p.polygone_base_set = polybase;
                set_graph_plotarr(grano, setno, &p);
            }
        }*/
        if (gnos!=NULL) delete[] gnos;
        if (snos!=NULL) delete[] snos;
    }
    blockSignals(true);
//qDebug() << "before apply and update";
    if (actapplyall->isChecked()==false && GlobalInhibitor==false)//only apply the changes
    {
        /*for(i = 0; i < cd; i++)
        {
        strcpy(g[grano].p[selset[i]].lstr,g[grano].p[selset[i]].orig_lstr);
        }*/
        mainWin->mainArea->compl_redraw_running=true;
        prepare_strings_for_saving();
//qDebug() << "Apply/Before: l=" << g[this->listSet->gr_no].p[this->cset].lstr << " --- orig_l=" << g[this->listSet->gr_no].p[this->cset].orig_lstr;
            for(i = 0; i < cd; i++)
            qDebug() << "vor apply: orig_lstr=" << g[grano].p[selset[i]].orig_lstr << " lstr=" << g[grano].p[selset[i]].lstr;
    ApplyListOfChanges();
            for(i = 0; i < cd; i++)
            qDebug() << "nach apply: orig_lstr=" << g[grano].p[selset[i]].orig_lstr << " lstr=" << g[grano].p[selset[i]].lstr;
//qDebug() << "Apply/After : l=" << g[this->listSet->gr_no].p[this->cset].lstr << " --- orig_l=" << g[this->listSet->gr_no].p[this->cset].orig_lstr;
        resume_strings_after_load_or_save();
        mainWin->mainArea->compl_redraw_running=false;
        /*for(i = 0; i < cd; i++)
        {
        qDebug() << "orig_lstr=" << g[grano].p[selset[i]].orig_lstr << " lstr=" << g[grano].p[selset[i]].lstr;
        strcpy(g[grano].p[selset[i]].orig_lstr,g[grano].p[selset[i]].lstr);
        qDebug() << "orig_lstr=" << g[grano].p[selset[i]].orig_lstr << " lstr=" << g[grano].p[selset[i]].lstr;
        convert_single_string_from_encoding_to_UTF8_static(g[grano].p[selset[i]].lstr);
        update_grace_string_from_UTF8_static(g[grano].p[selset[i]].lstr);
        }*/
    //tabMa->ledString->SetTextToMemory(g[this->listSet->gr_no].p[this->cset].lstr,g[this->listSet->gr_no].p[this->cset].orig_lstr);
    mainWin->mainArea->completeRedraw();
    }
    else if (GlobalInhibitor==false)//we already did the changes
    {
    mainWin->mainArea->completeRedraw();
    }
//qDebug() << "before set_new_selection";
    listSet->set_new_selection(cd,selset);
//qDebug() << "before showSetData";
    if (cd>0)
    {
    this->showSetData(grano,selset[0]);
    }
    delete[] selset;
//qDebug() << "after apply and update";
    blockSignals(false);
apply_running=false;
}

void frmSet_Appearance::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmSet_Appearance::doClose(void)
{
//parentWidget()->hide();
    emit(closeWish());
}

void frmSet_Appearance::doOpenFontTool(void)
{
    if (FormFontTool==NULL)
    {
        FormFontTool=new frmFontTool(this);
        FormFontTool->resize(460,570);
    }
    FormFontTool->show();
    FormFontTool->raise();
    FormFontTool->activateWindow();
}

void frmSet_Appearance::doHelpOnContext(void)
{
    mainWin->setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmSet_Appearance::doHelpOnSetAppearance(void)
{
    HelpCB("doc/UsersGuide.html#set-appearance");
}

void frmSet_Appearance::doDuplLegends(void)
{
    ;
}

void frmSet_Appearance::doColorSync(void)
{
    ;
}

void frmSet_Appearance::doApplyAll(void)
{
    ;
}

void frmSet_Appearance::doSetDiffColors(void)
{
    setapp_data_proc(SETAPP_ALL_COLORS);
}

void frmSet_Appearance::doSetDiffLineStyles(void)
{
    setapp_data_proc(SETAPP_ALL_LINES);
}

void frmSet_Appearance::doSetDiffLineWidths(void)
{
    setapp_data_proc(SETAPP_ALL_LINEW);
}

void frmSet_Appearance::doSetDiffSymbols(void)
{
    setapp_data_proc(SETAPP_ALL_SYMBOLS);
}

void frmSet_Appearance::doSetBlackAndWhite(void)
{
    setapp_data_proc(SETAPP_ALL_BW);
}

void frmSet_Appearance::doLoadComments(void)
{
    setapp_data_proc(SETAPP_LOAD_COMMENTS);
}

void frmSet_Appearance::doStripLegends(void)
{
    setapp_data_proc(SETAPP_STRIP_LEGENDS);
}

void frmSet_Appearance::newListSelection(int a)
{
    bool old_upd;
    old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    showSetData(listSet->gr_no,listSet->entries[a]);
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmSet_Appearance::ShowSetData_external(int graph_number,int set_number)
{
    bool old_upd;
    old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    int * selection=new int[2];
    int number=1;
/*int old_gno,old_selection;
    listSet->get_selection(&number,&selection);
    if (number<1)
    {
    old_gno=old_selection=-100;
    }
    else
    {
    old_gno=listSet->gr_no;
    old_selection=selection[0];
    }
if (old_gno==graph_number && old_selection==set_number)
{//just redisplay the old data
showSetData(graph_number,set_number);
}
else
{
    //reset selection and display (new) data
    if (selection!=NULL)
    delete[] selection;
selection=new int[2];*/
selection[0]=set_number;

    if (listSet->gr_no!=graph_number)
    listSet->set_graph_number(graph_number,false);

    listSet->set_new_selection(number,selection);

    listSet->get_selection(&number,&selection);
    showSetData(graph_number,set_number);
//}
    if (selection!=NULL)
    delete[] selection;
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmSet_Appearance::showSetData(int graph_number,int set_number)
{
    if (is_valid_setno(graph_number,set_number)==FALSE) return;

    updating=true;
    cset=set_number;

    char dummy[2048];
    plotarr p;
    get_graph_plotarr(graph_number, set_number, &p);

    redisplayContents();//to switch the decimal separator

    tabLi->cmbSet->update_entries(graph_number,true);

    ///SET APPROPRIATE SET_TYPE_CHOICES ACCORDING TO NUMBER OF COLUMNS --> SHOW ONLY AVAILABLE CHOICES, I DON'T KNOW HOW TO DISABLE CHOICES
    tabMa->cmbType->cmbSelect->clear();
    tabMa->number_of_Type_entries=0;
    delete[] tabMa->Type_entries;
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
        if (settype_cols(i) == settype_cols(p.type)) tabMa->number_of_Type_entries++;
    tabMa->Type_entries=new int[tabMa->number_of_Type_entries];
    tabMa->number_of_Type_entries=0;
    for (int i=0;i<NUMBER_OF_SETTYPES;i++)
    {
        if (settype_cols(i) == settype_cols(p.type))
        {
            strToUpper(dummy,set_types(i));
            tabMa->cmbType->cmbSelect->addItem(QString(dummy));
            tabMa->Type_entries[tabMa->number_of_Type_entries]=i;
            tabMa->number_of_Type_entries++;
        }
    }
    /*
SetOptionChoice(type_item, p.type);
        for (i = 0; i < type_item->nchoices; i++) {
            if (settype_cols(type_item->options[i].value) ==
                                            settype_cols(p.type)) {
                SetSensitive(type_item->options[i].widget, True);
            } else {
                SetSensitive(type_item->options[i].widget, False);
            }
        }
tabMa->cmbType
*/
    for (int i=0;i<tabMa->number_of_Type_entries;i++)
    {
        if (p.type==tabMa->Type_entries[i])
        {
            tabMa->cmbType->setCurrentIndex(i);
            break;
        }
    }
    tabMa->cmbSymbColor->setCurrentIndex(p.sympen.color);
    tabMa->cmbSymbColor->setAlpha(p.sympen.alpha);
    tabMa->cmbSymbType->setCurrentIndex(p.sym);
    tabMa->sldSymbSize->setValue((int)rint_2(p.symsize*100.0));
    //qDebug() << "p.symsize=" << p.symsize << " sliderValue: " << (int)(p.symsize*100.0) << " rint2()=" << rint_2(p.symsize*100.0);
    //tabMa->ledSymbChar->setDoubleValue("%d",(int)p.symchar);
        if (tabMa->selSymbChar->valueIsInList(p.symchar)==FALSE)
        tabMa->selSymbChar->setCurrentValue(65);//revert the char to 'A', whenever the value is 0 (which is unprintable)
        else
        tabMa->selSymbChar->setCurrentValue(p.symchar);
    tabMa->SymbTypeChanged(p.sym);
    //sprintf(val, "%d", p.symchar);
    //tabMa->ledSymbChar->setText(QString(val));
    tabMa->cmbLineType->setCurrentIndex(p.linet);
    tabMa->cmbLineStyle->setCurrentIndex(p.lines);
    tabMa->cmbLineColor->setCurrentIndex(p.linepen.color);
    tabMa->cmbLineColor->setAlpha(p.linepen.alpha);
    tabMa->spnLineWidth->setValue(p.linew);
    //tabMa->ledString->setText(QString(p.lstr));
    tabMa->ledString->SetTextToMemory(g[graph_number].p[set_number].lstr,g[graph_number].p[set_number].orig_lstr);
    tabMa->chkAnnVal->setChecked(p.avalue.active);
    tabMa->chkDispErrBars->setChecked(p.errbar.active);
    tabMa->chkIgnoreInAutoscale->setChecked(p.ignore_in_autoscale);

    tabSy->spnSymbWidth->setValue(p.symlinew);
    tabSy->cmbSymbStyle->setCurrentIndex(p.symlines);
    tabSy->cmbSymbPattern->setCurrentIndex(p.sympen.pattern);
    tabSy->cmbFillColor->setCurrentIndex(p.symfillpen.color);
    tabSy->cmbFillColor->setAlpha(p.symfillpen.alpha);
    tabSy->cmbFillPattern->setCurrentIndex(p.symfillpen.pattern);
    tabSy->spnSymbSkip->setValue(p.symskip);
    tabSy->cmbSymbFont->setCurrentIndex(p.charfont);

    tabLi->cmbPattern->setCurrentIndex(p.linepen.pattern);
    tabLi->chkDrawDropLines->setChecked(p.dropline);
    tabLi->chkDrawLine->setChecked(p.baseline);
    tabLi->cmbBaseType->setCurrentIndex(p.baseline_type);
    tabLi->cmbType->setCurrentIndex(p.filltype);
    tabLi->cmbRule->setCurrentIndex(p.fillrule);
    tabLi->cmbFillPattern->setCurrentIndex(p.setfillpen.pattern);
    tabLi->cmbFillColor->setCurrentIndex(p.setfillpen.color);
    tabLi->cmbFillColor->setAlpha(p.setfillpen.alpha);
    tabLi->cmbSet->setValue(p.polygone_base_set);

    tabAnVa->cmbFont->setCurrentIndex(p.avalue.font);
    tabAnVa->sldFontSize->setValue((int)rint_2(p.avalue.size*100.0));
    tabAnVa->cmbColor->setCurrentIndex(p.avalue.color);
    tabAnVa->cmbColor->setAlpha(p.avalue.alpha);
    tabAnVa->sldFontAngle->setValue(p.avalue.angle);
    //tabAnVa->ledPrepend->setText(QString(p.avalue.prestr));
    //tabAnVa->ledAppend->setText(QString(p.avalue.appstr));
    tabAnVa->ledPrepend->SetTextToMemory(g[graph_number].p[set_number].avalue.prestr,g[graph_number].p[set_number].avalue.orig_prestr);
    tabAnVa->ledAppend->SetTextToMemory(g[graph_number].p[set_number].avalue.appstr,g[graph_number].p[set_number].avalue.orig_appstr);
    tabAnVa->cmbType->setCurrentIndex(p.avalue.type);
    tabAnVa->cmbPrecision->setCurrentIndex(p.avalue.prec);
    tabAnVa->cmbFormat->setCurrentIndex(p.avalue.format);
    tabAnVa->ledXOffs->setDoubleValue("%g", p.avalue.offset.x);
    tabAnVa->ledYOffs->setDoubleValue("%g", p.avalue.offset.y);
    //sprintf(val, "%f", p.avalue.offset.x);
    //tabAnVa->ledXOffs->setText(QString(val));
    //sprintf(val, "%f", p.avalue.offset.y);
    //tabAnVa->ledYOffs->setText(QString(val));
    tabErBa->cmbColor->setCurrentIndex(p.errbar.pen.color);
    tabErBa->cmbColor->setAlpha(p.errbar.pen.alpha);
    tabErBa->cmbPattern->setCurrentIndex(p.errbar.pen.pattern);
    tabErBa->chkArrowClip->setChecked(p.errbar.arrow_clip);
    tabErBa->chkShowInLegend->setChecked(p.errbar.show_in_legend);
    tabErBa->chkConnectErrorBars->setCurrentValue(p.errbar.connect_bars);
    tabErBa->spnMaxLength->setValue(p.errbar.cliplen);
    tabErBa->spnbarWidth->setValue(p.errbar.linew);
    tabErBa->cmbBarStyle->setCurrentIndex(p.errbar.lines);
    tabErBa->spnRiserWidth->setValue(p.errbar.riser_linew);
    tabErBa->cmbRiserStyle->setCurrentIndex(p.errbar.riser_lines);
    tabErBa->sldBarSize->setValue((int)rint_2(p.errbar.barsize*100.0));
    tabErBa->cmbPlacement->setCurrentIndex(p.errbar.ptype);
    ///SET ITEM 4 ENABLED OR NOT --> ITEM 4 IS "NULL" --> DON'T KNOW WHAT THIS IS FOR!?
    /*
        switch (p.type) {
        case SET_XYDXDX:
        case SET_XYDYDY:
        case SET_XYDXDXDYDY:
            SetSensitive(errbar_ptype_item[4], False);
            break;
        default:
            SetSensitive(errbar_ptype_item[4], True);
            break;
        }
*/
    updating=false;
}

void frmSet_Appearance::SyncColors(int val)
{
    if (updating==true || actcolorsync->isChecked()==FALSE) return;//Color Change is internal or no sync-ing intended
    tabMa->cmbSymbColor->setCurrentIndex(val);
    tabSy->cmbFillColor->setCurrentIndex(val);
    tabErBa->cmbColor->setCurrentIndex(val);
}

void frmSet_Appearance::SyncColors2(int val)
{
    if (updating==true || actcolorsync->isChecked()==FALSE) return;//Color Change is internal or no sync-ing intended
    tabSy->cmbFillColor->setCurrentIndex(val);
    tabErBa->cmbColor->setCurrentIndex(val);
}

void frmSet_Appearance::writeSetData(int graph_number,int set_number)
{
    char err_txt[512];
    if (graph_number<0 || graph_number>number_of_graphs())
    {
        sprintf(err_txt,"%s%d%s%d!",tr("Invalid Graph number: ").toLocal8Bit().constData(),graph_number,tr(", can't write to Set ").toLocal8Bit().constData(),set_number);
        errmsg(err_txt);
        return;
    }
    if (set_number<0 || set_number>=g[graph_number].maxplot)
    {
        sprintf(err_txt,"%s%d%s%d!",tr("Invalid Set number: ").toLocal8Bit().constData(),set_number,tr("; No such Set in Graph ").toLocal8Bit().constData(),graph_number);
        errmsg(err_txt);
        return;
    }
}

void frmSet_Appearance::setapp_data_proc(int dat)
{
    bool sav_imm_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    int proc_type;
    int *selset=new int[2], cd;
    int i, setno;
    int old_val,new_val;
    double d_old_val,d_new_val;
    char * old_comm=NULL,*new_comm=NULL,*tmp_po;
    plotarr p;
    int c = 0, bg = getbgcolor();
    
    proc_type = dat;
    int * gnos=NULL;
    int * snos=NULL;

    listSet->get_selection(&cd,&selset);

    if (cd < 1)
    {
        if (sav_imm_upd==false)
        errmsg(tr("No set selected").toLocal8Bit().constData());
        immediateUpdate=sav_imm_upd;
        updateRunning=false;
        return;
    }
    else
    {
        gnos=new int[cd+1];
        snos=new int[cd+1];
        for (i=0;i<cd;i++)
        {
            gnos[i]=listSet->gr_no;
            snos[i]=selset[i];
        }
        SaveSetStatesPrevious(cd,gnos,snos,UNDO_APPEARANCE);
        ListOfChanges.clear();
        ListOfOldStates.clear();
        sprintf(dummy,"with g%d",listSet->gr_no);
        ListOfChanges << QString(dummy);
        ListOfOldStates << QString(dummy);
        for(i = 0; i < cd; i++)
        {
            setno = selset[i];
            switch (proc_type)
            {
            case SETAPP_STRIP_LEGENDS:
                tmp_po=get_legend_string(cg, setno);
                if (old_comm!=NULL) delete[] old_comm;
                old_comm=new char[strlen(tmp_po)+2];
                strcpy(old_comm,tmp_po);
                    if (!strncpy(tmp_po,"binary import from: ",20))
                    {
                    if (new_comm!=NULL) delete[] new_comm;
                    new_comm=new char[strlen(tmp_po)];
                    strcpy(new_comm,tmp_po+20);
                    }
                    else
                    {
                    set_legend_string(cg, setno, mybasename(get_legend_string(cg, setno)));
                    tmp_po=get_legend_string(cg, setno);
                    if (new_comm!=NULL) delete[] new_comm;
                    new_comm=new char[strlen(tmp_po)+2];
                    strcpy(new_comm,tmp_po);
                    }
                sprintf(dummy,"    s%d legend  \"%s\"",setno,new_comm);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d legend  \"%s\"",setno,old_comm);
                ListOfOldStates << QString(dummy);
                break;
            case SETAPP_LOAD_COMMENTS:
                tmp_po=get_legend_string(cg, setno);
                if (old_comm!=NULL) delete[] old_comm;
                old_comm=new char[strlen(tmp_po)+2];
                strcpy(old_comm,tmp_po);
                load_comments_to_legend(cg, setno);
                tmp_po=get_legend_string(cg, setno);
                if (new_comm!=NULL) delete[] new_comm;
                new_comm=new char[strlen(tmp_po)+2];
                strcpy(new_comm,tmp_po);
                sprintf(dummy,"    s%d legend  \"%s\"",setno,new_comm);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d legend  \"%s\"",setno,old_comm);
                ListOfOldStates << QString(dummy);
                break;
            case SETAPP_ALL_COLORS:
                while (c == bg || get_colortype(c) != COLOR_MAIN)
                {
                    c++;
                    c %= number_of_colors();
                }
                sprintf(dummy,"    s%d line color %d",setno,g[cg].p[setno].linepen.color);
                ListOfOldStates << QString(dummy);
                sprintf(dummy,"    s%d symbol color %d",setno,g[cg].p[setno].sympen.color);
                ListOfOldStates << QString(dummy);
                sprintf(dummy,"    s%d symbol fill color %d",setno,g[cg].p[setno].symfillpen.color);
                ListOfOldStates << QString(dummy);
                sprintf(dummy,"    s%d errorbar color %d",setno,g[cg].p[setno].errbar.pen.color);
                ListOfOldStates << QString(dummy);
                set_set_colors(cg, setno, c);
                sprintf(dummy,"    s%d line color %d",setno,g[cg].p[setno].linepen.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d symbol color %d",setno,g[cg].p[setno].sympen.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d symbol fill color %d",setno,g[cg].p[setno].symfillpen.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d errorbar color %d",setno,g[cg].p[setno].errbar.pen.color);
                ListOfChanges << QString(dummy);
                c++;
                break;
            case SETAPP_ALL_SYMBOLS:
                get_graph_plotarr(cg, setno, &p);
                old_val=p.sym;
                p.sym = (i % (MAXSYM - 2)) + 1;
                new_val=p.sym;
                sprintf(dummy,"    s%d symbol %d",setno,new_val);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d symbol %d",setno,old_val);
                ListOfOldStates << QString(dummy);
                set_graph_plotarr(cg, setno, &p);
                break;
            case SETAPP_ALL_LINEW:
                get_graph_plotarr(cg, setno, &p);
                d_old_val=p.linew;
                p.linew = ((i % (2*((int) MAX_LINEWIDTH) - 1)) + 1)/2.0;
                d_new_val=p.linew;
                sprintf(dummy,"    s%d symbol linewidth %f",setno,d_new_val);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d symbol linewidth %f",setno,d_old_val);
                ListOfOldStates << QString(dummy);
                set_graph_plotarr(cg, setno, &p);
                break;
            case SETAPP_ALL_LINES:
                get_graph_plotarr(cg, setno, &p);
                old_val=p.lines;
                p.lines = (i % (number_of_linestyles() - 1)) + 1;
                new_val=p.lines;
                sprintf(dummy,"    s%d symbol linestyle %d",setno,old_val);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d symbol linestyle %d",setno,new_val);
                ListOfOldStates << QString(dummy);
                set_graph_plotarr(cg, setno, &p);
                break;
            case SETAPP_ALL_BW:
                sprintf(dummy,"    s%d line color %d",setno,g[cg].p[setno].linepen.color);
                ListOfOldStates << QString(dummy);
                sprintf(dummy,"    s%d symbol color %d",setno,g[cg].p[setno].sympen.color);
                ListOfOldStates << QString(dummy);
                sprintf(dummy,"    s%d symbol fill color %d",setno,g[cg].p[setno].symfillpen.color);
                ListOfOldStates << QString(dummy);
                sprintf(dummy,"    s%d errorbar color %d",setno,g[cg].p[setno].errbar.pen.color);
                ListOfOldStates << QString(dummy);
                set_set_colors(cg, setno, 1);
                sprintf(dummy,"    s%d line color %d",setno,g[cg].p[setno].linepen.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d symbol color %d",setno,g[cg].p[setno].sympen.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d symbol fill color %d",setno,g[cg].p[setno].symfillpen.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    s%d errorbar color %d",setno,g[cg].p[setno].errbar.pen.color);
                ListOfChanges << QString(dummy);
                break;
            }//end switch
        }//end for
        //qDebug() << "cg=" << cg << " cset=" << cset;
        showSetData(cg, cset);
        ///UpdateSymbols(cg, cset);
        set_dirtystate();
        //mainWin->mainArea->completeRedraw();
        force_redraw();
        SetsModified(cd,gnos,snos,UNDO_APPEARANCE);
    }//end if c>=1
    if (gnos!=NULL) delete[] gnos;
    if (snos!=NULL) delete[] snos;
    if (old_comm!=NULL) delete[] old_comm;
    if (new_comm!=NULL) delete[] new_comm;
    delete[] selset;
    immediateUpdate=sav_imm_upd;
    updateRunning=false;
}

void frmSet_Appearance::redisplayContents(void)
{
/*tabMa->spnLineWidth->blockSignals(true);
tabSy->spnSymbWidth->blockSignals(true);
tabAnVa->ledXOffs->blockSignals(true);
tabAnVa->ledYOffs->blockSignals(true);
tabErBa->spnMaxLength->blockSignals(true);
tabErBa->spnbarWidth->blockSignals(true);
tabErBa->spnRiserWidth->blockSignals(true);*/
    if (DecimalPointToUse=='.')
    {
        tabMa->spnLineWidth->spnLineWidth->setLocale(*dot_locale);
        tabSy->spnSymbWidth->spnLineWidth->setLocale(*dot_locale);
        tabErBa->spnMaxLength->spnLineWidth->setLocale(*dot_locale);
        tabErBa->spnbarWidth->spnLineWidth->setLocale(*dot_locale);
        tabErBa->spnRiserWidth->spnLineWidth->setLocale(*dot_locale);
    }
    else
    {
        tabMa->spnLineWidth->spnLineWidth->setLocale(*comma_locale);
        tabSy->spnSymbWidth->spnLineWidth->setLocale(*comma_locale);
        tabErBa->spnMaxLength->spnLineWidth->setLocale(*comma_locale);
        tabErBa->spnbarWidth->spnLineWidth->setLocale(*comma_locale);
        tabErBa->spnRiserWidth->spnLineWidth->setLocale(*comma_locale);
    }
if (OldDecimalPoint==DecimalPointToUse) return;
    tabMa->spnLineWidth->setValue(tabMa->spnLineWidth->value());
    tabSy->spnSymbWidth->setValue(tabSy->spnSymbWidth->value());
    tabAnVa->ledXOffs->ReplaceNumberContents();
    tabAnVa->ledYOffs->ReplaceNumberContents();
    tabErBa->spnMaxLength->setValue(tabErBa->spnMaxLength->value());
    tabErBa->spnbarWidth->setValue(tabErBa->spnbarWidth->value());
    tabErBa->spnRiserWidth->setValue(tabErBa->spnRiserWidth->value());
/*tabMa->spnLineWidth->blockSignals(false);
tabSy->spnSymbWidth->blockSignals(false);
tabAnVa->ledXOffs->blockSignals(false);
tabAnVa->ledYOffs->blockSignals(false);
tabErBa->spnMaxLength->blockSignals(false);
tabErBa->spnbarWidth->blockSignals(false);
tabErBa->spnRiserWidth->blockSignals(false);*/
}

dialogScrollArea::dialogScrollArea(QWidget * parent):QScrollArea(parent)
{
//nothing special here
}

void dialogScrollArea::keyPressEvent(QKeyEvent * k)
{
    switch (k->key())
    {
    case Qt::Key_Up:
    case Qt::Key_Down:
//qDebug() << "Parent KeyPressed=" << k->key();
        k->ignore();
        break;
    default:
//qDebug() << "Scroll Area KeyPressed=" << k->key();
        k->accept();
        QScrollArea::keyPressEvent(k);
        break;
    }
}

frmSetAppearance::frmSetAppearance(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    min_w=502;
    min_h=600;
    bar_w=bar_h=20;//15
    setWindowTitle(tr("QtGrace: Set Appearance"));
    setWindowIcon(QIcon(*GraceIcon));
    QVBoxLayout * layout=new QVBoxLayout;
    layout->setMargin(0);
    layout->setSpacing(0);
    flp=new frmSet_Appearance(this);
    connect(flp,SIGNAL(closeWish()),SLOT(close()));
    layout->addWidget(flp->menuBar);
    //layout->addWidget(flp);
    scroll=new dialogScrollArea(this);
    scroll->setWidget(flp);
    layout->addWidget(scroll);
    listSet=flp->listSet;
    setLayout(layout);
    //resize(min_w,min_h);
    resize(LastSize_FormSetAppearance);
}

frmSetAppearance::~frmSetAppearance()
{
    LastSize_FormSetAppearance=this->size();
}

void frmSetAppearance::init(void)
{
    flp->init();
}

void frmSetAppearance::ShowSetData_external(int graph_number,int set_number)
{
    flp->ShowSetData_external(graph_number,set_number);
}

void frmSetAppearance::doApply(void)
{
    flp->doApply();
}

void frmSetAppearance::doAccept(void)
{
    flp->doAccept();
}

void frmSetAppearance::doClose(void)
{
    hide();
}

void frmSetAppearance::resizeEvent(QResizeEvent * event)
{
//cout << "resize: " << event->size().width() << "x" << event->size().height() << " bar_w=" << bar_w << " bar_h=" << bar_h << endl;

int n_size_w=event->size().width(),n_size_h=event->size().height();
int actual_space_w=n_size_w,actual_space_h=n_size_h;
if (small_screen_adjustments & 2)
{
    for (int i=0;i<2;i++)
    {
        if (actual_space_w<min_w)
        {
            n_size_w=min_w;
            actual_space_h=event->size().height()-bar_h;
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
        if (actual_space_h<min_h)
        {
            n_size_h=min_h;
            actual_space_w=event->size().width()-bar_w;
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
    }
if (scroll->verticalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_w-=bar_w;
if (scroll->horizontalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_h-=bar_h;
#if defined(WINDOWS_SYSTEM) || defined(LINUX_SYSTEM)
n_size_h-=flp->menuBar->height();
#endif
setMinimumSize(0,0);
}
else
{
scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
setMinimumSize(min_w,min_h);
}
flp->resize(QSize(n_size_w,n_size_h));
}

void frmSetAppearance::showEvent(QShowEvent * event)
{
    (void)event;
int * selected=new int[2];
int nr_sel=0;
flp->listSet->get_selection(&nr_sel,&selected);
if (nr_sel<1)
{
flp->listSet->set_graph_number(cg,false);
//cout << "no set selected" << endl;
    if (number_of_sets(cg)>0)
    {
    delete[] selected;
    selected=new int[2];
    selected[0]=selected[1]=first_set(cg,1,0);
    ShowSetData_external(cg,selected[0]);
    //cout << "selecting G[" << cg << "].S[" << selected[0] << "]" << endl;
    }
}
delete[] selected;
}

GrTabMain::GrTabMain(QWidget * parent):QWidget(parent)
{
    int number=7;
    QString types[7];
    types[0]=tr("XY graph");
    types[1]=tr("XY chart");
    types[2]=tr("Polar graph");
    types[3]=tr("Smith chart (N/I)");
    types[4]=tr("Fixed");
    types[5]=tr("Pie chart");
    types[6]=tr("Polar graph v2");

    grpPres=new QGroupBox(tr("Presentation"),this);
    grpTitles=new QGroupBox(tr("Titles"),this);
    grpViewport=new QGroupBox(tr("Viewport"),this);
    grpDispOpt=new QGroupBox(tr("Display options"),this);

    selType=new StdSelector(grpPres,tr("Type:"),number,types);
    connect(selType,SIGNAL(currentIndexChanged(int)),SLOT(serviceGrTypeSel(int)));
    chkStackChart=new QCheckBox(tr("Stacked chart"),grpPres);
    selphi0=new stdLineEdit(this,tr("Angle for phi=0:"));
    selphi0->setToolTip(tr("Set the position of the phi=0-line (X=0) relative to the 3 o'clock-position in rad."));
    selphi0->setVisible(false);
    selroffset=new LineWidthSelector(this);
    selroffset->lblText->setText(tr("Radius-offset (percentage):"));
    selroffset->spnLineWidth->setDecimals(2);
    selroffset->spnLineWidth->setSingleStep(0.1);
    selroffset->spnLineWidth->setRange(0.0,1.0);
    selroffset->setToolTip(tr("Define the size of the region from -infinity to Ymin."));
    selroffset->setVisible(false);

    ledTitle=new stdLineEdit(grpTitles,tr("Title:"),true);
    ledTitle->setText("");
    ledSubtitle=new stdLineEdit(grpTitles,tr("Subtitle:"),true);
    ledSubtitle->setText("");

    ledCoords[0]=new stdLineEdit(grpTitles,tr("Xmin:"));
    ledCoords[1]=new stdLineEdit(grpTitles,tr("Xmax:"));
    ledCoords[2]=new stdLineEdit(grpTitles,tr("Ymin:"));
    ledCoords[3]=new stdLineEdit(grpTitles,tr("Ymax:"));

    chkDisplLegend=new QCheckBox(tr("Display legend"),grpDispOpt);
    chkDisplLegend->setChecked(TRUE);
    chkFlipXY=new QCheckBox(tr("Flip XY (N/I)"),grpDispOpt);

    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    layout1->addWidget(selType,0,0);
    layout1->addWidget(chkStackChart,0,1);
    layout1->addWidget(selphi0,1,0);
    layout1->addWidget(selroffset,1,1);
    grpPres->setLayout(layout1);

    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(ledTitle);
    layout2->addWidget(ledSubtitle);
    grpTitles->setLayout(layout2);

    layout3=new QGridLayout;
    layout3->setMargin(STD_MARGIN);
    layout3->addWidget(ledCoords[0],0,0);
    layout3->addWidget(ledCoords[1],0,1);
    layout3->addWidget(ledCoords[2],1,0);
    layout3->addWidget(ledCoords[3],1,1);
    grpViewport->setLayout(layout3);

    layout4=new QHBoxLayout;
    layout4->setMargin(STD_MARGIN);
    layout4->addWidget(chkDisplLegend);
    layout4->addWidget(chkFlipXY);
    grpDispOpt->setLayout(layout4);

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpPres);
    layout->addWidget(grpTitles);
    layout->addWidget(grpViewport);
    layout->addWidget(grpDispOpt);
    setLayout(layout);
}

void GrTabMain::serviceGrTypeSel(int nr)
{
    if (nr==6)
    {
        selphi0->setVisible(true);
        selroffset->setVisible(true);
    }
    else
    {
        selphi0->setVisible(false);
        selroffset->setVisible(false);
    }
}

GrTabTitles::GrTabTitles(QWidget * parent):QWidget(parent)
{
    grpTitle=new QGroupBox(tr("Title"),this);
    grpSubTitle=new QGroupBox(tr("Subtitle"),this);

    selTitleFont=new FontSelector(grpTitle);
    sldTitleCharSize=new stdSlider(grpTitle,tr("Character size"),0,1000);
    sldTitleCharSize->setValue(150);
    selTitleColor=new ColorSelector(grpTitle);
    selTitleColor->setCurrentIndex(1);
    ledTitleShiftX=new stdLineEdit(this,tr("X-shift="));
    ledTitleShiftY=new stdLineEdit(this,tr("Y-shift="));

    selSubFont=new FontSelector(grpSubTitle);
    sldSubCharSize=new stdSlider(grpSubTitle,tr("Character size"),0,1000);
    sldSubCharSize->setValue(100);
    selSubColor=new ColorSelector(grpSubTitle);
    selSubColor->setCurrentIndex(1);
    ledSubTitleShiftX=new stdLineEdit(this,tr("X-shift="));
    ledSubTitleShiftY=new stdLineEdit(this,tr("Y-shift="));

    QWidget * emptyArea=new QWidget();
    emptyArea->setMaximumHeight(40);
    layout1=new QGridLayout;
    layout1->setSpacing(STD_SPACING);
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(selTitleFont,0,0,1,2);
    layout1->addWidget(sldTitleCharSize,1,0,1,2);
    layout1->addWidget(selTitleColor,2,0,1,2);
    layout1->addWidget(ledTitleShiftX,3,0,1,1);
    layout1->addWidget(ledTitleShiftY,3,1,1,1);
    grpTitle->setLayout(layout1);
    layout2=new QGridLayout;
    layout2->setSpacing(STD_SPACING);
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selSubFont,0,0,1,2);
    layout2->addWidget(sldSubCharSize,1,0,1,2);
    layout2->addWidget(selSubColor,2,0,1,2);
    layout2->addWidget(ledSubTitleShiftX,3,0,1,1);
    layout2->addWidget(ledSubTitleShiftY,3,1,1,1);
    grpSubTitle->setLayout(layout2);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpTitle);
    layout->addWidget(grpSubTitle);
    layout->addWidget(emptyArea);
    layout->setStretch(0,1);
    layout->setStretch(1,1);
    layout->setStretch(2,2);
    setLayout(layout);
}

GrTabFrame::GrTabFrame(QWidget * parent):QWidget(parent)
{
    int number=6;
    QString types[6];
    types[0]=tr("Closed");
    types[1]=tr("Half open");
    types[2]=tr("Break top");
    types[3]=tr("Break bottom");
    types[4]=tr("Break left");
    types[5]=tr("Break right");
    grpFrameBox=new QGroupBox(tr("Frame box"),this);
    grpFrameFill=new QGroupBox(tr("Frame fill"),this);

    selFrameType=new StdSelector(grpFrameBox,tr("Frame type:"),number,types);
    selBoxColor=new ColorSelector(grpFrameBox);
    selFrameBoxPattern=new FillPatternSelector(grpFrameBox);
    selFrameBoxPattern->lblText->setText(tr("Pattern:"));
    selFrameBoxWidth=new LineWidthSelector(grpFrameBox);
    selFrameBoxWidth->lblText->setText(tr("Width:"));
    selFrameBoxStyle=new LineStyleSelector(grpFrameBox);
    selFrameBoxStyle->lblText->setText(tr("Style:"));

    selFillColor=new ColorSelector(grpFrameFill);
    selFrameFillPattern=new FillPatternSelector(grpFrameFill);
    selFrameFillPattern->lblText->setText(tr("Pattern:"));

    emptyArea=new QWidget(this);
    emptyArea->setMinimumHeight(120);

    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(selFrameType,0,0,1,2);
    layout1->addWidget(selBoxColor,1,0);
    layout1->addWidget(selFrameBoxPattern,1,1);
    layout1->addWidget(selFrameBoxWidth,2,0);
    layout1->addWidget(selFrameBoxStyle,2,1);
    grpFrameBox->setLayout(layout1);
    layout2=new QHBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selFillColor);
    layout2->addWidget(selFrameFillPattern);
    grpFrameFill->setLayout(layout2);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpFrameBox);
    layout->addWidget(grpFrameFill);
    layout->addWidget(emptyArea);
    layout->setStretch(0,1);
    layout->setStretch(1,1);
    layout->setStretch(2,2);
    setLayout(layout);

    selFillColor->setCurrentIndex(0);
    selBoxColor->setCurrentIndex(1);
    selFrameBoxWidth->setValue(1.0);
    selFrameBoxPattern->setCurrentIndex(1);
    selFrameBoxStyle->setCurrentIndex(1);
}

GrTabLegBox::GrTabLegBox(QWidget * parent):QWidget(parent)
{
    grpLocation=new QGroupBox(tr("Location"),this);
    grpFrameLine=new QGroupBox(tr("Frame line"),this);
    grpFrameFill=new QGroupBox(tr("Frame fill"),this);

    selLoc=new PositionSelector(grpLocation);
    selLoc->lblText->setText(tr("Locate in:"));
    ledX=new stdLineEdit(grpLocation,QString("X:"));
    ledY=new stdLineEdit(grpLocation,QString("Y:"));

    int nr=9;
    QString entries[9];
    int * i_entries=new int[9];
    entries[0]=QString("None");
    i_entries[0]=G_LB_ATTACH_NONE;
    entries[1]=QString("Left");
    i_entries[1]=G_LB_ATTACH_LEFT;
    entries[2]=QString("Right");
    i_entries[2]=G_LB_ATTACH_RIGHT;
    entries[3]=QString("Top");
    i_entries[3]=G_LB_ATTACH_TOP;
    entries[4]=QString("Bottom");
    i_entries[4]=G_LB_ATTACH_BOTTOM;
    entries[5]=QString("Left+Top");
    i_entries[5]=G_LB_ATTACH_LEFT | G_LB_ATTACH_TOP;
    entries[6]=QString("Left+Bottom");
    i_entries[6]=G_LB_ATTACH_LEFT | G_LB_ATTACH_BOTTOM;
    entries[7]=QString("Right+Top");
    i_entries[7]=G_LB_ATTACH_RIGHT | G_LB_ATTACH_TOP;
    entries[8]=QString("Right+Bottom");
    i_entries[8]=G_LB_ATTACH_RIGHT | G_LB_ATTACH_BOTTOM;
    selLegBoxAttachement=new StdSelector(this,tr("Auto-attach to:"),nr,entries);
    selLegBoxAttachement->setValues(i_entries);
    connect(selLegBoxAttachement,SIGNAL(currentIndexChanged(int)),SLOT(autoAttachChanged(int)));
    delete[] i_entries;

    cmdAttachLeft=new QPushButton(tr("Left"),this);
    connect(cmdAttachLeft,SIGNAL(clicked()),SLOT(doAttachLeft()));
    cmdAttachTop=new QPushButton(tr("Top"),this);
    connect(cmdAttachTop,SIGNAL(clicked()),SLOT(doAttachTop()));
    cmdAttachRight=new QPushButton(tr("Right"),this);
    connect(cmdAttachRight,SIGNAL(clicked()),SLOT(doAttachRight()));
    cmdAttachBottom=new QPushButton(tr("Bottom"),this);
    connect(cmdAttachBottom,SIGNAL(clicked()),SLOT(doAttachBottom()));
#ifdef MAC_SYSTEM
    QString mac_symb_cmd(0x2318);
    QString ti=tr("Move Legend (") + mac_symb_cmd + QString("+L)");
    cmdMoveLegend=new QPushButton(ti,this);
#else
    cmdMoveLegend=new QPushButton(tr("Move Legend (crtl+L)"),this);
#endif
    connect(cmdMoveLegend,SIGNAL(clicked()),SLOT(doMoveLegend()));

    selFrameLineColor=new ColorSelector(grpFrameLine);
    selFrameLinePattern=new FillPatternSelector(grpFrameLine);
    selFrameLinePattern->lblText->setText(tr("Pattern:"));
    selFrameLineWidth=new LineWidthSelector(grpFrameLine);
    selFrameLineWidth->lblText->setText(tr("Width:"));
    selFrameLineStyle=new LineStyleSelector(grpFrameLine);
    selFrameLineStyle->lblText->setText(tr("Style:"));

    selFrameFillColor=new ColorSelector(grpFrameFill);
    selFrameFillPattern=new FillPatternSelector(grpFrameFill);
    selFrameFillPattern->lblText->setText(tr("Pattern:"));

    emptyArea=new QWidget(this);
    emptyArea->setMinimumHeight(30);

    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(0);
    layout1->addWidget(selLoc,0,0,1,2);
    layout1->addWidget(ledX,1,0);
    layout1->addWidget(ledY,1,1);
    layout1->addWidget(selLegBoxAttachement,2,0,1,2);
    layout1->addWidget(cmdAttachLeft,3,0,1,1);
    layout1->addWidget(cmdAttachRight,3,1,1,1);
    layout1->addWidget(cmdAttachTop,4,0,1,1);
    layout1->addWidget(cmdAttachBottom,4,1,1,1);
    layout1->addWidget(cmdMoveLegend,5,0,1,2);
    grpLocation->setLayout(layout1);

    layout2=new QGridLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selFrameLineColor,0,0);
    layout2->addWidget(selFrameLinePattern,0,1);
    layout2->addWidget(selFrameLineWidth,1,0);
    layout2->addWidget(selFrameLineStyle,1,1);
    grpFrameLine->setLayout(layout2);
    layout3=new QHBoxLayout;
    layout3->setMargin(STD_MARGIN);
    layout3->addWidget(selFrameFillColor);
    layout3->addWidget(selFrameFillPattern);
    grpFrameFill->setLayout(layout3);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpLocation);
    layout->addWidget(grpFrameLine);
    layout->addWidget(grpFrameFill);
    layout->addWidget(emptyArea);
    setLayout(layout);

    selLoc->setCurrentIndex(1);
    selFrameLineColor->setCurrentIndex(1);
    selFrameLinePattern->setCurrentIndex(1);
    selFrameLineStyle->setCurrentIndex(1);
    selFrameFillPattern->setCurrentIndex(1);
    selFrameLineWidth->setValue(1.0);
    connect(selLoc->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(viewCoordsChanged(int)));
}

void GrTabLegBox::viewCoordsChanged(int index)
{
int new_coords;
double ox,oy,nx,ny;
if (index==0) new_coords = COORD_WORLD;
else new_coords = COORD_VIEW;
ox=ledX->getDoubleValue();
oy=ledY->getDoubleValue();
    if( new_coords == COORD_WORLD )//new is world --> convert from viewport to world
    {
    view2world(ox,oy,&nx,&ny);
    }
    else// from world to viewport
    {
    world2view(ox,oy,&nx,&ny);
    }
ledX->setDoubleValue(sformat,nx);
ledY->setDoubleValue(sformat,ny);
}

void GrTabLegBox::autoAttachChanged(int index)
{
    (void)index;
int sel_val=selLegBoxAttachement->currentValue();
selLoc->setEnabled(true);
    if (sel_val==G_LB_ATTACH_NONE)//enable all
    {
        ledY->setEnabled(true);
        ledX->setEnabled(true);
        cmdAttachLeft->setEnabled(true);
        cmdAttachTop->setEnabled(true);
        cmdAttachRight->setEnabled(true);
        cmdAttachBottom->setEnabled(true);
        cmdMoveLegend->setEnabled(true);
    }
    else // some selections are useless
    {
        if (((sel_val & G_LB_ATTACH_LEFT) != 0) || ((sel_val & G_LB_ATTACH_RIGHT) != 0))
        {
        ledX->setEnabled(false);
        cmdAttachLeft->setEnabled(false);
        cmdAttachRight->setEnabled(false);
        }
        else
        {
        ledX->setEnabled(true);
        cmdAttachLeft->setEnabled(true);
        cmdAttachRight->setEnabled(true);
        }
        if (((sel_val & G_LB_ATTACH_TOP) != 0) || ((sel_val & G_LB_ATTACH_BOTTOM) != 0))
        {
        ledY->setEnabled(false);
        cmdAttachTop->setEnabled(false);
        cmdAttachBottom->setEnabled(false);
        }
        else
        {
        ledY->setEnabled(true);
        cmdAttachTop->setEnabled(true);
        cmdAttachBottom->setEnabled(true);
        }
        if (sel_val!=G_LB_ATTACH_LEFT && sel_val!=G_LB_ATTACH_RIGHT && sel_val!=G_LB_ATTACH_TOP && sel_val!=G_LB_ATTACH_BOTTOM)
        cmdMoveLegend->setEnabled(false);
        else
        cmdMoveLegend->setEnabled(true);
        /*cmdMoveLegend->setEnabled(false);*/
    }
}

void GrTabLegBox::doAttachLeft(void)
{
//cout << "attaching Legend to Left" << endl;
if (selLoc->currentIndex()!=1) selLoc->setCurrentIndex(1);//always change to viewport
double nx,ny;
position_leg_box(get_cg(),get_cg(),G_LB_ATTACH_LEFT,&nx,&ny);
ledX->setDoubleValue(sformat,nx);
emit(doApply());
}

void GrTabLegBox::doAttachTop(void)
{
//cout << "attaching Legend to Top" << endl;
if (selLoc->currentIndex()!=1) selLoc->setCurrentIndex(1);//always change to viewport
double nx,ny;
position_leg_box(get_cg(),get_cg(),G_LB_ATTACH_TOP,&nx,&ny);
ledY->setDoubleValue(sformat,ny);
emit(doApply());
}

void GrTabLegBox::doAttachBottom(void)
{
//cout << "attaching Legend to Bottom" << endl;
if (selLoc->currentIndex()!=1) selLoc->setCurrentIndex(1);//always change to viewport
double nx,ny;
position_leg_box(get_cg(),get_cg(),G_LB_ATTACH_BOTTOM,&nx,&ny);
ledY->setDoubleValue(sformat,ny);
emit(doApply());
}

void GrTabLegBox::doAttachRight(void)
{
//cout << "attaching Legend to Right" << endl;
if (selLoc->currentIndex()!=1) selLoc->setCurrentIndex(1);//always change to viewport
double nx,ny;
position_leg_box(get_cg(),get_cg(),G_LB_ATTACH_RIGHT,&nx,&ny);
ledX->setDoubleValue(sformat,nx);
emit(doApply());
}

void GrTabLegBox::doMoveLegend(void)
{
set_action(DO_NOTHING);
set_action(PLACE_LEGEND_1ST);
}

GrTabLegends::GrTabLegends(QWidget * parent):QWidget(parent)
{
    int number=1;
    char dummy[3];
    QString entries[10];
    for (int i=0;i<10;i++)
    {
        sprintf(dummy,"%d",i);
        entries[i]=QString(dummy);
    }

    grpTextProp=new QGroupBox(tr("Text properties"),this);
    grpPlacement=new QGroupBox(tr("Placement"),this);

    selTextFont=new FontSelector(grpTextProp);
    sldTextSize=new stdSlider(grpTextProp,tr("Char size"),0,1000);
    sldTextSize->setValue(100);
    selTextColor=new ColorSelector(grpTextProp);

    number=6;
    selVGap=new StdSelector(grpPlacement,tr("V-gap:"),number,entries);
    selHGap=new StdSelector(grpPlacement,tr("H-gap:"),number,entries);
    number=9;
    selLineLength=new StdSelector(grpPlacement,tr("Legend line length:"),number,entries);
    chkPutRevOrder=new QCheckBox(tr("Put in reverse order"),grpPlacement);

    emptyArea=new QWidget(this);
    emptyArea->setMinimumHeight(20);

    layout1=new QVBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(selTextFont);
    layout1->addWidget(sldTextSize);
    layout1->addWidget(selTextColor);
    grpTextProp->setLayout(layout1);
    layout2=new QGridLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selVGap,0,0);
    layout2->addWidget(selHGap,0,1);
    layout2->addWidget(selLineLength,1,0,1,2);
    layout2->addWidget(chkPutRevOrder,2,0,1,2);
    grpPlacement->setLayout(layout2);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpTextProp);
    layout->addWidget(grpPlacement);
    layout->addWidget(emptyArea);
    layout->setStretch(0,1);
    layout->setStretch(1,1);
    layout->setStretch(2,4);
    setLayout(layout);

    selVGap->setCurrentIndex(1);
    selHGap->setCurrentIndex(1);
    selLineLength->setCurrentIndex(4);
    selTextColor->setCurrentIndex(1);
}

GrTabSpecial::GrTabSpecial(QWidget * parent):QWidget(parent)
{
    grp2Dplusgraphs=new QGroupBox(tr("2D+ graphs"),this);
    grpXYcharts=new QGroupBox(tr("XY charts"),this);

    ledZnormal=new stdLineEdit(grp2Dplusgraphs,tr("Z normalization:"));
    ledZnormal->lenText->setText(QString("1"));
    selBarGap=new LineWidthSelector(grpXYcharts);
    selBarGap->lblText->setText(tr("Bar gap:"));
    selBarGap->spnLineWidth->setRange(-1.0,1.0);
    selBarGap->spnLineWidth->setDecimals(3);
    selBarGap->spnLineWidth->setSingleStep(0.005);

    emptyArea=new QWidget(this);
    emptyArea->setMinimumHeight(220);

    layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(ledZnormal);
    grp2Dplusgraphs->setLayout(layout1);
    layout2=new QHBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selBarGap);
    grpXYcharts->setLayout(layout2);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grp2Dplusgraphs);
    layout->addWidget(grpXYcharts);
    layout->addWidget(emptyArea);
    setLayout(layout);
}

frmGraph_App::frmGraph_App(QWidget * parent):QWidget(parent)
{
    frmOpenPara=NULL;
    frmSavePara=NULL;
    //setFont(*stdFont);
    //setWindowTitle(tr("QtGrace: Graph Appearance"));
    //setWindowIcon(QIcon(*GraceIcon));
    CreateActions();

    menuBar=new QMenuBar(this);
    mnuFile=new QMenu(tr("&File"));
    mnuFile->setTearOffEnabled(TRUE);
    mnuFile->addAction(actOpen);
    mnuFile->addAction(actSave);
    mnuFile->addSeparator();
    mnuFile->addAction(actClose);
    mnuEdit=new QMenu(tr("&Edit"));
    mnuEdit->setTearOffEnabled(TRUE);
    mnuEdit->addAction(actFocusTo);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actHide);
    mnuEdit->addAction(actShow);
    mnuEdit->addAction(actDuplicate);
    mnuEdit->addAction(actKill);
    mnuEdit->addSeparator();
    mnuEdit->addAction(actCreateNew);
    mnuHelp=new QMenu(tr("&Help"));
    mnuHelp->setTearOffEnabled(TRUE);
    mnuHelp->addAction(actHelpOnContext);
    mnuHelp->addSeparator();
    mnuHelp->addAction(actHelpGraphApp);

    menuBar->addMenu(mnuFile);
    menuBar->addMenu(mnuEdit);
    menuBar->addSeparator();
    menuBar->addMenu(mnuHelp);
    lblTitle=new QLabel(tr("Graph:"),this);
    listGraph=new uniList(GRAPHLIST,this);
    listGraph->setMaximumHeight(100);
    connect(listGraph,SIGNAL(new_selection(int)),SLOT(newSelection(int)));

    tabs=new QTabWidget(this);
    tabMain=new GrTabMain(tabs);
    tabTitles=new GrTabTitles(tabs);
    tabFrame=new GrTabFrame(tabs);
    tabLegBox=new GrTabLegBox(tabs);
    tabLegends=new GrTabLegends(tabs);
    tabSpec=new GrTabSpecial(tabs);
    tabs->addTab(tabMain, tr("Main"));
    tabs->addTab(tabTitles, tr("Titles"));
    tabs->addTab(tabFrame, tr("Frame"));
    tabs->addTab(tabLegBox, tr("Leg. box"));
    tabs->addTab(tabLegends, tr("Legends"));
    tabs->addTab(tabSpec, tr("Special"));

    buttonGroup=new stdButtonGroup(this,true,true,false);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    connect(tabLegBox,SIGNAL(doApply()),this,SLOT(doApply()));
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
#ifndef MAC_SYSTEM
    layout->addWidget(menuBar);
#endif
    layout->addWidget(lblTitle);
    layout->addWidget(listGraph);
    layout->addWidget(tabs);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    //immediate updates stuff
    connect(tabMain->selType,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMain->chkStackChart,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabMain->ledTitle->lenText,SIGNAL(returnPressed()),SLOT(update0()));
    connect(tabMain->ledSubtitle->lenText,SIGNAL(returnPressed()),SLOT(update0()));
    for (int i=0;i<4;i++)
        connect(tabMain->ledCoords[i]->lenText,SIGNAL(returnPressed()),SLOT(update0()));
    connect(tabMain->chkDisplLegend,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabMain->chkFlipXY,SIGNAL(toggled(bool)),SLOT(update3(bool)));

    connect(tabTitles->selTitleFont,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTitles->sldTitleCharSize,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabTitles->selTitleColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTitles->selTitleColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabTitles->selSubFont,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTitles->sldSubCharSize,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabTitles->selSubColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTitles->selSubColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));

    connect(tabFrame->selFrameType,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabFrame->selBoxColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabFrame->selBoxColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabFrame->selFrameBoxPattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabFrame->selFrameBoxWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(tabFrame->selFrameBoxStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabFrame->selFillColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabFrame->selFillColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabFrame->selFrameFillPattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));

    connect(tabLegBox->selLoc->cmbPositionSelect,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegBox->ledX->lenText,SIGNAL(returnPressed()),SLOT(update0()));
    connect(tabLegBox->ledY->lenText,SIGNAL(returnPressed()),SLOT(update0()));
    connect(tabLegBox->selFrameLineColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegBox->selFrameLineColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabLegBox->selFrameLinePattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegBox->selFrameLineWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(tabLegBox->selFrameLineStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegBox->selFrameFillColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegBox->selFrameFillColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabLegBox->selFrameFillPattern,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));

    connect(tabLegends->selTextFont,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegends->sldTextSize,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabLegends->selTextColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegends->selTextColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabLegends->selVGap,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegends->selHGap,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegends->selLineLength,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLegends->chkPutRevOrder,SIGNAL(toggled(bool)),SLOT(update3(bool)));

    connect(tabSpec->ledZnormal->lenText,SIGNAL(returnPressed()),SLOT(update0()));
    connect(tabSpec->selBarGap,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));

    setMinimumWidth(480);
    //end immediate updates stuff
    init();
}

void frmGraph_App::newSelection(int i)
{
    (void)i;
int sel=1,*selection=new int[2];
listGraph->get_selection(&sel,&selection);
update_graphapp_items(sel,selection);
    /*if (i<=0)
    switch_current_graph(0);
    else
    switch_current_graph(i);*/
if (sel>0)
    if (selection[0]!=get_cg()) switch_current_graph(selection[0]);
delete[] selection;
}

frmGraph_App::~frmGraph_App()
{}

void frmGraph_App::init(void)
{
    listGraph->update_number_of_entries();
    int n=1;
    int values[2]={0,0};

    int sel=1,*selection=new int[2];
    values[0]=selection[0]=get_cg();
    listGraph->set_new_selection(sel,selection);

    update_graphapp_items(n,values);
    delete[] selection;
}

void frmGraph_App::CreateActions(void)
{
    actClose = new QAction(tr("&Close"), this);
    actClose->setShortcut(tr("Esc"));
    actClose->setStatusTip(tr("Close this Window"));
    connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
    actOpen= new QAction(tr("&Open..."), this);
    actOpen->setShortcut(tr("Ctrl+O"));
    connect(actOpen, SIGNAL(triggered()), this, SLOT(doOpen()));
    actSave= new QAction(tr("&Save"), this);
    actSave->setShortcut(tr("Ctrl+S"));
    connect(actSave, SIGNAL(triggered()), this, SLOT(doSave()));
    actHelpOnContext= new QAction(tr("On conte&xt"), this);
    actHelpOnContext->setShortcut(tr("Shift+F1"));
    connect(actHelpOnContext, SIGNAL(triggered()), this, SLOT(doHelpOnContext()));
    actHelpGraphApp= new QAction(tr("On &graph appearance"), this);
    connect(actHelpGraphApp, SIGNAL(triggered()), this, SLOT(doHelpGraphApp()));
    actFocusTo= new QAction(tr("&Focus to"), this);
    connect(actFocusTo, SIGNAL(triggered()), this, SLOT(doFocus()));
    actDuplicate= new QAction(tr("&Duplicate"), this);
    connect(actDuplicate, SIGNAL(triggered()), this, SLOT(doDuplicate()));
    actCreateNew= new QAction(tr("&Create new"), this);
    connect(actCreateNew, SIGNAL(triggered()), this, SLOT(doCreateNew()));
    actShow= new QAction(tr("&Show"), this);
    connect(actShow, SIGNAL(triggered()), this, SLOT(doShow()));
    actHide= new QAction(tr("&Hide"), this);
    connect(actHide, SIGNAL(triggered()), this, SLOT(doHide()));
    actKill= new QAction(tr("&Kill"), this);
    connect(actKill, SIGNAL(triggered()), this, SLOT(doKill()));
}

void frmGraph_App::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmGraph_App::doClose(void)
{
//parentWidget()->hide();
    emit(closeWish());
}

void frmGraph_App::doApply(void)
{
    (void)graphapp_aac_cb();
}

void frmGraph_App::doOpen(void)
{
if (should_open_grace_file_dialog())
{
    if (frmOpenPara==NULL)
    {
        frmOpenPara=new frmIOForm(READ_PARAMETERS,this);
        connect(frmOpenPara,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    frmOpenPara->init();
    frmOpenPara->show();
    frmOpenPara->raise();
}
else
{
mainWin->UseOperatingSystemFileDialog(READ_PARAMETERS,tr("QtGrace: Read parameters"),Last_Dialog_Path[READ_PARAMETERS],tr("Parameter files (*.par);;All files (*)"));
}
}

void frmGraph_App::doSave(void)
{
if (should_open_grace_file_dialog())
{
    if (frmSavePara==NULL)
    {
        frmSavePara=new frmIOForm(WRITE_PARAMETERS,this);
        connect(frmSavePara,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    frmSavePara->init();
    frmSavePara->show();
    frmSavePara->raise();
}
else
{
mainWin->UseOperatingSystemFileDialog(WRITE_PARAMETERS,tr("QtGrace: Write parameters"),Last_Dialog_Path[WRITE_PARAMETERS],tr("Parameter files (*.par);;All files (*)"));
}
}

void frmGraph_App::doHelpOnContext(void)
{
    mainWin->setCursor(QCursor(Qt::WhatsThisCursor));
}

void frmGraph_App::doHelpGraphApp(void)
{
    HelpCB("doc/UsersGuide.html#graph-appearance");
}

void frmGraph_App::doPrepare(void)
{
    listGraph->get_selection(&listGraph->popupMenu2->number_of_selected_graphs,&listGraph->popupMenu2->selected_graphs);
    sort(listGraph->popupMenu2->number_of_selected_graphs,listGraph->popupMenu2->selected_graphs);
    listGraph->popupMenu2->update_menu_content();
}

void frmGraph_App::doHide(void)
{
    doPrepare();
    listGraph->popupMenu2->doHide();
}

void frmGraph_App::doShow(void)
{
    doPrepare();
    listGraph->popupMenu2->doShow();
}

void frmGraph_App::doKill(void)
{
    doPrepare();
    listGraph->popupMenu2->doKill();
}

void frmGraph_App::doDuplicate(void)
{
    doPrepare();
    listGraph->popupMenu2->doDuplicate();
}

void frmGraph_App::doFocus(void)
{
    doPrepare();
    if (listGraph->popupMenu2->number_of_selected_graphs==1)
    {
        listGraph->popupMenu2->selected_no=listGraph->popupMenu2->selected_graphs[0];
        listGraph->popupMenu2->doFocusTo();
    }
}

void frmGraph_App::doCreateNew(void)
{
    doPrepare();
    listGraph->popupMenu2->doCreateNew();
}

int frmGraph_App::graphapp_aac_cb(void)
{
    ApplyError=false;
    char dummy[MAX_STRING_LENGTH];
    int j, gno, n, *values=new int[5];
    view v,v2;
    labels labs;
    labels labs2;
    framep f,f2;
    legend l,l2;
    int graphtype;
    int stacked;
    double bargap;
    double znorm;
    int flipxy;
    double new_roffset,new_phi0;
/*    char buf[1024];

 *     int flipxy;
 */
    graphtype = tabMain->selType->currentIndex();//GetChoice(graph_type_choice_item);
    /*v.xv1=atof(tabMain->ledCoords[0]->text().toLocal8Bit());
v.xv2=atof(tabMain->ledCoords[1]->text().toLocal8Bit());
v.yv1=atof(tabMain->ledCoords[2]->text().toLocal8Bit());
v.yv2=atof(tabMain->ledCoords[3]->text().toLocal8Bit());*/

    xv_evalexpr(tabMain->ledCoords[0], &v.xv1);
    xv_evalexpr(tabMain->ledCoords[1], &v.xv2);
    xv_evalexpr(tabMain->ledCoords[2], &v.yv1);
    xv_evalexpr(tabMain->ledCoords[3], &v.yv2);
    if (isvalid_viewport(v) == FALSE)
    {
        errmsg(tr("Invalid viewport coordinates").toLocal8Bit().constData());
        ApplyError=true;
        return RETURN_FAILURE;
    }

    set_default_string(&labs.title);
    //set_plotstr_string(&labs.title, GetTextString(label_title_text_item));

    tabMain->ledTitle->DynSetMemoryToText(labs.title.s_plotstring,labs.title.alt_plotstring);
    //strcpy(buf,tabMain->ledTitle->text().toLocal8Bit());
    //set_plotstr_string(&labs.title,buf);
    ///setting plotstring

    labs.title.charsize = tabTitles->sldTitleCharSize->value()/100.0;//GetCharSizeChoice(title_size_item);
    labs.title.color = tabTitles->selTitleColor->currentIndex();//GetOptionChoice(title_color_item);
    labs.title.alpha = tabTitles->selTitleColor->alpha();
    labs.title.font = tabTitles->selTitleFont->currentIndex();//GetOptionChoice(title_font_item);

    xv_evalexpr(tabTitles->ledTitleShiftX,&(labs.shift_title.x));
    xv_evalexpr(tabTitles->ledTitleShiftY,&(labs.shift_title.y));
    xv_evalexpr(tabTitles->ledSubTitleShiftX,&(labs.shift_subtitle.x));
    xv_evalexpr(tabTitles->ledSubTitleShiftY,&(labs.shift_subtitle.y));

    set_default_string(&labs.stitle);
    //set_plotstr_string(&labs.stitle, GetTextString(label_subtitle_text_item));

    tabMain->ledSubtitle->DynSetMemoryToText(labs.stitle.s_plotstring,labs.stitle.alt_plotstring);
    //strcpy(buf,tabMain->ledSubtitle->text().toLocal8Bit());
    //set_plotstr_string(&labs.stitle,buf);
    ///setting plotstring

    labs.stitle.charsize = tabTitles->sldSubCharSize->value()/100.0;//GetCharSizeChoice(stitle_size_item);
    labs.stitle.color = tabTitles->selSubColor->currentIndex();//GetOptionChoice(stitle_color_item);
    labs.stitle.alpha = tabTitles->selSubColor->alpha();
    labs.stitle.font = tabTitles->selSubFont->currentIndex();//GetOptionChoice(stitle_font_item);

    f.type = tabFrame->selFrameType->currentIndex();//GetChoice(frame_framestyle_choice_item);
    f.pen.color = tabFrame->selBoxColor->currentIndex();//GetOptionChoice(frame_color_choice_item);
    f.pen.alpha = tabFrame->selBoxColor->alpha();
    f.pen.pattern = tabFrame->selFrameBoxPattern->currentIndex();//GetOptionChoice(frame_pattern_choice_item);
    f.linew = tabFrame->selFrameBoxWidth->value();//GetSpinChoice(frame_linew_choice_item);
    f.lines = tabFrame->selFrameBoxStyle->currentIndex();//GetOptionChoice(frame_lines_choice_item);
    f.fillpen.color = tabFrame->selFillColor->currentIndex();//GetOptionChoice(frame_fillcolor_choice_item);
    f.fillpen.alpha = tabFrame->selFillColor->alpha();
    f.fillpen.pattern = tabFrame->selFrameFillPattern->currentIndex();//GetOptionChoice(frame_fillpattern_choice_item);

    l.charsize = tabLegends->sldTextSize->value()/100.0;//GetCharSizeChoice(legend_charsize_item);
    l.active = (int)tabMain->chkDisplLegend->isChecked();//GetToggleButtonState(toggle_legends_item);
    l.vgap = tabLegends->selVGap->currentIndex();//GetChoice(legends_vgap_item);
    l.hgap = tabLegends->selHGap->currentIndex();//GetChoice(legends_hgap_item);
    l.len = tabLegends->selLineLength->currentIndex();//GetChoice(legends_len_item);
    l.invert = (int)tabLegends->chkPutRevOrder->isChecked();//GetToggleButtonState(legends_invert_item);
    l.loctype = tabLegBox->selLoc->currentIndex()==1? COORD_VIEW : COORD_WORLD;//GetChoice(toggle_legendloc_item)
    xv_evalexpr(tabLegBox->ledX, &l.legx);
    xv_evalexpr(tabLegBox->ledY, &l.legy);
    l.autoattach=tabLegBox->selLegBoxAttachement->currentValue();
    if (l.autoattach!=G_LB_ATTACH_NONE) set_action(DO_NOTHING);
    /*l.legx=atof(tabLegBox->ledX->text().toLocal8Bit());
    l.legy=atof(tabLegBox->ledY->text().toLocal8Bit());*/
    l.font = tabLegends->selTextFont->currentIndex();//GetOptionChoice(legend_font_item);
    l.color = tabLegends->selTextColor->currentIndex();//GetOptionChoice(legend_color_item);
    l.alpha = tabLegends->selTextColor->alpha();
    l.boxfillpen.color = tabLegBox->selFrameFillColor->currentIndex();//GetOptionChoice(legend_boxfillcolor_item);
    l.boxfillpen.alpha = tabLegBox->selFrameFillColor->alpha();
    l.boxfillpen.pattern = tabLegBox->selFrameFillPattern->currentIndex();//GetOptionChoice(legend_boxfillpat_item);
    l.boxpen.color = tabLegBox->selFrameLineColor->currentIndex();//GetOptionChoice(legend_boxcolor_item);
    l.boxpen.alpha = tabLegBox->selFrameLineColor->alpha();
    l.boxpen.pattern = tabLegBox->selFrameLinePattern->currentIndex();//GetOptionChoice(legend_boxpattern_item);
    l.boxlinew = tabLegBox->selFrameLineWidth->value();//GetSpinChoice(legend_boxlinew_item);
    l.boxlines = tabLegBox->selFrameLineStyle->currentIndex();//GetOptionChoice(legend_boxlines_item);

    stacked = (bool)tabMain->chkStackChart->isChecked();//GetToggleButtonState(stacked_item);
    bargap = tabSpec->selBarGap->value();//GetSpinChoice(bargap_item);

    xv_evalexpr(tabSpec->ledZnormal, &znorm);
    flipxy = (int)tabMain->chkFlipXY->isChecked();

/*
 *     flipxy = GetToggleButtonState(graph_flipxy_item);
 */

    //n = GetListChoices(graph_selector, &values);
    listGraph->get_selection(&n,&values);

    if (n<=0)
    {
    errmsg(tr("No graph selected!").toLocal8Bit().constData());
    ApplyError=true;
    return RETURN_FAILURE;
    }

    if (GlobalInhibitor==false)
        SaveGraphStatesPrevious(n,values,UNDO_APPEARANCE);

    ListOfChanges.clear();
    ListOfOldStates.clear();

    get_graph_viewport(values[0],&v2);
    get_graph_legend(values[0],&l2);
    get_graph_labels(values[0],&labs2);
    get_graph_framep(values[0],&f2);

    xv_evalexpr(tabMain->selphi0, &new_phi0);
    new_roffset=tabMain->selroffset->value();

    if (graphtype!=g[values[0]].type)
    {
        sprintf(dummy,"g%d type %s",values[0],graph_types(graphtype));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"g%d type %s",values[0],graph_types(g[values[0]].type));
        ListOfOldStates << QString(dummy);
    }
    if (stacked!=g[values[0]].stacked)
    {
        sprintf(dummy,"g%d stacked %s",values[0],stacked?"true":"false");
        ListOfChanges << QString(dummy);
        sprintf(dummy,"g%d stacked %s",values[0],g[values[0]].stacked?"true":"false");
        ListOfOldStates << QString(dummy);
    }
    if (bargap!=g[values[0]].bargap)
    {
        sprintf(dummy,"g%d bar hgap %f",values[0],bargap);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"g%d bar hgap %f",values[0],g[values[0]].bargap);
        ListOfOldStates << QString(dummy);
    }

    sprintf(dummy,"with g%d",values[0]);
    ListOfChanges << QString(dummy);
    ListOfOldStates << QString(dummy);

    if (znorm!=g[values[0]].znorm)
    {
        sprintf(dummy,"    znorm %f",znorm);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    znorm %f",g[values[0]].znorm);
        ListOfOldStates << QString(dummy);
    }
    if (v.xv1 != v2.xv1 || v.xv2 != v2.xv2 || v.yv1 != v2.yv1 || v.yv2 != v2.yv2)//v2==original
    {
        sprintf(dummy,"    view %f, %f, %f, %f",v.xv1,v.yv1,v.xv2,v.yv2);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    view %f, %f, %f, %f",v2.xv1,v2.yv1,v2.xv2,v2.yv2);
        ListOfOldStates << QString(dummy);
    }
    if (labs.stitle.charsize!=labs2.stitle.charsize)
    {
        sprintf(dummy,"    subtitle size %f",labs.stitle.charsize);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    subtitle size %f",labs2.stitle.charsize);
        ListOfOldStates << QString(dummy);
    }
    if (labs.stitle.font!=labs2.stitle.font)
    {
        sprintf(dummy,"    subtitle font %d",labs.stitle.font);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    subtitle font %d",labs2.stitle.font);
        ListOfOldStates << QString(dummy);
    }
    if (labs.stitle.color!=labs2.stitle.color)
    {
        sprintf(dummy,"    subtitle color %d",labs.stitle.color);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    subtitle color %d",labs2.stitle.color);
        ListOfOldStates << QString(dummy);
    }
    if (labs.title.charsize!=labs2.title.charsize)
    {
        sprintf(dummy,"    title size %f",labs.title.charsize);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    title size %f",labs2.title.charsize);
        ListOfOldStates << QString(dummy);
    }
    if (labs.title.font!=labs2.title.font)
    {
        sprintf(dummy,"    title font %d",labs.title.font);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    title font %d",labs2.title.font);
        ListOfOldStates << QString(dummy);
    }
    if (labs.title.color!=labs2.title.color)
    {
        sprintf(dummy,"    title color %d",labs.title.color);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    title color %d",labs2.title.color);
        ListOfOldStates << QString(dummy);
    }
    if (!(labs.title.s_plotstring==NULL && labs2.title.s_plotstring==NULL))
        if ((labs.title.s_plotstring!=NULL && labs2.title.s_plotstring==NULL) || (labs.title.s_plotstring==NULL && labs2.title.s_plotstring!=NULL) || strcmp(labs.title.s_plotstring,labs2.title.s_plotstring))
        {
            sprintf(dummy,"    title \"%s\"",labs.title.s_plotstring);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    title \"%s\"",labs2.title.s_plotstring);
            ListOfOldStates << QString(dummy);
        }
    if (!(labs.stitle.s_plotstring==NULL && labs2.stitle.s_plotstring==NULL))
        if ((labs.stitle.s_plotstring!=NULL && labs2.stitle.s_plotstring==NULL) || (labs.stitle.s_plotstring==NULL && labs2.stitle.s_plotstring!=NULL) || strcmp(labs.stitle.s_plotstring,labs2.stitle.s_plotstring))
        {
            sprintf(dummy,"    subtitle \"%s\"",labs.stitle.s_plotstring);
            ListOfChanges << QString(dummy);
            sprintf(dummy,"    subtitle \"%s\"",labs2.stitle.s_plotstring);
            ListOfOldStates << QString(dummy);
        }
    if (f.type!=f2.type)
    {
        sprintf(dummy,"    frame type %d",f.type);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    frame type %d",f2.type);
        ListOfOldStates << QString(dummy);
    }
    if (f.pen.color!=f2.pen.color)
    {
        sprintf(dummy,"    frame color %d",f.pen.color);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    frame color %d",f2.pen.color);
        ListOfOldStates << QString(dummy);
    }
    if (f.pen.pattern!=f2.pen.pattern)
    {
        sprintf(dummy,"    frame pattern %d",f.pen.pattern);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    frame pattern %d",f2.pen.pattern);
        ListOfOldStates << QString(dummy);
    }
    if (f.linew!=f2.linew)
    {
        sprintf(dummy,"    frame linewidth %f",f.linew);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    frame linewidth %f",f2.linew);
        ListOfOldStates << QString(dummy);
    }
    if (f.lines!=f2.lines)
    {
        sprintf(dummy,"    frame linestyle %d",f.lines);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    frame linestyle %d",f2.lines);
        ListOfOldStates << QString(dummy);
    }
    if (f.fillpen.color!=f2.fillpen.color)
    {
        sprintf(dummy,"    frame background color %d",f.fillpen.color);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    frame background color %d",f2.fillpen.color);
        ListOfOldStates << QString(dummy);
    }
    if (f.fillpen.pattern!=f2.fillpen.pattern)
    {
        sprintf(dummy,"    frame background pattern %d",f.fillpen.pattern);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    frame background pattern %d",f2.fillpen.pattern);
        ListOfOldStates << QString(dummy);
    }
    if (l.charsize!=l2.charsize)
    {
        sprintf(dummy,"    legend char size %f",l.charsize);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend char size %f",l2.charsize);
        ListOfOldStates << QString(dummy);
    }
    if (l.active!=l2.active)
    {
        sprintf(dummy,"    legend %s",l.active?"on":"off");
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend %s",l2.active?"on":"off");
        ListOfOldStates << QString(dummy);
    }
    if (l.vgap!=l2.vgap)
    {
        sprintf(dummy,"    legend vgap %d",l.vgap);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend vgap %d",l2.vgap);
        ListOfOldStates << QString(dummy);
    }
    if (l.hgap!=l2.hgap)
    {
        sprintf(dummy,"    legend hgap %d",l.hgap);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend hgap %d",l2.hgap);
        ListOfOldStates << QString(dummy);
    }
    if (l.len!=l2.len)
    {
        sprintf(dummy,"    legend length %d",l.len);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend length %d",l2.len);
        ListOfOldStates << QString(dummy);
    }
    if (l.invert!=l2.invert)
    {
        sprintf(dummy,"    legend invert %s",l.invert?"true":"false");
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend invert %s",l2.invert?"true":"false");
        ListOfOldStates << QString(dummy);
    }
    if (l.loctype!=l2.loctype)
    {
        sprintf(dummy,"    legend loctype %s",l.loctype?"world":"view");
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend loctype %s",l2.loctype?"world":"view");
        ListOfOldStates << QString(dummy);
    }
    if (l.legx!=l2.legx || l.legy!=l2.legy)
    {
        sprintf(dummy,"    legend %f, %f",l.legx,l.legy);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend %f, %f",l2.legx,l2.legy);
        ListOfOldStates << QString(dummy);
    }
    if (l.font!=l2.font)
    {
        sprintf(dummy,"    legend font %d",l.font);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend font %d",l2.font);
        ListOfOldStates << QString(dummy);
    }
    if (l.color!=l2.color)
    {
        sprintf(dummy,"    legend color %d",l.color);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend color %d",l2.color);
        ListOfOldStates << QString(dummy);
    }
    if (l.boxfillpen.color!=l2.boxfillpen.color)
    {
        sprintf(dummy,"    legend box fill color %d",l.boxfillpen.color);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend box fill color %d",l2.boxfillpen.color);
        ListOfOldStates << QString(dummy);
    }
    if (l.boxfillpen.pattern!=l2.boxfillpen.pattern)
    {
        sprintf(dummy,"    legend box fill pattern %d",l.boxfillpen.pattern);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend box fill pattern %d",l2.boxfillpen.pattern);
        ListOfOldStates << QString(dummy);
    }
    if (l.boxpen.color!=l2.boxpen.color)
    {
        sprintf(dummy,"    legend box color %d",l.boxpen.color);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend box color %d",l2.boxpen.color);
        ListOfOldStates << QString(dummy);
    }
    if (l.boxpen.pattern!=l2.boxpen.pattern)
    {
        sprintf(dummy,"    legend box pattern %d",l.boxpen.pattern);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend box pattern %d",l2.boxpen.pattern);
        ListOfOldStates << QString(dummy);
    }
    if (l.boxlinew!=l2.boxlinew)
    {
        sprintf(dummy,"    legend box linewidth %f",l.boxlinew);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend box linewidth %f",l2.boxlinew);
        ListOfOldStates << QString(dummy);
    }
    if (l.boxlines!=l2.boxlines)
    {
        sprintf(dummy,"    legend box linestyle %d",l.boxlines);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"    legend box linestyle %d",l2.boxlines);
        ListOfOldStates << QString(dummy);
    }
    if (labs.shift_title.x!=labs2.shift_title.x || labs.shift_title.y!=labs2.shift_title.y)
    {
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: TITLE_SHIFT G %d %g %g\n",values[0],labs.shift_title.x,labs.shift_title.y);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: TITLE_SHIFT G %d %g %g\n",values[0],labs2.shift_title.x,labs2.shift_title.y);
        ListOfOldStates << QString(dummy);
    }
    if (labs.shift_subtitle.x!=labs2.shift_subtitle.x || labs.shift_subtitle.y!=labs2.shift_subtitle.y)
    {
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: SUBTITLE_SHIFT G %d %g %g\n",values[0],labs.shift_subtitle.x,labs.shift_subtitle.y);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: SUBTITLE_SHIFT G %d %g %g\n",values[0],labs2.shift_subtitle.x,labs2.shift_subtitle.y);
        ListOfOldStates << QString(dummy);
    }
    if (g[values[0]].phi0!=new_phi0 || g[values[0]].roffset!=new_roffset)
    {
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: POLAR_V2 G %d %g %g\n",values[0],new_phi0,new_roffset);
        ListOfChanges << QString(dummy);
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: POLAR_V2 G %d %g %g\n",values[0],g[values[0]].phi0,g[values[0]].roffset);
        ListOfOldStates << QString(dummy);
    }
    if (labs.title.alpha != labs2.title.alpha || labs.stitle.alpha != labs2.stitle.alpha || f.pen.alpha != f2.pen.alpha || f.fillpen.alpha != f2.fillpen.alpha || l.alpha != l2.alpha || l.boxpen.alpha != l2.boxpen.alpha || l.boxfillpen.alpha != l2.boxfillpen.alpha)
    {
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: GRAPH_ALPHA G %d %s\n",values[0],create_list_of_arguments(7, labs.title.alpha,labs.stitle.alpha,f.pen.alpha,f.fillpen.alpha,l.alpha,l.boxpen.alpha,l.boxfillpen.alpha));
        ListOfChanges << QString(dummy);
        sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: GRAPH_ALPHA G %d %s\n",values[0],create_list_of_arguments(7, labs2.title.alpha,labs2.stitle.alpha,f2.pen.alpha,f2.fillpen.alpha,l2.alpha,l2.boxpen.alpha,l2.boxfillpen.alpha));
        ListOfOldStates << QString(dummy);
    }
    /*
for (int i=0;i<ListOfChanges.size();i++)
cout << ListOfChanges.at(i).toLocal8Bit().constData() << endl;
*/
/*///I think is command is here a second time - should only be once
    for (j = 0; j < n; j++)
        set_graph_labels(values[j], &labs);//title and subtitle
*/
    if (GlobalInhibitor==false)
    {
        for (j = 0; j < n; j++)
        {
            gno = values[j];
            if (is_valid_gno(gno))
            {
                set_graph_type(gno, graphtype);
                set_graph_stacked(gno, stacked);
                set_graph_bargap(gno, bargap);
                set_graph_znorm(gno, znorm);
                set_graph_viewport(gno, v);
                set_graph_labels(gno, &labs);
                set_graph_framep(gno, &f);
                l.autoattachG=gno;
                set_graph_legend(gno, &l);
                g[gno].xyflip = flipxy;
                g[gno].phi0=new_phi0;
                g[gno].roffset=new_roffset;
/*
 *             g[gno].xyflip = flipxy;
 */
            }
        }
        GraphsModified(n,values,UNDO_APPEARANCE);
        ListOfChanges.clear();
        ListOfOldStates.clear();
        mainWin->mainArea->completeRedraw();
    }
    delete[] values;
    return RETURN_SUCCESS;
}

void frmGraph_App::redisplayContents(void)
{
    if (DecimalPointToUse=='.')
    {
        tabSpec->selBarGap->spnLineWidth->setLocale(*dot_locale);
        tabFrame->selFrameBoxWidth->spnLineWidth->setLocale(*dot_locale);
        tabLegBox->selFrameLineWidth->spnLineWidth->setLocale(*dot_locale);
        tabMain->selroffset->spnLineWidth->setLocale(*dot_locale);
    }
    else
    {
        tabSpec->selBarGap->spnLineWidth->setLocale(*comma_locale);
        tabFrame->selFrameBoxWidth->spnLineWidth->setLocale(*comma_locale);
        tabLegBox->selFrameLineWidth->spnLineWidth->setLocale(*comma_locale);
        tabMain->selroffset->spnLineWidth->setLocale(*comma_locale);
    }
    if (OldDecimalPoint==DecimalPointToUse) return;
    tabMain->selphi0->ReplaceNumberContents();
    for (int i=0;i<4;i++)
        tabMain->ledCoords[i]->ReplaceNumberContents();
    tabFrame->selFrameBoxWidth->setValue(tabFrame->selFrameBoxWidth->value());
    tabLegBox->ledX->ReplaceNumberContents();
    tabLegBox->ledY->ReplaceNumberContents();
    tabLegBox->selFrameLineWidth->setValue(tabLegBox->selFrameLineWidth->value());
    tabSpec->ledZnormal->ReplaceNumberContents();
    tabSpec->selBarGap->setValue(tabSpec->selBarGap->value());
}

void frmGraph_App::update_graphapp_items(int n, int *values)
{
    bool sav_imm_upd=immediateUpdate;
    int gno;
    labels labs;
    
    if (n != 1)
    {
        return;
    }
    else
    {
        gno = values[0];
    }

    if (is_valid_gno(gno) != TRUE)
    {
        return;
    }

    immediateUpdate=false;
    updateRunning=true;

    redisplayContents();//to switch the decimal point (if necessary)

    update_view(gno);
    update_frame_items(gno);
    updatelegends(gno);
    get_graph_labels(gno, &labs);

    tabMain->selType->setCurrentIndex(get_graph_type(gno));
    tabMain->selphi0->setDoubleValue(g[gno].phi0);
    tabMain->selroffset->setValue(g[gno].roffset);
    tabSpec->selBarGap->setValue(get_graph_bargap(gno));
    tabMain->chkStackChart->setChecked((bool)is_graph_stacked(gno));
    tabSpec->ledZnormal->setDoubleValue("%g",get_graph_znorm(gno));
    tabMain->ledTitle->SetTextToMemory(g[gno].labs.title.s_plotstring,g[gno].labs.title.alt_plotstring);
    tabMain->ledSubtitle->SetTextToMemory(g[gno].labs.stitle.s_plotstring,g[gno].labs.stitle.alt_plotstring);
    tabTitles->sldTitleCharSize->setValue((int)rint_2(labs.title.charsize*100.0));
    tabTitles->sldSubCharSize->setValue((int)rint_2(labs.stitle.charsize*100.0));
    tabTitles->selTitleColor->setCurrentIndex(labs.title.color);
    tabTitles->selSubColor->setCurrentIndex(labs.stitle.color);
    tabTitles->selTitleColor->setAlpha(labs.title.alpha);
    tabTitles->selSubColor->setAlpha(labs.stitle.alpha);
    tabTitles->selTitleFont->setCurrentIndex(labs.title.font);
    tabTitles->selSubFont->setCurrentIndex(labs.stitle.font);
    tabTitles->ledTitleShiftX->setDoubleValue(labs.shift_title.x);
    tabTitles->ledTitleShiftY->setDoubleValue(labs.shift_title.y);
    tabTitles->ledSubTitleShiftX->setDoubleValue(labs.shift_subtitle.x);
    tabTitles->ledSubTitleShiftY->setDoubleValue(labs.shift_subtitle.y);
    tabMain->chkFlipXY->setChecked(bool(g[gno].xyflip));
/*
 *         SetToggleButtonState(graph_flipxy_item, g[gno].xyflip);
 */
    immediateUpdate=sav_imm_upd;
    updateRunning=false;
}

/*
 * Viewport update
 */
void frmGraph_App::update_view(int gno)
{
    view v;
    get_graph_viewport(gno, &v);
    tabMain->ledCoords[0]->setDoubleValue("%.9g",v.xv1);
    tabMain->ledCoords[1]->setDoubleValue("%.9g",v.xv2);
    tabMain->ledCoords[2]->setDoubleValue("%.9g",v.yv1);
    tabMain->ledCoords[3]->setDoubleValue("%.9g",v.yv2);
}

/*
 * legend popup
 */
void frmGraph_App::updatelegends(int gno)
{
    legend l;
    get_graph_legend(gno, &l);
    tabLegends->sldTextSize->setValue((int)rint_2(l.charsize*100.0));
    tabMain->chkDisplLegend->setChecked(l.active);
    tabLegBox->ledX->setDoubleValue("%.9g",l.legx);
    //sprintf(buf, "%.9g", l.legx);
    //tabLegBox->ledX->setText(QString(buf));
    //xv_setstr(legend_x_item, buf);
    tabLegBox->ledY->setDoubleValue("%.9g",l.legy);
    //sprintf(buf, "%.9g", l.legy);
    //tabLegBox->ledY->setText(QString(buf));
    //xv_setstr(legend_y_item, buf);
    tabLegBox->selLegBoxAttachement->setCurrentValue(l.autoattach);
    tabLegends->selVGap->setCurrentIndex(l.vgap);
    tabLegends->selHGap->setCurrentIndex(l.hgap);
    tabLegends->selLineLength->setCurrentIndex(l.len);
    tabLegends->chkPutRevOrder->setChecked(bool(l.invert));
    tabLegBox->selLoc->setCurrentIndex(!l.loctype);
    tabLegends->selTextFont->setCurrentIndex(l.font);
    tabLegends->selTextColor->setCurrentIndex(l.color);
    tabLegends->selTextColor->setAlpha(l.alpha);
    tabLegBox->selFrameLineColor->setCurrentIndex(l.boxpen.color);
    tabLegBox->selFrameLineColor->setAlpha(l.boxpen.alpha);
    tabLegBox->selFrameLinePattern->setCurrentIndex(l.boxpen.pattern);
    tabLegBox->selFrameLineWidth->setValue(l.boxlinew);
    tabLegBox->selFrameLineStyle->setCurrentIndex(l.boxlines);
    tabLegBox->selFrameFillColor->setCurrentIndex(l.boxfillpen.color);
    tabLegBox->selFrameFillColor->setAlpha(l.boxfillpen.alpha);
    tabLegBox->selFrameFillPattern->setCurrentIndex(l.boxfillpen.pattern);
}

void frmGraph_App::update_frame_items(int gno)
{
    framep f;
    get_graph_framep(gno, &f);
    tabFrame->selFrameType->setCurrentIndex(f.type);
    tabFrame->selBoxColor->setCurrentIndex(f.pen.color);
    tabFrame->selBoxColor->setAlpha(f.pen.alpha);
    tabFrame->selFrameBoxPattern->setCurrentIndex(f.pen.pattern);
    tabFrame->selFrameBoxWidth->setValue(f.linew);
    tabFrame->selFrameBoxStyle->setCurrentIndex(f.lines);
    tabFrame->selFillColor->setCurrentIndex(f.fillpen.color);
    tabFrame->selFillColor->setAlpha(f.fillpen.alpha);
    tabFrame->selFrameFillPattern->setCurrentIndex(f.fillpen.pattern);
}

void frmGraph_App::show_graph_data_external(int n_gno)
{
int number=1;
int * sel=new int[2];
int old_gno;
    listGraph->get_selection(&number,&sel);
    if (number<1) old_gno=-100;
    else old_gno=sel[0];
        if (sel) delete[] sel;
if (old_gno==n_gno)//already selected (somehow)
{
listGraph->new_selection();//force a redisplay
}
else//set new selection --> will automatically force a redisplay
{
sel=new int[2];
sel[0]=n_gno;
number=1;
    listGraph->set_new_selection(number,sel);
if (sel) delete[] sel;
}

}

void frmGraph_App::IOrequested(int type,QString file,bool exists,bool writeable,bool readable)
{
    char filename[512];
    (void)exists;
    (void)writeable;
    (void)readable;
    strcpy(filename,file.toLocal8Bit());
    if (type==READ_PARAMETERS)
    {
        getparms(filename);
        if (frmOpenPara)
        frmOpenPara->hide();
        mainWin->mainArea->completeRedraw();
    }
    else if (type==WRITE_PARAMETERS)
    {
        int gno;
        FILE *pp;
        if (!frmSavePara)
        {
            gno = ALL_GRAPHS;
        }
        else
        {
            if (GetChoice(frmSavePara->selParamGraph) == 0) {
            gno = get_cg();
            } else {
            gno = ALL_GRAPHS;
            }
        }
        if (frmSavePara)
        frmSavePara->hide();
        pp = grace_openw(filename);
        if (pp != NULL) {
            putparms(gno, pp, 0);
            grace_close(pp);
        }
    }
}

void frmGraph_App::update0(void)
{
    static int i,nr;//,errpos;
    bool imm_upd_sav;
    if (!immediateUpdate) return;
    imm_upd_sav=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    GlobalInhibitor=true;
    (void)graphapp_aac_cb();//do this without actually doing something
    nr=nr_of_true_changes(ListOfChanges);
    //errpos=0;
    if (nr>0)
    {
        for (i=0;i<ListOfChanges.size();i++)
        {
            strcpy(command,ListOfChanges.at(i).toLocal8Bit().constData());
            //errpos = scanner(command);
            if (command[0]=='#')
            parse_qtGrace_Additions(command);
            else
            (void)scanner(command);
        }
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
    }
    ListOfChanges.clear();
    ListOfOldStates.clear();
    GlobalInhibitor=false;
    immediateUpdate=imm_upd_sav;
    updateRunning=false;
}

void frmGraph_App::update1(int v)
{
    (void)v;
    update0();
}

void frmGraph_App::update2(QString v)
{
    (void)v;
    update0();
}

void frmGraph_App::update3(bool v)
{
    (void)v;
    update0();
}

void frmGraph_App::update4(double v)
{
    (void)v;
    update0();
}

frmGraphApp::frmGraphApp(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    min_w=484;
    min_h=594;
    bar_w=bar_h=20;//15
    setWindowTitle(tr("QtGrace: Graph Appearance"));
    setWindowIcon(QIcon(*GraceIcon));
    QVBoxLayout * layout=new QVBoxLayout;
    layout->setMargin(0);
    layout->setSpacing(0);
    flp=new frmGraph_App(this);
    connect(flp,SIGNAL(closeWish()),SLOT(close()));
    layout->addWidget(flp->menuBar);
    //layout->addWidget(flp);
    scroll=new dialogScrollArea(this);
    scroll->setWidget(flp);
    layout->addWidget(scroll);
    listGraph=flp->listGraph;
    setLayout(layout);
    //resize(min_w,min_h);
    resize(LastSize_FormGraphAppearance);
}

frmGraphApp::~frmGraphApp()
{
    LastSize_FormGraphAppearance=this->size();
}

void frmGraphApp::init(void)
{
    flp->init();
}

void frmGraphApp::show_graph_data_external(int n_gno)
{
    flp->show_graph_data_external(n_gno);
}

void frmGraphApp::update_view(int gno)
{
    flp->update_view(gno);
}

void frmGraphApp::updatelegends(int gno)
{
    flp->updatelegends(gno);
}

void frmGraphApp::doApply(void)
{
    flp->doApply();
}

void frmGraphApp::doAccept(void)
{
    flp->doAccept();
}

void frmGraphApp::doClose(void)
{
    hide();
}

void frmGraphApp::resizeEvent(QResizeEvent * event)
{
//cout << "resize: " << event->size().width() << "x" << event->size().height() << " bar_w=" << bar_w << " bar_h=" << bar_h << endl;
int n_size_w=event->size().width(),n_size_h=event->size().height();
int actual_space_w=n_size_w,actual_space_h=n_size_h;
if (small_screen_adjustments & 2)
{
    for (int i=0;i<2;i++)
    {
        if (actual_space_w<min_w)
        {
            n_size_w=min_w;
            actual_space_h=event->size().height()-bar_h;
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
        if (actual_space_h<min_h)
        {
            n_size_h=min_h;
            actual_space_w=event->size().width()-bar_w;
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
            scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
    }
if (scroll->verticalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_w-=bar_w;
if (scroll->horizontalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_h-=bar_h;
#if defined(WINDOWS_SYSTEM) || defined(LINUX_SYSTEM)
n_size_h-=flp->menuBar->height();
#endif
setMinimumSize(0,0);
}
else
{
scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
setMinimumSize(min_w,min_h);
}
flp->resize(QSize(n_size_w,n_size_h));
}

AxisTabMain::AxisTabMain(QWidget * parent):QWidget(parent)
{
    int number;
    char dummy[10];
    QString * entr=new QString[NUM_FMT_OPTION_ITEMS+2];
    grpAxisLabel=new QGroupBox(tr("Axis label"),this);
    ledAxisLabel=new stdLineEdit(grpAxisLabel,tr("Label string:"),true);
    layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(ledAxisLabel);
    grpAxisLabel->setLayout(layout0);

    grpTickProp=new QGroupBox(tr("Tick properties"),this);
    ledMajorSpacing=new stdLineEdit(grpTickProp,tr("Major spacing:"));
    selMinTicks=new stdIntSelector(grpTickProp,tr("Minor ticks:"),0,MAX_TICKS - 1);
    number=NUM_FMT_OPTION_ITEMS;
    for (int i=0;i<number;i++)
    {
        entr[i]=QString(fmt_option_items[i].label);
    }
    selFormat=new StdSelector(grpTickProp,tr("Format:"),number,entr);
    number=10;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i]=QString(dummy);
    }
    selPrecision=new StdSelector(grpTickProp,tr("Precision:"),number,entr);
    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(ledMajorSpacing,0,0);
    layout1->addWidget(selMinTicks,0,1);
    layout1->addWidget(selFormat,1,0);
    layout1->addWidget(selPrecision,1,1);
    grpTickProp->setLayout(layout1);

    grpDisplOpt=new QGroupBox(tr("Display options"),this);
    chkDisplTickLabels=new QCheckBox(tr("Display tick labels"),grpDisplOpt);
    chkDisplAxixBar=new QCheckBox(tr("Display axis bar"),grpDisplOpt);
    chkDisplTickMarks=new QCheckBox(tr("Display tick marks"),grpDisplOpt);
    layout2=new QGridLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(chkDisplTickLabels,0,0);
    layout2->addWidget(chkDisplAxixBar,0,1);
    layout2->addWidget(chkDisplTickMarks,1,0);
    grpDisplOpt->setLayout(layout2);

    grpAxisPlace=new QGroupBox(tr("Axis placement"),this);
    chkZeroAxis=new QCheckBox(tr("Zero axis"),grpAxisPlace);
    ledOffsetNormal=new stdLineEdit(grpAxisPlace,tr("Offsets - Normal:"));
    ledOffsetOpposite=new stdLineEdit(grpAxisPlace,tr("Opposite:"));
    layout3=new QHBoxLayout;
    layout3->setMargin(STD_MARGIN);
    layout3->addWidget(chkZeroAxis);
    layout3->addWidget(ledOffsetNormal);
    layout3->addWidget(ledOffsetOpposite);
    grpAxisPlace->setLayout(layout3);

    grpTickLabelProp=new QGroupBox(tr("Tick label properties"),this);
    selTickLabelFont=new FontSelector(grpTickLabelProp);
    selTickLabelColor=new ColorSelector(grpTickLabelProp);
    layout4=new QHBoxLayout;
    layout4->setMargin(STD_MARGIN);
    layout4->addWidget(selTickLabelFont);
    layout4->addWidget(selTickLabelColor);
    grpTickLabelProp->setLayout(layout4);


    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpAxisLabel);
    layout->addWidget(grpTickProp);
    layout->addWidget(grpDisplOpt);
    layout->addWidget(grpAxisPlace);
    layout->addWidget(grpTickLabelProp);
    setLayout(layout);
    delete[] entr;
}

AxisTabLabelBars::AxisTabLabelBars(QWidget * parent):QWidget(parent)
{
    int number;
    QString * entr=new QString[5];
    grpLabelProperties=new QGroupBox(tr("Label properties"),this);
    selLabelFont=new FontSelector(grpLabelProperties);
    selLabelColor=new ColorSelector(grpLabelProperties);
    sldCharSize=new stdSlider(grpLabelProperties,tr("Char size"),0,1000);
    number=2;
    entr[0]=tr("Parallel to axis");
    entr[1]=tr("Perpendicular to axis");
    selLayout=new StdSelector(grpLabelProperties,tr("Layout:"),number,entr);
    number=3;
    entr[0]=tr("Normal");
    entr[1]=tr("Opposite");
    entr[2]=tr("Both");
    selSide=new StdSelector(grpLabelProperties,tr("Side:"),number,entr);
    number=2;
    entr[0]=tr("Auto");
    entr[1]=tr("Specified");
    selLocation=new StdSelector(grpLabelProperties,tr("Location:"),number,entr);
    connect(selLocation->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(locationChanged(int)));
    ledParaOffs=new stdLineEdit(grpLabelProperties,tr("Parallel offset:"));
    ledPerpendOffs=new stdLineEdit(grpLabelProperties,tr("Perpendicular offset:"));
    ledParaOffs->setEnabled(FALSE);
    ledPerpendOffs->setEnabled(FALSE);
    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(selLabelFont,0,0);
    layout1->addWidget(selLabelColor,0,1);
    layout1->addWidget(sldCharSize,1,0);
    layout1->addWidget(selLayout,1,1);
    layout1->addWidget(selSide,2,0);
    layout1->addWidget(selLocation,2,1);
    layout1->addWidget(ledParaOffs,3,0);
    layout1->addWidget(ledPerpendOffs,3,1);
    grpLabelProperties->setLayout(layout1);

    grpBarProperties=new QGroupBox(tr("Bar properties:"),this);
    selBarColor=new ColorSelector(grpBarProperties);
    selBarStyle=new LineStyleSelector(grpBarProperties);
    selBarWidth=new LineWidthSelector(grpBarProperties);
    selBarWidth->lblText->setText(tr("Width:"));
    layout2=new QGridLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selBarColor,0,0);
    layout2->addWidget(selBarWidth,0,1);
    layout2->addWidget(selBarStyle,1,0);
    grpBarProperties->setLayout(layout2);

    //empty=new QWidget(this);
    //empty->setMinimumHeight(140);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpLabelProperties);
    layout->addWidget(grpBarProperties);
    layout->addStretch(3);
    //layout->addWidget(empty);
    setLayout(layout);
    delete[] entr;
}

void AxisTabLabelBars::locationChanged(int i)
{
    if (i==0)
    {
        ledParaOffs->setEnabled(FALSE);
        ledPerpendOffs->setEnabled(FALSE);
    }
    else
    {
        ledParaOffs->setEnabled(TRUE);
        ledPerpendOffs->setEnabled(TRUE);
    }
}

AxisTabTickLabels::AxisTabTickLabels(QWidget * parent):QWidget(parent)
{
    int number;
    char dummy[10];
    QString * entr=new QString[12];

    grpLabels=new QGroupBox(tr("Labels"),this);
    sldCharSize=new stdSlider(grpLabels,tr("Char size"),0,1000);
    sldCharAngle=new stdSlider(grpLabels,tr("Angle"),0,360);
    layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(sldCharSize);
    layout0->addWidget(sldCharAngle);
    grpLabels->setLayout(layout0);

    grpPlacement=new QGroupBox(tr("Placement"),this);
    number=3;
    entr[0]=tr("Normal");
    entr[1]=tr("Opposite");
    entr[2]=tr("Both");
    selSide=new StdSelector(grpPlacement,tr("Side:"),number,entr);
    number=2;
    entr[0]=tr("Axis min");
    entr[1]=tr("Specified:");
    selStartAt=new StdSelector(grpPlacement,tr("Start at:"),number,entr);
    entr[0]=tr("Axis max");
    selStopAt=new StdSelector(grpPlacement,tr("Stop at:"),number,entr);
    number=10;
    for (int i=0;i<number;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i]=QString(dummy);
    }
    selStagger=new StdSelector(grpPlacement,tr("Stagger:"),number,entr);
    ledStart=new QLineEdit(QString(""),grpPlacement);
    ledStop=new QLineEdit(QString(""),grpPlacement);
    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(selSide,0,0);
    layout1->addWidget(selStartAt,0,1);
    layout1->addWidget(ledStart,0,2);
    layout1->addWidget(selStagger,1,0);
    layout1->addWidget(selStopAt,1,1);
    layout1->addWidget(ledStop,1,2);
    grpPlacement->setLayout(layout1);

    grpExtra=new QGroupBox(tr("Extra"),this);
    ledPrepend=new stdLineEdit(grpExtra,tr("Prepend:"),true);
    ledAppend=new stdLineEdit(grpExtra,tr("Append:"),true);
    ledAxisTransform=new stdLineEdit(grpExtra,tr("Axis transform:"));
    ledParaOffs=new stdLineEdit(grpExtra,tr("Parallel offset:"));
    ledPerpendOffs=new stdLineEdit(grpExtra,tr("Perpendicular offset:"));
    ledParaOffs->setEnabled(FALSE);
    ledPerpendOffs->setEnabled(FALSE);
    selSkipEvery=new StdSelector(grpExtra,tr("Skip every:"),number,entr);
    number=2;
    entr[0]=tr("Auto");
    entr[1]=tr("Specified");
    selLocation=new StdSelector(grpExtra,tr("Location:"),number,entr);
    connect(selLocation->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(locationChanged(int)));
    layout2=new QGridLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(selSkipEvery,0,0);
    layout2->addWidget(ledAxisTransform,0,1);
    layout2->addWidget(ledPrepend,1,0);
    layout2->addWidget(ledAppend,1,1);
    layout2->addWidget(selLocation,2,0);
    layout2->addWidget(ledParaOffs,3,0);
    layout2->addWidget(ledPerpendOffs,3,1);
    grpExtra->setLayout(layout2);

    grpQuick=new QGroupBox(tr("Quick transformation"),this);
    grpQuick->setToolTip(tr("The buttons in this group assume that the data is present in radians.\nThey just set axis transformations for different representations of angles."));
    layout3=new QHBoxLayout;
    cmdQuickNormal=new QPushButton(tr("Normal"),this);
    cmdQuickNormal->setToolTip(tr("Reset axis transformation to default\n(i.e. no transformation)"));
    cmdQuickDegrees=new QPushButton(tr("Degrees"),this);
    cmdQuickDegrees->setToolTip(tr("Set tick labels to degrees\n(with spacing = 90 degrees)"));
    cmdQuickPis=new QPushButton(tr("Multiples of Pi"),this);
    cmdQuickPis->setToolTip(tr("Set tick labels to multiples of PI\n(with spacing = PI/2)"));
    connect(cmdQuickNormal,SIGNAL(clicked()),SLOT(doQuickNormal()));
    connect(cmdQuickDegrees,SIGNAL(clicked()),SLOT(doQuickDegrees()));
    connect(cmdQuickPis,SIGNAL(clicked()),SLOT(doQuickPis()));
    layout3->setMargin(STD_MARGIN);
    layout3->addWidget(cmdQuickNormal);
    layout3->addWidget(cmdQuickDegrees);
    layout3->addWidget(cmdQuickPis);
    grpQuick->setLayout(layout3);

    //empty=new QWidget(this);
    //empty->setMinimumHeight(70);
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpLabels);
    layout->addWidget(grpPlacement);
    layout->addWidget(grpExtra);
    layout->addWidget(grpQuick);
    layout->addStretch(3);
    //layout->addWidget(empty);
    setLayout(layout);
    delete[] entr;
}

void AxisTabTickLabels::locationChanged(int i)
{
    if (i==0)
    {
        ledParaOffs->setEnabled(FALSE);
        ledPerpendOffs->setEnabled(FALSE);
    }
    else
    {
        ledParaOffs->setEnabled(TRUE);
        ledPerpendOffs->setEnabled(TRUE);
    }
}

void AxisTabTickLabels::doQuickNormal(void)
{
emit(quickSetNormal());
}

void AxisTabTickLabels::doQuickDegrees(void)
{
emit(quickSetDegrees());
}

void AxisTabTickLabels::doQuickPis(void)
{
emit(quickSetPis());
}

AxisTabTickMarks::AxisTabTickMarks(QWidget * parent):QWidget(parent)
{
    int number;
    char dummy[10];
    QString * entr=new QString[12];

    grpPlacement=new QGroupBox(tr("Placement"),this);
    number=3;
    entr[0]=tr("In");
    entr[1]=tr("Out");
    entr[2]=tr("Both");
    selPointing=new StdSelector(grpPlacement,tr("Pointing"),number,entr);
    entr[0]=tr("Normal side");
    entr[1]=tr("Opposite side");
    entr[2]=tr("Both sides");
    selDrawOn=new StdSelector(grpPlacement,tr("Draw on:"),number,entr);
    number=11;
    for (int i=2;i<13;i++)
    {
        sprintf(dummy,"%d",i);
        entr[i-2]=QString(dummy);
    }
    setAutotickDiv=new StdSelector(grpPlacement,tr("Autotick divisions:"),number,entr);
    chkPlaceRoundPos=new QCheckBox(tr("Place at rounded positions"),grpPlacement);
    layout0=new QGridLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->addWidget(selPointing,0,0);
    layout0->addWidget(selDrawOn,0,1);
    layout0->addWidget(chkPlaceRoundPos,1,0);
    layout0->addWidget(setAutotickDiv,1,1);
    grpPlacement->setLayout(layout0);

    grpMajorTicks=new QGroupBox(tr("Major ticks"),this);
    chkDrawMajGrid=new QCheckBox(tr("Draw grid lines"),grpMajorTicks);
    sldMajTickLength=new stdSlider(grpMajorTicks,tr("Tick length"),0,1000);
    selMajTickColor=new ColorSelector(grpMajorTicks);
    selMajTickWidth=new LineWidthSelector(grpMajorTicks);
    selMajTickStyle=new LineStyleSelector(grpMajorTicks);
    layout1=new QVBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->addWidget(chkDrawMajGrid);
    layout1->addWidget(sldMajTickLength);
    layout1->addWidget(selMajTickColor);
    layout1->addWidget(selMajTickWidth);
    layout1->addWidget(selMajTickStyle);
    grpMajorTicks->setLayout(layout1);

    grpMinorTicks=new QGroupBox(tr("Minor ticks"),this);
    chkDrawMinGrid=new QCheckBox(tr("Draw grid lines"),grpMinorTicks);
    sldMinTickLength=new stdSlider(grpMinorTicks,tr("Tick length"),0,1000);
    selMinTickColor=new ColorSelector(grpMinorTicks);
    selMinTickWidth=new LineWidthSelector(grpMinorTicks);
    selMinTickStyle=new LineStyleSelector(grpMinorTicks);
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->addWidget(chkDrawMinGrid);
    layout2->addWidget(sldMinTickLength);
    layout2->addWidget(selMinTickColor);
    layout2->addWidget(selMinTickWidth);
    layout2->addWidget(selMinTickStyle);
    grpMinorTicks->setLayout(layout2);

    empty=new QWidget(this);
    empty->setMinimumHeight(40);

    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(grpPlacement,0,0,1,2);
    layout->addWidget(grpMajorTicks,1,0);
    layout->addWidget(grpMinorTicks,1,1);
    layout->addWidget(empty,2,0,1,2);
    layout->setRowStretch(0,1);
    layout->setRowStretch(1,1);
    layout->setRowStretch(2,5);
    setLayout(layout);
    delete[] entr;
}

AxisTabSpecial::AxisTabSpecial(QWidget * parent):QWidget(parent)
{
    int number;
    QString * entr=new QString[12];
    number=3;
    entr[0]=tr("None");
    entr[1]=tr("Tick marks only");
    entr[2]=tr("Tick marks and labels");
    selSpecTicks=new StdSelector(this,tr("Custom ticks:"),number,entr);
    selSpecTicks->entryValues[0]=TICKS_SPEC_NONE;
    selSpecTicks->entryValues[1]=TICKS_SPEC_MARKS;
    selSpecTicks->entryValues[2]=TICKS_SPEC_BOTH;
    selNumber=new stdIntSelector(this,tr("Number of user ticks to use:"),0,MAX_TICKS - 1);
    //lblTickLocLabel=new QLabel(tr("Nr. - Tick location - Label:"),this);

    connect(selSpecTicks,SIGNAL(currentIndexChanged(int)),SLOT(updateSpreadSheet(int)));
    connect(selNumber,SIGNAL(currentValueChanged(int)),SLOT(updateSpreadSheet(int)));

    scroll=new QScrollArea(this);
    empty=new QWidget(this);
    layout0=new QGridLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    int index=0;
    lblTitles[0]=new QLabel(tr("Nr.  "),this);
    lblTitles[1]=new QLabel(tr("Tick Location"),this);
    lblTitles[2]=new QLabel(tr("Tick Label"),this);
        for (int i=0;i<3;i++) layout0->addWidget(lblTitles[i],index,i);
        index++;
    for (int i=0;i<MAX_TICKS;i++)
    {
    original[i]=true;
    orig_text[i]=text[i]=NULL;
    lblNr[i]=new QLabel(QString::number(i),this);
    ledLocation[i]=new QLineEdit(QString(""),this);
    ledLabel[i]=new QLineEdit(QString(""),this);
    layout0->addWidget(lblNr[i],index,0);
    layout0->addWidget(ledLocation[i],index,1);
    layout0->setRowStretch(index,0);
    layout0->addWidget(ledLabel[i],index++,2);
    }
    empty->setLayout(layout0);
    scroll->setWidget(empty);

    /*spreadSpecLabels=new spreadSheet(scroll,2,256,3);
    spreadSpecLabels->setMinimumWidth(400);
    scroll->setWidget(spreadSpecLabels);*/

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(selSpecTicks);
    layout->addWidget(selNumber);
    //layout->addWidget(lblTickLocLabel);
    layout->addWidget(scroll);
    setLayout(layout);
    delete[] entr;
}

void AxisTabSpecial::updateSpreadSheet(int i)
{
    (void)i;
int custom_type=selSpecTicks->currentIndex();//0=none,1=TickMarks only,2=TickMarks and Labels
int custom_nr=selNumber->value();

headerHeight=lblTitles[0]->height();
stdHeight=lblNr[0]->height();
if (headerHeight<16) headerHeight=16;
if (stdHeight<22) stdHeight=22;

int w,h;
w=lblTitles[0]->width()+lblTitles[1]->width()+lblTitles[2]->width();
if (w<316) w=316;
w+=2*(STD_MARGIN+STD_SPACING);
h=2*STD_MARGIN+(STD_SPACING+stdHeight)*custom_nr+headerHeight;
empty->resize(w,h);

if (custom_type==0)//none
{
    for (int i=0;i<MAX_TICKS;i++)
    {
    lblNr[i]->setEnabled(false);
    ledLocation[i]->setEnabled(false);
    ledLabel[i]->setEnabled(false);
    }
}
else if (custom_type==1)//TickMarks only
{
    for (int i=0;i<MAX_TICKS;i++)
    {
    lblNr[i]->setEnabled(true);
    ledLocation[i]->setEnabled(true);
    ledLabel[i]->setEnabled(false);
    }
}
else//TickMarks and Labels
{
    for (int i=0;i<MAX_TICKS;i++)
    {
    lblNr[i]->setEnabled(true);
    ledLocation[i]->setEnabled(true);
    ledLabel[i]->setEnabled(true);
    }
}

for (int i=0;i<custom_nr;i++)
{
    lblNr[i]->setVisible(true);
    ledLocation[i]->setVisible(true);
    ledLabel[i]->setVisible(true);
}
for (int i=custom_nr;i<MAX_TICKS;i++)
{
    lblNr[i]->setVisible(false);
    ledLocation[i]->setVisible(false);
    ledLabel[i]->setVisible(false);
}

}

frmAxis_Prop::frmAxis_Prop(QWidget * parent):QWidget(parent)
{
    int number;
    curaxis=X_AXIS;
    QString * entr=new QString[8];
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Axis"));
    setWindowIcon(QIcon(*GraceIcon));

    number=4;
    entr[0]=tr("X axis");
    entr[1]=tr("Y axis");
    entr[2]=tr("Alt X axis");
    entr[3]=tr("Alt Y axis");
    selEdit=new StdSelector(this,tr("Edit:"),number,entr);
    selEdit->entryValues[0]=X_AXIS;
    selEdit->entryValues[1]=Y_AXIS;
    selEdit->entryValues[2]=ZX_AXIS;
    selEdit->entryValues[3]=ZY_AXIS;
    connect(selEdit->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(selEditChanged(int)));
    chkActive=new QCheckBox(tr("Active"),this);
    chkActive->setChecked(TRUE);
    connect(chkActive,SIGNAL(stateChanged(int)),SLOT(set_active_proc(int)));

    ledStart=new stdLineEdit(this,tr("Start:"));
    ledStop=new stdLineEdit(this,tr("Stop:"));
    chkInvAxis=new QCheckBox(tr("Invert axis"),this);
    chkInvAxis->setChecked(FALSE);
    tabs=new QTabWidget(this);
    tabMain=new AxisTabMain(tabs);
    tabLabelsBars=new AxisTabLabelBars(tabs);
    tabTickLabels=new AxisTabTickLabels(tabs);
    tabTickMarks=new AxisTabTickMarks(tabs);
    tabSpecial=new AxisTabSpecial(tabs);
    tabs->addTab(tabMain, tr("Main"));
    tabs->addTab(tabLabelsBars, tr("Axis label && bar"));
    tabs->addTab(tabTickLabels, tr("Tick labels"));
    tabs->addTab(tabTickMarks, tr("Tick marks"));
    tabs->addTab(tabSpecial, tr("Custom ticks"));
    number=4;
    entr[0]=tr("Linear");
    entr[1]=tr("Logarithmic");
    entr[2]=tr("Reciprocal");
    entr[3]=tr("Logit");
    selScale=new StdSelector(this,tr("Scale:"),number,entr);
    selScale->entryValues[0]=SCALE_NORMAL;
    selScale->entryValues[1]=SCALE_LOG;
    selScale->entryValues[2]=SCALE_REC;
    selScale->entryValues[3]=SCALE_LOGIT;
    connect(selScale->cmbSelect,SIGNAL(currentIndexChanged(int)),this,SLOT(axis_scale_cb(int)));
    number=8;
    entr[0]=tr("Current axis");
    entr[1]=tr("All axes, current graph");
    entr[2]=tr("Current axis, all graphs");
    entr[3]=tr("All axes, all graphs");
    entr[4]=tr("x+y axes, current graph");
    entr[5]=tr("x+y axes, all graphs");
    entr[6]=tr("alt x+y axes, current graph");
    entr[7]=tr("alt x+y axes, all graphs");
    selApplyTo=new StdSelector(this,tr("Apply to:"),number,entr);
    selApplyTo->lblText->setVisible(true);
    cmdApplyTo=new QPushButton(tr("Apply to:"),selApplyTo);
    selApplyTo->layout->removeWidget(selApplyTo->lblText);
    selApplyTo->layout->removeWidget(selApplyTo->cmbSelect);
    selApplyTo->layout->addWidget(cmdApplyTo);
    selApplyTo->layout->addWidget(selApplyTo->cmbSelect);
    connect(cmdApplyTo,SIGNAL(clicked()),SLOT(doApplyTo()));

    buttonGroup=new stdButtonGroup(this);
    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doAccept()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(doClose()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(doApply()));
    buttonGroup->cmdApply->setDefault(true);
    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(selEdit,0,0);
    layout->addWidget(chkActive,0,1);
    //layout->addWidget(empty[0],0,2);
    layout->addWidget(ledStart,1,0);
    layout->addWidget(ledStop,1,1);
    //layout->addWidget(empty[1],1,2);
    layout->addWidget(selScale,2,0);
    layout->addWidget(chkInvAxis,2,1);
    //layout->addWidget(empty[2],2,2);
    layout->addWidget(tabs,3,0,1,3);
    layout->addWidget(selApplyTo,4,0,1,2);
    //layout->addWidget(empty[3],4,2);
    layout->addWidget(buttonGroup,5,0,1,3);
    setLayout(layout);

    //immediateUpdate
    connect(chkActive,SIGNAL(stateChanged(int)),SLOT(update1(int)));
    connect(chkInvAxis,SIGNAL(stateChanged(int)),SLOT(update1(int)));

    connect(tabMain->ledAxisLabel,SIGNAL(changed()),SLOT(update0()));
    connect(tabMain->ledMajorSpacing,SIGNAL(changed()),SLOT(update0()));
    connect(tabMain->selMinTicks,SIGNAL(currentValueChanged(int)),SLOT(update1(int)));
    connect(tabMain->selFormat,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMain->selPrecision,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMain->chkDisplTickLabels,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabMain->chkDisplAxixBar,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabMain->chkDisplTickMarks,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabMain->chkZeroAxis,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabMain->ledOffsetNormal,SIGNAL(changed()),SLOT(update0()));
    connect(tabMain->ledOffsetOpposite,SIGNAL(changed()),SLOT(update0()));
    connect(tabMain->selTickLabelFont,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMain->selTickLabelColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabMain->selTickLabelColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));

    connect(tabLabelsBars->selLabelFont,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->selLabelColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->selLabelColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->sldCharSize,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->selLayout,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->selSide,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->selLocation,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->ledParaOffs,SIGNAL(changed()),SLOT(update0()));
    connect(tabLabelsBars->ledPerpendOffs,SIGNAL(changed()),SLOT(update0()));
    connect(tabLabelsBars->selBarColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->selBarColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->selBarStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabLabelsBars->selBarWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));

    connect(tabTickLabels->sldCharSize,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabTickLabels->sldCharAngle,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabTickLabels->selSide,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickLabels->selStartAt,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickLabels->selStopAt,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickLabels->selStagger,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickLabels->ledStart,SIGNAL(returnPressed()),SLOT(update0()));
    connect(tabTickLabels->ledStop,SIGNAL(returnPressed()),SLOT(update0()));
    connect(tabTickLabels->ledPrepend,SIGNAL(changed()),SLOT(update0()));
    connect(tabTickLabels->ledAppend,SIGNAL(changed()),SLOT(update0()));
    connect(tabTickLabels->ledAxisTransform,SIGNAL(changed()),SLOT(update0()));
    connect(tabTickLabels->ledParaOffs,SIGNAL(changed()),SLOT(update0()));
    connect(tabTickLabels->ledPerpendOffs,SIGNAL(changed()),SLOT(update0()));
    connect(tabTickLabels->selSkipEvery,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickLabels->selLocation,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));

    connect(tabTickMarks->selPointing,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->selDrawOn,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->setAutotickDiv,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->chkPlaceRoundPos,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabTickMarks->chkDrawMajGrid,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabTickMarks->sldMajTickLength,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->selMajTickColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->selMajTickColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->selMajTickWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(tabTickMarks->selMajTickStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->chkDrawMinGrid,SIGNAL(toggled(bool)),SLOT(update3(bool)));
    connect(tabTickMarks->sldMinTickLength,SIGNAL(valueChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->selMinTickColor,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->selMinTickColor,SIGNAL(alphaChanged(int)),SLOT(update1(int)));
    connect(tabTickMarks->selMinTickWidth,SIGNAL(currentValueChanged(double)),SLOT(update4(double)));
    connect(tabTickMarks->selMinTickStyle,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));

    connect(tabSpecial->selSpecTicks,SIGNAL(currentIndexChanged(int)),SLOT(update1(int)));
    connect(tabSpecial->selNumber,SIGNAL(currentValueChanged(int)),SLOT(update1(int)));

    connect(tabTickLabels,SIGNAL(quickSetNormal()),SLOT(doQuickNormalTicks()));
    connect(tabTickLabels,SIGNAL(quickSetDegrees()),SLOT(doQuickDegreesTicks()));
    connect(tabTickLabels,SIGNAL(quickSetPis()),SLOT(doQuickPisTricks()));
//connect(tabSpecial->spreadSpecLabels,SIGNAL(changed()),SLOT(update0()));
    //end immediateUpdate
    delete[] entr;
}

frmAxis_Prop::~frmAxis_Prop()
{}

void frmAxis_Prop::selEditChanged(int i)
{
    set_axis_proc(i);
}

void frmAxis_Prop::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmAxis_Prop::doApply(void)
{
    apply_to_selection = 0;//only apply to the current Axis!
    axes_aac_cb();
}

void frmAxis_Prop::doApplyTo(void)
{
    apply_to_selection = selApplyTo->currentValue();
    axes_aac_cb();
}

void frmAxis_Prop::doClose(void)
{
//parentWidget()->hide();
    emit(closeWish());
}

/*
 * Callback function for definition of tick marks and axis labels.
 */
int frmAxis_Prop::axes_aac_cb(void)
{
    ApplyError=false;
    //QString text;
    char dummy[MAX_STRING_LENGTH],dummy2[MAX_STRING_LENGTH],descr_axis[32];
    int i, j;
    int applyto;//,tmp_active;
    int axis_start, axis_stop, graph_start, graph_stop;
    int scale, invert;
    tickmarks *t,*t2;
    double axestart, axestop;
    world w,w2;

    //applyto = selApplyTo->currentValue();
    applyto = apply_to_selection;

    t = new_graph_tickmarks();
    if (!t)
    {
        return RETURN_FAILURE;
    }
    t->active = chkActive->isChecked();
    t->zero = tabMain->chkZeroAxis->isChecked();
    if (xv_evalexpr(tabMain->ledMajorSpacing, &t->tmajor) != RETURN_SUCCESS)
    {
        errmsg(tr("Specify major tick spacing").toLocal8Bit().constData());
        free_graph_tickmarks(t);
        ApplyError=true;
        return RETURN_FAILURE;
    }
    t->nminor =tabMain->selMinTicks->value();
    t->tl_flag = tabMain->chkDisplTickLabels->isChecked();
    t->t_flag = tabMain->chkDisplTickMarks->isChecked();
    t->t_drawbar = tabMain->chkDisplAxixBar->isChecked();

    tabMain->ledAxisLabel->DynSetMemoryToText(t->label.s_plotstring,t->label.alt_plotstring);
    //strcpy(dummy,tabMain->ledAxisLabel->text().toLocal8Bit());
    //set_plotstr_string(&t->label, dummy);
    ///setting plotstring
    xv_evalexpr(tabMain->ledOffsetNormal, &t->offsx);
    xv_evalexpr(tabMain->ledOffsetOpposite, &t->offsy);
    t->label_layout = tabLabelsBars->selLayout->currentIndex() ? LAYOUT_PERPENDICULAR : LAYOUT_PARALLEL;
    t->label_place = tabLabelsBars->selLocation->currentIndex();
    if (t->label_place == TYPE_SPEC)//or auto
    {
        xv_evalexpr(tabLabelsBars->ledParaOffs, &t->label.x);
        xv_evalexpr(tabLabelsBars->ledPerpendOffs, &t->label.y);
    }
    t->label.font = tabLabelsBars->selLabelFont->currentIndex();
    t->label.color = tabLabelsBars->selLabelColor->currentIndex();
    t->label.alpha = tabLabelsBars->selLabelColor->alpha();
    t->label.charsize = tabLabelsBars->sldCharSize->value()/100.0;

    /* somehow the value of axislabelop gets automagically correctly
       applied to all selected axes without checking for the value of
       applyto directly here (strange...) */
    switch(tabLabelsBars->selSide->currentIndex())
    {
    case 0:
        t->label_op = PLACEMENT_NORMAL;
        break;
    case 1:
        t->label_op = PLACEMENT_OPPOSITE;
        break;
    case 2:
        t->label_op = PLACEMENT_BOTH;
        break;
    }
    t->tl_font = tabMain->selTickLabelFont->currentIndex();
    t->tl_color = tabMain->selTickLabelColor->currentIndex();
    t->tl_alpha = tabMain->selTickLabelColor->alpha();
    t->tl_skip = tabTickLabels->selSkipEvery->currentIndex();
    t->tl_prec = tabMain->selPrecision->currentIndex();
    t->tl_staggered = tabTickLabels->selStagger->currentIndex();

    tabTickLabels->ledAppend->SetMemoryToText(t->tl_appstr,t->orig_tl_appstr);
    tabTickLabels->ledPrepend->SetMemoryToText(t->tl_prestr,t->orig_tl_prestr);
    //strcpy(t->tl_appstr, tabTickLabels->ledAppend->text().toLocal8Bit());
    //strcpy(t->tl_prestr, tabTickLabels->ledPrepend->text().toLocal8Bit());
    ///setting strings
    t->tl_starttype =  tabTickLabels->selStartAt->currentIndex()== 0 ? TYPE_AUTO : TYPE_SPEC;
    if (t->tl_starttype == TYPE_SPEC)
    {
        if(xv_evalexpr(tabTickLabels->ledStart, &t->tl_start) != RETURN_SUCCESS)
        {
            errmsg(tr("Specify tick label start").toLocal8Bit().constData());
            free_graph_tickmarks(t);
            ApplyError=true;
            return RETURN_FAILURE;
        }
    }
    t->tl_stoptype =  tabTickLabels->selStopAt->currentIndex()== 0 ? TYPE_AUTO : TYPE_SPEC;
    if (t->tl_stoptype == TYPE_SPEC)
    {
        if(xv_evalexpr(tabTickLabels->ledStop, &t->tl_stop) != RETURN_SUCCESS)
        {
            errmsg(tr("Specify tick label stop").toLocal8Bit().constData());
            free_graph_tickmarks(t);
            ApplyError=true;
            return RETURN_FAILURE;
        }
    }
    t->tl_format = tabMain->selFormat->currentIndex();
    strcpy(dummy,tabTickLabels->ledAxisTransform->text().toLatin1().constData());
    PrepareFormula(dummy);//replace ',' with '.' if necessary
    t->tl_formula = copy_string(NULL, dummy);
    t->tl_gaptype = tabTickLabels->selLocation->currentIndex()== 0 ? TYPE_AUTO : TYPE_SPEC;
    if (t->tl_gaptype == TYPE_SPEC)
    {
        xv_evalexpr(tabTickLabels->ledParaOffs, &t->tl_gap.x);
        xv_evalexpr(tabTickLabels->ledPerpendOffs, &t->tl_gap.y);
    }
    
    t->tl_angle = tabTickLabels->sldCharAngle->value();
    t->tl_charsize = tabTickLabels->sldCharSize->value()/100.0;

    switch (tabTickMarks->selPointing->currentIndex())
    {
    case 0:
        t->t_inout = TICKS_IN;
        break;
    case 1:
        t->t_inout = TICKS_OUT;
        break;
    case 2:
        t->t_inout = TICKS_BOTH;
        break;
    }
    
    t->props.color = tabTickMarks->selMajTickColor->currentIndex();
    t->props.alpha = tabTickMarks->selMajTickColor->alpha();
    t->props.linew = tabTickMarks->selMajTickWidth->value();
    t->props.lines = tabTickMarks->selMajTickStyle->currentIndex();
    t->mprops.color = tabTickMarks->selMinTickColor->currentIndex();
    t->mprops.alpha = tabTickMarks->selMinTickColor->alpha();
    t->mprops.linew = tabTickMarks->selMinTickWidth->value();
    t->mprops.lines = tabTickMarks->selMinTickStyle->currentIndex();
    t->props.size = tabTickMarks->sldMajTickLength->value()/100.0;
    t->mprops.size = tabTickMarks->sldMinTickLength->value()/100.0;
    t->t_autonum = 2+tabTickMarks->setAutotickDiv->currentIndex();
    t->t_round = tabTickMarks->chkPlaceRoundPos->isChecked();
    t->props.gridflag = tabTickMarks->chkDrawMajGrid->isChecked();
    t->mprops.gridflag = tabTickMarks->chkDrawMinGrid->isChecked();
    t->t_drawbarcolor = tabLabelsBars->selBarColor->currentIndex();
    t->t_drawbaralpha = tabLabelsBars->selBarColor->alpha();
    t->t_drawbarlinew = tabLabelsBars->selBarWidth->value();
    t->t_drawbarlines = tabLabelsBars->selBarStyle->currentIndex();

    t->t_spec = tabSpecial->selSpecTicks->currentValue();
    /* only read special info if special ticks used */
    if (t->t_spec != TICKS_SPEC_NONE)
    {
        t->nticks = tabSpecial->selNumber->value();
        /* ensure that enough tick positions have been specified */
        for (i = 0; i < t->nticks; i++)
        {
            //if (xv_evalexpr(tabSpecial->spreadSpecLabels->axislines[i]->ledLocation, &t->tloc[i].wtpos) == RETURN_SUCCESS)
            if (xv_evalexpr(tabSpecial->ledLocation[i], &t->tloc[i].wtpos) == RETURN_SUCCESS)
            {
                //strcpy(dummy,tabSpecial->spreadSpecLabels->axislines[i]->ledLabel->text().toLatin1().constData());//copy text directly
                //strcpy(dummy,tabSpecial->ledLabel[i]->text().toLatin1().constData());//copy text directly
                /// Warning --> use encoding here! (instead of latin1)
                //strcpy(dummy,tabSpecial->spreadSpecLabels->axislines[i]->LabelText().toLocal8Bit());
                //if (dummy[0] == '\0')
                if (tabSpecial->ledLabel[i]->text().isEmpty()==true)
                {
                    t->tloc[i].type = TICK_TYPE_MINOR;
                }
                else
                {
                    t->tloc[i].type = TICK_TYPE_MAJOR;
                }
                if (t->t_spec == TICKS_SPEC_BOTH)
                {
                    DynSetMemoryToLineEdit(t->tloc[i].label,t->tloc[i].orig_label,tabSpecial->text[i],tabSpecial->orig_text[i],tabSpecial->original[i],true,tabSpecial->ledLabel[i]);
                    //tabSpecial->spreadSpecLabels->axislines[i]->SetMemoryToText(t->tloc[i].label,t->tloc[i].orig_label);
                    /*
                    t->tloc[i].orig_label = copy_string(t->tloc[i].label, dummy);
                    t->tloc[i].label = copy_string(t->tloc[i].label, dummy);
                    if (activateLaTeXsupport==true)
                    {
                    text=QString(t->tloc[i].label);
                    complete_LaTeX_to_Grace_Translator(text);
                    t->tloc[i].label=copy_string(t->tloc[i].label,text.toLocal8Bit().constData());
                    }
                    */
                }
                else
                {//simply copy everything - delete entries
                    t->tloc[i].orig_label = copy_string(t->tloc[i].label, NULL);
                    t->tloc[i].label = copy_string(t->tloc[i].label, NULL);
                }
            }
            else
            {
                errmsg(tr("Not enough tick locations specified").toLocal8Bit().constData());
                free_graph_tickmarks(t);
                ApplyError=true;
                return RETURN_FAILURE;
            }
        }//end for-loop
    }//end if !TICK_SPEC_NONE
    
    switch (applyto)
    {
    case 0:                     /* current axis */
        axis_start = curaxis;
        axis_stop  = curaxis;
        graph_start = cg;
        graph_stop  = cg;
        break;
    case 1:                     /* all axes, current graph */
        axis_start = 0;
        axis_stop  = MAXAXES - 1;
        graph_start = cg;
        graph_stop  = cg;
        break;
    case 2:                     /* current axis, all graphs */
        axis_start = curaxis;
        axis_stop  = curaxis;
        graph_start = 0;
        graph_stop  = number_of_graphs() - 1;
        break;
    case 3:                     /* all axes, all graphs */
        axis_start = 0;
        axis_stop  = MAXAXES - 1;
        graph_start = 0;
        graph_stop  = number_of_graphs() - 1;
        break;
    case 4:                     /* x+y axes, current graph */
        axis_start = 0;
        axis_stop  = 1;
        graph_start = cg;
        graph_stop  = cg;
        break;
    case 5:                     /* x+y axes, all graphs */
        axis_start = 0;
        axis_stop  = 1;
        graph_start = 0;
        graph_stop  = number_of_graphs() - 1;
        break;
    case 6:                     /* alt x+y axes, current graph */
        axis_start = 2;
        axis_stop  = 3;
        graph_start = cg;
        graph_stop  = cg;
        break;
    case 7:                     /* alt x+y axes, all graphs */
        axis_start = 2;
        axis_stop  = 3;
        graph_start = 0;
        graph_stop  = number_of_graphs() - 1;
        break;
    default:
        axis_start = curaxis;
        axis_stop  = curaxis;
        graph_start = cg;
        graph_stop  = cg;
        break;
    }

    if (xv_evalexpr(ledStart,&axestart)!=RETURN_SUCCESS || xv_evalexpr(ledStop,&axestop)!=RETURN_SUCCESS)
    {
        errmsg(tr("Axis start/stop values undefined").toLocal8Bit().constData());
        free_graph_tickmarks(t);
        ApplyError=true;
        return RETURN_FAILURE;
    }

    //Undo-Stuff
    SaveTickmarksStatesPrevious(axis_start,axis_stop,graph_start,graph_stop);
    ListOfChanges.clear();
    ListOfOldStates.clear();

    for (i = graph_start; i <= graph_stop; i++)
    {
        for (j = axis_start; j <= axis_stop; j++)
        {
            switch (j)
            {
            case 0:
                strcpy(descr_axis,"xaxis");
                break;
            case 1:
                strcpy(descr_axis,"yaxis");
                break;
            case 2:
                strcpy(descr_axis,"altxaxis");
                break;
            case 3:
                strcpy(descr_axis,"altyaxis");
                break;
            }
            t2 = get_graph_tickmarks(i,j);//t2 is the original
            sprintf(dummy,"with g%d",i);
            ListOfChanges << QString(dummy);
            ListOfOldStates << QString(dummy);
            get_graph_world(i, &w2);//w2 is the original
            get_graph_world(i, &w);
            if (is_xaxis(j))
            {
                w.xg1 = axestart;
                w.xg2 = axestop;
            }
            else
            {
                w.yg1 = axestart;
                w.yg2 = axestop;
            }
            set_graph_world(i, w);
            if (w.xg1!=w2.xg1 || w.xg2!=w2.xg2 || w.yg1!=w2.yg1 || w.yg2!=w2.yg2)
            {
                sprintf(dummy,"    world %f, %f, %f, %f",w.xg1,w.yg1,w.xg2,w.yg2);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    world %f, %f, %f, %f",w2.xg1,w2.yg1,w2.xg2,w2.yg2);
                ListOfOldStates << QString(dummy);
            }
            scale = selScale->currentValue();
            switch (scale)
            {
            case 0:
                strcpy(dummy2,"Normal");
                break;
            case 1:
                strcpy(dummy2,"Logarithmic");
                break;
            case 2:
                strcpy(dummy2,"Reciprocal");
                break;
            case 3:
                strcpy(dummy2,"Logit");
                break;
            }
            if (is_xaxis(j))
            {
                if (g[i].xscale!=scale)
                {
                    sprintf(dummy,"    xaxes scale %s",dummy2);
                    ListOfChanges << QString(dummy);
                    switch (g[i].xscale)
                    {
                    case 0:
                        strcpy(dummy2,"Normal");
                        break;
                    case 1:
                        strcpy(dummy2,"Logarithmic");
                        break;
                    case 2:
                        strcpy(dummy2,"Reciprocal");
                        break;
                    case 3:
                        strcpy(dummy2,"Logit");
                        break;
                    }
                    sprintf(dummy,"    xaxes scale %s",dummy2);
                    ListOfOldStates << QString(dummy);
                }
                set_graph_xscale(i, scale);
            }
            else
            {
                if (g[i].yscale!=scale)
                {
                    sprintf(dummy,"    yaxes scale %s",dummy2);
                    ListOfChanges << QString(dummy);
                    switch (g[i].yscale)
                    {
                    case 0:
                        strcpy(dummy2,"Normal");
                        break;
                    case 1:
                        strcpy(dummy2,"Logarithmic");
                        break;
                    case 2:
                        strcpy(dummy2,"Reciprocal");
                        break;
                    case 3:
                        strcpy(dummy2,"Logit");
                        break;
                    }
                    sprintf(dummy,"    yaxes scale %s",dummy2);
                    ListOfOldStates << QString(dummy);
                }
                set_graph_yscale(i, scale);
            }

            invert = chkInvAxis->isChecked();
            strcpy(dummy2,invert?"on":"off");
            if (is_xaxis(j))
            {
                if (g[i].xinvert!=invert)
                {
                    sprintf(dummy,"    xaxes invert %s",dummy2);
                    ListOfChanges << QString(dummy);
                    strcpy(dummy2,g[i].xinvert?"on":"off");
                    sprintf(dummy,"    xaxes invert %s",dummy2);
                    ListOfOldStates << QString(dummy);
                }
                set_graph_xinvert(i, invert);
            }
            else
            {
                if (g[i].yinvert!=invert)
                {
                    sprintf(dummy,"    yaxes invert %s",dummy2);
                    ListOfChanges << QString(dummy);
                    strcpy(dummy2,g[i].yinvert?"on":"off");
                    sprintf(dummy,"    yaxes invert %s",dummy2);
                    ListOfOldStates << QString(dummy);
                }
                set_graph_yinvert(i, invert);
            }
            switch(tabTickLabels->selSide->currentIndex())
            {
            case 0:
                t->tl_op = PLACEMENT_NORMAL;
                strcpy(dummy2,"normal");
                break;
            case 1:
                t->tl_op = PLACEMENT_OPPOSITE;
                strcpy(dummy2,"opposite");
                break;
            case 2:
                t->tl_op = PLACEMENT_BOTH;
                strcpy(dummy2,"both");
                break;
            }
            if (t2->tl_op!=t->tl_op)
            {
                sprintf(dummy,"    %s  label place %s",descr_axis,dummy2);
                ListOfChanges << QString(dummy);
                switch(t2->tl_op)
                {
                case PLACEMENT_NORMAL:
                    strcpy(dummy2,"normal");
                    break;
                case PLACEMENT_OPPOSITE:
                    strcpy(dummy2,"opposite");
                    break;
                case PLACEMENT_BOTH:
                    strcpy(dummy2,"both");
                    break;
                }
                sprintf(dummy,"    %s  label place %s",descr_axis,dummy2);
                ListOfOldStates << QString(dummy);
            }
            switch(tabTickMarks->selDrawOn->currentIndex())
            {
            case 0:
                t->t_op = PLACEMENT_NORMAL;
                strcpy(dummy2,"normal");
                break;
            case 1:
                t->t_op = PLACEMENT_OPPOSITE;
                strcpy(dummy2,"opposite");
                break;
            case 2:
                t->t_op = PLACEMENT_BOTH;
                strcpy(dummy2,"both");
                break;
            }
            if (t2->t_op!=t->t_op)
            {
                sprintf(dummy,"    %s  tick place %s",descr_axis,dummy2);
                ListOfChanges << QString(dummy);
                switch(t2->t_op)
                {
                case PLACEMENT_NORMAL:
                    strcpy(dummy2,"normal");
                    break;
                case PLACEMENT_OPPOSITE:
                    strcpy(dummy2,"opposite");
                    break;
                case PLACEMENT_BOTH:
                    strcpy(dummy2,"both");
                    break;
                }
                sprintf(dummy,"    %s  tick place %s",descr_axis,dummy2);
                ListOfOldStates << QString(dummy);
            }
            if (t->active!=t2->active)// && applyto==0)//active will only be changed if we apply to current axis
            {
                sprintf(dummy,"    %s %s",descr_axis,t->active?"on":"off");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s %s",descr_axis,t2->active?"on":"off");
                ListOfOldStates << QString(dummy);
            }
            if (t->zero!=t2->zero)
            {
                sprintf(dummy,"    %s  type zero %s",descr_axis,t->zero?"true":"false");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  type zero %s",descr_axis,t2->zero?"true":"false");
                ListOfOldStates << QString(dummy);
            }
            if (t->tmajor!=t2->tmajor)
            {
                sprintf(dummy,"    %s  tick major %f",descr_axis,t->tmajor);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick major %f",descr_axis,t2->tmajor);
                ListOfOldStates << QString(dummy);
            }
            if (t->nminor!=t2->nminor)
            {
                sprintf(dummy,"    %s  tick minor ticks %d",descr_axis,t->nminor);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick minor ticks %d",descr_axis,t2->nminor);
                ListOfOldStates << QString(dummy);
            }
            if (t->tl_flag!=t2->tl_flag)
            {
                sprintf(dummy,"    %s  ticklabel %s",descr_axis,t->tl_flag?"on":"off");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel %s",descr_axis,t2->tl_flag?"on":"off");
                ListOfOldStates << QString(dummy);
            }
            if (t->t_flag!=t2->t_flag)
            {
                sprintf(dummy,"    %s  tick %s",descr_axis,t->t_flag?"on":"off");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick %s",descr_axis,t2->t_flag?"on":"off");
                ListOfOldStates << QString(dummy);
            }
            if (t->t_drawbar!=t2->t_drawbar)
            {
                sprintf(dummy,"    %s  bar %s",descr_axis,t->t_drawbar?"on":"off");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  bar %s",descr_axis,t2->t_drawbar?"on":"off");
                ListOfOldStates << QString(dummy);
            }
            if (t->t_drawbarlines!=t2->t_drawbarlines)
            {
                sprintf(dummy,"    %s  bar linestyle %d",descr_axis,t->t_drawbarlines);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  bar linestyle %d",descr_axis,t2->t_drawbarlines);
                ListOfOldStates << QString(dummy);
            }
            if (t->t_drawbarcolor!=t2->t_drawbarcolor)
            {
                sprintf(dummy,"    %s  bar color %d",descr_axis,t->t_drawbarcolor);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  bar color %d",descr_axis,t2->t_drawbarcolor);
                ListOfOldStates << QString(dummy);
            }
            if (t->t_drawbarlinew!=t2->t_drawbarlinew)
            {
                sprintf(dummy,"    %s  bar linewidth %f",descr_axis,t->t_drawbarlinew);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  bar linewidth %f",descr_axis,t2->t_drawbarlinew);
                ListOfOldStates << QString(dummy);
            }
            if (!(t->label.s_plotstring==NULL && t2->label.s_plotstring==NULL))
            {
                if ((t->label.s_plotstring!=NULL && t2->label.s_plotstring==NULL) || (t->label.s_plotstring==NULL && t2->label.s_plotstring!=NULL) || (t->label.s_plotstring!=NULL && t2->label.s_plotstring!=NULL && strcmp(t->label.s_plotstring,t2->label.s_plotstring)))
                {
                    sprintf(dummy,"    %s  label \"%s\"",descr_axis,t->label.s_plotstring);
                    ListOfChanges << QString(dummy);
                    sprintf(dummy,"    %s  label \"%s\"",descr_axis,t2->label.s_plotstring);
                    ListOfOldStates << QString(dummy);
                }
            }
            if (t->offsx!=t2->offsx || t->offsy!=t2->offsy)
            {
                sprintf(dummy,"    %s  offset %f , %f",descr_axis,t->offsx,t->offsy);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  offset %f , %f",descr_axis,t2->offsx,t2->offsy);
                ListOfOldStates << QString(dummy);
            }
            if (t->label_layout!=t2->label_layout)
            {
                sprintf(dummy,"    %s  label layout %s",descr_axis,t->label_layout?"para":"perp");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  label layout %s",descr_axis,t2->label_layout?"para":"perp");
                ListOfOldStates << QString(dummy);
            }
            if (t->label_place!=t2->label_place)
            {
                sprintf(dummy,"    %s  label place %s",descr_axis,t->label_place==TYPE_SPEC?"spec":"auto");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  label place %s",descr_axis,t2->label_place==TYPE_SPEC?"spec":"auto");
                ListOfOldStates << QString(dummy);
                if (t->label_place==TYPE_SPEC)
                {
                    sprintf(dummy,"    %s  label place %f, %f",descr_axis,t->label.x,t->label.y);
                    ListOfChanges << QString(dummy);
                }
                if (t2->label_place==TYPE_SPEC)
                {
                    sprintf(dummy,"    %s  label place %f, %f",descr_axis,t2->label.x,t2->label.y);
                    ListOfOldStates << QString(dummy);
                }
            }
            if (t->label.font!=t2->label.font)
            {
                sprintf(dummy,"    %s  label font %d",descr_axis,t->label.font);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  label font %d",descr_axis,t2->label.font);
                ListOfOldStates << QString(dummy);
            }
            if (t->label.color!=t2->label.color)
            {
                sprintf(dummy,"    %s  label color %d",descr_axis,t->label.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  label color %d",descr_axis,t2->label.color);
                ListOfOldStates << QString(dummy);
            }
            if (t->label.charsize!=t2->label.charsize)
            {
                sprintf(dummy,"    %s  label char size %f",descr_axis,t->label.charsize);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  label char size %f",descr_axis,t2->label.charsize);
                ListOfOldStates << QString(dummy);
            }
            if (t->label_op!=t2->label_op)
            {
                sprintf(dummy,"    %s  ticklabel place %s",descr_axis,t->label_op==PLACEMENT_NORMAL?"normal":(t->label_op==PLACEMENT_OPPOSITE?"opposite":"both"));
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel place %s",descr_axis,t2->label_op==PLACEMENT_NORMAL?"normal":(t2->label_op==PLACEMENT_OPPOSITE?"opposite":"both"));
                ListOfOldStates << QString(dummy);
            }
            if (t->tl_font!=t2->tl_font)
            {
                sprintf(dummy,"    %s  ticklabel font %d",descr_axis,t->tl_font);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel font %d",descr_axis,t2->tl_font);
                ListOfOldStates << QString(dummy);
            }
            if (t->tl_color!=t2->tl_color)
            {
                sprintf(dummy,"    %s  ticklabel color %d",descr_axis,t->tl_color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel color %d",descr_axis,t2->tl_color);
                ListOfOldStates << QString(dummy);
            }
            if (t->tl_skip!=t2->tl_skip)
            {
                sprintf(dummy,"    %s  ticklabel skip %d",descr_axis,t->tl_skip);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel skip %d",descr_axis,t2->tl_skip);
                ListOfOldStates << QString(dummy);
            }
            if (t->tl_prec!=t2->tl_prec)
            {
                sprintf(dummy,"    %s  ticklabel prec %d",descr_axis,t->tl_prec);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel prec %d",descr_axis,t2->tl_prec);
                ListOfOldStates << QString(dummy);
            }
            if (t->tl_staggered!=t2->tl_staggered)
            {
                sprintf(dummy,"    %s  ticklabel stagger %d",descr_axis,t->tl_staggered);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel stagger %d",descr_axis,t2->tl_staggered);
                ListOfOldStates << QString(dummy);
            }
            //if (!(t->tl_appstr==NULL && t2->tl_appstr==NULL))
            //if ((t->tl_appstr!=NULL && t2->tl_appstr==NULL)|| (t->tl_appstr==NULL && t2->tl_appstr!=NULL) || (t->tl_appstr!=NULL && t2->tl_appstr!=NULL && strcmp(t->tl_appstr,t2->tl_appstr)))

                if (strcmp(t->tl_appstr,t2->tl_appstr))
                {
                    sprintf(dummy,"    %s  ticklabel append \"%s\"",descr_axis,t->tl_appstr);
                    ListOfChanges << QString(dummy);
                    sprintf(dummy,"    %s  ticklabel append \"%s\"",descr_axis,t2->tl_appstr);
                    ListOfOldStates << QString(dummy);
                }
             //if (!(t->tl_prestr==NULL && t2->tl_prestr==NULL))
             //if ((t->tl_prestr!=NULL && t2->tl_prestr==NULL) || (t->tl_prestr==NULL && t2->tl_prestr!=NULL) || (t->tl_prestr!=NULL && t2->tl_prestr!=NULL && strcmp(t->tl_prestr,t2->tl_prestr)))
                if (strcmp(t->tl_prestr,t2->tl_prestr))
                {
                    sprintf(dummy,"    %s  ticklabel prepend \"%s\"",descr_axis,t->tl_prestr);
                    ListOfChanges << QString(dummy);
                    sprintf(dummy,"    %s  ticklabel prepend \"%s\"",descr_axis,t2->tl_prestr);
                    ListOfOldStates << QString(dummy);
                }
            if (t->tl_starttype!=t2->tl_starttype)
            {
                sprintf(dummy,"    %s  ticklabel start type %s",descr_axis,t->tl_starttype==TYPE_AUTO?"auto":"spec");
                ListOfChanges << QString(dummy);
                if (t->tl_starttype!=TYPE_AUTO)
                {
                    sprintf(dummy,"    %s  ticklabel start %f",descr_axis,t->tl_start);
                    ListOfChanges << QString(dummy);
                }
                sprintf(dummy,"    %s  ticklabel start type %s",descr_axis,t2->tl_starttype==TYPE_AUTO?"auto":"spec");
                ListOfOldStates << QString(dummy);
                if (t2->tl_starttype!=TYPE_AUTO)
                {
                    sprintf(dummy,"    %s  ticklabel start %f",descr_axis,t2->tl_start);
                    ListOfOldStates << QString(dummy);
                }
            }
            if (t->tl_stoptype!=t2->tl_stoptype)
            {
                sprintf(dummy,"    %s  ticklabel stop type %s",descr_axis,t->tl_stoptype==TYPE_AUTO?"auto":"spec");
                ListOfChanges << QString(dummy);
                if (t->tl_stoptype!=TYPE_AUTO)
                {
                    sprintf(dummy,"    %s  ticklabel stop %f",descr_axis,t->tl_stop);
                    ListOfChanges << QString(dummy);
                }
                sprintf(dummy,"    %s  ticklabel stop type %s",descr_axis,t2->tl_stoptype==TYPE_AUTO?"auto":"spec");
                ListOfOldStates << QString(dummy);
                if (t2->tl_stoptype!=TYPE_AUTO)
                {
                    sprintf(dummy,"    %s  ticklabel stop %f",descr_axis,t2->tl_stop);
                    ListOfOldStates << QString(dummy);
                }
            }
            if (t->tl_format!=t2->tl_format)
            {
                sprintf(dummy,"    %s  ticklabel format %s",descr_axis,fmt_option_items[t->tl_format].label);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel format %s",descr_axis,fmt_option_items[t2->tl_format].label);
                ListOfOldStates << QString(dummy);
            }
            if (!(t->tl_formula==NULL && t2->tl_formula==NULL))
                if ((t->tl_formula==NULL && t2->tl_formula!=NULL) || (t->tl_formula!=NULL && t2->tl_formula==NULL) || (t->tl_formula!=NULL && t2->tl_formula!=NULL && strcmp(t->tl_formula,t2->tl_formula)))
                {
                    sprintf(dummy,"    %s  ticklabel formula \"%s\"",descr_axis,t->tl_formula);
                    ListOfChanges << QString(dummy);
                    sprintf(dummy,"    %s  ticklabel formula \"%s\"",descr_axis,t2->tl_formula);
                    ListOfOldStates << QString(dummy);
                }
            if (t->tl_gaptype!=t2->tl_gaptype)
            {
                sprintf(dummy,"    %s  ticklabel offset %s",descr_axis,t->tl_gaptype==TYPE_AUTO?"auto":"spec");
                ListOfChanges << QString(dummy);
                if (t->tl_gaptype == TYPE_SPEC)
                {
                    sprintf(dummy,"    %s  ticklabel offset %f , %f",descr_axis,t->tl_gap.x,t->tl_gap.y);
                    ListOfChanges << QString(dummy);
                }
                sprintf(dummy,"    %s  ticklabel offset %s",descr_axis,t2->tl_gaptype==TYPE_AUTO?"auto":"spec");
                ListOfOldStates << QString(dummy);
                if (t2->tl_gaptype == TYPE_SPEC)
                {
                    sprintf(dummy,"    %s  ticklabel offset %f , %f",descr_axis,t2->tl_gap.x,t2->tl_gap.y);
                    ListOfOldStates << QString(dummy);
                }
            }
            if (t->tl_angle!=t2->tl_angle)
            {
                sprintf(dummy,"    %s  ticklabel angle %d",descr_axis,t->tl_angle);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel angle %d",descr_axis,t2->tl_angle);
                ListOfOldStates << QString(dummy);
            }
            if (t->tl_charsize!=t2->tl_charsize)
            {
                sprintf(dummy,"    %s  ticklabel char size %f",descr_axis,t->tl_charsize);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  ticklabel char size %f",descr_axis,t2->tl_charsize);
                ListOfOldStates << QString(dummy);
            }
            if (t->t_inout!=t2->t_inout)
            {
                sprintf(dummy,"    %s  tick %s",descr_axis,t->t_inout==TICKS_IN?"in":(t->t_inout==TICKS_OUT?"out":"both"));
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick %s",descr_axis,t2->t_inout==TICKS_IN?"in":(t2->t_inout==TICKS_OUT?"out":"both"));
                ListOfOldStates << QString(dummy);
            }

            if (t->props.color!=t2->props.color)
            {
                sprintf(dummy,"    %s  tick major color %d",descr_axis,t->props.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick major color %d",descr_axis,t2->props.color);
                ListOfOldStates << QString(dummy);
            }
            if (t->mprops.color!=t2->mprops.color)
            {
                sprintf(dummy,"    %s  tick minor color %d",descr_axis,t->mprops.color);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick minor color %d",descr_axis,t2->mprops.color);
                ListOfOldStates << QString(dummy);
            }
            if (t->props.linew!=t2->props.linew)
            {
                sprintf(dummy,"    %s  tick major linewidth %f",descr_axis,t->props.linew);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick major linewidth %f",descr_axis,t2->props.linew);
                ListOfOldStates << QString(dummy);
            }
            if (t->mprops.linew!=t2->mprops.linew)
            {
                sprintf(dummy,"    %s  tick minor linewidth %f",descr_axis,t->mprops.linew);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick minor linewidth %f",descr_axis,t2->mprops.linew);
                ListOfOldStates << QString(dummy);
            }
            if (t->props.lines!=t2->props.lines)
            {
                sprintf(dummy,"    %s  tick major linestyle %d",descr_axis,t->props.lines);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick major linestyle %d",descr_axis,t2->props.lines);
                ListOfOldStates << QString(dummy);
            }
            if (t->mprops.lines!=t2->mprops.lines)
            {
                sprintf(dummy,"    %s  tick minor linestyle %d",descr_axis,t->mprops.lines);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick minor linestyle %d",descr_axis,t2->mprops.lines);
                ListOfOldStates << QString(dummy);
            }
            if (t->props.size!=t2->props.size)
            {
                sprintf(dummy,"    %s  tick major size %f",descr_axis,t->props.size);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick major size %f",descr_axis,t2->props.size);
                ListOfOldStates << QString(dummy);
            }
            if (t->mprops.size!=t2->mprops.size)
            {
                sprintf(dummy,"    %s  tick minor size %f",descr_axis,t->mprops.size);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick minor size %f",descr_axis,t2->mprops.size);
                ListOfOldStates << QString(dummy);
            }
            if (t->t_autonum!=t2->t_autonum)
            {
                sprintf(dummy,"    %s  tick default %d",descr_axis,t->t_autonum);
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick default %d",descr_axis,t2->t_autonum);
                ListOfOldStates << QString(dummy);
            }
            if (t->t_round!=t2->t_round)
            {
                sprintf(dummy,"    %s  tick place rounded %s",descr_axis,t->t_round?"true":"false");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick place rounded %s",descr_axis,t2->t_round?"true":"false");
                ListOfOldStates << QString(dummy);
            }
            if (t->props.gridflag!=t2->props.gridflag)
            {
                sprintf(dummy,"    %s  tick major grid %s",descr_axis,t->props.gridflag?"on":"off");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick major grid %s",descr_axis,t2->props.gridflag?"on":"off");
                ListOfOldStates << QString(dummy);
            }
            if (t->mprops.gridflag!=t2->mprops.gridflag)
            {
                sprintf(dummy,"    %s  tick minor grid %s",descr_axis,t->mprops.gridflag?"on":"off");
                ListOfChanges << QString(dummy);
                sprintf(dummy,"    %s  tick minor grid %s",descr_axis,t2->mprops.gridflag?"on":"off");
                ListOfOldStates << QString(dummy);
            }
            if (t->t_spec!=t2->t_spec || t->nticks!=t2->nticks)///TODO: Check for further small differences between t and t2 here
            {
                sprintf(dummy,"    %s  tick spec type %s",descr_axis,t->t_spec==TICKS_SPEC_NONE?"none":(t->t_spec==TICKS_SPEC_BOTH?"both":"ticks"));
                ListOfChanges << QString(dummy);
                if (t->t_spec!=TICKS_SPEC_NONE)
                {
                    sprintf(dummy,"    %s  tick spec %d",descr_axis,t->nticks);
                    ListOfChanges << QString(dummy);
                    for (int l=0;l<t->nticks;l++)
                    {
                        if (t->tloc[l].type==TICK_TYPE_MINOR)
                            strcpy(dummy2,"minor");
                        else
                            strcpy(dummy2,"major");
                        sprintf(dummy,"    %s  tick %s %d, %f",descr_axis,dummy2,l,t->tloc[l].wtpos);
                        ListOfChanges << QString(dummy);
                        if (t->t_spec == TICKS_SPEC_BOTH)
                        {
                            sprintf(dummy,"    %s  ticklabel %d, \"%s\"",descr_axis,l,t->tloc[l].label);
                            ListOfChanges << QString(dummy);
                        }
                    }
                }
                sprintf(dummy,"    %s  tick spec type %s",descr_axis,t2->t_spec==TICKS_SPEC_NONE?"none":(t2->t_spec==TICKS_SPEC_BOTH?"both":"ticks"));
                ListOfOldStates << QString(dummy);

            }
            if (t->tl_alpha != t2->tl_alpha || t->label.alpha != t2->label.alpha || t->t_drawbaralpha != t2->t_drawbaralpha || t->props.alpha != t2->props.alpha || t->mprops.alpha != t2->mprops.alpha)
            {
                sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: AXIS_ALPHA G %d A %d %s\n",i,j,create_list_of_arguments(5, t->tl_alpha,t->label.alpha,t->t_drawbaralpha,t->props.alpha,t->mprops.alpha));
                ListOfChanges << QString(dummy);
                sprintf(dummy,"#QTGRACE_ADDITIONAL_PARAMETER: AXIS_ALPHA G %d A %d %s\n",i,j,create_list_of_arguments(5, t2->tl_alpha,t2->label.alpha,t2->t_drawbaralpha,t2->props.alpha,t2->mprops.alpha));
                ListOfOldStates << QString(dummy);
            }

            /*if (applyto>0 && !(i==get_cg() && j==curaxis))//apply to more than one axis and we are not on the current axis
            {
            tmp_active=t->active;
            t->active=t2->active;
            }*/
            set_graph_tickmarks(i, j, t);//actually do something!!!
            /*if (applyto>0 && !(i==get_cg() && j==curaxis))//apply to more than one axis and we are not on the current axis
            {
            t->active=tmp_active;
            }*/

            //the following commands are neccessary for LaTeX-support (because dynamic strings are coppied dynamically)
            if (i==get_cg() && j==curaxis)
            {
                tabMain->ledAxisLabel->SetTextToMemory(g[i].t[j]->label.s_plotstring,g[i].t[j]->label.alt_plotstring);
                tabTickLabels->ledAppend->SetTextToMemory(g[i].t[j]->tl_appstr,g[i].t[j]->orig_tl_appstr);
                tabTickLabels->ledPrepend->SetTextToMemory(g[i].t[j]->tl_prestr,g[i].t[j]->orig_tl_prestr);
                if (g[i].t[j]->t_spec == TICKS_SPEC_BOTH)
                {
                    for (int k=0;k<g[i].t[j]->nticks;k++)
                    {
                    SetLineEditToMemory(g[i].t[j]->tloc[k].label,g[i].t[j]->tloc[k].orig_label,tabSpecial->text[k],tabSpecial->orig_text[k],tabSpecial->original[k],tabSpecial->ledLabel[k]);
                    //tabSpecial->spreadSpecLabels->axislines[k]->SetTextToMemory(g[i].t[j]->tloc[k].label,g[i].t[j]->tloc[k].orig_label);
                    }
                }
            }

        }//end axes
    }//end graphs
    free_graph_tickmarks(t);
    if (GlobalInhibitor==false)
        mainWin->mainArea->completeRedraw();
    update_ticks(cg);
    //Show actual list of changes
    /*cout << "changes" << endl;
for (i=0;i<ListOfChanges.size();i++)
cout << ListOfChanges.at(i).toLocal8Bit().constData() << endl;
    cout << "old states" << endl;
for (i=0;i<ListOfOldStates.size();i++)
cout << ListOfOldStates.at(i).toLocal8Bit().constData() << endl;*/
    //Undo-Stuff
    TickmarksModified(axis_start,axis_stop,graph_start,graph_stop);
    if (GlobalInhibitor==false)
    {
        ListOfChanges.clear();
        ListOfOldStates.clear();
    }
    return RETURN_SUCCESS;
}

/*
 * This CB services the axis "Scale" selector
 */
void frmAxis_Prop::axis_scale_cb(int value)
{
    ApplyError=false;
    int scale = value;
    double major_space, axestart, axestop;
    int auton;
    char buf[32];
    xv_evalexpr(tabMain->ledMajorSpacing, &major_space);
    xv_evalexpr(ledStart, &axestart);
    xv_evalexpr(ledStop,  &axestop);
    auton = 2+tabTickMarks->setAutotickDiv->currentIndex();
    switch (scale) {
    case SCALE_NORMAL:
        if (major_space <= 0.0) {
            sprintf(buf, "%g", (axestop - axestart)/auton);
            tabMain->ledMajorSpacing->setText(QString(buf));
        }
        tabMain->selMinTicks->setValue(1);/// Changed for 0.2.6
        break;
    case SCALE_LOG:
        if (axestart <= 0.0 && axestop <= 0.0) {
            errmsg(tr("Can't set logarithmic scale for negative coordinates").toLocal8Bit().constData());
            ApplyError=true;
            selScale->setCurrentValue(SCALE_NORMAL);
            return;
        } else if (axestart <= 0.0) {
            axestart = axestop/1.0e3;
            sprintf(buf, "%g", axestart);
            ledStart->setText(QString(buf));
        }
        tabMain->ledMajorSpacing->setText(QString("10"));
        tabMain->selMinTicks->setValue(9);
        break;
    case SCALE_LOGIT:
        if (axestart <= 0.0 && axestop <= 0.0) {
            errmsg(tr("Can't set logit scale for values outside 0 and 1").toLocal8Bit().constData());
            ApplyError=true;
            selScale->setCurrentValue(SCALE_NORMAL);//SetOptionChoice(axis_scale, SCALE_NORMAL);
            return;
        }
        if (axestart <= 0.0) {
            axestart = 0.1;
            sprintf(buf, "%g", axestart);
            ledStart->setText(QString(buf));
        }
        if (axestop >= 1.0) {
            axestop = 0.95;
            sprintf(buf, "%g", axestop);
            ledStop->setText(QString(buf));
        }
        if (major_space >= 1.0) {
            tabMain->ledMajorSpacing->setText(QString("0.6"));
        }
        break;
    }
}

/*
 * Fill 'Axes' dialog with values
 */
void frmAxis_Prop::update_ticks(int gno)
{
    bool old_upd;
    tickmarks *t;
    world w;
    char buf[128];
    int i;
    old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;

    setWindowTitle(tr("QtGrace: Axis (G")+QString::number(gno)+QString(")"));

    redisplayContents();

    t = get_graph_tickmarks(gno, curaxis);
//qDebug() << "ticks=" << t->nticks;
    if (!t)
    {
        immediateUpdate=old_upd;
        updateRunning=false;
        return;
    }
    chkActive->setChecked(is_axis_active(gno, curaxis));
    if (is_axis_active(gno, curaxis) == FALSE)
    {
        tabs->setEnabled(false);
    }
    else
    {
        tabs->setEnabled(true);
    }
    selEdit->setCurrentValue(curaxis);
    tabMain->chkZeroAxis->setChecked(is_zero_axis(gno, curaxis));
    get_graph_world(gno, &w);
    if (is_xaxis(curaxis))
    {
        ledStart->setDoubleValue("%.16g", w.xg1);
        //sprintf(buf, "%.9g", w.xg1);
        //ledStart->setText(QString(buf));
        //xv_setstr(axis_world_start, buf);
        ledStop->setDoubleValue("%.16g", w.xg2);
        //sprintf(buf, "%.9g", w.xg2);
        //ledStop->setText(QString(buf));
        //xv_setstr(axis_world_stop, buf);
        selScale->setCurrentValue(get_graph_xscale(gno));
        chkInvAxis->setChecked(is_graph_xinvert(gno));
    }
    else
    {
        ledStart->setDoubleValue("%.16g", w.yg1);
        //sprintf(buf, "%.9g", w.yg1);
        //ledStart->setText(QString(buf));
        //xv_setstr(axis_world_start, buf);
        ledStop->setDoubleValue("%.16g", w.yg2);
        //sprintf(buf, "%.9g", w.yg2);
        //ledStop->setText(QString(buf));
        //xv_setstr(axis_world_stop, buf);
        selScale->setCurrentValue(get_graph_yscale(gno));
        chkInvAxis->setChecked(is_graph_yinvert(gno));
    }
    tabMain->ledOffsetNormal->setDoubleValue("%.4f",t->offsx);
    //sprintf(buf, "%.4f", t->offsx);
    //tabMain->ledOffsetNormal->setText(QString(buf));
    //xv_setstr(offx, buf);
    tabMain->ledOffsetOpposite->setDoubleValue("%.4f",t->offsy);
    //sprintf(buf, "%.4f", t->offsy);
    //tabMain->ledOffsetOpposite->setText(QString(buf));
    //xv_setstr(offy, buf);
    tabLabelsBars->selLayout->setCurrentIndex(t->label_layout == LAYOUT_PERPENDICULAR ? 1 : 0);
    tabLabelsBars->selLocation->setCurrentIndex(t->label_place);
    tabLabelsBars->ledParaOffs->setDoubleValue("%.4f",t->label.x);
    //tabLabelsBars->ledParaOffs->setText(QString(buf));
    //sprintf(buf, "%.4f", t->label.x);
    //xv_setstr(axislabelspec_para, buf);
    tabLabelsBars->ledPerpendOffs->setDoubleValue("%.4f",t->label.y);
    //tabLabelsBars->ledPerpendOffs->setText(QString(buf));
    //sprintf(buf, "%.4f", t->label.y);
    //xv_setstr(axislabelspec_perp, buf);
    tabLabelsBars->ledParaOffs->setEnabled(t->label_place == TYPE_SPEC);
    tabLabelsBars->ledPerpendOffs->setEnabled(t->label_place == TYPE_SPEC);
    tabLabelsBars->selLabelFont->setCurrentIndex(t->label.font);
    tabLabelsBars->selLabelColor->setCurrentIndex(t->label.color);
    tabLabelsBars->selLabelColor->setAlpha(t->label.alpha);
    tabLabelsBars->sldCharSize->setValue((int)rint_2(100.0*t->label.charsize));
    switch(t->label_op)
    {
    case PLACEMENT_NORMAL:
        tabLabelsBars->selSide->setCurrentIndex(0);
        break;
    case PLACEMENT_OPPOSITE:
        tabLabelsBars->selSide->setCurrentIndex(1);
        break;
    case PLACEMENT_BOTH:
        tabLabelsBars->selSide->setCurrentIndex(2);
        break;
    }
    tabMain->chkDisplTickLabels->setChecked((bool)t->tl_flag);
    tabMain->chkDisplTickMarks->setChecked((bool)t->t_flag);
    tabMain->chkDisplAxixBar->setChecked((bool)t->t_drawbar);
    tabMain->ledAxisLabel->SetTextToMemory(g[gno].t[curaxis]->label.s_plotstring,g[gno].t[curaxis]->label.alt_plotstring);
    //tabMain->ledAxisLabel->setText(QString(t->label.s));
    if (is_log_axis(gno, curaxis))
    {
        if (t->tmajor <= 1.0)
        {
            t->tmajor = 10.0;
        }
        //sprintf(buf, "%g", t->tmajor);
        tabMain->ledMajorSpacing->setDoubleValue("%g",t->tmajor);
    }
    else if (is_logit_axis(gno, curaxis))
    {
        if (t->tmajor <= 0.0)
        {
            t->tmajor = 0.1;
        }
        else if (t->tmajor >= 0.5)
        {
            t->tmajor = 0.4;
        }
        tabMain->ledMajorSpacing->setDoubleValue("%g",t->tmajor);
        //sprintf(buf, "%g", t->tmajor);
    }
    else if (t->tmajor > 0)
    {
        tabMain->ledMajorSpacing->setDoubleValue("%g",t->tmajor);
        //sprintf(buf, "%g", t->tmajor);
    }
    else
    {
        tabMain->ledMajorSpacing->setText(tr("UNDEFINED"));
    }
    //tabMain->ledMajorSpacing->setText(QString(buf));
    //xv_setstr(tmajor, buf);
    tabMain->selMinTicks->setValue(t->nminor);
    //SetSpinChoice(nminor, t->nminor);
    tabMain->selTickLabelFont->setCurrentIndex(t->tl_font);
    tabMain->selTickLabelColor->setCurrentIndex(t->tl_color);
    tabMain->selTickLabelColor->setAlpha(t->tl_alpha);
    tabTickLabels->selSkipEvery->setCurrentIndex(t->tl_skip);
    tabTickLabels->selStagger->setCurrentIndex(t->tl_staggered);

    //tabTickLabels->ledAppend->setText(QString(t->tl_appstr));
    //tabTickLabels->ledPrepend->setText(QString(t->tl_prestr));
    tabTickLabels->ledAppend->SetTextToMemory(g[gno].t[curaxis]->tl_appstr,g[gno].t[curaxis]->orig_tl_appstr);
    tabTickLabels->ledPrepend->SetTextToMemory(g[gno].t[curaxis]->tl_prestr,g[gno].t[curaxis]->orig_tl_prestr);

    tabTickLabels->selStartAt->setCurrentIndex(t->tl_starttype == TYPE_SPEC?1:0);
    /*xv_setstr(tlappstr, t->tl_appstr);
        xv_setstr(tlprestr, t->tl_prestr);*/
    //SetChoice(tlstarttype, t->tl_starttype == TYPE_SPEC);
    if (t->tl_starttype == TYPE_SPEC)
    {
        sprintf(buf, "%g", t->tl_start);
        SetDecimalSeparatorToUserValue(buf);
        tabTickLabels->ledStart->setText(QString(buf));
    }
    //else
    //tabTickLabels->ledStart->setText("");
    tabTickLabels->selStopAt->setCurrentIndex(t->tl_stoptype== TYPE_SPEC?1:0);
    if (t->tl_stoptype == TYPE_SPEC)
    {
        sprintf(buf, "%g", t->tl_stop);
        SetDecimalSeparatorToUserValue(buf);
        tabTickLabels->ledStop->setText(QString(buf));
    }
    //else
    //tabTickLabels->ledStop->setText("");
    tabMain->selFormat->setCurrentIndex(t->tl_format);
    tabMain->selPrecision->setCurrentIndex(t->tl_prec);
    if (t->tl_formula!=NULL)
        strcpy(buf,t->tl_formula);
    else
        strcpy(buf,"");
    RedisplayFormula(buf);
    tabTickLabels->ledAxisTransform->setText(QString(buf));
    switch (t->tl_op)
    {
    case PLACEMENT_NORMAL:
        tabTickLabels->selSide->setCurrentIndex(0);
        break;
    case PLACEMENT_OPPOSITE:
        tabTickLabels->selSide->setCurrentIndex(1);
        break;
    case PLACEMENT_BOTH:
        tabTickLabels->selSide->setCurrentIndex(2);
        break;
    }
    tabTickLabels->selLocation->setCurrentIndex(t->tl_gaptype==TYPE_AUTO?0:1);
    tabTickLabels->ledParaOffs->setDoubleValue("%.4f",t->tl_gap.x);
    //sprintf(buf, "%.4f", t->tl_gap.x);
    //tabTickLabels->ledParaOffs->setText(QString(buf));
    //xv_setstr(tlgap_para, buf);
    tabTickLabels->ledPerpendOffs->setDoubleValue("%.4f",t->tl_gap.y);
    //sprintf(buf, "%.4f", t->tl_gap.y);
    //tabTickLabels->ledPerpendOffs->setText(QString(buf));
    //xv_setstr(tlgap_perp, buf);
    tabTickLabels->ledParaOffs->setEnabled(t->tl_gaptype == TYPE_SPEC);
    tabTickLabels->ledPerpendOffs->setEnabled(t->tl_gaptype == TYPE_SPEC);
    tabTickLabels->sldCharAngle->setValue(t->tl_angle);
    tabTickLabels->sldCharSize->setValue((int)rint_2(t->tl_charsize*100.0));
    switch (t->t_inout)
    {
    case TICKS_IN:
        tabTickMarks->selPointing->setCurrentIndex(0);
        break;
    case TICKS_OUT:
        tabTickMarks->selPointing->setCurrentIndex(1);
        break;
    case TICKS_BOTH:
        tabTickMarks->selPointing->setCurrentIndex(2);
        break;
    }
    switch (t->t_op)
    {
    case PLACEMENT_NORMAL:
        tabTickMarks->selDrawOn->setCurrentIndex(0);
        break;
    case PLACEMENT_OPPOSITE:
        tabTickMarks->selDrawOn->setCurrentIndex(1);
        break;
    case PLACEMENT_BOTH:
        tabTickMarks->selDrawOn->setCurrentIndex(2);
        break;
    }
    tabTickMarks->selMajTickColor->setCurrentIndex(t->props.color);
    tabTickMarks->selMajTickColor->setAlpha(t->props.alpha);
    tabTickMarks->selMajTickWidth->setValue(t->props.linew);
    tabTickMarks->selMajTickStyle->setCurrentIndex(t->props.lines);
    tabTickMarks->selMinTickColor->setCurrentIndex(t->mprops.color);
    tabTickMarks->selMinTickColor->setAlpha(t->mprops.alpha);
    tabTickMarks->selMinTickWidth->setValue(t->mprops.linew);
    tabTickMarks->selMinTickStyle->setCurrentIndex(t->mprops.lines);
    tabTickMarks->sldMajTickLength->setValue((int)rint_2(100.0*t->props.size));
    tabTickMarks->sldMinTickLength->setValue((int)rint_2(100.0*t->mprops.size));
    tabTickMarks->setAutotickDiv->setCurrentIndex(t->t_autonum - 2);
    tabTickMarks->chkPlaceRoundPos->setChecked((bool)t->t_round);
    tabTickMarks->chkDrawMajGrid->setChecked((bool)t->props.gridflag);
    tabTickMarks->chkDrawMinGrid->setChecked((bool)t->mprops.gridflag);
    tabLabelsBars->selBarColor->setCurrentIndex(t->t_drawbarcolor);
    tabLabelsBars->selBarColor->setAlpha(t->t_drawbaralpha);
    tabLabelsBars->selBarWidth->setValue(t->t_drawbarlinew);
    tabLabelsBars->selBarStyle->setCurrentIndex(t->t_drawbarlines);
    tabSpecial->selSpecTicks->setCurrentValue(t->t_spec);
    tabSpecial->selNumber->setValue(t->nticks);
char * ni=NULL;
    for (i = 0; i < t->nticks; i++)
    {
        sprintf(buf, "%.9g", t->tloc[i].wtpos);
        SetDecimalSeparatorToUserValue(buf);
        //tabSpecial->spreadSpecLabels->axislines[i]->ledLocation->setText(QString(buf));
        tabSpecial->ledLocation[i]->setText(QString(buf));
        //xv_setstr(specloc[i], buf);
        if (t->tloc[i].type == TICK_TYPE_MAJOR)
        {
        SetLineEditToMemory(g[gno].t[curaxis]->tloc[i].label,g[gno].t[curaxis]->tloc[i].orig_label,tabSpecial->text[i],tabSpecial->orig_text[i],tabSpecial->original[i],tabSpecial->ledLabel[i]);
        //tabSpecial->spreadSpecLabels->axislines[i]->SetTextToMemory(g[gno].t[curaxis]->tloc[i].label,g[gno].t[curaxis]->tloc[i].orig_label);
            //tabSpecial->spreadSpecLabels->axislines[i]->ledLabel->setText(QString(t->tloc[i].label));
            //xv_setstr(speclabel[i], t->tloc[i].label);
        }
        else
        {
        SetLineEditToMemory(ni,ni,tabSpecial->text[i],tabSpecial->orig_text[i],tabSpecial->original[i],tabSpecial->ledLabel[i]);
        //tabSpecial->spreadSpecLabels->axislines[i]->SetTextToMemory(ni,ni);
            //tabSpecial->spreadSpecLabels->axislines[i]->ledLabel->setText(QString(""));
            //xv_setstr(speclabel[i], "");
        }
    }
    strcpy(buf,"");
    for (i = (t->nticks>=0?t->nticks:0); i < MAX_TICKS; i++)
    {
    SetLineEditToMemory(ni,ni,tabSpecial->text[i],tabSpecial->orig_text[i],tabSpecial->original[i],tabSpecial->ledLabel[i]);
    //tabSpecial->spreadSpecLabels->axislines[i]->SetTextToMemory(ni,ni);//only affects the label
        tabSpecial->ledLocation[i]->setText(QString(buf));
        //tabSpecial->spreadSpecLabels->axislines[i]->ledLocation->setText(QString(buf));
        //tabSpecial->spreadSpecLabels->axislines[i]->ledLabel->setText(QString(buf));
    }
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmAxis_Prop::set_active_proc(int onoff)
{
    tabs->setEnabled((bool)onoff);
}

void frmAxis_Prop::set_axis_proc(int value)
{
    curaxis = value;
    update_ticks(cg);
}

void frmAxis_Prop::create_axes_dialog(int axisno)
{
    if (axisno >= 0 && axisno < MAXAXES)
    {
        curaxis = axisno;
    }
    update_ticks(cg);
}

void frmAxis_Prop::redisplayContents(void)
{
    if (DecimalPointToUse=='.')
    {
        tabLabelsBars->selBarWidth->spnLineWidth->setLocale(*dot_locale);
        tabTickMarks->selMajTickWidth->spnLineWidth->setLocale(*dot_locale);
        tabTickMarks->selMinTickWidth->spnLineWidth->setLocale(*dot_locale);
    }
    else
    {
        tabLabelsBars->selBarWidth->spnLineWidth->setLocale(*comma_locale);
        tabTickMarks->selMajTickWidth->spnLineWidth->setLocale(*comma_locale);
        tabTickMarks->selMinTickWidth->spnLineWidth->setLocale(*comma_locale);
    }
    if (OldDecimalPoint==DecimalPointToUse) return;
    tabMain->ledMajorSpacing->ReplaceNumberContents();
    ledStart->ReplaceNumberContents();
    ledStop->ReplaceNumberContents();
    tabMain->ledOffsetNormal->ReplaceNumberContents();
    tabMain->ledOffsetOpposite->ReplaceNumberContents();
    tabLabelsBars->ledParaOffs->ReplaceNumberContents();
    tabLabelsBars->ledPerpendOffs->ReplaceNumberContents();
    tabLabelsBars->selBarWidth->setValue(tabLabelsBars->selBarWidth->value());
    tabTickLabels->ledParaOffs->ReplaceNumberContents();
    tabTickLabels->ledPerpendOffs->ReplaceNumberContents();
    QString te=tabTickLabels->ledAxisTransform->text();
    strcpy(dummy,te.toLatin1().constData());
    RedisplayFormula(dummy);
    tabTickLabels->ledAxisTransform->setText(QString(dummy));/// Formula-transformation???
    te=tabTickLabels->ledStart->text();
    Replace_Dec_Sep_In_Single_String(te);
    //te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
    tabTickLabels->ledStart->setText(te);/// Formula-transformation???
    te=tabTickLabels->ledStop->text();
    Replace_Dec_Sep_In_Single_String(te);
    //te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
    tabTickLabels->ledStop->setText(te);/// Formula-transformation???
    tabTickMarks->selMajTickWidth->setValue(tabTickMarks->selMajTickWidth->value());
    tabTickMarks->selMinTickWidth->setValue(tabTickMarks->selMinTickWidth->value());
    //for (int i = 0; i < tabSpecial->spreadSpecLabels->rows; i++)
    for (int i = 0; i < MAX_TICKS; i++)
    {
        //te=tabSpecial->spreadSpecLabels->axislines[i]->ledLocation->text();
        te=tabSpecial->ledLocation[i]->text();
        if (!te.isEmpty())
        {
            //te.replace(QChar(OldDecimalPoint),QChar(DecimalPointToUse));
            Replace_Dec_Sep_In_Single_String(te);
            tabSpecial->ledLocation[i]->setText(te);
            //tabSpecial->spreadSpecLabels->axislines[i]->ledLocation->setText(te);
        }
    }
}

void frmAxis_Prop::doQuickNormalTicks(void)
{
int cur_gr=get_cg();
//int sav_undo_active=undo_active;
    //Undo-Stuff
    SaveTickmarksStatesPrevious(curaxis,curaxis,cur_gr,cur_gr);
    ListOfChanges.clear();
    ListOfOldStates.clear();
//qDebug() << "Resetting ticks to default";
    quickSetAxisFormat(cur_gr,curaxis,QUICK_AXIS_TRANSFORM_NORMAL);
/*tabTickLabels->ledAxisTransform->setText(QString(""));
strcpy(g[cur_gr].t[curaxis]->tl_appstr,"");
strcpy(g[cur_gr].t[curaxis]->orig_tl_appstr,"");
tabTickLabels->ledAppend->SetTextToMemory(g[cur_gr].t[curaxis]->tl_appstr,g[cur_gr].t[curaxis]->orig_tl_appstr);*/

//undo_active=FALSE;
//mainWin->mainArea->compl_redraw_running=true;
doApply();
//autotick_axis(cur_gr,curaxis);
//mainWin->mainArea->compl_redraw_running=false;
//undo_active=sav_undo_active;
    //Undo-Stuff
/*    TickmarksModified(curaxis,curaxis,cur_gr,cur_gr);
    ListOfChanges.clear();
    ListOfOldStates.clear();
mainWin->mainArea->completeRedraw();*/
}

void frmAxis_Prop::doQuickDegreesTicks(void)
{
int cur_gr=get_cg();
    //Undo-Stuff
    SaveTickmarksStatesPrevious(curaxis,curaxis,cur_gr,cur_gr);
    ListOfChanges.clear();
    ListOfOldStates.clear();
//qDebug() << "Setting ticks to degrees";
    quickSetAxisFormat(cur_gr,curaxis,QUICK_AXIS_TRANSFORM_DEGREES);
/*tabTickLabels->ledAxisTransform->setText(QString("$t*180.0/PI"));
strcpy(g[cur_gr].t[curaxis]->tl_appstr,"\\c:");
strcpy(g[cur_gr].t[curaxis]->orig_tl_appstr,"\\c:");
tabTickLabels->ledAppend->SetTextToMemory(g[cur_gr].t[curaxis]->tl_appstr,g[cur_gr].t[curaxis]->orig_tl_appstr);
tabMain->ledMajorSpacing->setText(QString("PI/2"));*/
doApply();
}

void frmAxis_Prop::doQuickPisTricks(void)
{
int cur_gr=get_cg();
    //Undo-Stuff
    SaveTickmarksStatesPrevious(curaxis,curaxis,cur_gr,cur_gr);
    ListOfChanges.clear();
    ListOfOldStates.clear();
//qDebug() << "Setting ticks to Multiples of Pi";
    quickSetAxisFormat(cur_gr,curaxis,QUICK_AXIS_TRANSFORM_MULT_PI);
/*tabTickLabels->ledAxisTransform->setText(QString("$t/PI"));
strcpy(g[cur_gr].t[curaxis]->tl_appstr,"\\xp");//"\\c7\\C\\xp"
strcpy(g[cur_gr].t[curaxis]->orig_tl_appstr,"\\xp");
tabTickLabels->ledAppend->SetTextToMemory(g[cur_gr].t[curaxis]->tl_appstr,g[cur_gr].t[curaxis]->orig_tl_appstr);
tabMain->ledMajorSpacing->setText(QString("PI/2"));*/
doApply();
}

void frmAxis_Prop::update0(void)
{
    static int i,nr;//,errpos;
    bool imm_upd_sav;
    if (!immediateUpdate) return;
    imm_upd_sav=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    GlobalInhibitor=true;
    doApply();//do this without actually doing something
    nr=nr_of_true_changes(ListOfChanges);
    //errpos=0;
    if (nr>0)
    {
        for (i=0;i<ListOfChanges.size();i++)
        {
            strcpy(command,ListOfChanges.at(i).toLocal8Bit().constData());
            //errpos = scanner(command);
            (void)scanner(command);
        }
        set_dirtystate();
        mainWin->mainArea->completeRedraw();
    }
    ListOfChanges.clear();
    ListOfOldStates.clear();
    GlobalInhibitor=false;
    immediateUpdate=imm_upd_sav;
    updateRunning=false;
}

void frmAxis_Prop::update1(int v)
{
    (void)v;
    update0();
}

void frmAxis_Prop::update2(QString v)
{
    (void)v;
    update0();
}

void frmAxis_Prop::update3(bool v)
{
    (void)v;
    update0();
}

void frmAxis_Prop::update4(double v)
{
    (void)v;
    update0();
}

frmAxisProp::frmAxisProp(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
     min_w=545;
     min_h=623;
    setWindowTitle(tr("QtGrace: Axis"));
    setWindowIcon(QIcon(*GraceIcon));
    QVBoxLayout * layout=new QVBoxLayout;
    layout->setMargin(0);
    layout->setSpacing(0);
    flp=new frmAxis_Prop(this);
    connect(flp,SIGNAL(closeWish()),SLOT(close()));
    //layout->addWidget(flp);

    scroll=new QScrollArea(this);
    scroll->setWidget(flp);
    layout->addWidget(scroll);

     //bar_w=scroll->verticalScrollBar()->width();
     //bar_h=scroll->horizontalScrollBar()->height();
     bar_w=bar_h=20;//15
    setLayout(layout);
    //resize(min_w,min_h);
    resize(LastSize_FormAxisProperties);
}

frmAxisProp::~frmAxisProp()
{
    LastSize_FormAxisProperties=this->size();
}

void frmAxisProp::update_ticks(int gno)
{
    flp->update_ticks(gno);
}

void frmAxisProp::create_axes_dialog(int axisno)
{
    flp->create_axes_dialog(axisno);
}

void frmAxisProp::doAccept(void)
{
    flp->doAccept();
}

void frmAxisProp::doClose(void)
{
    hide();
}

void frmAxisProp::resizeEvent(QResizeEvent * event)
{
//cout << "resize: " << event->size().width() << "x" << event->size().height() << " bar_w=" << bar_w << " bar_h=" << bar_h << endl;
int n_size_w=event->size().width(),n_size_h=event->size().height();
int actual_space_w=n_size_w,actual_space_h=n_size_h;
if (small_screen_adjustments & 2)
{
for (int i=0;i<2;i++)
{
        if (actual_space_w<min_w)
        {
        n_size_w=min_w;
        actual_space_h=event->size().height()-bar_h;
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
        }
        else
        {
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        }
    if (actual_space_h<min_h)
    {
    n_size_h=min_h;
    actual_space_w=event->size().width()-bar_w;
    scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    }
    else
    {
    scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    }
}
if (scroll->verticalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_w-=bar_w;
if (scroll->horizontalScrollBarPolicy()==Qt::ScrollBarAlwaysOn) n_size_h-=bar_h;
this->setMinimumSize(0,0);
}
else
{
scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
this->setMinimumSize(min_w,min_h);
}
flp->resize(QSize(n_size_w,n_size_h));
}

frmNetCDF::frmNetCDF(QWidget * parent):QDialog(parent)
{
    cmdQuery=new QPushButton(tr("Close"),this);
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: netCDF"));
    setWindowIcon(QIcon(*GraceIcon));
    lblSelX=new QLabel(tr("Select set X:"));
    lblSelY=new QLabel(tr("Select set Y:"));
    netcdf_listx_item=new uniList(TEXTLIST,this);
    netcdf_listy_item=new uniList(TEXTLIST,this);
    netcdf_listx_item->setBehavior(true,false,false);
    netcdf_listy_item->setBehavior(true,false,false);
    netcdf_file_item=new stdLineEdit(this,tr("netCDF file:"));
    netcdf_file_item->lenText->setText(QString(""));
    buttonGroup=new stdButtonGroup(this,true,true,true);
    buttonGroup->layout->addWidget(cmdQuery);
    buttonGroup->cmdApply->setText(tr("Accept"));
    buttonGroup->cmdAccept->setText(tr("Files..."));
    buttonGroup->cmdClose->setText(tr("Update"));
    buttonGroup->cmdHelp->setText(tr("Query"));
    cmdQuery->setDefault(false);
    buttonGroup->cmdApply->setDefault(true);

    connect(buttonGroup->cmdAccept,SIGNAL(clicked()),this,SLOT(doFiles()));
    connect(buttonGroup->cmdClose,SIGNAL(clicked()),this,SLOT(update_netcdfs()));
    connect(buttonGroup->cmdApply,SIGNAL(clicked()),this,SLOT(do_netcdf_proc()));
    connect(buttonGroup->cmdHelp,SIGNAL(clicked()),this,SLOT(do_netcdfquery_proc()));
    connect(cmdQuery,SIGNAL(clicked()),this,SLOT(doClose()));

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->addWidget(lblSelX);
    layout->addWidget(netcdf_listx_item);
    layout->addWidget(lblSelY);
    layout->addWidget(netcdf_listy_item);
    layout->addWidget(netcdf_file_item);
    layout->addWidget(buttonGroup);
    setLayout(layout);
    resize(LastSize_FormNetCDF);
}

frmNetCDF::~frmNetCDF()
{
    LastSize_FormNetCDF=this->size();
}

void frmNetCDF::init(void)
{
    update_netcdfs();
}

void frmNetCDF::doFiles(void)
{
if (should_open_grace_file_dialog())
{
    if (FormReadNetCDF==NULL)
    {
        FormReadNetCDF=new frmIOForm(READ_NETCDF_FORM,this);
        connect(FormReadNetCDF,SIGNAL(newFileSelectedForIO(int,QString,bool,bool,bool)),SLOT(IOrequested(int,QString,bool,bool,bool)));
    }
    FormReadNetCDF->init();
    FormReadNetCDF->show();
    FormReadNetCDF->raise();
    FormReadNetCDF->activateWindow();
}
else
{
mainWin->UseOperatingSystemFileDialog(READ_NETCDF_FORM,tr("QtGrace: Select netCDF file"),Last_Dialog_Path[READ_NETCDF_FORM],tr("Netcdf files (*.nc);;All files (*)"));
}
}

void frmNetCDF::IOrequested(int type,QString file,bool exists,bool writeable,bool readable)
{
    (void)type;
    (void)writeable;
    char * filename=new char[file.length()+5];
    strcpy(filename,file.toLocal8Bit());
    char * dummy=new char[strlen(filename)+30];
    sprintf(dummy,"%s%s.",tr("Can't open file ").toLocal8Bit().constData(),filename);
    if (exists==true && readable==true)
    {
        xv_setstr(netcdf_file_item, filename);
        update_netcdfs();
        if (FormReadNetCDF)
        FormReadNetCDF->hide();
    }
    else
    {
        errwin(dummy);
    }
    delete[] dummy;
    delete[] filename;
}

void frmNetCDF::doClose(void)
{
    hide();
}

void frmNetCDF::update_netcdfs(void)
{
    int i;
    char buf[256], fname[512];
    QString xms;
    //int cdfid;			/* netCDF id */
    int ndims=0, nvars=0;//, ngatts, recdim;
    //int var_id;
    char varname[256];
    /*nc_type datatype = 0;
    int dim[100], natts;
    long dimlen[100];
    long len;*/

    set_wait_cursor();

    ncopts = 0;			/* no crash on error */

    //if (netcdf_frame != NULL) {
    strcpy(fname, xv_getstr(netcdf_file_item));
    set_wait_cursor();
    netcdf_listx_item->clear();
    //XmListDeleteAllItems(netcdf_listx_item);
    netcdf_listy_item->clear();
    //XmListDeleteAllItems(netcdf_listy_item);
    xms = tr("INDEX");
    netcdf_listx_item->add_Item(xms);
    //XmListAddItemUnselected(netcdf_listx_item, xms, 0);
    //XmStringFree(xms);

    if (strlen(fname) < 2) {
        unset_wait_cursor();
        return;
    }
#ifdef HAVE_NETCDF
    if ((cdfid = ncopen(fname, NC_NOWRITE)) == -1) {
        errmsg(tr("Can't open file.").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }

    ncinquire(cdfid, &ndims, &nvars, &ngatts, &recdim);
    for (i = 0; i < ndims; i++) {
        ncdiminq(cdfid, i, NULL, &dimlen[i]);
    }
#endif
    for (i = 0; i < nvars; i++) {
#ifdef HAVE_NETCDF
        ncvarinq(cdfid, i, varname, &datatype, &ndims, dim, &natts);

        if ((var_id = ncvarid(cdfid, varname)) == -1) {
            char ebuf[256];
            sprintf(ebuf, "update_netcdfs(): %s %s",tr("No such variable").toLocal8Bit().constData(), varname);
            errmsg(ebuf);
            continue;
        }
#endif
        if (ndims != 1) {
            continue;
        }
#ifdef HAVE_NETCDF
        ncdiminq(cdfid, dim[0], (char *) NULL, &len);
#endif
        sprintf(buf, "%s", varname);
        xms = QString(buf);
        netcdf_listx_item->addItem(xms);
        //XmListAddItemUnselected(netcdf_listx_item, xms, 0);
        netcdf_listy_item->addItem(xms);
        //XmListAddItemUnselected(netcdf_listy_item, xms, 0);
        //XmStringFree(xms);
    }
#ifdef HAVE_NETCDF
    ncclose(cdfid);
#endif
    unset_wait_cursor();
    //}
}

void frmNetCDF::do_netcdf_proc(void)
{
    #ifdef HAVE_NETCDF
    int setno;
    #endif
    char xvar[256], yvar[256];
    QString *s=new QString(), cs;
    int *pos_list=new int[5];
    int pos_cnt, retval=RETURN_FAILURE;//j,cnt
    char cstr[256];
    set_wait_cursor();
/*
 * setno == -1, then next set
 */
    #ifdef HAVE_NETCDF
    setno = -1;
    #endif
    netcdf_listx_item->get_selection(&pos_cnt,&pos_list);
    if (pos_cnt) {//XmListGetSelectedPos(netcdf_listx_item, &pos_list, &pos_cnt)) {
        /*XtVaGetValues(netcdf_listx_item,
                      XmNselectedItemCount, &cnt,
                      XmNselectedItems, &s,
                      NULL);*/
        //cnt=pos_cnt;
        sprintf(cstr,"%d",pos_list[0]);
        *s=QString(cstr);
        cs = *s;//XmStringCopy(*s);
        strcpy(cstr,cs.toLocal8Bit());
        //if ((cstr = GetStringSimple(cs))) {
        if (strlen(cstr)) {
            strcpy(xvar, cstr);
            //XtFree(cstr);
        }
        //XmStringFree(cs);
    } else {
        errmsg(tr("Need to select X, either variable name or INDEX").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
    netcdf_listy_item->get_selection(&pos_cnt,&pos_list);
    if (pos_cnt) {//XmListGetSelectedPos(netcdf_listy_item, &pos_list, &pos_cnt)) {
        //j = pos_list[0];
        /*XtVaGetValues(netcdf_listy_item,
                      XmNselectedItemCount, &cnt,
                      XmNselectedItems, &s,
                      NULL);*/
        //cnt=pos_cnt;
        sprintf(cstr,"%d",pos_list[0]);
        *s=QString(cstr);
        cs = *s;//XmStringCopy(*s);
        strcpy(cstr,cs.toLocal8Bit());
        //if ((cstr = GetStringSimple(cs))) {
        if (strlen(cstr)) {
            strcpy(yvar, cstr);
            //XtFree(cstr);
        }
        //XmStringFree(cs);
    } else {
        errmsg(tr("Need to select Y").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
    if (strcmp(xvar, "INDEX") == 0) {
#ifdef HAVE_NETCDF
        retval = readnetcdf(get_cg(), setno, fname, NULL, yvar, -1, -1, 1);
#endif
    } else {
#ifdef HAVE_NETCDF
        retval = readnetcdf(get_cg(), setno, fname, xvar, yvar, -1, -1, 1);
#endif
    }
    if (retval) {
        mainWin->mainArea->completeRedraw();//xdrawgraph();
    }
    delete[] pos_list;
    delete s;

    unset_wait_cursor();
}

const char * frmNetCDF::getcdf_type(nc_type datatype)
{
    switch (datatype) {
    case NC_SHORT:
        return "NC_SHORT";
        break;
    case NC_LONG:
        return "NC_LONG";
        break;
    case NC_FLOAT:
        return "NC_FLOAT";
        break;
    case NC_DOUBLE:
        return "NC_DOUBLE";
        break;
    default:
        return "UNKNOWN (can't read this)";
        break;
    }
}

void frmNetCDF::do_netcdfquery_proc(void)
{
    char xvar[256], yvar[256];
    char buf[256], fname[512];
    int s, cs;
    int *pos_list=new int[5];
    int i=0, pos_cnt=0;//, cnt;
    char cstr[256];
//int cdfid;			/* netCDF id */
    nc_type datatype = 0;
    float f=0.0;
    double d=0.0;
//int x_id, y_id;
    nc_type xdatatype = 0;
    nc_type ydatatype = 0;
    int xnatts=0, ynatts=0;
    /*int xndims, xdim[10];
    int yndims, ydim[10];*/
    long nx=0, ny=0;

    int atlen=0;
    char attname[256];
    char atcharval[256];

    ncopts = 0;			/* no crash on error */

    set_wait_cursor();

    strcpy(fname, xv_getstr(netcdf_file_item));
#ifdef HAVE_NETCDF
    if ((cdfid = ncopen(fname, NC_NOWRITE)) == -1) {
        errmsg(tr("Can't open file.").toLocal8Bit().constData());
        unset_wait_cursor();
        return;
    }
#endif
    netcdf_listx_item->get_selection(&pos_cnt,&pos_list);
    if (pos_cnt) {//XmListGetSelectedPos(netcdf_listx_item, &pos_list, &pos_cnt)) {
        /*XtVaGetValues(netcdf_listx_item,
                      XmNselectedItemCount, &cnt,
                      XmNselectedItems, &s,
                      NULL);*/
        //cnt=pos_cnt;
        s=pos_list[0];
        cs = s;//XmStringCopy(*s);
        strcpy(cstr,netcdf_listx_item->text_entries[cs].toLocal8Bit().constData());
        if (strlen(cstr)) {//(cstr = GetStringSimple(cs))) {
            strcpy(xvar, cstr);
            //XtFree(cstr);
        }
        //XmStringFree(cs);
    } else {
        errmsg(tr("Need to select X, either variable name or INDEX").toLocal8Bit().constData());
        goto out1;
    }
    netcdf_listy_item->get_selection(&pos_cnt,&pos_list);
    if (pos_cnt) {//XmListGetSelectedPos(netcdf_listy_item, &pos_list, &pos_cnt)) {
        /*XtVaGetValues(netcdf_listy_item,
                      XmNselectedItemCount, &cnt,
                      XmNselectedItems, &s,
                      NULL);*/
        //cnt=pos_cnt;
        s=pos_list[0];
        cs = s;//XmStringCopy(*s);
        strcpy(cstr,netcdf_listy_item->text_entries[cs].toLocal8Bit());
        if (strlen(cstr)) {//(cstr = GetStringSimple(cs))) {
            strcpy(xvar, cstr);
            //XtFree(cstr);
        }
        //XmStringFree(cs);
    } else {
        errmsg(tr("Need to select Y").toLocal8Bit().constData());
        goto out1;
    }
    if (strcmp(xvar, "INDEX") == 0) {
        stufftext("X is the index of the Y variable\n");
    } else {
#ifdef HAVE_NETCDF
        if ((x_id = ncvarid(cdfid, xvar)) == -1) {
            char ebuf[256];
            sprintf(ebuf, "do_query(): %s %s%s",tr("No such variable").toLocal8Bit().constData(),xvar,tr(" for X").toLocal8Bit().constData());
            errmsg(ebuf);
            goto out1;
        }
        ncvarinq(cdfid, x_id, NULL, &xdatatype, &xndims, xdim, &xnatts);
        ncdiminq(cdfid, xdim[0], NULL, &nx);
#endif
        sprintf(buf, "X is %s, data type %s \t length [%ld]\n", xvar, getcdf_type(xdatatype), nx);
        stufftext(buf);
        sprintf(buf, "\t%d Attributes:\n", xnatts);
        stufftext(buf);
        for (i = 0; i < xnatts; i++) {
            atcharval[0] = 0;
#ifdef HAVE_NETCDF
            ncattname(cdfid, x_id, i, attname);
            ncattinq(cdfid, x_id, attname, &datatype, &atlen);
#endif
            switch (datatype) {
            case NC_CHAR:
#ifdef HAVE_NETCDF
                ncattget(cdfid, x_id, attname, (void *) atcharval);
#endif
                atcharval[atlen] = 0;
                sprintf(buf, "\t\t%s: %s\n", attname, atcharval);
                stufftext(buf);
                break;
            case NC_FLOAT:
#ifdef HAVE_NETCDF
                ncattget(cdfid, x_id, attname, (void *) &f);
#endif
                sprintf(buf, "\t\t%s: %f\n", attname, f);
                stufftext(buf);
                break;
            case NC_DOUBLE:
#ifdef HAVE_NETCDF
                ncattget(cdfid, x_id, attname, (void *) &d);
#endif
                sprintf(buf, "\t\t%s: %f\n", attname, d);
                stufftext(buf);
                break;
            default:
                break;
            }
        }
    }
#ifdef HAVE_NETCDF
    if ((y_id = ncvarid(cdfid, yvar)) == -1) {
        char ebuf[256];
        sprintf(ebuf, "do_query(): %s %s%s",tr("No such variable").toLocal8Bit().constData(),yvar,tr(" for Y").toLocal8Bit().constData());
        errmsg(ebuf);
        goto out1;
    }
    ncvarinq(cdfid, y_id, NULL, &ydatatype, &yndims, ydim, &ynatts);
    ncdiminq(cdfid, ydim[0], NULL, &ny);
#endif
    sprintf(buf, "Y is %s, data type %s \t length [%ld]\n", yvar, getcdf_type(ydatatype), ny);
    stufftext(buf);
    sprintf(buf, "\t%d Attributes:\n", ynatts);
    stufftext(buf);
    for (i = 0; i < ynatts; i++) {
        atcharval[0] = 0;
#ifdef HAVE_NETCDF
        ncattname(cdfid, y_id, i, attname);
        ncattinq(cdfid, y_id, attname, &datatype, &atlen);
#endif
        switch (datatype) {
        case NC_CHAR:
#ifdef HAVE_NETCDF
            ncattget(cdfid, y_id, attname, (void *) atcharval);
#endif
            atcharval[atlen] = 0;
            sprintf(buf, "\t\t%s: %s\n", attname, atcharval);
            stufftext(buf);
            break;
        case NC_FLOAT:
#ifdef HAVE_NETCDF
            ncattget(cdfid, y_id, attname, (void *) &f);
#endif
            sprintf(buf, "\t\t%s: %f\n", attname, f);
            stufftext(buf);
            break;
        case NC_DOUBLE:
#ifdef HAVE_NETCDF
            ncattget(cdfid, y_id, attname, (void *) &d);
#endif
            sprintf(buf, "\t\t%s: %f\n", attname, d);
            stufftext(buf);
            break;
        default:
            break;
        }
    }

out1:;
#ifdef HAVE_NETCDF
    ncclose(cdfid);
#endif
    stufftext("\n");
    delete[] pos_list;
    //delete s;
    unset_wait_cursor();
}

/*binary format input*/
inputLine::inputLine(int t,QWidget * parent):QWidget(parent)
{
    char dummy[256];
    type=t;//type of input line: input from header(0) or input from data(1)
    if (type)
    {
    layout=new QHBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    }
    lblOffset=new QLabel(QString("0:"),this);
    cmdNew=new QPushButton(QString("-"),this);
    cmdNew->setToolTip(tr("Remove this import token."));
        if (type)
        {
        //lblOffset->setVisible(false);
        cmdNew->setVisible(false);
        }
    spnSize=new QSpinBox(this);
    spnSize->setMinimum(0);
    spnSize->setMaximum(10000);
    cmbFormat=new QComboBox(this);
    //Fill in formats
    for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
    {
        if (i==0 || i==COLUMN_STRING)
            sprintf(dummy,"%s",binaryImportFormatName[i]);
        else
            sprintf(dummy,"%s (%d)",binaryImportFormatName[i],binaryImportFormat[i].size);
        cmbFormat->addItem(QString(dummy));
    }
    connect(cmbFormat,SIGNAL(currentIndexChanged(int)),SLOT(formatChanged(int)));
    cmbImportAs=new QComboBox(this);
    //Fill in targets
    int index=0;
    for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
    {
        if (ImportDestinationType[i]&(type+1))
        {
            cmbImportAs->addItem(QString(ImportDestinationName[i]));
            datas[index++]=i;
        }
    }
    if (type)
    {
    layout->addWidget(lblOffset);
    layout->addWidget(cmbFormat);
    layout->addWidget(spnSize);
    layout->addWidget(cmbImportAs);
    layout->addWidget(cmdNew);
    setLayout(layout);
    }
    spnSize->setEnabled(false);
    cmbFormat->setCurrentIndex(10);//set Standard-Format to double
}

inputLine::~inputLine()
{
    if (type)
    delete layout;
    delete lblOffset;
    delete cmdNew;
    delete spnSize;
    delete cmbFormat;
    delete cmbImportAs;
}

int inputLine::getSize(void)
{
    if (cmbFormat->currentIndex()==0 || cmbFormat->currentIndex()==COLUMN_STRING)
        return spnSize->value();
    else
        return binaryImportFormat[cmbFormat->currentIndex()].size;
}

int inputLine::getType(void)
{
    return cmbFormat->currentIndex();
}

int inputLine::getTarget(void)
{
    return datas[cmbImportAs->currentIndex()];
}

void inputLine::setSize(int s)
{
spnSize->setValue(s);
}

void inputLine::setType(int t)
{
cmbFormat->setCurrentIndex(t);
}

void inputLine::setTarget(int t)
{
int ret=-1;
for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
{
    if (datas[i]==t)
    {
    ret=i;
    break;
    }
}
if (ret>=0) cmbImportAs->setCurrentIndex(ret);
}

void inputLine::formatChanged(int i)
{
    spnSize->setEnabled(!((bool)i));
    if (i==COLUMN_STRING) spnSize->setEnabled(true);
    cmbImportAs->setEnabled((bool)i);
/*if (i==0)
{
}
else
{
}
*/
}

manualHeaderData::manualHeaderData(QWidget * parent):QWidget(parent)
{
    layout=new QGridLayout();
    layout->setSpacing(STD_SPACING);
    layout->setMargin(STD_MARGIN);
    selNrOfEntries=new stdIntSelector(this,tr("Number of Tokens:"),0,64);
    selNrOfEntries->setValue(0);
    connect(selNrOfEntries,SIGNAL(currentValueChanged(int)),SLOT(changeNumberOfEntries(int)));
    /*
    selTokenType=new StdSelector(this,tr("Token:"),);
    ledTokenValue=new stdLineEdit(this,tr("Value="));
    */
    layout->addWidget(selNrOfEntries,0,0,1,3);
    selTokenType=NULL;
    ledTokenValue=NULL;
    selTargetChannel=NULL;
    tokens=0;
    setLayout(layout);
    setMinimumSize(500,30*(1+tokens));
}

void manualHeaderData::changeNumberOfEntries(int nr)
{
StdSelector ** n_selTokenType=NULL;
stdLineEdit ** n_ledTokenValue=NULL;
StdSelector ** n_selTargetChannel=NULL;
    if (nr<tokens)//remove something
    {
        if (nr>0)
        {
        n_selTokenType=new StdSelector*[nr];
        n_ledTokenValue=new stdLineEdit*[nr];
        n_selTargetChannel=new StdSelector*[nr];
            for (int i=0;i<nr;i++)
            {
            n_selTokenType[i]=selTokenType[i];
            n_ledTokenValue[i]=ledTokenValue[i];
            n_selTargetChannel[i]=selTargetChannel[i];
            }
        }
        for (int i=nr;i<tokens;i++)
        {
        layout->removeWidget(selTokenType[i]);
        layout->removeWidget(ledTokenValue[i]);
        layout->removeWidget(selTargetChannel[i]);
        delete selTokenType[i];
        delete ledTokenValue[i];
        delete selTargetChannel[i];
        }
        delete[] selTokenType;
        selTokenType=n_selTokenType;
        delete[] ledTokenValue;
        ledTokenValue=n_ledTokenValue;
        delete[] selTargetChannel;
        selTargetChannel=n_selTargetChannel;
        tokens=nr;
    }
    else//add tokens
    {
        n_selTokenType=new StdSelector*[nr];
        n_ledTokenValue=new stdLineEdit*[nr];
        n_selTargetChannel=new StdSelector*[nr];
        for (int i=0;i<tokens;i++)
        {
        n_selTokenType[i]=selTokenType[i];
        n_ledTokenValue[i]=ledTokenValue[i];
        n_selTargetChannel[i]=selTargetChannel[i];
        }
        delete[] selTokenType;
        selTokenType=n_selTokenType;
        delete[] ledTokenValue;
        ledTokenValue=n_ledTokenValue;
        delete[] selTargetChannel;
        selTargetChannel=n_selTargetChannel;
        QString * impdest=new QString[NUMBER_OF_IMPORT_DESTINATIONS];
        int * datas=new int[NUMBER_OF_IMPORT_DESTINATIONS];
        int nr_impdest=0;
        int * channel_nrs=new int[MAX_BIN_IMPORT_CHANNELS+1];
        QString * impchannels=new QString[MAX_BIN_IMPORT_CHANNELS+1];
        impchannels[0]=tr("All");
        channel_nrs[0]=-1;
        for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
        {
        channel_nrs[i+1]=i;
        impchannels[i+1]=QString::number(i);
        }
        for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
        {
        if (ImportDestination[i]==IMPORT_TO_NUMBER_OF_DATA || ImportDestination[i]==IMPORT_TO_NUMBER_OF_CHANNELS || ImportDestination[i]==IMPORT_TO_DATA_SIZE || ImportDestination[i]==IMPORT_TO_DATA_SIZE_BIT || ImportDestination[i]==IMPORT_TO_WHOLE_DATA_BLOCK_SIZE || ImportDestination[i]==IMPORT_TO_SINGLE_DATA_BLOCK_SIZE) continue;
            if (ImportDestinationType[i]&(1))
            {
            impdest[nr_impdest]=ImportDestinationName[i];
            datas[nr_impdest++]=ImportDestination[i];
            }
        }
        for (int i=tokens;i<nr;i++)
        {
        selTokenType[i]=new StdSelector(this,tr("Token:"),nr_impdest,impdest);
        selTokenType[i]->setValues(datas);
        ledTokenValue[i]=new stdLineEdit(this,tr("Value="));
        selTargetChannel[i]=new StdSelector(this,tr("Channel:"),MAX_BIN_IMPORT_CHANNELS+1,impchannels);
        selTargetChannel[i]->setValues(channel_nrs);
        layout->addWidget(selTokenType[i],i+1,0);
        layout->addWidget(ledTokenValue[i],i+1,1);
        layout->addWidget(selTargetChannel[i],i+1,2);
        }
        delete[] impdest;
        delete[] datas;
        delete[] channel_nrs;
        delete[] impchannels;
        tokens=nr;
    }
    setMinimumSize(500,30*(1+tokens));
}

void manualHeaderData::readDataToScheme(struct importSettings & imp_schema)
{
int cur_type,channel_target;
double cur_val;
QString cur_text;

imp_schema.nr_of_header_values=0;
prepare_imp_settings_for_header_import(imp_schema);
imp_schema.valid_status=1;
imp_schema.contains_trigger=false;

    for (int i=0;i<tokens;i++)
    {
    cur_type=selTokenType[i]->currentValue();
        if (cur_type==IMPORT_TO_NONE) continue;
    channel_target=selTargetChannel[i]->currentValue();
    cur_val=ledTokenValue[i]->getDoubleValue();
    cur_text=ledTokenValue[i]->text();
        switch (cur_type)
        {
        case IMPORT_TO_X0:
            imp_schema.x0set=true;
            imp_schema.x0=cur_val;
        break;
        case IMPORT_TO_DELTAX:
            imp_schema.deltaxset=true;
            imp_schema.deltax=cur_val;
        break;
        case IMPORT_TO_DATA_SAMPLING_RATE:
            imp_schema.fset=true;
            imp_schema.f=cur_val;
        break;
        case IMPORT_TO_TITLE:
            if (imp_schema.title==NULL) delete[] imp_schema.title;
            imp_schema.title=new char[2+cur_text.toLocal8Bit().length()];
            strcpy(imp_schema.title,cur_text.toLocal8Bit().constData());
        break;
        case IMPORT_TO_SUBTITLE:
            if (imp_schema.subtitle==NULL) delete[] imp_schema.subtitle;
            imp_schema.subtitle=new char[2+cur_text.toLocal8Bit().length()];
            strcpy(imp_schema.subtitle,cur_text.toLocal8Bit().constData());
        break;
        case IMPORT_TO_XTITLE:
            if (imp_schema.x_title==NULL) delete[] imp_schema.x_title;
            imp_schema.x_title=new char[2+cur_text.toLocal8Bit().length()];
            strcpy(imp_schema.x_title,cur_text.toLocal8Bit().constData());
        break;
        case IMPORT_TO_YTITLE:
            if (imp_schema.y_title==NULL) delete[] imp_schema.y_title;
            imp_schema.y_title=new char[2+cur_text.toLocal8Bit().length()];
            strcpy(imp_schema.y_title,cur_text.toLocal8Bit().constData());
        break;
        case IMPORT_TO_SET_LEGEND:
            if (channel_target==-1)//All
            {
                for (int j=0;j<MAX_BIN_IMPORT_CHANNELS;j++)
                {
                if (imp_schema.set_title[j]==NULL) delete[] imp_schema.set_title[j];
                imp_schema.set_title[j]=new char[2+cur_text.toLocal8Bit().length()];
                strcpy(imp_schema.set_title[j],cur_text.toLocal8Bit().constData());
                }
            }
            else
            {
                if (imp_schema.set_title[channel_target]==NULL) delete[] imp_schema.set_title[channel_target];
                imp_schema.set_title[channel_target]=new char[2+cur_text.toLocal8Bit().length()];
                strcpy(imp_schema.set_title[channel_target],cur_text.toLocal8Bit().constData());
            }
        break;
        case IMPORT_TO_DATA_START_OFFSET:
            imp_schema.whole_size=int(cur_val);
        break;
        case IMPORT_TO_XFACTOR:
        case IMPORT_TO_YFACTOR:
        case IMPORT_TO_Y1FACTOR:
        case IMPORT_TO_Y2FACTOR:
        case IMPORT_TO_Y3FACTOR:
        case IMPORT_TO_Y4FACTOR:
            if (channel_target==-1)//all --> use the general factors
            imp_schema.factors[cur_type-IMPORT_TO_XFACTOR]*=cur_val;
            else//just one channel
            imp_schema.channel_factors[channel_target]*=cur_val;
        break;
        case IMPORT_TO_X_OFFSET:
        case IMPORT_TO_Y_OFFSET:
        case IMPORT_TO_Y1_OFFSET:
        case IMPORT_TO_Y2_OFFSET:
        case IMPORT_TO_Y3_OFFSET:
        case IMPORT_TO_Y4_OFFSET:
            if (channel_target==-1)//all --> use the general offsets
            imp_schema.offsets[cur_type-IMPORT_TO_X_OFFSET]+=cur_val;
            else//just one channel
            imp_schema.channel_offsets[channel_target]+=cur_val;
        break;

        }
    }
}

void manualHeaderData::displayDataFromScheme(struct importSettings imp_schema)
{
int counter=0;

if (imp_schema.x0set==true) counter++;
if (imp_schema.deltaxset==true) counter++;
if (imp_schema.fset==true) counter++;
if (imp_schema.whole_size>0) counter++;
if (imp_schema.title!=NULL) counter++;
if (imp_schema.subtitle!=NULL) counter++;
if (imp_schema.x_title!=NULL) counter++;
if (imp_schema.y_title!=NULL) counter++;
for (int i=0;i<7;i++)
{
    if (imp_schema.factors[i]!=1.0) counter++;
    if (imp_schema.offsets[i]!=0.0) counter++;
}
for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
{
    if (imp_schema.channel_factors[i]!=1.0) counter++;
    if (imp_schema.channel_offsets[i]!=0.0) counter++;
    if (imp_schema.set_title[i]!=NULL) counter++;
}

selNrOfEntries->setValue(counter);
qApp->processEvents();

counter=0;

if (imp_schema.x0set==true)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_X0);
ledTokenValue[counter]->setDoubleValue(imp_schema.x0);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.deltaxset==true)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_DELTAX);
ledTokenValue[counter]->setDoubleValue(imp_schema.deltax);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.fset==true)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_DATA_SAMPLING_RATE);
ledTokenValue[counter]->setDoubleValue(imp_schema.f);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.whole_size>0)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_DATA_START_OFFSET);
ledTokenValue[counter]->setDoubleValue(imp_schema.whole_size);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.title!=NULL)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_TITLE);
ledTokenValue[counter]->setText(imp_schema.title);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.subtitle!=NULL)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_SUBTITLE);
ledTokenValue[counter]->setText(imp_schema.subtitle);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.x_title!=NULL)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_XTITLE);
ledTokenValue[counter]->setText(imp_schema.x_title);
selTargetChannel[counter++]->setCurrentValue(-1);
}
if (imp_schema.y_title!=NULL)
{
selTokenType[counter]->setCurrentValue(IMPORT_TO_YTITLE);
ledTokenValue[counter]->setText(imp_schema.y_title);
selTargetChannel[counter++]->setCurrentValue(-1);
}
for (int i=0;i<7;i++)
{
    if (imp_schema.offsets[i]!=0.0)
    {
    selTokenType[counter]->setCurrentValue(i+IMPORT_TO_XFACTOR);
    ledTokenValue[counter]->setDoubleValue(imp_schema.offsets[i]);
    selTargetChannel[counter++]->setCurrentValue(-1);
    }
    if (imp_schema.factors[i]!=1.0)
    {
    selTokenType[counter]->setCurrentValue(i+IMPORT_TO_X_OFFSET);
    ledTokenValue[counter]->setDoubleValue(imp_schema.factors[i]);
    selTargetChannel[counter++]->setCurrentValue(-1);
    }
}
for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
{
    if (imp_schema.channel_offsets[i]!=0.0)
    {
    selTokenType[counter]->setCurrentValue(IMPORT_TO_Y_OFFSET);
    ledTokenValue[counter]->setDoubleValue(imp_schema.channel_offsets[i]);
    selTargetChannel[counter++]->setCurrentValue(i);
    }
    if (imp_schema.channel_factors[i]!=1.0)
    {
    selTokenType[counter]->setCurrentValue(IMPORT_TO_YFACTOR);
    ledTokenValue[counter]->setDoubleValue(imp_schema.channel_factors[i]);
    selTargetChannel[counter++]->setCurrentValue(i);
    }
    if (imp_schema.set_title[i]!=NULL)
    {
    selTokenType[counter]->setCurrentValue(IMPORT_TO_SET_LEGEND);
    ledTokenValue[counter]->setText(imp_schema.set_title[i]);
    selTargetChannel[counter++]->setCurrentValue(i);
    }
}

}

inputIniData::inputIniData(QWidget * parent):QWidget(parent)
{
layout=new QGridLayout();
layout->setMargin(STD_MARGIN*2);
layout->setSpacing(STD_SPACING*2);
titles=new QLabel*[4];
titles[0]=new QLabel(tr("Import key"));
titles[1]=new QLabel(tr("Value"));
titles[2]=new QLabel(tr("Channel"));
titles[3]=new QLabel(tr("Import as"));
QFont stfont=titles[0]->font();
stfont.setBold(true);
        for (int i=0;i<4;i++)
        {
        titles[i]->setFont(stfont);
        layout->addWidget(titles[i],0,i);
        }
    lbl_imp_key=NULL;
    lbl_imp_value=NULL;
    cmbChannel=NULL;
    cmbImportTo=NULL;
    lines=0;
setLayout(layout);
}

void inputIniData::clearData(void)
{
    for (int i=0;i<lines;i++)
    {
    delete lbl_imp_key[i];
    delete lbl_imp_value[i];
    delete cmbChannel[i];
    delete cmbImportTo[i];
    }
    if (lbl_imp_key!=NULL) delete[] lbl_imp_key;
    if (lbl_imp_value!=NULL) delete[] lbl_imp_value;
    if (cmbChannel!=NULL) delete[] cmbChannel;
    if (cmbImportTo!=NULL)delete[] cmbImportTo;
    lbl_imp_key=NULL;
    lbl_imp_value=NULL;
    cmbChannel=NULL;
    cmbImportTo=NULL;
    lines=0;
}

void inputIniData::initData(struct importSettings imp_set)
{
clearData();
lines=imp_set.keys.length();
if (lines>0)
{
lbl_imp_key=new QLabel*[lines];
lbl_imp_value=new QLabel*[lines];
cmbChannel=new QComboBox*[lines];
cmbImportTo=new QComboBox*[lines];
    for (int i=0;i<lines;i++)
    {
    lbl_imp_key[i]=new QLabel(imp_set.keys.at(i),this);
    lbl_imp_value[i]=new QLabel(imp_set.vals.at(i),this);
    cmbChannel[i]=new QComboBox(this);
    cmbImportTo[i]=new QComboBox(this);
    layout->addWidget(lbl_imp_key[i],1+i,0);
    layout->addWidget(lbl_imp_value[i],1+i,1);
    layout->addWidget(cmbChannel[i],1+i,2);
    cmbChannel[i]->addItem(tr("All"));
        for (int j=0;j<MAX_BIN_IMPORT_CHANNELS;j++)
        {
        cmbChannel[i]->addItem(QString::number(j));
        }
    layout->addWidget(cmbImportTo[i],1+i,3);
    }

datas.clear();
for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
{
    if (ImportDestinationType[i]&(1))
    {
        for (int j=0;j<lines;j++)
        cmbImportTo[j]->addItem(QString(ImportDestinationName[i]));
        datas << ImportDestination[i];
        //datas[index++]=i;
    }
}

//set the values
int index;
for (int i=0;i<lines;i++)
{
cmbChannel[i]->setCurrentIndex(1+imp_set.import_channel_dest.at(i));
index=datas.indexOf(imp_set.import_dest.at(i));
//cout << "imp_set.import_dest.at(i)=" << imp_set.import_dest.at(i) << " --> Position=" << index << endl;
if (index>=0)
cmbImportTo[i]->setCurrentIndex(index);
else
cmbImportTo[i]->setCurrentIndex(0);
}

}//lines > 0

}

void inputIniData::setData(struct importSettings & imp_set)
{
//read settings and save them into imp_set
    imp_set.import_channel_dest.clear();
    imp_set.import_dest.clear();
    imp_set.keys.clear();
    imp_set.vals.clear();
    //cout << "lines=" << lines << endl;
        for (int i=0;i<lines;i++)
        {
        imp_set.import_channel_dest << cmbChannel[i]->currentIndex()-1;
        //cout << "channel_dest=" << imp_set.import_channel_dest.at(i) << endl;
        imp_set.import_dest << datas.at(cmbImportTo[i]->currentIndex());
        imp_set.keys << lbl_imp_key[i]->text();
        imp_set.vals << cmbImportTo[i]->currentText();
        }
    if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
    imp_set.token_target=new int[imp_set.import_dest.length()];
        for (int i=0;i<imp_set.import_dest.length();i++)
        {
        imp_set.token_target[i]=imp_set.import_dest.at(i);
        //cout << i << ": token target=" << imp_set.token_target[i] << endl;
        }
    /*for (int i=0;i<imp_set.keys.length();i++)
    {
    cout << i << ": key=" << imp_set.keys.at(i).toLocal8Bit().constData() << endl;
    }*/

    /*for (int i=0;i<imp_set.keys.length();i++)
    {
    imp_set.import_channel_dest.at(i)
    imp_set.keys.at(i).toLocal8Bit().constData()
    ImportDestinationName[imp_set.token_target[i]]
    }*/
}

pageHeaderInfo::pageHeaderInfo(QWidget * parent):QWidget(parent)
{
    grid=new QVBoxLayout;
    grid->setMargin(STD_MARGIN);
    grid->setSpacing(STD_SPACING);

    gridLayout=new QGridLayout;
    gridLayout->setMargin(STD_MARGIN);
    gridLayout->setSpacing(STD_SPACING);

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);

    /*
    empty0=new QWidget;
    QHBoxLayout * layout0=new QHBoxLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    empty0->setLayout(layout0);
    */

    empty1=new QWidget;
    QHBoxLayout * layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    empty1->setLayout(layout1);

    empty=new QWidget;
    scroll=new QScrollArea(this);
    scroll->setWidget(empty);
    cmdAdd=new QPushButton(QString("+"),this);
    cmdAdd->setToolTip(tr("Add another import token."));
    connect(cmdAdd,SIGNAL(clicked()),SLOT(doNew()));
    Headers=new QLabel*[5];
    for (int i=0;i<5;i++)
    {
        Headers[i]=new QLabel(QString(""),this);
        //layout0->addWidget(Headers[i]);
    }
    Headers[0]->setText(tr("Offset  "));
    Headers[1]->setText(tr("Format (Bytes)"));
    Headers[2]->setText(tr("Bytes"));
    Headers[3]->setText(tr("Import as"));
    Headers[4]->setText(tr("Remove"));
    //grid->addWidget(empty0);
    grid->addWidget(scroll);
    lblEndChar=new QLabel(QString("String-End-Char (Ascii-code):"),this);
    layout1->addWidget(lblEndChar);
    lenEndChar=new QLineEdit(QString("0"),this);
    layout1->addWidget(lenEndChar);
    cmdTestLoad=new QPushButton(QString("Test-Load"),this);
    cmdTestLoad->setToolTip(tr("Try to load header data using current settings."));
    layout1->addWidget(cmdTestLoad);
    connect(cmdTestLoad,SIGNAL(clicked()),SLOT(doTestLoad()));
    grid->addWidget(empty1);
    setLayout(grid);
    map=new QSignalMapper;
    number_of_lines=1;
    inFormats=new inputLine*[number_of_lines+2];
    inFormats[0]=new inputLine(0,this);
    inFormats[0]->cmdNew->setEnabled(false);//never delete first line
    connect(inFormats[0]->cmdNew,SIGNAL(clicked()),map,SLOT(map()));
    connect(inFormats[0]->cmbFormat,SIGNAL(currentIndexChanged(int)),SLOT(offsetChanged(int)));
    connect(inFormats[0]->spnSize,SIGNAL(valueChanged(int)),SLOT(offsetChanged(int)));
    map->setMapping(inFormats[0]->cmdNew,0);
    connect(map,SIGNAL(mapped(int)),SLOT(doDelete(int)));
    //layout->addWidget(inFormats[0]);
        for (int i=0;i<5;i++)
        {
        gridLayout->addWidget(Headers[i],0,i,1,1);
        }
    gridLayout->addWidget(inFormats[0]->lblOffset,1,0,1,1);
    gridLayout->addWidget(inFormats[0]->cmbFormat,1,1,1,1);
    gridLayout->addWidget(inFormats[0]->spnSize,1,2,1,1);
    gridLayout->addWidget(inFormats[0]->cmbImportAs,1,3,1,1);
    gridLayout->addWidget(inFormats[0]->cmdNew,1,4,1,1);
    gridLayout->addWidget(cmdAdd,2,0,1,5);
    gridLayout->setRowStretch(0,0);
    gridLayout->setRowStretch(1,10);
    gridLayout->setRowStretch(2,10);

    //layout->addWidget(cmdAdd);
    //empty->setLayout(layout);
    empty->setLayout(gridLayout);
    empty->setGeometry(0,0,500,28*(number_of_lines+2));

    nr_of_entries=0;
    for (int i=0;i<NUMBER_OF_IMPORT_DESTINATIONS;i++)
    {
        if (ImportDestinationType[i]&1)
        {
            entries[nr_of_entries]=QString(ImportDestinationName[i]);
            entry_values[nr_of_entries++]=ImportDestination[i];
        }
    }

    //nr_of_sels=0;
    iniDataGroup=new inputIniData(this);
    manHeaderGroup=new manualHeaderData(this);
    manHeaderGroup->setVisible(false);
    //iniDataGroup->setVisible(false);

    cmdReadIni=new QPushButton(tr("Read Ini File"),this);
    connect(cmdReadIni,SIGNAL(clicked()),SLOT(doReadIni()));
    cmdReadIni->setVisible(false);
    scroll2=new QScrollArea;
    empty2=new QWidget;
    layout2=new QVBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    empty2->setLayout(layout2);
    empty2->setVisible(false);
    //scroll2->setWidget(empty2);
    scroll2->setWidget(iniDataGroup);
    scroll2->setVisible(false);

    scroll3=new QScrollArea;
    scroll3->setWidget(manHeaderGroup);
    scroll3->setVisible(false);

    grid->addWidget(cmdReadIni);
    grid->addWidget(scroll2);
    grid->addWidget(scroll3);
}

void pageHeaderInfo::changeRepresentation(int r)
{
(void)r;
bool headerPresent=par_wid->chkHeader->isChecked();
int headerType=par_wid->cmbHeaderFileFormat->currentIndex();
int formatSource=par_wid->cmbFormatSource->currentIndex();

/*cout << "Change Header Representation" << endl;
cout << "headerPresent=" << headerPresent << endl;
cout << "formatSource=" << formatSource << endl;
cout << "headerType=" << headerType << endl;*/

    if (headerPresent==false)
    {
        cmdReadIni->setVisible(false);
        manHeaderGroup->setVisible(true);
        manHeaderGroup->setEnabled(false);
        scroll2->setVisible(false);
        scroll3->setVisible(false);
        scroll->setVisible(false);
        //empty0->setVisible(false);
        empty1->setVisible(false);
    }
    else if (formatSource==0)//manual
    {
        cmdReadIni->setVisible(false);
        manHeaderGroup->setVisible(true);
        manHeaderGroup->setEnabled(true);
        scroll2->setVisible(false);
        scroll3->setVisible(true);
        scroll->setVisible(false);
        //empty0->setVisible(false);
        empty1->setVisible(false);
    }
    else if (formatSource==1 || (formatSource==2 && headerType==0))
    {
        cmdReadIni->setVisible(false);
        manHeaderGroup->setVisible(false);
        scroll2->setVisible(false);
        scroll3->setVisible(false);
        scroll->setVisible(true);
        //empty0->setVisible(true);
        empty1->setVisible(true);
    }
    else if (formatSource==2 && headerType==1)//ini-Header
    {
        cmdReadIni->setVisible(true);
        manHeaderGroup->setVisible(false);
        scroll2->setVisible(true);
        scroll3->setVisible(false);
        scroll->setVisible(false);
        //empty0->setVisible(false);
        empty1->setVisible(false);
    }
    else//ascii-file
    {

    }
}

void get_all_settings_from_ini_file(QString ini_file,QStringList & keys,QStringList & vals,QList<int> & import_channels)
{
QVariant val1;
QString val2,tval;
QStringList val3;
QSettings settings(ini_file,QSettings::IniFormat);
(void)import_channels;
//cout << "ini_file to read from=" << ini_file.toLocal8Bit().constData() << endl;
keys.clear();
vals.clear();
//import_channels.clear();
keys=settings.allKeys();
    for (int i=0;i<keys.length();i++)
    {
    val1=settings.value(keys.at(i));
    val2=val1.toString();
    val3=val1.toStringList();
        if (val1.type()==QVariant::String)
        {
        tval=val2;
        }
        else if (val1.type()==QVariant::StringList)
        {
        tval=val3.at(0)+QString(".")+val3.at(1);
        }
        else
        {
        tval=QObject::tr("unidentified");
        }
    vals << tval;
    //import_channels << -1;//none
    }
}

void pageHeaderInfo::doReadIni(void)
{
struct importSettings null_import;
initSettings(null_import,false);
QString err_txt;
    if (par_wid->headerFileNames.length()<=0)
    {
    err_txt=tr("No header-file selected.");
    errwin(err_txt.toLocal8Bit().constData());
    }
    else
    {
    par_wid->imp_set.HeaderFile=par_wid->headerFileNames.at(par_wid->bin_file_nr_to_import);
        if (par_wid->cur_import_scheme>=0)
        read_INI_header(par_wid->imp_set,std_bin_import_settings[par_wid->cur_import_scheme]);
        else
        read_INI_header(par_wid->imp_set,null_import);
    iniDataGroup->initData(par_wid->imp_set);
    resizeIniDisplay();
    }
return;
/// function ends here

//QStringList vals;
//QList<int> imp_ch_dest;
//keys.clear();
//imp_ch_dest.clear();

    /*if (nr_of_sels>0)
    {
        for (int i=nr_of_sels-1;i>=0;i--)
        {
            delete sels[i];
        }
        delete[] sels;
        delete[] readValues;
        par_wid->tabHeader->nr_of_sels=0;
    }*/
/// initSettings(par_wid->imp_set);
/// par_wid->transmitInfos();
    //if (par_wid->headerFileName[0]!='\0')
    if (!par_wid->headerFileNames.at(par_wid->bin_file_nr_to_import).isEmpty())
    {
    int std_format_nr;
    bool is_header_file;

    //par_wid->imp_set.HeaderFile=QString::fromLocal8Bit(par_wid->headerFileName);
    par_wid->imp_set.HeaderFile=par_wid->headerFileNames.at(par_wid->bin_file_nr_to_import);
        //if (guess_bin_format(par_wid->headerFileName,std_format_nr,is_header_file)==RETURN_SUCCESS)
        if (guess_bin_format(par_wid->headerFileNames.at(par_wid->bin_file_nr_to_import),std_format_nr,is_header_file)==RETURN_SUCCESS && par_wid->actautoguess->isChecked())
        {
        read_INI_header(par_wid->imp_set,std_bin_import_settings[std_format_nr]);
        }
        else
        {
        read_INI_header(par_wid->imp_set,null_import);
        }
    /*
    get_all_settings_from_ini_file(par_wid->headerFileName,keys,vals,imp_ch_dest);
    par_wid->imp_set.keys=keys;
    par_wid->imp_set.vals=vals;
    par_wid->imp_set.import_channel_dest=imp_ch_dest;*/

    /*inpIniData=new inputIniData(0);
    inpIniData->initData(par_wid->imp_set);
    inpIniData->show();*/

    iniDataGroup->initData(par_wid->imp_set);
    int wid=300;
    if (scroll2->width()>310) wid=scroll2->width()-10;
    iniDataGroup->setGeometry(0,0,wid,(5+iniDataGroup->titles[0]->height())*(1+par_wid->imp_set.keys.length()));

        /*QString tval2;
        nr_of_sels=par_wid->imp_set.keys.length();
        if (nr_of_sels>0)
        {
            readValues=new QString[nr_of_sels];
            sels=new StdSelector*[nr_of_sels];
            for (int i=0;i<nr_of_sels;i++)
            {
                readValues[i]=par_wid->imp_set.vals.at(i);
                tval2=tr("Import key [ ") + par_wid->imp_set.keys.at(i) + QString(" ]=( ") + readValues[i] + tr(" ) as ");
                sels[i]=new StdSelector(this,tval2,nr_of_entries,entries);
                sels[i]->setValues(entry_values);
                sels[i]->setVisible(true);
                layout2->addWidget(sels[i]);
            }
            int wid=600;
            if (scroll2->width()>610) wid=scroll2->width()-10;
            empty2->setGeometry(0,0,wid,35*nr_of_sels);
        }*/
    }
    else
    {
        errwin(tr("No ini-file set!").toLocal8Bit().constData());
    }
}

void pageHeaderInfo::resizeIniDisplay(void)
{
int wid=300;
int s_h=iniDataGroup->titles[0]->height();
if (scroll2->width()>310) wid=scroll2->width()-10;
if (s_h<15) s_h=15;
iniDataGroup->setGeometry(0,0,wid,(5+s_h)*(1+par_wid->imp_set.keys.length()));

}

void pageHeaderInfo::doTestLoad(void)
{
    par_wid->determine_string_size=true;
//first: read header settings into current scheme (not set)
    par_wid->CheckHeadersAndDatFiles();
    par_wid->imp_set.HeaderFile=par_wid->headerFileNames.at(0);
    read_header_settings(par_wid->imp_scheme);

    //this is for reading the header only and importing all the informations to check whether the file-structure matches the informations set
    emit(readHeader());
qApp->processEvents();
    par_wid->convertSettingsToString();
    par_wid->tabFileInfo->headerContents=par_wid->settingString;
}

void pageHeaderInfo::read_header_settings(struct importSettings & imp_set)
{
//int counter;
imp_set.header_present=par_wid->chkHeader->isChecked();
imp_set.multiple_header_files=par_wid->chkMultiHeaders->isChecked();
int val=lenEndChar->text().toInt();

imp_set.string_end_char=(char)val;
if (par_wid->cmbFormatSource->currentIndex()==0)//manual
imp_set.header_format=0;
else if (par_wid->cmbFormatSource->currentIndex()==1)//header in data file
imp_set.header_format=1;
else
imp_set.header_format=2+par_wid->cmbHeaderFileFormat->currentIndex();//header in separate file

    if (par_wid->cmbHeaderFileFormat->currentIndex()==0)//binary header information
    {
    //cout << "read header settings: binary header" << endl;
    imp_set.nr_of_header_values=number_of_lines;
    if (imp_set.header_value_format!=NULL) delete[] imp_set.header_value_format;
    if (imp_set.header_value_size!=NULL) delete[] imp_set.header_value_size;
    if (imp_set.header_value_import!=NULL) delete[] imp_set.header_value_import;
    imp_set.header_value_format=new int[number_of_lines];
    imp_set.header_value_size=new int[number_of_lines];
    imp_set.header_value_import=new int[number_of_lines];
    imp_set.headersize=0;
        for (int i=0;i<number_of_lines;i++)
        {
        imp_set.header_value_format[i]=inFormats[i]->getType();
        imp_set.header_value_size[i]=inFormats[i]->getSize();
        imp_set.header_value_import[i]=inFormats[i]->getTarget();
        imp_set.headersize+=imp_set.header_value_size[i];
        }
    }
    else if (par_wid->cmbHeaderFileFormat->currentIndex()==1)//ini-header information
    {
    /*imp_set.keys.clear();
    if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
    imp_set.token_target=new int[nr_of_sels+1];
    counter=0;
        for (int i=0;i<nr_of_sels;i++)
        {
            if (sels[i]->currentValue()!=IMPORT_TO_NONE)
            {
            imp_set.keys << keys.at(i);
            imp_set.token_target[counter++]=sels[i]->currentValue();
            }
        }
    imp_set.nr_of_import_tokens=imp_set.keys.length();*/
    //cout << "read header settings: ini header" << endl;
        iniDataGroup->setData(imp_set);
    }
    else//ascii header
    {

    }
}

void pageHeaderInfo::write_header_settings(struct importSettings & imp_set)
{
//cout << "write header settings to gui" << endl;
par_wid->chkHeader->setChecked(imp_set.header_present);
par_wid->chkMultiHeaders->setChecked(imp_set.multiple_header_files);
    if (imp_set.header_present)
    par_wid->chkMultiHeaders->setVisible(true);
    else
    par_wid->chkMultiHeaders->setVisible(false);
int val=imp_set.header_format-2;
if (val==-2)//manual
{
par_wid->cmbFormatSource->setCurrentIndex(0);
par_wid->cmbHeaderFileFormat->setCurrentIndex(0);
}
else if (val==-1)//header in data file
{
par_wid->cmbFormatSource->setCurrentIndex(1);
par_wid->cmbHeaderFileFormat->setCurrentIndex(0);
}
else//separate header file
{
par_wid->cmbFormatSource->setCurrentIndex(2);
par_wid->cmbHeaderFileFormat->setCurrentIndex(val);
}
lenEndChar->setText(QString::number((int)(imp_set.string_end_char)));
qApp->processEvents();
    if (par_wid->cmbHeaderFileFormat->currentIndex()==0)//binary header information
    {
    //cout << "setting binary header data number_of_lines=" << number_of_lines << endl;
    //cout << "imp_set.nr_of_header_values=" << imp_set.nr_of_header_values << endl;
        while (number_of_lines>imp_set.nr_of_header_values)
        {
        doDelete(number_of_lines-1);
        }
        while (number_of_lines<imp_set.nr_of_header_values)
        {
        doNew();
        }
        for (int i=0;i<number_of_lines;i++)
        {
        //cout << "header_val_format=" << imp_set.header_value_format[i] << endl;
        inFormats[i]->setType(imp_set.header_value_format[i]);
        inFormats[i]->setSize(imp_set.header_value_size[i]);
        inFormats[i]->setTarget(imp_set.header_value_import[i]);
        }
    }
    else if (par_wid->cmbHeaderFileFormat->currentIndex()==1)//ini-header information
    {
        //cout << "ini-Header is going to be displayed" << endl;
        iniDataGroup->initData(imp_set);
        resizeIniDisplay();
        //cout << "finished displaying iniheader" << endl;

        /*for (int i=0;i<imp_set.nr_of_import_tokens;i++)
        {
            for (int j=0;j<nr_of_sels;j++)
            {
                if (keys.at(j)==imp_set.keys.at(i))
                {
                sels[i]->setCurrentValue(imp_set.token_target[i]);
                break;
                }
            }
        }*/
    }
    else//ascii header
    {

    }

}

void pageHeaderInfo::updateOffsets(void)
{
    int offset=0;
    char dummy[32];
    for (int i=0;i<number_of_lines;i++)
    {
        sprintf(dummy,"%d",offset);
        inFormats[i]->lblOffset->setText(QString(dummy));
        offset+=inFormats[i]->getSize();
    }
}

void pageHeaderInfo::doNew(void)
{
//cout << "before new=" << gridLayout->rowCount() << endl;
    inputLine ** nlines=new inputLine*[number_of_lines+2];
    for (int i=0;i<number_of_lines;i++)
        nlines[i]=inFormats[i];
    nlines[number_of_lines]=new inputLine(0,this);
    connect(nlines[number_of_lines]->cmdNew,SIGNAL(clicked()),map,SLOT(map()));
    connect(nlines[number_of_lines]->cmbFormat,SIGNAL(currentIndexChanged(int)),SLOT(offsetChanged(int)));
    connect(nlines[number_of_lines]->spnSize,SIGNAL(valueChanged(int)),SLOT(offsetChanged(int)));
    map->setMapping(nlines[number_of_lines]->cmdNew,number_of_lines);
    int rows=number_of_lines+2;
    gridLayout->removeWidget(cmdAdd);
    gridLayout->addWidget(cmdAdd,rows,0,1,5);
    gridLayout->setRowStretch(rows,10);
    //layout->insertWidget(number_of_lines,nlines[number_of_lines]);

    gridLayout->addWidget(nlines[number_of_lines]->lblOffset,rows-1,0,1,1);
    gridLayout->addWidget(nlines[number_of_lines]->cmbFormat,rows-1,1,1,1);
    gridLayout->addWidget(nlines[number_of_lines]->spnSize,rows-1,2,1,1);
    gridLayout->addWidget(nlines[number_of_lines]->cmbImportAs,rows-1,3,1,1);
    gridLayout->addWidget(nlines[number_of_lines]->cmdNew,rows-1,4,1,1);

    number_of_lines++;
    delete[] inFormats;
    inFormats=nlines;
    empty->setGeometry(0,0,500,(28)*(number_of_lines+2));
    updateOffsets();
//cout << "after new=" << gridLayout->rowCount() << endl;
}

void pageHeaderInfo::doDelete(int j)
{
//cout << "before delete=" << gridLayout->rowCount() << endl;
    inputLine ** nlines=new inputLine*[number_of_lines+1];
    int ofs=0;
//cout << "Deleting " << j << endl;
    for (int i=0;i<number_of_lines;i++)
    {
        if (i!=j)
        nlines[ofs++]=inFormats[i];
    map->removeMappings(inFormats[i]->cmdNew);
    }
    gridLayout->removeWidget(cmdAdd);
    for (int i=number_of_lines-1;i>=j;i--)
    {
        gridLayout->removeWidget(inFormats[i]->lblOffset);
        gridLayout->removeWidget(inFormats[i]->cmbFormat);
        gridLayout->removeWidget(inFormats[i]->spnSize);
        gridLayout->removeWidget(inFormats[i]->cmbImportAs);
        gridLayout->removeWidget(inFormats[i]->cmdNew);
//cout << "remove=" << i << endl;
    }
    delete inFormats[j];
    for (int i=j+1;i<number_of_lines;i++)
    {
//cout << "add Widget again=" << i << endl;
        gridLayout->addWidget(inFormats[i]->lblOffset,i,0,1,1);
        gridLayout->addWidget(inFormats[i]->cmbFormat,i,1,1,1);
        gridLayout->addWidget(inFormats[i]->spnSize,i,2,1,1);
        gridLayout->addWidget(inFormats[i]->cmbImportAs,i,3,1,1);
        gridLayout->addWidget(inFormats[i]->cmdNew,i,4,1,1);
    }
//cout << "add Add-Button at " << number_of_lines << endl;
    gridLayout->addWidget(cmdAdd,number_of_lines,0,1,5);
    delete[] inFormats;
    inFormats=nlines;
    number_of_lines--;
    empty->setGeometry(0,0,500,28*(number_of_lines+2));
    for (int i=0;i<number_of_lines;i++)
    {
        connect(inFormats[i]->cmdNew,SIGNAL(clicked()),map,SLOT(map()));
        map->setMapping(inFormats[i]->cmdNew,i);
    }
    updateOffsets();
//cout << "after delete=" << gridLayout->rowCount() << endl;
}

void pageHeaderInfo::offsetChanged(int i)
{
    (void)i;
    updateOffsets();
}

pageDataInfo::pageDataInfo(QWidget * parent):QWidget(parent)
{
    grid=new QGridLayout;
    grid->setMargin(STD_MARGIN);
    grid->setSpacing(STD_SPACING);
    map=new QSignalMapper(this);
    empty=new QWidget;
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    empty->setLayout(layout);
    lblComment=new QLabel(tr("Structure of Dataset in binary file (Channel / Format / Bytesize / Import-Target):"),this);
    lblChannelCount=new QLabel(tr("Channel-Count (number of sets):"),this);
    spnChannelCount=new QSpinBox(this);
    spnChannelCount->setMinimum(0);
    spnChannelCount->setMaximum(1000);
    spnChannelCount->setValue(1);
    connect(spnChannelCount,SIGNAL(valueChanged(int)),SLOT(channelCountChanged(int)));
    lblDataSetCount=new QLabel(tr("Data-Set-Count (setlength):"),this);
    spnDataSetCount=new QSpinBox(this);
    spnDataSetCount->setMinimum(0);
    spnDataSetCount->setMaximum(INT_MAX);
    scroll=new QScrollArea;
    scroll->setWidget(empty);
    number_of_lines=1;
    inFormats=new inputLine*[number_of_lines+2];
    inFormats[0]=new inputLine(1,this);
    layout->addWidget(inFormats[0]);
    empty->setGeometry(0,0,500,35);
    chkReadToEOF=new QCheckBox(tr("Read Data until EOF"),this);
    chkKeppTrigger=new QCheckBox(tr("KeepTriggerChannel"),this);
    connect(chkReadToEOF,SIGNAL(toggled(bool)),SLOT(eofToggled(bool)));
    int nr_of_entries=2;
    QString * entries=new QString[4];
    entries[0]=QString("a0 b0 c0 | a1 b1 c1 | ... | an bn cn");
    entries[1]=QString("a0 a1 ... an | b0 b1 ... bn | c0 c1 ... cn");
    selOrder=new StdSelector(this,tr("Channel ordering in file:"),nr_of_entries,entries);
    nr_of_entries=4;
    entries[0]=tr("No trigger");
    entries[1]=tr("Rising edge");
    entries[2]=tr("Falling edge");
    entries[3]=tr("Either edge");
    selTriggerType=new StdSelector(this,tr("Trigger type:"),nr_of_entries,entries);
    int * tri_vals=new int[4];
        for (int i=0;i<4;i++)
        tri_vals[i]=i-1;
    selTriggerType->setValues(tri_vals);
        delete[] tri_vals;
    selTriggerValue=new LineWidthSelector(this);
    selTriggerValue->lblText->setText(tr("Trigger value:"));
    selTriggerValue->spnLineWidth->setRange(-1e12,1e12);
    selTriggerValue->spnLineWidth->setDecimals(6);
    int row=0;
    grid->addWidget(lblChannelCount,row,0);
    grid->addWidget(spnChannelCount,row++,1);
    grid->addWidget(lblDataSetCount,row,0);
    grid->addWidget(spnDataSetCount,row++,1);
    grid->addWidget(selOrder,row++,0,1,2);
    grid->addWidget(selTriggerType,row++,0,1,2);
    grid->addWidget(selTriggerValue,row++,0,1,2);
    grid->addWidget(lblComment,row++,0,1,2);
    grid->addWidget(scroll,row++,0,1,2);
    grid->addWidget(chkReadToEOF,row,0,1,1);
    grid->addWidget(chkKeppTrigger,row++,1,1,1);
    setLayout(grid);
    connect(map,SIGNAL(mapped(int)),SLOT(input_target_changed(int)));
}

void pageDataInfo::channelCountChanged(int i)
{
inputLine ** inLines=new inputLine*[i+2];
char dummy[32];
    for (int j=0;j<number_of_lines;j++)
    map->removeMappings(inFormats[j]->cmbImportAs);
//cout << "Channel Count=" << i << endl;
    if (i>number_of_lines)//new line(s)
    {
        for (int j=0;j<number_of_lines;j++)
        {
            inLines[j]=inFormats[j];
        }
        for (int j=number_of_lines;j<i;j++)
        {
            inLines[j]=new inputLine(1,this);
            layout->addWidget(inLines[j]);
            sprintf(dummy,"%d:",j);
            inLines[j]->lblOffset->setText(QString(dummy));
        }
        delete[] inFormats;
        inFormats=inLines;
    }
    else if (i<number_of_lines)
    {
        for (int j=i;j<number_of_lines;j++)
            delete  inFormats[j];
        delete[] inLines;
    }

    number_of_lines=i;
    empty->setGeometry(0,0,500,35*number_of_lines+2);

    for (int j=0;j<number_of_lines;j++)
    {
    connect(inFormats[j]->cmbImportAs,SIGNAL(currentIndexChanged(int)), map, SLOT(map()));
    map->setMapping(inFormats[j]->cmbImportAs,j);
    }

    emit(newChannelCount(i));
}

void pageDataInfo::eofToggled(bool i)
{
    lblDataSetCount->setEnabled(!i);
    spnDataSetCount->setEnabled(!i);
}

void pageDataInfo::input_target_changed(int t)
{
static int update_running=0;
if (update_running==1 || !(inFormats[t]->cmbImportAs->currentIndex()==7 || inFormats[t]->cmbImportAs->currentIndex()==1)) return;
update_running=1;
    for (int j=0;j<number_of_lines;j++)
    {
        if (j==t) continue;
    if (inFormats[j]->cmbImportAs->currentIndex()==7 && inFormats[t]->cmbImportAs->currentIndex()==7)
    inFormats[j]->cmbImportAs->setCurrentIndex(2);
    else if (inFormats[j]->cmbImportAs->currentIndex()==1 && inFormats[t]->cmbImportAs->currentIndex()==1)
    inFormats[j]->cmbImportAs->setCurrentIndex(0);
    }
update_running=0;
}

void pageDataInfo::readDataSettings(importSettings & imp_set)
{
    if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
    if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
    if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
    imp_set.channels=spnChannelCount->value();
    imp_set.read_to_eof=chkReadToEOF->isChecked();
        if (imp_set.read_to_eof) imp_set.points=-1;
        else imp_set.points=spnDataSetCount->value();
    imp_set.channel_target=new int[imp_set.channels];
    imp_set.channel_size=new int[imp_set.channels];
    imp_set.channel_format=new int[imp_set.channels];
    for (int i=0;i<imp_set.channels;i++)
    {
        imp_set.channel_target[i]=inFormats[i]->getTarget();
        imp_set.channel_size[i]=inFormats[i]->getSize();
        imp_set.channel_format[i]=inFormats[i]->getType();
    }
    imp_set.setorder=selOrder->currentIndex();
    imp_set.keep_trigger=chkKeppTrigger->isChecked();
    imp_set.triggervalue=selTriggerValue->value();
    imp_set.trigger_type=selTriggerType->currentValue();
}

void pageDataInfo::writeDataSettings(importSettings & imp_set)
{
spnChannelCount->setValue(imp_set.channels);
    if (imp_set.points<0)
    spnDataSetCount->setValue(0);
    else
    spnDataSetCount->setValue(imp_set.points);
chkReadToEOF->setChecked(imp_set.read_to_eof);
qApp->processEvents();
    for (int i=0;i<imp_set.channels;i++)
    {
    inFormats[i]->setTarget(imp_set.channel_target[i]);
    inFormats[i]->setSize(imp_set.channel_size[i]);
    inFormats[i]->setType(imp_set.channel_format[i]);
    }
selOrder->setCurrentValue(imp_set.setorder);
chkKeppTrigger->setChecked(imp_set.keep_trigger);
selTriggerValue->setValue(imp_set.triggervalue);
selTriggerType->setCurrentValue(imp_set.trigger_type);
}

pageFileInfo::pageFileInfo(QWidget * parent):QWidget(parent)
{
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    lblText=new QLabel(tr("Informations about file / Informations read from header"),this);
    lenText=new QTextEdit(QString(""),this);
    lenText->setReadOnly(true);
    lenText->setWordWrapMode(QTextOption::NoWrap);
    layout->addWidget(lblText);
    layout->addWidget(lenText);
    setLayout(layout);
    headerContents=QString("");
    DatFile=NULL;
    HeaderFile=NULL;
}

pageFileInfo::~pageFileInfo()
{
    if (DatFile!=NULL) delete[] DatFile;
    if (HeaderFile!=NULL) delete[] HeaderFile;
}

void pageFileInfo::showEvent(QShowEvent * event)
{
    event->accept();
    emit(requestInfos());
    qApp->processEvents();
    ShowInfos();
}

void pageFileInfo::ShowInfos(void)
{
    QString filenames=QString::fromLocal8Bit(DatFile);
    lenText->clear();
    char dummy[256];
    if (DatFile)
    {
        if (filenames.contains(";"))
        {
        filenames=filenames.left(filenames.indexOf(";"));
        lenText->append("Multiple files selected; only info on first file shown!");
        }
            if (DatFile==HeaderFile)
            lenText->append(QString("Headerfile=Datafile=\"")+filenames+QString("\""));
            else
            lenText->append(QString("Datafile=\"")+filenames+QString("\""));
        QFileInfo * dfi=new QFileInfo(filenames);
        if (dfi->exists())
        {
        sprintf(dummy,"FileSize= %ld Bytes",(long)dfi->size());
        lenText->append(QString(dummy));
        }
        else
        {
        lenText->append(tr("This File does not exist!"));
        }
    }
    else
    {
        if (DatFile==HeaderFile)
        lenText->append(tr("No Datafile and Headerfile selected!"));
        else
        lenText->append(tr("No Datafile selected!"));
    }
    if (DatFile!=HeaderFile && strcmp(DatFile,HeaderFile)!=0)
    {
        lenText->append(QString(" "));
        if (HeaderFile)
        {
            lenText->append(QString("Headerfile=\"")+QString::fromLocal8Bit(HeaderFile)+QString("\""));
            QFileInfo * hfi=new QFileInfo(QString::fromLocal8Bit(HeaderFile));
            if (hfi->exists())
            {
            sprintf(dummy,"Filesize= %ld Bytes",(long)hfi->size());
            lenText->append(QString(dummy));
            }
            else
            {
            lenText->append(tr("This File does not exist!"));
            }
        }
        else
        lenText->append(tr("No Headerfile selected!"));
    }
    lenText->append(QString(" "));
    lenText->append(headerContents);
}

pageImportInfo::pageImportInfo(QWidget * parent):QWidget(parent)
{
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    selType=new stdSetTypeSelector(this);
    selType->setShowAll(true);
    selType->lblText->setText(tr("Set-Type for imported data:"));
    lblImportTo=new QLabel(tr("Read to graph:"),this);
    importGraph=new uniList(GRAPHLIST,this);
    int number=4;
    QString entr[4];
    int vals[4];
    entr[0]=tr("None");
    vals[0]=AUTOSCALE_NONE;
    entr[1]=tr("X");
    vals[1]=AUTOSCALE_X;
    entr[2]=tr("Y");
    vals[2]=AUTOSCALE_Y;
    entr[3]=tr("XY");
    vals[3]=AUTOSCALE_XY;
    selAutoscale=new StdSelector(this,tr("Autoscale on read:"),number,entr);
    selAutoscale->setValues(vals);
    selAutoscale->setCurrentIndex(3);
    layout->addWidget(selType);
    layout->addWidget(selAutoscale);
    layout->addWidget(lblImportTo);
    layout->addWidget(importGraph);
    setLayout(layout);
}

void pageImportInfo::newChannelCount(int i)
{
    (void)i;
}

void pageImportInfo::read_settings(struct importSettings & imp_set)
{
imp_set.set_type=selType->currentValue();
imp_set.autoscale=selAutoscale->currentValue();
int nr_sel,*selection=new int[2];
    importGraph->get_selection(&nr_sel,&selection);
    if (nr_sel<1) imp_set.target_gno=-1;//no target graph!?
    else imp_set.target_gno=selection[0];
delete[] selection;
}

void pageImportInfo::write_settings(struct importSettings & imp_set)
{
selType->setCurrentIndex(imp_set.set_type);
selAutoscale->setCurrentValue(imp_set.autoscale);
int *selection=new int[2];
    selection[0]=imp_set.target_gno;
    importGraph->set_new_selection(1,selection);
delete[] selection;
}

frmBinaryFormatInput::frmBinaryFormatInput(QWidget * parent):QDialog(parent)
{
    /*dlgLoadFormat=NULL;
    dlgSaveFormat=NULL;
    dlgLoadIniFile=NULL;
    dlgLoadDataFile=NULL;*/
    LoadFormatPath.clear();
    SaveFormatPath.clear();
    LoadIniPath.clear();
    LoadDataPath.clear();
    FormatFileLastUsed.clear();

    CreateActions();

    mnuBar=new QMenuBar(this);
    mnuData=new QMenu(tr("File"),mnuBar);
    mnuSettings=new QMenu(tr("Settings"),mnuBar);

    mnuData->addAction(actLoadDataFile);
    mnuData->addAction(actLoadHeaderFile);
    mnuData->addSeparator();
    mnuData->addAction(actClose);
    mnuSettings->addAction(actautoguess);
    actautoguess->setChecked(true);
    mnuSettings->addSeparator();
    mnuSettings->addAction(actLoadSettings);
    mnuSettings->addAction(actSaveSettings);
    mnuSettings->addSeparator();
    mnuSettings->addAction(actLoadStdSettings);
    mnuSettings->addAction(actSaveStdSettings);
    mnuSettings->addSeparator();
    mnuSettings->addAction(actDeleteSettings);
    mnuBar->addMenu(mnuData);
    mnuBar->addMenu(mnuSettings);

    imp_set.title=new char[2];
    imp_set.subtitle=new char[2];
    imp_set.x_title=new char[2];
    imp_set.y_title=new char[2];
        for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
        imp_set.set_title[i]=new char[2];
    imp_set.first_data=new double*[2];
    imp_set.channel_format=new int[2];
    imp_set.channel_size=new int[2];
    imp_set.channel_target=new int[2];
    imp_set.nr_of_import_tokens=0;
    imp_set.token_target=new int[2];
    imp_set.valid_status=-1;//to tell the functions, that we did not initialize anything (we do not know anything about the file format yet)

    determine_string_size=auto_transfer_from_header=true;

    headerFileNames.clear();
    datFileNames.clear();

    setWindowTitle(tr("QtGrace: Binary file input"));
    grid=new QGridLayout;
    grid->setMargin(STD_MARGIN);
    grid->setSpacing(STD_SPACING);
    QGridLayout * layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING*2);
    QWidget * empty=new QWidget;
    QWidget * empty2=new QWidget;
    QHBoxLayout * layout2=new QHBoxLayout;
    layout2->setMargin(STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    QLabel * lblempty=new QLabel(QString(""),this);
    layout2->addWidget(lblempty);
    empty2->setLayout(layout2);

    /*cmdSave=new QPushButton(tr("Save Format"),this);
    connect(cmdSave,SIGNAL(clicked()),SLOT(doSaveFileFormat()));
    cmdLoad=new QPushButton(tr("Load Format"),this);
    connect(cmdLoad,SIGNAL(clicked()),SLOT(doLoadFileFormat()));
    cmdStdSave=new QPushButton(tr("Save Std.-Format"),this);
    connect(cmdStdSave,SIGNAL(clicked()),SLOT(doSaveStdFormat()));
    cmdStdLoad=new QPushButton(tr("Load Std.-Format"),this);
    connect(cmdStdLoad,SIGNAL(clicked()),SLOT(doLoadStdFormat()));*/

    lblFormatSource=new QLabel(tr("Format Source:"),this);
    cmbFormatSource=new QComboBox(this);
    cmbFormatSource->addItem(tr("manual"));
    cmbFormatSource->addItem(tr("datafile"));
    cmbFormatSource->addItem(tr("seperate file"));
    cmbFormatSource->setCurrentIndex(1);
    connect(cmbFormatSource,SIGNAL(currentIndexChanged(int)),SLOT(formatSourceChanged(int)));
        lenDataFile=new stdLineEdit(this,tr("Datafile:"));
        lenDataFile->setAcceptDrops(true);
        lenDataFile->setText(QString(""));
        lenHeaderFile=new stdLineEdit(this,tr("Headerfile:"));
        lenHeaderFile->setAcceptDrops(true);
        lenHeaderFile->setText(QString(""));
    connect(lenDataFile,SIGNAL(changed()),SLOT(newFileEntry()));
    connect(lenHeaderFile,SIGNAL(changed()),SLOT(newFileEntry()));
    /*lblDataFile=new QLabel(tr("Datafile:"),this);
    lenDataFile=new QLineEdit(QString(""),this);
    lblHeaderFile=new QLabel(tr("Headerfile:"),this);
    lenHeaderFile=new QLineEdit(QString(""),this);*/

    /*chkAutoGuessFormat=new QCheckBox(tr("Auto-guess binary file format"),this);
    chkAutoGuessFormat->setChecked(true);*/
    lblCurScheme=new QLabel(tr("Current import scheme: None"),this);
    chkHeader=new QCheckBox(tr("Header informations present"),this);
    chkHeader->setChecked(true);
    connect(chkHeader,SIGNAL(toggled(bool)),SLOT(headerToggled(bool)));
    chkMultiHeaders=new QCheckBox(tr("separate header file for every data file"),this);
    chkMultiHeaders->setChecked(true);
    lblHeaderFileFormat=new QLabel(tr("Headerfile-Format:"),this);
    cmbHeaderFileFormat=new QComboBox(this);
    cmbHeaderFileFormat->addItem(tr("binary-file"));
    cmbHeaderFileFormat->addItem(tr("ini-file"));
    /// cmbHeaderFileFormat->addItem(tr("ascii-file"));///deactivated at the moment
    connect(cmbHeaderFileFormat,SIGNAL(currentIndexChanged(int)),SLOT(HeaderFormatChanged(int)));

    tabs=new QTabWidget;

    tabHeader=new pageHeaderInfo(this);
    tabHeader->par_wid=this;
    tabDataInfo=new pageDataInfo(this);
    tabFileInfo=new pageFileInfo(this);
    tabImportInfo=new pageImportInfo(this);
    connect(tabHeader,SIGNAL(readHeader()),this,SLOT(readHeader()));
    connect(tabFileInfo,SIGNAL(requestInfos()),SLOT(transmitInfos()));
    tabs->addTab(tabHeader,tr("Header-Format"));
    tabs->addTab(tabFileInfo,tr("File-Info"));
    tabs->addTab(tabDataInfo,tr("Data-Format"));
    tabs->addTab(tabImportInfo,tr("Import"));

    aac=new stdButtonGroup(this,true,true,false);
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doOK()));
    connect(aac->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

    cmdSelectDataFile=new QPushButton(tr("Browse..."),this);
    connect(cmdSelectDataFile,SIGNAL(clicked()),SLOT(SelectDataFile()));
    cmdSelectHeaderFile=new QPushButton(tr("Browse..."),this);
    connect(cmdSelectHeaderFile,SIGNAL(clicked()),SLOT(SelectHeaderFile()));

int index=0,index2=0;
    //layout->addWidget(chkAutoGuessFormat,index,0,1,2);
    //layout->addWidget(lblCurScheme,index++,2,1,2);
    layout->addWidget(lblCurScheme,index++,0,1,4);
    /*layout->addWidget(cmdLoad,index,0,1,1);
    layout->addWidget(cmdSave,index,1,1,1);
    layout->addWidget(cmdStdLoad,index,2,1,1);
    layout->addWidget(cmdStdSave,index++,3,1,1);*/
    layout->addWidget(chkHeader,index,0,1,2);
    layout->addWidget(chkMultiHeaders,index++,2,1,2);
    empty->setLayout(layout);

#ifndef MAC_SYSTEM
    grid->addWidget(mnuBar,index2++,0,1,3);
#endif
    grid->addWidget(empty,index2++,0,1,3);
    grid->addWidget(lblFormatSource,index2,0);
    grid->addWidget(cmbFormatSource,index2++,1);
    /*grid->addWidget(lblDataFile,2,0);
    grid->addWidget(lenDataFile,2,1);*/
    grid->addWidget(lenDataFile,index2,0,1,2);
    grid->addWidget(cmdSelectDataFile,index2++,2);
    /*grid->addWidget(lblHeaderFile,3,0);
    grid->addWidget(lenHeaderFile,3,1);*/
    grid->addWidget(lenHeaderFile,index2,0,1,2);
    grid->addWidget(cmdSelectHeaderFile,index2++,2);
    grid->addWidget(lblHeaderFileFormat,index2,0);
    grid->addWidget(cmbHeaderFileFormat,index2++,1);
    grid->addWidget(empty2,index2++,0,1,3);
    grid->addWidget(tabs,index2++,0,1,3);
    grid->addWidget(aac,index2++,0,1,3);
    setLayout(grid);

    cmbFormatSource->setCurrentIndex(1);
    formatSourceChanged(1);
    initSettings(imp_set,false);//the settings will be uninitialized
    initSettings(imp_scheme,false);

cur_import_scheme=-1;//no schema
    resize(LastSize_FormBinaryImportFilter);
}

frmBinaryFormatInput::~frmBinaryFormatInput()
{
    LastSize_FormBinaryImportFilter=this->size();
}

void frmBinaryFormatInput::displaySettings(struct importSettings & imp_s)
{
    //cout << "header present: " << imp_set.header_present << endl;
chkHeader->setChecked(imp_s.header_present);
    //cout << "multiple_headers: " << imp_set.multiple_header_files << endl;
chkMultiHeaders->setChecked(imp_s.multiple_header_files);
    //cout << "header Format=" << imp_set.header_format << endl;
    if (imp_s.header_format==0)
    {
    cmbFormatSource->setCurrentIndex(0);
    }
    else if (imp_s.header_format==1)
    {
    cmbFormatSource->setCurrentIndex(1);
    }
    else
    {
    cmbFormatSource->setCurrentIndex(2);
    cmbHeaderFileFormat->setCurrentIndex(imp_s.header_format-2);
    }
//transmitInfos();
    tabHeader->write_header_settings(imp_s);
    tabDataInfo->writeDataSettings(imp_s);
    tabImportInfo->write_settings(imp_s);
}

void frmBinaryFormatInput::readSettings(struct importSettings & imp_s, int type)
{
    if (type==0 || type==3)
    {
    imp_s.header_present=chkHeader->isChecked();
    imp_s.multiple_header_files=chkMultiHeaders->isChecked();
        if (cmbFormatSource->currentIndex()==0)//manual
        {
        imp_s.header_format=0;
        }
        else if (cmbFormatSource->currentIndex()==1)//header in bin-data-file
        {
        imp_s.header_format=1;
        }
        else//header in separate file (bin/ini/ascii)
        {
        imp_s.header_format=2+cmbHeaderFileFormat->currentIndex();
        }
    tabHeader->read_header_settings(imp_s);
    }
if (type==1 || type==3)
tabDataInfo->readDataSettings(imp_s);
if (type==2 || type==3)
tabImportInfo->read_settings(imp_s);
/// for debugging
//SaveFileFormat("/Users/andreaswinter/Read_schema_Settings.fmt",imp_s);/// just save for testing
/// end debugging
}

void frmBinaryFormatInput::HeaderFormatChanged(int i)
{
bool headerPresent=chkHeader->isChecked();
//int headerType=cmbHeaderFileFormat->currentIndex();
int formatSource=cmbFormatSource->currentIndex();
    if (headerPresent==false || formatSource<=1)
    {
        lenHeaderFile->setVisible(false);
        cmdSelectHeaderFile->setVisible(false);
    lblHeaderFileFormat->setVisible(false);
    cmbHeaderFileFormat->setVisible(false);
        if (formatSource==1)//datafile
        {
        cmbHeaderFileFormat->setCurrentIndex(0);//always binary
        }
    }
    else//headerPresent==true && formatSource>1//ini- || ascii-header
    {
        lenHeaderFile->setVisible(true);
        cmdSelectHeaderFile->setVisible(true);
    lblHeaderFileFormat->setVisible(true);
    cmbHeaderFileFormat->setVisible(true);
    }
tabHeader->changeRepresentation(i);
}

void frmBinaryFormatInput::doSaveFileFormat(void)
{
    /*
    if (dlgSaveFormat==NULL)
    {
    dlgSaveFormat=new QFileDialog(this,tr("Save File Format Settings"),qt_grace_share_dir);
    dlgSaveFormat->setFileMode(QFileDialog::AnyFile);
    dlgSaveFormat->setNameFilter(tr("Format specification (*.fmt)"));
    }
    if (dlgSaveFormat->exec())
    {
    QStringList fileNames;
    QString str;
    fileNames = dlgSaveFormat->selectedFiles();
        if (fileNames.length()<=0) return;
        str=fileNames.at(0);
    }*/
    QString templ_dir=QString(qt_grace_templates_dir);
    QString str;
    if (!SaveFormatPath.isEmpty())
    str=QFileDialog::getSaveFileName(this,tr("Save Format Info File"),SaveFormatPath);
    else
    str=QFileDialog::getSaveFileName(this,tr("Save Format Info File"),templ_dir);

    if (!str.isEmpty())
    {
    char * files=new char[8+str.length()];
    strcpy(files,str.toLocal8Bit().constData());
        updateSuffixes();
        imp_set.DataSuffix=Data_Suffix;
        imp_set.HeaderSuffix=HeaderSuffix;

        tabHeader->read_header_settings(imp_set);
        tabDataInfo->readDataSettings(imp_set);
        imp_set.set_type=tabImportInfo->selType->currentIndex();

        SaveFileFormat(files,imp_set);

        QFileInfo tmpInfo(files);
        SaveFormatPath=tmpInfo.path();

    delete[] files;
    }
}

void frmBinaryFormatInput::doLoadFileFormat(void)
{
    /*if (dlgLoadFormat==NULL)
    {
    dlgLoadFormat=new QFileDialog(this,tr("Load File Format Settings"),qt_grace_share_dir);
    dlgLoadFormat->setFileMode(QFileDialog::ExistingFile);
    dlgLoadFormat->setNameFilter(tr("Format specification (*.fmt)"));
    }
    if (dlgLoadFormat->exec())
    {
    QStringList fileNames;
    QString str;
    fileNames = dlgLoadFormat->selectedFiles();
        if (fileNames.length()<=0) return;
        str=fileNames.at(0);
    }*/
    QString templ_dir=QString(qt_grace_templates_dir);
    QString str;
    if (!LoadFormatPath.isEmpty())
    str=QFileDialog::getOpenFileName(this,tr("Load Format Info File"),LoadFormatPath,tr("Format specification (*.fmt)"));
    else
        str=QFileDialog::getOpenFileName(this,tr("Load Format Info File"),templ_dir,tr("Format specification (*.fmt)"));
    if (!str.isEmpty())
    {
    char * files=new char[8+str.length()];
    strcpy(files,str.toLocal8Bit().constData());
    FormatFileLastUsed=str;
        LoadFileFormat(files,imp_scheme);///load the import settings in the scheme
    displaySettings(imp_scheme);
    tabHeader->write_header_settings(imp_scheme);
        QFileInfo tmpInfo(files);
        LoadFormatPath=tmpInfo.path();
    cur_import_scheme=-2;//scheme loaded form a format file
        lblCurScheme->setText(tr("Current scheme: ")+tmpInfo.fileName());
    delete[] files;
    }//end of !str.isEmpty()
}

void frmBinaryFormatInput::doSaveStdFormat(void)
{
/*QString stdTarget=QString(qt_grace_share_dir)+QString("/QtGrace_StdBinFormat.fmt");
char * std_File_Save=new char[2+2*stdTarget.length()];
strcpy(std_File_Save,stdTarget.toLocal8Bit().constData());
    updateSuffixes();
    imp_set.DataSuffix=DataSuffix;
    imp_set.HeaderSuffix=HeaderSuffix;
    tabHeader->read_header_settings(imp_set);
    tabDataInfo->readDataSettings(imp_set);
    imp_set.set_type=tabImportInfo->selType->currentIndex();
    SaveFileFormat(std_File_Save,imp_set);
delete[] std_File_Save;*/
QString templ_dir=QString(qt_grace_templates_dir);
    if (FormSimpleListSel==NULL)
    {
    FormSimpleListSel=new frmSimpleListSelectionDialog(0);
    }
QString * entries=new QString[2+nr_of_std_bin_import_settings];
    for (int i=0;i<nr_of_std_bin_import_settings;i++)
    {
    entries[i]=std_bin_import_settings[i].name;
    }
FormSimpleListSel->init(entries,nr_of_std_bin_import_settings,false);
int ret=FormSimpleListSel->exec();
    if (ret==1 && FormSimpleListSel->return_nr!=-1)//not cancel
    {
        if (FormSimpleListSel->return_nr==-2)//new name
        {
        QString n_filename=templ_dir+QDir::separator()+QString("QtGrace_std_bin_format_")+FormSimpleListSel->return_name+QString(".fmt");
            //cout << "Filename=" << n_filename.toLocal8Bit().data() << endl;
        SaveFileFormat(n_filename.toLocal8Bit().data(),imp_set);
        imp_set.name=FormSimpleListSel->return_name;
        imp_set.filename=n_filename;
        struct importSettings * n_imp_set=new struct importSettings[1+nr_of_std_bin_import_settings];
        for (int i=0;i<nr_of_std_bin_import_settings;i++)
        {
        initSettings(n_imp_set[i],false);
        copy_import_settings(std_bin_import_settings+i,n_imp_set+i);
        initSettings(std_bin_import_settings[i]);
        }
        copy_import_settings(&imp_set,n_imp_set+nr_of_std_bin_import_settings);
        nr_of_std_bin_import_settings++;
        delete[] std_bin_import_settings;
        std_bin_import_settings=n_imp_set;
        }
        else if (FormSimpleListSel->return_nr>=0)//existing name
        {
        SaveFileFormat(std_bin_import_settings[FormSimpleListSel->return_nr].filename.toLocal8Bit().data(),imp_set);
        }
    }
delete[] entries;
}

void frmBinaryFormatInput::doLoadStdFormat(void)
{
/*QString stdTarget=QString(qt_grace_share_dir)+QString("/QtGrace_StdBinFormat.fmt");
char * std_File_Save=new char[2+2*stdTarget.length()];
strcpy(std_File_Save,stdTarget.toLocal8Bit().constData());
    LoadFileFormat(std_File_Save,imp_set);
delete[] std_File_Save;*/
    if (FormSimpleListSel==NULL)
    {
    FormSimpleListSel=new frmSimpleListSelectionDialog(0);
    }
QString * entries=new QString[2+nr_of_std_bin_import_settings];
    for (int i=0;i<nr_of_std_bin_import_settings;i++)
    {
    entries[i]=std_bin_import_settings[i].name;
    }
FormSimpleListSel->init(entries,nr_of_std_bin_import_settings,true);
int ret=FormSimpleListSel->exec();
    if (ret==1 && FormSimpleListSel->return_nr!=-1)//not cancel
    {
    //FormatFileLastUsed=std_bin_import_settings[FormSimpleListSel->return_nr].filename;
    LoadFileFormat(std_bin_import_settings[FormSimpleListSel->return_nr].filename.toLocal8Bit().data(),imp_set);
    LoadFileFormat(std_bin_import_settings[FormSimpleListSel->return_nr].filename.toLocal8Bit().data(),imp_scheme);
        displaySettings(imp_scheme);
        tabHeader->write_header_settings(imp_scheme);
    QFileInfo tmpInfo(std_bin_import_settings[FormSimpleListSel->return_nr].filename);
        LoadFormatPath=tmpInfo.path();
    cur_import_scheme=FormSimpleListSel->return_nr;
        lblCurScheme->setText(tr("Current scheme: ")+std_bin_import_settings[FormSimpleListSel->return_nr].name);
    }
delete[] entries;
}

void frmBinaryFormatInput::doClearCurrentScheme(void)
{
int ret=QMessageBox::question(this,tr("Clear current scheme"),tr("Do you really want do clear the current import settings and reset the import-dialog? (Any saved format-files stay untouched.)"),QMessageBox::Yes,QMessageBox::Cancel);
    if (ret==QMessageBox::Yes)
    {
    initSettings(imp_set);
    initSettings(imp_scheme);
    lblCurScheme->setText(tr("Current import scheme: None"));
    }
    else
    {
    cout << "CANCEL" << endl;
    }
}

void LoadFileFormat(const char *fname,struct importSettings & imp_set)
{
    QString s_dummy,s_dummy2;
    int version;
    //int nr_of_channels,nr_of_datasets,nr_of_lines;
    int dint;
    int idummy;
    char dummy[512];
    char dummy2[512];//,dummy3[8];
    strcpy(dummy,fname);
    ifstream ifi;
    ifi.open(dummy);
    ifi >> dummy >> version;
///cout << fname << " --> dummy=#" << dummy << "# version=" << version << endl;
    if (strcmp(dummy,"Binary_Format_Info_File_V"))
    {
        errwin(QObject::tr("File is not a Grace-format description!").toLocal8Bit().constData());
        ifi.close();
        return;
    }
    initSettings(imp_set);//clear old settings
    if (version==1)/// old format
    {
//cout << "Loading OLD format description" << endl;
    ifi >> dint;
    imp_set.header_present=(bool)dint;
    //chkHeader->setChecked((bool)dint);
    ifi >> dint;
    imp_set.header_format=dint;
    ///cmbFormatSource->setCurrentIndex(dint);
    ifi >> dint;
    if (imp_set.header_format>1)
    {
    imp_set.header_format=2+dint;
    }
    //cmbHeaderFileFormat->setCurrentIndex(dint);
    ifi >> dummy;
    //cout << "dummy=#" << dummy << "#" << endl;
    imp_set.string_end_char=dummy[0];
    //tabHeader->lenEndChar->setText(QString(dummy));
    ifi >> imp_set.nr_of_header_values;//nr_of_lines;
    if (imp_set.header_value_format!=NULL) delete[] imp_set.header_value_format;
    if (imp_set.header_value_size!=NULL) delete[] imp_set.header_value_size;
    if (imp_set.header_value_import!=NULL) delete[] imp_set.header_value_import;
    imp_set.header_value_format=new int[2+imp_set.nr_of_header_values];
    imp_set.header_value_size=new int[2+imp_set.nr_of_header_values];
    imp_set.header_value_import=new int[2+imp_set.nr_of_header_values];
        //int nr_of_header_values;
        //int * header_value_format,* header_value_size,* header_value_import;
    /*
    //cout << "nr_of_lines=" << nr_of_lines << endl;
    while (tabHeader->number_of_lines<nr_of_lines)
    {
        //cout << "tabHeader_nroflines=" << tabHeader->number_of_lines << endl;
        tabHeader->doNew();
    }
    while (tabHeader->number_of_lines>nr_of_lines)
    {
        //cout << "tabHeader_nroflines=" << tabHeader->number_of_lines << endl;
        tabHeader->doDelete(tabHeader->number_of_lines-1);
    }*/
    for (int i=0;i<imp_set.nr_of_header_values;i++)//nr_of_lines;i++)
    {
        ifi >> dint;
        imp_set.header_value_format[i]=dint;
        //tabHeader->inFormats[i]->cmbFormat->setCurrentIndex(dint);
        ifi >> dint;
        imp_set.header_value_size[i]=dint;
        //tabHeader->inFormats[i]->spnSize->setValue(dint);
        ifi >> dint;
        imp_set.header_value_import[i]=dint;
        //tabHeader->inFormats[i]->cmbImportAs->setCurrentIndex(dint);
    }
    ifi >> dint;
    imp_set.read_to_eof=dint;
    //tabDataInfo->chkReadToEOF->setChecked((bool)dint);
    ifi >> imp_set.channels;//nr_of_channels;
    //tabDataInfo->spnChannelCount->setValue(nr_of_channels);
    ifi >> imp_set.points;//nr_of_datasets;
    //tabDataInfo->spnDataSetCount->setValue(nr_of_datasets);
    ifi >> dint;
    imp_set.setorder=dint;
    //tabDataInfo->selOrder->setCurrentIndex(dint);
    ifi >> dint;//nr_of_lines;
    //cout << "nr_of_lines=" << nr_of_lines << endl;
    //cout << "tabDataInfo->number_of_lines=" << tabDataInfo->number_of_lines << endl;
        //tabDataInfo->channelCountChanged(nr_of_lines);
    if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
    if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
    if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
    imp_set.channel_format=new int[2+imp_set.channels];
    imp_set.channel_size=new int[2+imp_set.channels];
    imp_set.channel_target=new int[2+imp_set.channels];
    for (int i=0;i<imp_set.channels;i++)//nr_of_lines;i++)
    {
        ifi >> dint;
        imp_set.channel_format[i]=dint;
        //tabDataInfo->inFormats[i]->cmbFormat->setCurrentIndex(dint);
        ifi >> dint;
        imp_set.channel_size[i]=dint;
        //tabDataInfo->inFormats[i]->spnSize->setValue(dint);
        ifi >> dint;
        imp_set.channel_target[i]=dint;
        //tabDataInfo->inFormats[i]->cmbImportAs->setCurrentIndex(dint);
    }
    ifi >> dint;
    /*if (nr_of_channels<=1)
        tabImportInfo->selType->setColumnCount(2);
    else
        tabImportInfo->selType->setColumnCount(nr_of_channels);*/
    imp_set.set_type=dint;
    //tabImportInfo->selType->setCurrentValue(dint);
    ifi.close();
    }
    else if (version==2)/// new file format
    {
    //int count_set_tokens=0;
    int nr_of_lines;
//cout << "Loading NEW format description" << endl;
        ifi >> dummy2 >> idummy;//Header_present
        imp_set.header_present=idummy;
        //chkHeader->setChecked(idummy==1?true:false);
        ifi >> dummy2 >> idummy;//Multiple_headers
        imp_set.multiple_header_files=idummy;
        //chkMultiHeaders->setChecked(idummy==1?true:false);
        ifi >> dummy2 >> dummy;//Data_Suffix
        imp_set.DataSuffix=get_text_in_quotations(QString(dummy));
        //DataSuffix=QString(dummy);
        ifi >> dummy2 >> dummy;//Header_Suffix
        imp_set.HeaderSuffix=get_text_in_quotations(QString(dummy));
        //HeaderSuffix=QString(dummy);
        ifi >> dummy2 >> idummy;//Format_Source
        imp_set.header_format=idummy;
        //cmbFormatSource->setCurrentIndex(idummy);
        ifi >> dummy2 >> idummy;//Header_Format
            if (imp_set.header_format==2)
            imp_set.header_format=2+idummy;
        //cmbHeaderFileFormat->setCurrentIndex(idummy);
        ifi >> dummy2 >> dummy;//Line_End_Char(ASCII)
        imp_set.string_end_char=dummy[0];
        //tabHeader->lenEndChar->setText(dummy);
        ifi >> dummy2 >> imp_set.nr_of_header_values;//nr_of_lines;//Bin_Header_Definition_Length

        /*while (tabHeader->number_of_lines<nr_of_lines)
        {
            //cout << "tabHeader_nroflines=" << tabHeader->number_of_lines << endl;
            tabHeader->doNew();
        }
        while (tabHeader->number_of_lines>nr_of_lines)
        {
            //cout << "tabHeader_nroflines=" << tabHeader->number_of_lines << endl;
            tabHeader->doDelete(tabHeader->number_of_lines-1);
        }*/
        if (imp_set.header_value_format!=NULL) delete[] imp_set.header_value_format;
        imp_set.header_value_format=new int[2+imp_set.nr_of_header_values];
        if (imp_set.header_value_size!=NULL) delete[] imp_set.header_value_size;
        imp_set.header_value_size=new int[2+imp_set.nr_of_header_values];
        if (imp_set.header_value_import!=NULL) delete[] imp_set.header_value_import;
        imp_set.header_value_import=new int[2+imp_set.nr_of_header_values];
//cout << "Header dummy2=#" << dummy2 << "# nr=" << nr_of_lines << endl;
            if (imp_set.nr_of_header_values)//tabHeader->number_of_lines>0)
            ifi.getline(dummy2,512);//to remove the line ending
        for (int i=0;i<imp_set.nr_of_header_values;i++)//tabHeader->number_of_lines;i++)
        {
            ifi.getline(dummy2,512);
         //cout << i << " Format dummy2=#" << dummy2 << "#" << endl;
            s_dummy=QString(dummy2);
            s_dummy2=get_text_in_quotations(s_dummy);
         //cout << "gelesen=#" << s_dummy2.toLocal8Bit().constData() << "#" << endl;
            strcpy(dummy2,s_dummy2.toLocal8Bit().constData());
            //idummy=find_import_destination(dummy2,2);//data in bin-header

            idummy=find_import_format(dummy2);//data-type in bin-header

            /*
            for (int j=0;j<NUMBER_OF_COLUMN_FORMATS;j++)
            {
                if (!strcmp(dummy2,binaryImportFormatName[j]))
                {
                idummy=j;
                break;
                }
            }
            */
         //cout << "index=" << idummy << endl;
            imp_set.header_value_format[i]=idummy;
            //tabHeader->inFormats[i]->cmbFormat->setCurrentIndex(idummy);
            //ifi >> dummy2 >> dummy;//Format
            //cout << "H: Format=#" << dummy << "#" << endl;
                //ifi >> dummy2 >> s_dummy;//Format
                //cout << "H: Format=#" << s_dummy.toLocal8Bit().constData() << "#" << endl;
            /// ToDo: find the format
            //ofi << i << ":Format= \"" << binaryImportFormatName[tabHeader->inFormats[i]->cmbFormat->currentIndex()] << "\"" << endl;
            ifi >> dummy2 >> idummy;//Size
            imp_set.header_value_size[i]=idummy;
            //tabHeader->inFormats[i]->spnSize->setValue(idummy);
         //cout << "size=" << idummy << endl;
            //ifi >> dummy2 >> dummy;//ImportAs
            //cout << "H: ImportAs=#" << dummy << "#" << endl;
            ifi.getline(dummy2,512);//to remove the line ending
            ifi.getline(dummy2,512);
         //cout << i << " ImportAs dummy2=#" << dummy2 << "#" << endl;
            s_dummy=QString(dummy2);
            s_dummy2=get_text_in_quotations(s_dummy);
            strcpy(dummy2,s_dummy2.toLocal8Bit().constData());
         //cout << "gelesen=#" << s_dummy2.toLocal8Bit().constData() << "#" << endl;
            idummy=find_import_destination(dummy2,1);//header-destination in bin-header
            /*for (int j=0;j<tabHeader->inFormats[0]->cmbImportAs->count();j++)
            {
                if (QString::compare(tabHeader->inFormats[0]->cmbImportAs->itemText(j),s_dummy2)==0)
                {
                idummy=j;
                break;
                }
            }*/
        //cout << "index=" << idummy << endl;
            imp_set.header_value_import[i]=idummy;
            //tabHeader->inFormats[i]->cmbImportAs->setCurrentIndex(idummy);
                //ifi >> dummy2 >> s_dummy2;//ImportAs
                //cout << "H: ImportAs=#" << s_dummy2.toLocal8Bit().constData() << "#" << endl;
            /// ToDo: Search for this dummy
            //tabHeader->inFormats[i]->cmbImportAs->currentText().toLatin1().constData();
        }

        ifi >> dummy2 >> idummy;//ReadUntilEOF
        imp_set.read_to_eof=(idummy==1?true:false);
        //tabDataInfo->chkReadToEOF->setChecked(idummy==1?true:false);
        ifi >> dummy2 >> idummy;//ChannelCount
        imp_set.channels=idummy;
        //tabDataInfo->spnChannelCount->setValue(idummy);
        ifi >> dummy2 >> idummy;//NrOfDataSets
        imp_set.points=idummy;
        //tabDataInfo->spnDataSetCount->setValue(idummy);
        ifi >> dummy2 >> idummy;//SetOrderingInFile
        imp_set.setorder=idummy;
        //tabDataInfo->selOrder->setCurrentIndex(idummy);
        ifi >> dummy2 >> idummy;//Trigger_Type
        imp_set.trigger_type=idummy;
        //tabDataInfo->selTriggerType->setCurrentIndex(idummy);
        ifi >> dummy2 >> dummy;//Trigger_Value
        imp_set.triggervalue=atof(dummy);
        //tabDataInfo->selTriggerValue->setValue(atof(dummy));
        ifi >> dummy2 >> nr_of_lines;//Bin_Input_Definition_Length
///cout << "Data dummy2=#" << dummy2 << "# nr=" << nr_of_lines << endl;

        //tabDataInfo->channelCountChanged(nr_of_lines);

        if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
        if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
        if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;

        imp_set.channel_format=new int[imp_set.channels+2];
        imp_set.channel_size=new int[imp_set.channels+2];
        imp_set.channel_target=new int[imp_set.channels+2];

        //if (nr_of_lines>0)
        if (imp_set.channels>0)
        ifi.getline(dummy2,512);//to remove the line ending
        for (int i=0;i<imp_set.channels;i++)//tabDataInfo->number_of_lines;i++)
        {
            ifi.getline(dummy2,512);
         //cout << i << " Format dummy2=#" << dummy2 << "#" << endl;
            s_dummy=QString(dummy2);
            s_dummy2=get_text_in_quotations(s_dummy);
            strcpy(dummy2,s_dummy2.toLocal8Bit().constData());
            idummy=-1;
            for (int j=0;j<NUMBER_OF_COLUMN_FORMATS;j++)
            {
                if (!strcmp(dummy2,binaryImportFormatName[j]))
                {
                idummy=j;
                break;
                }
            }
         //cout << "index=" << idummy << endl;
            imp_set.channel_format[i]=idummy;
            //tabDataInfo->inFormats[i]->cmbFormat->setCurrentIndex(idummy);
            //ifi >> dummy2 >> dummy;//Format
         //cout << "D: Format=#" << dummy2 << "#" << endl;
            /// ToDo: find the format
            //ofi << i << ":Format= \"" << binaryImportFormatName[tabDataInfo->inFormats[i]->cmbFormat->currentIndex()] << "\"" << endl;
            ifi >> dummy2 >> idummy;//Size
            imp_set.channel_size[i]=idummy;
            //tabDataInfo->inFormats[i]->spnSize->setValue(idummy);
         //cout << "size=" << idummy << endl;
            //ifi >> dummy2 >> dummy;//ImportAs
            //cout << "H: ImportAs=#" << dummy << "#" << endl;
            ifi.getline(dummy2,512);//to remove the line ending
            ifi.getline(dummy2,512);
         //cout << i << " ImportAs dummy2=#" << dummy2 << "#" << endl;
            s_dummy=QString(dummy2);
            s_dummy2=get_text_in_quotations(s_dummy);
            strcpy(dummy2,s_dummy2.toLocal8Bit().constData());
         //cout << "gelesen=#" << s_dummy2.toLocal8Bit().constData() << "#" << endl;
            idummy=find_import_destination(dummy2,2);
            /*for (int j=0;j<tabDataInfo->inFormats[0]->cmbImportAs->count();j++)
            {
                if (QString::compare(tabDataInfo->inFormats[0]->cmbImportAs->itemText(j),s_dummy2)==0)
                {
                idummy=j;
                break;
                }
            }*/
         //cout << "index=" << idummy << endl;
            imp_set.channel_target[i]=idummy;
            //tabDataInfo->inFormats[i]->cmbImportAs->setCurrentIndex(idummy);

            if (imp_set.channel_size[i]<=0)
            {
            imp_set.channel_size[i]=binaryImportFormat[imp_set.channel_format[i]].size;
            }

        }
        ifi >> dummy2 >> idummy;//Import_Set_As
        imp_set.set_type=idummy;
///cout << "dummy2=" << dummy2 << " idummy=" << idummy << endl;
        //tabImportInfo->selType->setCurrentValue(idummy);
        ifi >> dummy2 >> idummy;//Autoscale
        imp_set.autoscale=idummy;
        ifi >> dummy2 >> imp_set.nr_of_import_tokens;//count_set_tokens;//INI-Import-Tokens

        imp_set.vals.clear();
        imp_set.keys.clear();
        imp_set.import_channel_dest.clear();
            if (imp_set.nr_of_import_tokens>0)//count_set_tokens
            {
            ifi.getline(dummy2,512);//to remove the line ending
            if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
            imp_set.token_target=new int[imp_set.nr_of_import_tokens];
            }
        imp_set.import_dest.clear();
        for (int i=0;i<imp_set.nr_of_import_tokens;i++)
        {
        ifi.getline(dummy2,512);
        s_dummy=QString(dummy2);
        idummy=s_dummy.indexOf(" ");
        s_dummy=s_dummy.left(idummy);
        imp_set.import_channel_dest << s_dummy.toInt();
        s_dummy=QString(dummy2);
        idummy=s_dummy.indexOf(" ");
        s_dummy=s_dummy.mid(idummy+1);
        idummy=s_dummy.lastIndexOf(" = \"");
        s_dummy=s_dummy.left(idummy);
        imp_set.keys << s_dummy;
        s_dummy=QString(dummy2);
        s_dummy2=get_text_in_quotations(s_dummy);
        imp_set.vals << s_dummy2;
///cout << "Key=#" << imp_set.keys.last().toLocal8Bit().constData() << "#" << endl;
///cout << "Val=#" << imp_set.vals.last().toLocal8Bit().constData() << "#" << endl;
///cout << "Channel=#" << imp_set.import_channel_dest.last() << "#" << endl;
        imp_set.token_target[i]=find_import_destination(imp_set.vals.last().toLocal8Bit().data(),1);
        imp_set.import_dest << imp_set.token_target[i];
        }
    }
    ifi.close();
}

void SaveFileFormat(const char * fname,struct importSettings & imp_set)
{
    char * dummy=new char[512>strlen(fname)?512:strlen(fname)];
    strcpy(dummy,fname);
    ofstream ofi;
    ofi.open(fname);
    ofi << "Binary_Format_Info_File_V 2" << endl;
    ofi << "Header_present= " << (imp_set.header_present==true?1:0) << endl;//(chkHeader->isChecked()==true?1:0) << endl;
    ofi << "Multiple_headers= " << (imp_set.multiple_header_files==true?1:0) << endl;//(chkMultiHeaders->isChecked()==true?1:0) << endl;
    ofi << "Data_Suffix= \"" << imp_set.DataSuffix.toLocal8Bit().constData() << "\"" << endl;
    ofi << "Header_Suffix= \"" << imp_set.HeaderSuffix.toLocal8Bit().constData() << "\"" << endl;
//0=manual
//1=header in data file itself
//2=header in separate binary-data-file
//3=header in separate ini-fil
//4=header in separate ascii-file
    if (imp_set.header_format<2)
    {
    ofi << "Format_Source= " << imp_set.header_format << endl;//cmbFormatSource->currentIndex()
    ofi << "Header_Format= " << 0 << endl;//cmbHeaderFileFormat->currentIndex()
    }
    else
    {
    ofi << "Format_Source= " << 2 << endl;//cmbFormatSource->currentIndex()
    ofi << "Header_Format= " << imp_set.header_format-2 << endl;//cmbHeaderFileFormat->currentIndex()
    }
    //strcpy(dummy,tabHeader->lenEndChar->text().toLocal8Bit());
    ofi << "Line_End_Char(ASCII)= " << (int)(imp_set.string_end_char) << endl;
    ofi << "Bin_Header_Definition_Length= " << imp_set.nr_of_header_values << endl;//tabHeader->number_of_lines
    for (int i=0;i<imp_set.nr_of_header_values;i++)//tabHeader->number_of_lines;i++)
    {
        ofi << i << ":Format= \"" << binaryImportFormatName[imp_set.header_value_format[i]] << "\"" << endl;//tabHeader->inFormats[i]->cmbFormat->currentIndex()
        ofi << i << ":Size= " << imp_set.header_value_size[i] << endl;//tabHeader->inFormats[i]->spnSize->value()
        ofi << i << ":ImportAs= \"" << ImportDestinationName[imp_set.header_value_import[i]] << "\"" << endl;//tabHeader->inFormats[i]->cmbImportAs->currentText().toLatin1().constData()
    }
    ofi << "ReadUntilEOF= " << (imp_set.read_to_eof==true?1:0) << endl;//tabDataInfo->chkReadToEOF->isChecked()
    ofi << "ChannelCount= " << imp_set.channels << endl;//tabDataInfo->spnChannelCount->value()
    ofi << "NrOfDataSets= " << imp_set.points << endl;//tabDataInfo->spnDataSetCount->value()
    ofi << "SetOrderingInFile= " << imp_set.setorder << endl;//tabDataInfo->selOrder->currentIndex()
    ofi << "Trigger_Type= " << imp_set.trigger_type << endl;//tabDataInfo->selTriggerType->currentIndex()
    ofi << "Trigger_Value= " << imp_set.triggervalue << endl;//tabDataInfo->selTriggerValue->value()
    ofi << "Bin_Input_Definition_Length= " << imp_set.channels << endl;//tabDataInfo->number_of_lines
    for (int i=0;i<imp_set.channels;i++)//tabDataInfo->number_of_lines;i++)
    {
        ofi << i << ":Format= \"" << binaryImportFormatName[imp_set.channel_format[i]] << "\"" << endl;//tabDataInfo->inFormats[i]->cmbFormat->currentIndex()
        ofi << i << ":Size= " << imp_set.channel_size[i] << endl;//tabDataInfo->inFormats[i]->spnSize->value()
        ofi << i << ":ImportAs= \"" << ImportDestinationName[imp_set.channel_target[i]] << "\"" << endl;//tabDataInfo->inFormats[i]->cmbImportAs->currentText().toLatin1().constData()
    }
    ofi << "Import_Set_As= " << imp_set.set_type << endl;//tabImportInfo->selType->currentValue() << endl;
    ofi << "Autoscale= " << imp_set.autoscale << endl;
/*int count_set_tokens=0;
for (int i=0;i<tabHeader->nr_of_sels;i++)
{
    if (tabHeader->sels[i]->currentValue()!=IMPORT_TO_NONE)
    {
    count_set_tokens++;
    }
}*/
    //ofi << "INI-Import-Tokens= " << count_set_tokens << endl;
    ofi << "INI-Import-Tokens= " << imp_set.keys.length() << endl;
/*for (int i=0;i<tabHeader->nr_of_sels;i++)
{
    if (tabHeader->sels[i]->currentValue()!=IMPORT_TO_NONE)
    {
    ofi << tabHeader->keys.at(i).toLocal8Bit().constData() << " = \"" << ImportDestinationName[tabHeader->sels[i]->currentValue()] << "\"" << endl;
    }
}
*/

/*cout << "KEYS=" << imp_set.keys.length() << endl;
cout << "Channel Destinations=" << imp_set.import_channel_dest.length() << endl;
cout << "Destinations=" << imp_set.import_dest.length() << endl;*/

    for (int i=0;i<imp_set.keys.length();i++)
    {
    //cout << "imp_set.token_target[" << i << "]=#" << imp_set.token_target[i] << "# imp_set.import_dest=" << imp_set.import_dest.at(i) << endl;
    //ofi << imp_set.import_channel_dest.at(i) << " " << imp_set.keys.at(i).toLocal8Bit().constData() << " = \"" << ImportDestinationName[imp_set.token_target[i]] << "\"" << endl;
    ofi << imp_set.import_channel_dest.at(i) << " " << imp_set.keys.at(i).toLocal8Bit().constData() << " = \"" << ImportDestinationName[imp_set.import_dest.at(i)] << "\"" << endl;
    }
    ofi.close();

delete[] dummy;
}

/*void matchSchemeToHeader(char * fname,struct importSettings & imp_set,struct importSettings & imp_scheme)
{

}*/

void frmBinaryFormatInput::newFileEntry(void)
{
QStringList str;
bool is_header;
bool header_reread=false;
int guessed_schema;
bin_file_nr_to_import=0;
//cout << "New File Entry" << endl;
    if (actautoguess->isChecked())//this means: guess format, complete data- and header-names and try reading the header
    {
    //cout << "autoguessing" << endl;
        if (!lenDataFile->text().isEmpty())
        {
        readAndCompleteFileNames(0,guessed_schema,is_header);
        str=lenDataFile->text().split(QString(";"));
            if (lenHeaderFile->text().isEmpty()) lenHeaderFile->lenText->setText(headerFileNames.join(QString(";")));
        cur_import_scheme=guessed_schema;//detectStdBinFormat(str.at(0));
        }
        else if (!lenHeaderFile->text().isEmpty())
        {
        readAndCompleteFileNames(1,guessed_schema,is_header);
        str=lenHeaderFile->text().split(QString(";"));
            if (lenDataFile->text().isEmpty()) lenDataFile->lenText->setText(datFileNames.join(QString(";")));
        cur_import_scheme=guessed_schema;//detectStdBinFormat(str.at(0));
        }
        else//header- and data-file-names are already set --> just read the set names
        {
        readAndCompleteFileNames(2,guessed_schema,is_header);
        }
    }
    else//do not autoguess --> just read the file-entries
    {
    //cout << "no autoguessing" << endl;
        readAndCompleteFileNames(2,guessed_schema,is_header);
    }
/// now we have set up the file-lists:
/// datFileNames
/// headerFileNames
/// and the bin_file_nr_to_import index to use for import
        if (cur_import_scheme>=0 || cur_import_scheme==-2)//a regular scheme --> we delete everything first, because we can copy everything back in later!
        initSettings(imp_scheme);

    //first: set the new filenames
    if (datFileNames.length()>0 && headerFileNames.length()>0)
    insert_filenames_in_settings(imp_set,imp_scheme,headerFileNames.at(0),datFileNames.at(0));
    else if (datFileNames.length()>0 && headerFileNames.length()<=0)
    insert_filenames_in_settings(imp_set,imp_scheme,QString(""),datFileNames.at(0));
    else if (datFileNames.length()<=0 && headerFileNames.length()>0)
    insert_filenames_in_settings(imp_set,imp_scheme,headerFileNames.at(0),QString(""));

    if (cur_import_scheme!=-1)//there already is an import schema --> we should try to load the header informations
    {
    //cout << "There have been settings before" << endl;
    //cout << "current data-file: " << datFileNames.at(bin_file_nr_to_import).toLocal8Bit().constData() << endl;
    //cout << "current header-file: " << headerFileNames.at(bin_file_nr_to_import).toLocal8Bit().constData() << endl;
        if (cur_import_scheme>=0)//one of the std-settings
        {
        copy_import_settings(std_bin_import_settings+cur_import_scheme,&imp_scheme);
        }
        else if (cur_import_scheme==-2)
        {
        QByteArray ba=FormatFileLastUsed.toLocal8Bit();
        char * files=new char[8+ba.length()];
        strcpy(files,ba.constData());
        LoadFileFormat(files,imp_scheme);///load the import settings in the scheme
        delete[] files;
        }
        //cout << "(Re)read header data from " << imp_set.HeaderFile.toLocal8Bit().constData() << endl;
            if (imp_scheme.header_format==1 || imp_scheme.header_format==2)///real binary header
            {
            read_BINARY_header(imp_set,imp_scheme);
            header_reread=true;
            }
            else if (imp_scheme.header_format==3)//ini header
            {
            read_INI_header(imp_set,imp_scheme);
            header_reread=true;
            }
            else if (imp_scheme.header_format==4)//ascii-header
            {
            read_ASCII_header(imp_set,imp_scheme);
            header_reread=true;
            }
            else if (imp_scheme.header_format==0)//manual header
            {
            copy_basic_scheme_data(imp_set,imp_scheme);
            }
        //cout << "finished reading Header" << endl;
    }

    if (cur_import_scheme==-1)
    {
    lblCurScheme->setText(tr("Current import scheme: None"));
    }
    else if (cur_import_scheme==-2)
    {
    lblCurScheme->setText(tr("Current import scheme: Manual"));
    }
    else
    {
    lblCurScheme->setText(tr("Current import scheme: ")+std_bin_import_settings[cur_import_scheme].name);
    }

        if (actautoguess->isChecked() || header_reread==true)// && (imp_set.header_format==1 || imp_set.header_format==2))
        {
        //cout << "transfer imported header values to gui" << endl;

        tabHeader->write_header_settings(imp_set);
        transmitInfos();

        }
}

void frmBinaryFormatInput::SelectDataFile(void)
{
QStringList str;
/*bool is_header;
int guessed_schema;*/

    if (!LoadDataPath.isEmpty())
    str=QFileDialog::getOpenFileNames(this,tr("Select Data File(s)"),LoadDataPath);
    else
    str=QFileDialog::getOpenFileNames(this,tr("Select Data File(s)"),QString(user_home_dir));

    if (str.length()>0)
    {
        bin_file_nr_to_import=0;
        datFileNames=str;
        headerFileNames=str;

        QString filesText=str.join(QString(";"));
        lenDataFile->lenText->setText(filesText);
        QFileInfo tmpInfo(str.at(0));
        LoadDataPath=tmpInfo.path();

        newFileEntry();

        /*if (chkAutoGuessFormat->isChecked())
        {
        readAndCompleteFileNames(0,guessed_schema,is_header);

        if (lenHeaderFile->text().isEmpty()) lenHeaderFile->lenText->setText(headerFileNames.join(QString(";")));

        //char * filename=new char[8+str.at(0).length()];
        //strcpy(filename,str.at(0).toLocal8Bit().constData());
        cur_import_scheme=detectStdBinFormat(str.at(0));
            if (cur_import_scheme==-1)
            {
            lblCurScheme->setText(tr("Current scheme: None"));
            }
            else
            {
            lblCurScheme->setText(tr("Current scheme: ")+std_bin_import_settings[cur_import_scheme].name);
            }
        //delete[] filename;
        }*/
    }
}

void frmBinaryFormatInput::SelectHeaderFile(void)
{
QStringList str;
/*bool is_header;
int guessed_schema;*/

    if (!LoadIniPath.isEmpty())
    str=QFileDialog::getOpenFileNames(this,tr("Select Header File(s)"),LoadIniPath);
    else
    str=QFileDialog::getOpenFileNames(this,tr("Select Header File(s)"),QString(user_home_dir));

    if (!str.isEmpty())
    {
        bin_file_nr_to_import=0;//we may have more than one, but we operate on the first one
        //datFileNames=str;
        headerFileNames=str;//the header Filenames (a list)

        QString filesText=str.join(QString(";"));//combine the separate files into one line of text (separated by ';')
        lenHeaderFile->lenText->setText(filesText);
        QFileInfo tmpInfo(str.at(0));
        LoadIniPath=tmpInfo.path();//so we can load the binary data from the same doirectory next time

        newFileEntry();

        /*if (chkAutoGuessFormat->isChecked())
        {
        readAndCompleteFileNames(1,guessed_schema,is_header);

        if (lenDataFile->text().isEmpty()) lenDataFile->lenText->setText(datFileNames.join(QString(";")));

        //char * filename=new char[8+str.at(0).length()];
        //strcpy(filename,str.at(0).toLocal8Bit().constData());
        cur_import_scheme=detectStdBinFormat(str.at(0));
            if (cur_import_scheme==-1)
            {
            lblCurScheme->setText(tr("Current scheme: None"));
            }
            else
            {
            lblCurScheme->setText(tr("Current scheme: ")+std_bin_import_settings[cur_import_scheme].name);
            }
        //delete[] filename;
        }*/
    }
}

int frmBinaryFormatInput::detectStdBinFormat(QString filen)
{
bool is_header_file;
int std_schema_nr=-1;
    //cout << "guess " << filen.toLocal8Bit().constData() << endl;
    if (guess_bin_format(filen.toLocal8Bit().constData(),std_schema_nr,is_header_file)==RETURN_SUCCESS)//look for a std binary format
    {
        initSettings(imp_set);
    if (std_bin_import_settings[std_schema_nr].header_format==1 || std_bin_import_settings[std_schema_nr].header_format==2)///real binary header
    {
    copy_import_settings(std_bin_import_settings+std_schema_nr,&imp_set);
    }
    else if (std_bin_import_settings[std_schema_nr].header_format==0)//manual header
    {
    copy_basic_scheme_data(imp_set,std_bin_import_settings[std_schema_nr]);
    }
        if (std_bin_import_settings[std_schema_nr].header_present)//there should be a header
        {
            if (is_header_file==false)
            {
            imp_set.DataFile=filen;
            imp_set.HeaderFile=imp_set.DataFile;
            replaceSuffix(imp_set.HeaderFile,std_bin_import_settings[std_schema_nr].HeaderSuffix);
            }
            else
            {
            imp_set.HeaderFile=filen;
            imp_set.DataFile=imp_set.HeaderFile;
            replaceSuffix(imp_set.DataFile,std_bin_import_settings[std_schema_nr].DataSuffix);
            }
            if (std_bin_import_settings[std_schema_nr].header_format==1)
            imp_set.HeaderFile=imp_set.DataFile;
        }
        else//no header
        {
        imp_set.DataFile=filen;
        imp_set.HeaderFile=QString("");
        }
    //cout << "read bin files:" << endl;
    //cout << "Header-File=#" << imp_set.HeaderFile.toLocal8Bit().constData() << "#" << endl;
    //cout << "Data - File=#" << imp_set.DataFile.toLocal8Bit().constData() << "#" << endl;
        if (lenDataFile->text().isEmpty())
        {
        lenDataFile->setText(imp_set.DataFile);
        }
        if (lenHeaderFile->text().isEmpty() && std_bin_import_settings[std_schema_nr].header_present && std_bin_import_settings[std_schema_nr].header_format>=2)
        {
        lenHeaderFile->setText(imp_set.HeaderFile);
        }
    if (std_bin_import_settings[std_schema_nr].header_format==3)
    {
        //cout << "Start reading reading INI header" << endl;
    read_INI_header(imp_set,std_bin_import_settings[std_schema_nr]);
        //cout << "Finished reading INI header" << endl;
    displaySettings(imp_set);
    qApp->processEvents();
    tabHeader->doReadIni();
    }
    else if (std_bin_import_settings[std_schema_nr].header_format==1 || std_bin_import_settings[std_schema_nr].header_format==2)
    {
        //cout << "Start reading reading BIN header" << endl;
    read_BINARY_header(imp_set,std_bin_import_settings[std_schema_nr]);
        //cout << "Finished reading BIN header" << endl << endl;
    displaySettings(imp_set);
    qApp->processEvents();
    /// tabHeader->doTestLoad();
    }
    /// TODO: Format pruefen!
    //tabHeader->write_header_settings(imp_set);//scheint ok
    //displaySettings(imp_set);
    tabDataInfo->writeDataSettings(imp_set);//copy the settings into the gui
    tabImportInfo->write_settings(imp_set);
    return std_schema_nr;
    }
    else return -1;
}

void frmBinaryFormatInput::formatSourceChanged(int i)
{
    //tabHeader->changeRepresentation(i);
    HeaderFormatChanged(i);
    /*
    if (i==0 || i==1)
    {
        //lblHeaderFile->setEnabled(false);
        lenHeaderFile->setEnabled(false);
        lblHeaderFileFormat->setEnabled(false);
        cmbHeaderFileFormat->setEnabled(false);
        if (cmbHeaderFileFormat->currentIndex()==1)
            cmbHeaderFileFormat->setCurrentIndex(0);
        cmdSelectHeaderFile->setEnabled(false);
        chkMultiHeaders->setVisible(false);
    }
    else if (i==2)
    {
        //lblHeaderFile->setEnabled(true);
        lenHeaderFile->setEnabled(true);
        lblHeaderFileFormat->setEnabled(true);
        cmbHeaderFileFormat->setEnabled(true);
        cmdSelectHeaderFile->setEnabled(true);
        chkMultiHeaders->setVisible(true);
    }*/
}

void frmBinaryFormatInput::CreateActions(void)
{
actLoadSettings=new QAction(tr("Load Import Settings"),this);
actLoadSettings->setStatusTip(tr("Load import settings from file"));
connect(actLoadSettings, SIGNAL(triggered()), this, SLOT(doLoadFileFormat()));
actSaveSettings=new QAction(tr("Save Import Settings"),this);
actSaveSettings->setStatusTip(tr("Save import settings to file"));
connect(actSaveSettings, SIGNAL(triggered()), this, SLOT(doSaveFileFormat()));
actLoadStdSettings=new QAction(tr("Load Std. Import Settings"),this);
actLoadStdSettings->setStatusTip(tr("Load automatic import settings from std. file"));
connect(actLoadStdSettings, SIGNAL(triggered()), this, SLOT(doLoadStdFormat()));
actSaveStdSettings=new QAction(tr("Save Std. Import Settings"),this);
actSaveStdSettings->setStatusTip(tr("Save automatic import settings to std. file"));
connect(actSaveStdSettings, SIGNAL(triggered()), this, SLOT(doSaveStdFormat()));
actDeleteSettings=new QAction(tr("Clear current import scheme"),this);
actDeleteSettings->setStatusTip(tr("Clear current import setting scheme"));
connect(actDeleteSettings, SIGNAL(triggered()), this, SLOT(doClearCurrentScheme()));
actClose=new QAction(tr("Close"),this);
actClose->setStatusTip(tr("Close dialog"));
connect(actClose, SIGNAL(triggered()), this, SLOT(doClose()));
actautoguess=new QAction(tr("Auto-guess binary file format"),this);
actautoguess->setStatusTip(tr("Try to guess the file format by comparing the suffix with the std. import settings"));
actautoguess->setCheckable(true);

actLoadDataFile=new QAction(tr("Select binary data file(s)"),this);
actLoadDataFile->setStatusTip(tr("Browse for binary data file(s) to import"));
connect(actLoadDataFile, SIGNAL(triggered()), this, SLOT(SelectDataFile()));
actLoadHeaderFile=new QAction(tr("Select header file(s)"),this);
actLoadHeaderFile->setStatusTip(tr("Browse for header file(s) with import informations"));
connect(actLoadHeaderFile, SIGNAL(triggered()), this, SLOT(SelectHeaderFile()));
}

void frmBinaryFormatInput::init(void)
{
    QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
    tabDataInfo->selTriggerValue->spnLineWidth->setLocale(newLocale);
    update_all();
    int nr=1,*sel=new int[2];
    sel[0]=get_cg();
    tabImportInfo->importGraph->set_new_selection(nr,sel);
}

void frmBinaryFormatInput::doOK(void)
{
ApplyError=false;
int schema_nr_dummy;
bool header_dummy;
/*int nr_of_new_sets=0;
int *n_snos=NULL,*n_gnos=NULL;
int gen_nr_of_new_sets=0;
int *gen_n_snos=NULL,*gen_n_gnos=NULL;*/
ifstream ifi;

set_wait_cursor();
//read the file-names set
readAndCompleteFileNames(2,schema_nr_dummy,header_dummy);
/// check for multiple headers (yes/no)
/// --> if multiple headers selected: the number of header files have to match the number of data files
/// --> if no multiple headers: only the first header will be used for all files
/// BEACHTE: option header present=false oder headerformat=manuel --> ignoriere header

/*cout << "OK: we have read the header- and data-files: headers nr=" << datFileNames.length() << " datas nr=" << headerFileNames.length() << endl;
for (int i=0;i<datFileNames.length();i++)
{
qDebug() << datFileNames.at(i);
}*/
//cout << "now we have to read the schema from the gui" << endl;
readSettings(imp_scheme,3);
//cout << "apply the schema to loading every file" << endl;

for (int i=0;i<datFileNames.length();i++)
{
copy_bin_settings_to_current_bin_import(datFileNames.at(i),false,&imp_scheme);
insert_filenames_in_settings(current_bin_import_settings,imp_scheme,headerFileNames.at(i),datFileNames.at(i));
readHeaderData(current_bin_import_settings,imp_scheme);

/// for debugging
//SaveFileFormat("/Users/andreaswinter/akt_bin_settings.fmt",current_bin_import_settings);/// just save for testing
/// end debugging

    if (i==datFileNames.length()-1)
    read_bin_file_by_current_settings(false);
    else
    read_bin_file_by_current_settings(true);
/// binary_load_Phase1(headerFileNames.at(i),datFileNames.at(i),imp_set,imp_scheme);//initialize and load header to imp_set
//insert_filenames_in_settings(imp_set,imp_scheme,headerFileNames.at(i),datFileNames.at(i));
/// copy_import_settings(&imp_scheme,&imp_set);
//CopyBinaryImportSettings(imp_scheme,imp_set);
/// ifi.open(imp_set.DataFile.toLocal8Bit().constData(),ios::binary);
/// readBinaryFromFile(ifi,imp_set,&imp_set.first_data);
/// ifi.close();
/// cout << "Postprocessing: " << postprocess_bin_import_data(imp_set,nr_of_new_sets,&n_gnos,&n_snos) << endl;
/// append_to_storage2(&gen_nr_of_new_sets,&gen_n_snos,&gen_n_gnos,nr_of_new_sets,n_gnos,n_snos);
}
unset_wait_cursor();
}

void frmBinaryFormatInput::doClose(void)
{
    hide();
}

void frmBinaryFormatInput::doAccept(void)
{
    doOK();
    if (ApplyError==false)
        doClose();
}

/*void frmBinaryFormatInput::binary_load_Phase0(int stage,struct importSettings & imp_scheme)
{
    switch (stage)
    {
    case 0:
    break;
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    }
}*/

void frmBinaryFormatInput::getDatFilesFromString(QString * origin,QStringList * lst)
{
    (*lst).clear();
    (*lst)=origin->split(QString(";"));
    if (lst->length()>0)
    {
        QString dummy;
        QChar sep=QDir::separator();
        QString dir=lst->at(0).left(lst->at(0).lastIndexOf(sep));
        //cout << "dir=#" << dir.toLocal8Bit().constData() << "#" << endl;
        for (int i=1;i<lst->length();i++)
        {
            if (lst->at(i).contains(sep)==false)
            {
                dummy=lst->at(i);
                lst->replace(i,dir+sep+dummy);
            }
        }
    }
    //cout << lst->at(0).toLocal8Bit().constData() << endl;
}

void frmBinaryFormatInput::readAndCompleteFileNames(int dat_header,int & std_schema_nr,bool & is_header_file)
{
std_schema_nr=-1;
QStringList str;
QString t_str;
if (dat_header==0)//read from dat-files-line and complete header-filename(s) if possible
{
str=lenDataFile->text().split(";");
datFileNames=str;
headerFileNames.clear();
    for (int i=0;i<str.length();i++)
    {
        t_str=str.at(i);
    //cout << "Data: guess " << str.at(i).toLocal8Bit().constData() << endl;
        if (guess_bin_format(str.at(i).toLocal8Bit().constData(),std_schema_nr,is_header_file)==RETURN_SUCCESS)//look for a std binary format
        {
        //cout << "guessed=" << std_schema_nr << " is_header_file=" << is_header_file << endl;
            if (std_bin_import_settings[std_schema_nr].HeaderSuffix==QString("-"))
            replaceSuffix(t_str,std_bin_import_settings[std_schema_nr].DataSuffix);
            else
            replaceSuffix(t_str,std_bin_import_settings[std_schema_nr].HeaderSuffix);
        headerFileNames << t_str;
        }
        else
        {
        errmsg(QObject::tr("Could not guess format.").toLocal8Bit().constData());
        //cout <<  << endl;
        }
            if (i==0 && chkMultiHeaders->isChecked()==false)
            break;
    }
}
else if (dat_header==1)//read from header-files-line and complete data-filename(s) if possible
{
str=lenHeaderFile->text().split(";");
headerFileNames=str;
datFileNames.clear();
    for (int i=0;i<str.length();i++)
    {
        t_str=str.at(i);
    //cout << "Header: guess " << str.at(i).toLocal8Bit().constData() << endl;
        if (guess_bin_format(str.at(i).toLocal8Bit().constData(),std_schema_nr,is_header_file)==RETURN_SUCCESS)//look for a std binary format
        {
        //cout << "guessed=" << std_schema_nr << " is_header_file=" << is_header_file << endl;
        replaceSuffix(t_str,std_bin_import_settings[std_schema_nr].DataSuffix);
        datFileNames << t_str;
        }
        else
        {
        errmsg(QObject::tr("Could not guess format.").toLocal8Bit().constData());
        }
    }
}
else//read both header- and dat-file-line
{
str=lenDataFile->text().split(";");
datFileNames=str;
str=lenHeaderFile->text().split(";");
headerFileNames=str;
}
bin_file_nr_to_import=0;//set current file name to first in the list
}

void frmBinaryFormatInput::CheckHeadersAndDatFiles(void)
{
//cout << "Checking Headers and DataFiles" << endl;
int nr_of_datafiles=datFileNames.length();
//cout << "nr_of_datafiles=" << nr_of_datafiles << endl;
int nr_of_headerfiles=headerFileNames.length();
//cout << "nr_of_headerfiles=" << nr_of_headerfiles << endl;
HeaderSuffix.clear();
Data_Suffix.clear();
HeaderPath.clear();
Data_Path.clear();
    if (nr_of_datafiles>0)
    {
    QFileInfo fi(datFileNames.at(0));
    Data_Suffix=fi.suffix();
    Data_Path=fi.absolutePath()+QDir::separator();
    //strcpy(datFileName,datFileNames.at(0).toLocal8Bit().constData());
    }

    if (nr_of_headerfiles>0)
    {
    QFileInfo fi(headerFileNames.at(0));
    HeaderSuffix=fi.suffix();
    HeaderPath=fi.absolutePath()+QDir::separator();
    //strcpy(headerFileName,headerFileNames.at(0).toLocal8Bit().constData());
    }
    else//no header file set - but maybe there should be one
    {
    HeaderSuffix.clear();
    HeaderPath.clear();
    //strcpy(headerFileName,"");
        if (imp_set.header_present==true && imp_set.header_format>=2)//no headers, but there should be one in a separate file
        {
            HeaderPath=Data_Path;
            HeaderSuffix=imp_set.HeaderSuffix;
        }
    }

/*cout << "HeaderSuffix = " << HeaderSuffix.toLocal8Bit().constData() << endl;
cout << "HeaderPath   = " << HeaderPath.toLocal8Bit().constData() << endl;
cout << "DataSuffix   = " << Data_Suffix.toLocal8Bit().constData() << endl;
cout << "DataPath     = " << Data_Path.toLocal8Bit().constData() << endl;*/

//datFileNames.clear();
//headerFileNames.clear();
        imp_set.HeaderSuffix=HeaderSuffix;
        imp_set.DataSuffix=Data_Suffix;
    if (nr_of_headerfiles!=nr_of_datafiles && imp_set.multiple_header_files==true)//not matching number of headerfiles, but there should be as many headers as data files
    {
        if (imp_set.header_format==HEADER_FORMAT_DATA_FILE || imp_set.header_format==HEADER_FORMAT_MANUAL)//header in data file or no header at all
        {
            HeaderSuffix.clear();
            HeaderPath.clear();
            //strcpy(headerFileName,"");
            headerFileNames.clear();
        }
        else if (imp_set.header_format==HEADER_FORMAT_BIN_FILE || imp_set.header_format==HEADER_FORMAT_INI_FILE || imp_set.header_format==HEADER_FORMAT_ASCII_FILE)//separate bin-, ini-file or ascii-file
        {
            headerFileNames.clear();
            for (int i=0;i<nr_of_datafiles;i++)
            {
            QFileInfo fi(datFileNames.at(i));
            if (HeaderSuffix==QString("-"))
            headerFileNames << HeaderPath+fi.completeBaseName()+QString(".")+Data_Suffix;
            else
            headerFileNames << HeaderPath+fi.completeBaseName()+QString(".")+HeaderSuffix;
            //cout << "newHeader=" << headerFileNames.at(i).toLocal8Bit().constData() << endl;
            }
        }
    }
    else if (imp_set.multiple_header_files==false)//we make the number of headers match the number of data files by just copying the same header name again and again
    {
        if (nr_of_headerfiles<=0)
        {
        headerFileNames.clear();
        QFileInfo fi(datFileNames.at(0));
        if (HeaderSuffix==QString("-"))
        headerFileNames << HeaderPath+fi.completeBaseName()+QString(".")+Data_Suffix;
        else
        headerFileNames << HeaderPath+fi.completeBaseName()+QString(".")+HeaderSuffix;
        }
        for (int i=1;i<nr_of_datafiles;i++)
        {
        headerFileNames.replace(i,headerFileNames.at(0));
        }
    }
}

void frmBinaryFormatInput::readHeader(void)
{
if (imp_scheme.header_present)
{
    if (imp_scheme.header_format==1 || imp_scheme.header_format==2)//bin-header in data-file or separate bin-file
    {
        //cout << "reading binary header from file" << endl;
    read_BINARY_header(imp_set,imp_scheme);
        //cout << "nach reading binary header" << endl;
    }
    else if (imp_scheme.header_format==3)//ini-header in separate file
    {
    read_INI_header(imp_set,imp_scheme);
    }
    else if (imp_scheme.header_format==4)//ascii-header in separate file
    {
    read_ASCII_header(imp_set,imp_scheme);
    }
}
//else: no header present, all settings should be in the scheme
return;

/// function ends here

bool is_header;
int guessed_schema;
    //initialize the import settings
    /// initSettings(imp_set);
datFileNames.clear();
headerFileNames.clear();
    /*if (!lenDataFile->text().isEmpty())
    {
        QString help=lenDataFile->text().toLocal8Bit();
        help=lenDataFile->text();/// TEST
        getDatFilesFromString(&help,&datFileNames);//we seperate the individual filenames and save them in datFileNames
            for (int i=0;i<datFileNames.length();i++)
            {
                cout << "File " << i << " --> " << datFileNames.at(i).toLocal8Bit().constData() << endl;
            }
        /// strcpy(datFileName,datFileNames.at(0).toLocal8Bit());//only get the name of the first file here
    }
    else//no data-file!?
    {
        ;/// datFileName[0]='\0';
    }

    if (!chkHeader->isChecked())//no header
    {
        imp_set.header_present=false;
        /// headerFileName[0]='\0';
    }
    else
    {
        imp_set.header_present=true;
    }*/

    readAndCompleteFileNames(2,guessed_schema,is_header);

    imp_set.multiple_header_files=chkMultiHeaders->isChecked();

    imp_set.header_format=HEADER_FORMAT_MANUAL;
    //cmbFormatSource->currentIndex()==0 --> manual format setup
    if (cmbFormatSource->currentIndex()==1)//header in datafile --> binary header format
    {
        imp_set.header_format=HEADER_FORMAT_DATA_FILE;
        headerFileNames=datFileNames;
        /// strcpy(headerFileName,datFileName);
        tabHeader->read_header_settings(imp_set);
    }
    else if (cmbFormatSource->currentIndex()==2)//header in separate file
    {
        tabHeader->read_header_settings(imp_set);
        cout << "nach read_header_settings" << endl;
        for (int i=0;i<imp_set.import_channel_dest.length();i++) cout << "dest[" << i << "]=" << imp_set.import_channel_dest.at(i) << endl;

        if (!lenHeaderFile->text().isEmpty())
        {
        //strcpy(headerFileName,lenHeaderFile->text().toLocal8Bit());
            QString help=lenHeaderFile->text().toLocal8Bit();
            getDatFilesFromString(&help,&headerFileNames);//we seperate the individual filenames
            /// strcpy(headerFileName,headerFileNames.at(0).toLocal8Bit());//only get the name of the first file here
        }
        else
        {
            ;/// headerFileName[0]='\0';
        }
        imp_set.header_format=HEADER_FORMAT_BIN_FILE;
        if (cmbHeaderFileFormat->currentIndex()==1) imp_set.header_format=HEADER_FORMAT_INI_FILE;
        else if (cmbHeaderFileFormat->currentIndex()==2) imp_set.header_format=HEADER_FORMAT_ASCII_FILE;
    }
    //cout << "vor check Headers and dat files" << endl;
    for (int i=0;i<imp_set.import_channel_dest.length();i++) cout << "dest[" << i << "]=" << imp_set.import_channel_dest.at(i) << endl;

CheckHeadersAndDatFiles();//to complete filenames and check completeness of informations

    //cout << "nach check Headers and dat files" << endl;
    for (int i=0;i<imp_set.import_channel_dest.length();i++) cout << "dest[" << i << "]=" << imp_set.import_channel_dest.at(i) << endl;

    //if (headerFileName[0]!='\0')
    if (!headerFileNames.at(0).isEmpty())
    {
        ifstream ifi;
            if (cmbFormatSource->currentIndex()==1 || (cmbFormatSource->currentIndex()==2 && cmbHeaderFileFormat->currentIndex()==0) )
            ifi.open(headerFileNames.at(0).toLocal8Bit().constData(),ios::binary);
            else
            ifi.open(headerFileNames.at(0).toLocal8Bit().constData());
        //read data from header to imp_set
        doReadDataFromHeader(ifi,imp_set);

        cout << "nach doReadDataFromHeader" << endl;
        for (int i=0;i<imp_set.import_channel_dest.length();i++) cout << "dest[" << i << "]=" << imp_set.import_channel_dest.at(i) << endl;

        //read a few datapoints for showing
        //cout << "channels=" << imp_set.channels << " bytes=" << imp_set.bytesize << " bits=" << imp_set.bitsize << " suggestion=" << first_suggestion << endl;
        if (imp_set.channels>0 && (imp_set.bytesize!=-1 || imp_set.bitsize!=-1))
        {
            int sav_points=imp_set.points;
            imp_set.points=(imp_set.points<10?imp_set.points:10);
            imp_set.channel_target=new int[imp_set.channels];
            imp_set.channel_size=new int[imp_set.channels];
            imp_set.channel_format=new int[imp_set.channels];
            for (int i=0;i<imp_set.channels;i++)
            {
                imp_set.channel_target[i]=IMPORT_TO_X;
                imp_set.channel_size[i]=imp_set.bytesize!=-1?imp_set.bytesize:imp_set.bitsize/8;
                imp_set.channel_format[i]=first_suggestion;
            }
            ifi.close();
            ifi.open(imp_set.DataFile.toLocal8Bit().constData(),ios::binary);
            readBinaryFromFile(ifi,imp_set,&imp_set.first_data);
            imp_set.points=sav_points;
        }
        else
        {
            imp_set.first_data=NULL;
        }
        ifi.close();

cout << "nach BBBB" << endl;
for (int i=0;i<imp_set.import_channel_dest.length();i++)
cout << "dest[" << i << "]=" << imp_set.import_channel_dest.at(i) << endl;

        if (imp_set.x0set==true && imp_set.deltaxset==false && imp_set.fset==false)
        {
            imp_set.deltax=1.0;
            imp_set.deltaxset=true;
        }
        else if (imp_set.x0set==false && imp_set.deltaxset==true && imp_set.fset==false)
        {
            imp_set.x0=0.0;
            imp_set.x0set=true;
        }
        else if (imp_set.x0set==false && imp_set.deltaxset==false && imp_set.fset==true)
        {
            imp_set.x0=0.0;
            imp_set.x0set=true;
        }

        if (auto_transfer_from_header)
        {
            convertSettingsToString();
            if (imp_set.channels!=-1) tabDataInfo->spnChannelCount->setValue(imp_set.channels);
            if (imp_set.points!=-1)
            {
                tabDataInfo->spnDataSetCount->setValue(imp_set.points);
                tabDataInfo->chkReadToEOF->setChecked(false);//if a number of sample points is set, we won't need to read until end
            }
            qApp->processEvents();
            if (first_suggestion!=-1)
            {
                for (int i=0;i<tabDataInfo->number_of_lines;i++)
                    tabDataInfo->inFormats[i]->cmbFormat->setCurrentIndex(first_suggestion);
            }
            tabFileInfo->headerContents=settingString;
        }

    }//end header file selected

    if (auto_transfer_from_header)
        tabs->setCurrentWidget(tabFileInfo);

}

void frmBinaryFormatInput::headerToggled(bool t)
{
    if (t)
    {
        //cmbFormatSource->setCurrentIndex(1);
        tabHeader->setEnabled(true);
        //lblHeaderFile->setVisible(true);
        lenHeaderFile->setVisible(true);
        cmdSelectHeaderFile->setVisible(true);
        cmbHeaderFileFormat->setVisible(true);
        lblHeaderFileFormat->setVisible(true);
    }
    else
    {
        //cmbFormatSource->setCurrentIndex(0);
        tabHeader->setEnabled(false);
        //lblHeaderFile->setVisible(false);
        lenHeaderFile->setVisible(false);
        cmdSelectHeaderFile->setVisible(false);
        cmbHeaderFileFormat->setVisible(false);
        lblHeaderFileFormat->setVisible(false);
    }
}

void frmBinaryFormatInput::updateSuffixes(void)
{
    QString d_inp=lenDataFile->text();
    QStringList l_inp=d_inp.split(";");
cout << "Data l_inp.length=" << l_inp.length() << endl;
    if (l_inp.length()>0)
    {
    QFileInfo fi1(l_inp.at(0));
    Data_Suffix=fi1.suffix();
    }
    else// if (imp_set.DataSuffix.isEmpty())
    {
    Data_Suffix=QString("-");
    }
//cout << "Data-suffix=#" << Data_Suffix.toLocal8Bit().constData() << "#" << endl;
    d_inp=lenHeaderFile->text();
    l_inp=d_inp.split(";");
//cout << "Header l_inp.length=" << l_inp.length() << endl;
    if (l_inp.length()>0)
    {
    QFileInfo fi1(l_inp.at(0));
    HeaderSuffix=fi1.suffix();
    }
    else// if (imp_set.HeaderSuffix.isEmpty())
    {
    HeaderSuffix=QString("-");
    }
//cout << "Header-suffix=#" << HeaderSuffix.toLocal8Bit().constData() << "#" << endl;
}

int guess_bin_channel_import_format(int bytesize)
{
for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)//we look for a format that has the suitable number of bytes
{
    if (binaryImportFormat[i].size==bytesize)
    {
    return i;
    }
}
return -1;
}

void prepare_imp_settings_for_header_import(struct importSettings & imp_set)
{
    imp_set.x0set=false;
    imp_set.deltaxset=false;
    imp_set.fset=false;
        for (int i=0;i<7;i++)
        {
        imp_set.factors[i]=1.0;
        imp_set.offsets[i]=0.0;
        }
        for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
        {
        imp_set.channel_factors[i]=1.0;
        imp_set.channel_offsets[i]=0.0;
        }
    imp_set.channels=imp_set.points=-1;
    imp_set.bitsize=imp_set.bytesize=-1;
    imp_set.whole_size=imp_set.single_size=-1;
    imp_set.headersize=0;
    for (int i=0;i<imp_set.nr_of_header_values;i++)
    {
        if (imp_set.header_value_size[i]<=0)
        {
        imp_set.header_value_size[i]=binaryImportFormat[imp_set.header_value_format[i]].size;
        }
    imp_set.headersize+=imp_set.header_value_size[i];
    }
}

void complete_channel_settings(struct importSettings & imp_set)
{
for (int j=0;j<=2;j++)//we do this more than once to get everything as complete as possible
{
        if (imp_set.bitsize==-1 && imp_set.bytesize>0) imp_set.bitsize=imp_set.bytesize*8;
        if (imp_set.bitsize>0 && imp_set.bytesize==-1) imp_set.bytesize=imp_set.bitsize/8;
        if (imp_set.bytesize>0 && imp_set.single_size>0 && imp_set.channels==-1) imp_set.channels=imp_set.single_size/imp_set.bytesize;
    if (imp_set.channels>0)
    {
        if (imp_set.points>0 && imp_set.whole_size>0 && imp_set.bytesize==-1) imp_set.bytesize=imp_set.whole_size/(imp_set.channels*imp_set.points);
        if (imp_set.single_size>0 && imp_set.bytesize==-1) imp_set.bytesize=imp_set.single_size/(imp_set.channels);
        if (imp_set.bytesize>0 && imp_set.single_size==-1) imp_set.single_size=imp_set.bytesize*imp_set.channels;
        if (imp_set.points==-1 && imp_set.whole_size>0 && imp_set.bytesize>0) imp_set.points=imp_set.whole_size/(imp_set.bytesize*imp_set.channels);
    }
    if (imp_set.points>0)
    {
        if (imp_set.whole_size==-1 && imp_set.single_size>0) imp_set.whole_size=imp_set.single_size*imp_set.points;
        if (imp_set.whole_size>0 && imp_set.single_size==-1) imp_set.single_size=imp_set.whole_size/imp_set.points;
    }
}
}

void readHeaderData(struct importSettings & imp_set,struct importSettings & imp_scheme)
{
if (imp_scheme.header_present)//at this point only the scheme should contain suitable data (imp_set is empty here)
{
///when reading from the headers
    if (imp_scheme.header_format==1 || imp_scheme.header_format==2)//bin-header in data-file or separate bin-file
    {
    read_BINARY_header(imp_set,imp_scheme);
    }
    else if (imp_scheme.header_format==3)//ini-header in separate file
    {
    read_INI_header(imp_set,imp_scheme);
    }
    else if (imp_scheme.header_format==4)//ascii-header in separate file
    {
    read_ASCII_header(imp_set,imp_scheme);
    }
    else if (imp_scheme.header_format==0)//manual header
    {
    copy_basic_scheme_data(imp_set,imp_scheme);
    copy_manual_header_data(imp_set,imp_scheme);
    }
}
else//no header present, all settings should be in the scheme
{
    copy_basic_scheme_data(imp_set,imp_scheme);
    //we also have to copy the data-import-settings! Usually we take them from the header, but here is no header
    imp_set.channels=imp_scheme.channels;
    imp_set.points=imp_scheme.points;
    if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
    if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
    if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
    memcpy(imp_set.channel_format,imp_scheme.channel_format,sizeof(int)*imp_set.channels);
    memcpy(imp_set.channel_size,imp_scheme.channel_size,sizeof(int)*imp_set.channels);
    memcpy(imp_set.channel_target,imp_scheme.channel_target,sizeof(int)*imp_set.channels);
}
}

void copy_basic_scheme_data(struct importSettings & imp_set,struct importSettings & imp_schema)
{//copies some basic settings from the scheme to imp_set
    imp_set.header_present=imp_schema.header_present;
    imp_set.header_format=imp_schema.header_format;
    imp_set.multiple_header_files=imp_schema.multiple_header_files;
    imp_set.read_to_eof=imp_schema.read_to_eof;
    imp_set.keep_trigger=imp_schema.keep_trigger;
    imp_set.trigger_type=imp_schema.trigger_type;
    imp_set.triggervalue=imp_schema.triggervalue;
    imp_set.autoscale=imp_schema.autoscale;
    imp_set.setorder=imp_schema.setorder;
    imp_set.set_type=imp_schema.set_type;
    imp_set.string_end_char=imp_schema.string_end_char;
    imp_set.target_gno=get_cg();//we assume to import to the current graph - we do not take settings from a scheme here (this has to be overwritten in the dialog, but not in the automatic binary import)
}

void copy_manual_header_data(struct importSettings & imp_set,struct importSettings & imp_schema)
{
    imp_set.x0=imp_schema.x0;
    imp_set.x0set=imp_schema.x0set;
    imp_set.f=imp_schema.f;
    imp_set.fset=imp_schema.fset;
    imp_set.deltax=imp_schema.deltax;
    imp_set.deltaxset=imp_schema.deltaxset;
    imp_set.whole_size=imp_schema.whole_size;
    for (int i=0;i<7;i++)
    {
    imp_set.offsets[i]=imp_schema.offsets[i];
    imp_set.factors[i]=imp_schema.factors[i];
    }
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
    imp_set.channel_offsets[i]=imp_schema.channel_offsets[i];
    imp_set.channel_factors[i]=imp_schema.channel_factors[i];
        if (imp_set.set_title[i]!=NULL) delete[] imp_set.set_title[i];
        if (imp_schema.set_title[i]==NULL) imp_set.set_title[i]=NULL;
        else strcpy(imp_set.set_title[i],imp_schema.set_title[i]);
    }
        if (imp_set.title!=NULL) delete[] imp_set.title;
            if (imp_schema.title==NULL) imp_set.title=NULL;
            else strcpy(imp_set.title,imp_schema.title);
        if (imp_set.subtitle!=NULL) delete[] imp_set.subtitle;
            if (imp_schema.subtitle==NULL) imp_set.subtitle=NULL;
            else strcpy(imp_set.subtitle,imp_schema.subtitle);
        if (imp_set.x_title!=NULL) delete[] imp_set.x_title;
            if (imp_schema.x_title==NULL) imp_set.x_title=NULL;
            else strcpy(imp_set.x_title,imp_schema.x_title);
        if (imp_set.y_title!=NULL) delete[] imp_set.y_title;
            if (imp_schema.y_title==NULL) imp_set.y_title=NULL;
            else strcpy(imp_set.y_title,imp_schema.y_title);
}

//this function is very important to make sure the file names are inserted properly
void insert_filenames_in_settings(struct importSettings & imp_set,struct importSettings & imp_schema,QString headerfilename,QString datafilename)
{
imp_schema.HeaderFile=imp_set.HeaderFile=headerfilename;
imp_schema.DataFile=imp_set.DataFile=datafilename;
}

void read_BINARY_header(struct importSettings & imp_set,struct importSettings & imp_schema)//imp_set should contain the header-file-name
{
char dummy[1024];
bool integer_type;
char buffer[16];
char * stringText=new char[2];
int size,readbytes,global_size=0;
long * headerDatas=new long[imp_set.nr_of_header_values];
long double * ldHeaderDatas=new long double[imp_set.nr_of_header_values];

// 0) set some basics from the imp_schema
//basic settings
copy_basic_scheme_data(imp_set,imp_schema);
//binary header settings
imp_set.nr_of_header_values=imp_schema.nr_of_header_values;
if (imp_set.header_value_format!=NULL) delete[] imp_set.header_value_format;
imp_set.header_value_format=new int[imp_set.nr_of_header_values];
if (imp_set.header_value_import!=NULL) delete[] imp_set.header_value_import;
imp_set.header_value_import=new int[imp_set.nr_of_header_values];
if (imp_set.header_value_size!=NULL) delete[] imp_set.header_value_size;
imp_set.header_value_size=new int[imp_set.nr_of_header_values];
memcpy(imp_set.header_value_size,imp_schema.header_value_size,sizeof(int)*imp_set.nr_of_header_values);
memcpy(imp_set.header_value_import,imp_schema.header_value_import,sizeof(int)*imp_set.nr_of_header_values);
memcpy(imp_set.header_value_format,imp_schema.header_value_format,sizeof(int)*imp_set.nr_of_header_values);

//cout << "read Header: " << imp_set.HeaderFile.toLocal8Bit().constData() << endl;
//cout << "HEADER IN A BIN-DATA FILE, header_values=" << imp_set.nr_of_header_values << endl;

// 1) prepare the control variables in the imp_set
prepare_imp_settings_for_header_import(imp_set);

// 2) read the header-data from the binary file
ifstream ifi;
ifi.open(imp_set.HeaderFile.toLocal8Bit().constData(),ios::binary);
    for (int i=0;i<imp_set.nr_of_header_values;i++)
    {
    //cout << i << ": format=" << imp_set.header_value_format[i] << " size=" << imp_set.header_value_size[i] << " import_to=" << imp_set.header_value_import[i] << endl;
        size=imp_set.header_value_size[i];
        global_size+=size;
        if (imp_set.header_value_format[i]!=COLUMN_OFFSET && imp_set.header_value_format[i]!=COLUMN_STRING)
        {
            ifi.read(buffer,size);
            readbytes=(int)(ifi.gcount());
            if (readbytes!=size)
            {
                sprintf(dummy,"[Information] Stopped reading header item after import of %d Bytes (of %d bytes).",readbytes,size);
                stufftext(dummy);
            }
        }
        switch (imp_set.header_value_format[i])
        {
        case COLUMN_OFFSET:
        default:
            integer_type=false;
            for (int j=0;j<size;j++)
                ifi.read(buffer,1);//read byte after byte into the same buffer (we dont need it)
            break;
        case COLUMN_SIG_CHAR:
            integer_type=true;
            headerDatas[i]=(long)(*((signed char*)((void*)buffer)));
            break;
        case COLUMN_USIG_CHAR:
            integer_type=true;
            headerDatas[i]=(long)(*((unsigned char*)((void*)buffer)));
            break;
        case COLUMN_SIG_SHORT:
            integer_type=true;
            headerDatas[i]=(long)(*((signed short*)((void*)buffer)));
            break;
        case COLUMN_USIG_SHORT:
            integer_type=true;
            headerDatas[i]=(long)(*((unsigned short*)((void*)buffer)));
            break;
        case COLUMN_SIG_INT:
            integer_type=true;
            headerDatas[i]=(long)(*((signed int*)((void*)buffer)));
            break;
        case COLUMN_USIG_INT:
            integer_type=true;
            headerDatas[i]=(long)(*((unsigned int*)((void*)buffer)));
            break;
        case COLUMN_SIG_LONG:
            integer_type=true;
            headerDatas[i]=(long)(*((signed long*)((void*)buffer)));
            break;
        case COLUMN_USIG_LONG:
            integer_type=true;
            headerDatas[i]=(long)(*((unsigned long*)((void*)buffer)));
            break;
        case COLUMN_FLOAT:
            integer_type=false;
            ldHeaderDatas[i]=(long double)(*((float*)((void*)buffer)));
            break;
        case COLUMN_DOUBLE:
            integer_type=false;
            ldHeaderDatas[i]=(long double)(*((double*)((void*)buffer)));
            break;
        case COLUMN_LONG_DOUBLE:
            integer_type=false;
            ldHeaderDatas[i]=(long double)(*((long double*)((void*)buffer)));
            break;
        case COLUMN_STRING:
            integer_type=false;
            if (imp_set.determine_string_size==true)
            {
                int res=16;
                int read_s=0;
                char * targ=new char[res+1];
                char read_c=imp_set.string_end_char-1;
                while (read_c!=imp_set.string_end_char)
                {
                    ifi.read(&read_c,1);
                    targ[read_s]=read_c;
                    read_s++;
                    if (read_s==res)
                    {
                        char * targ2=new char[res+17];
                        memcpy(targ2,targ,sizeof(char)*read_s);
                        delete[] targ;
                        targ=targ2;
                        res+=16;
                    }
                }
                targ[read_s]='\0';
                global_size-=size;
                size=read_s;
                /// tabHeader->inFormats[i]->spnSize->setValue(size);
                global_size+=size;
                delete[] stringText;
                stringText=new char[size+2];
                strcpy(stringText,targ);
            }
            else
            {
                delete[] stringText;
                stringText=new char[size+2];
                ifi.read(stringText,size);
                stringText[size]='\0';
                readbytes=(int)(ifi.gcount());
                if (readbytes!=size)
                {
                    sprintf(dummy,"[Information] Stopped reading header item after import of %d Bytes (of %d bytes).",readbytes,size);
                    stufftext(dummy);
                }
            }
            break;
        }//end switch-block

            switch (imp_set.header_value_import[i])
            {
            case IMPORT_TO_NONE:
                break;
            case IMPORT_TO_TITLE:
                delete[] imp_set.title;
                imp_set.title=new char[size+1];
                strcpy(imp_set.title,stringText);
                break;
            case IMPORT_TO_SET_LEGEND:
                if (imp_set.set_title[imp_set.import_dest.at(i)]!=NULL)
                    delete[] imp_set.set_title[imp_set.import_dest.at(i)];
                imp_set.set_title[imp_set.import_dest.at(i)]=new char[size+1];
                strcpy(imp_set.set_title[imp_set.import_dest.at(i)],stringText);
                break;
            case IMPORT_TO_X0:
                if (integer_type)
                    imp_set.x0=headerDatas[i];
                else
                    imp_set.x0=ldHeaderDatas[i];
                imp_set.x0set=true;
                break;
            case IMPORT_TO_DELTAX:
                if (integer_type)
                    imp_set.deltax=headerDatas[i];
                else
                    imp_set.deltax=ldHeaderDatas[i];
                imp_set.deltaxset=true;
                break;
            case IMPORT_TO_XTITLE:
                if (imp_set.x_title!=NULL)
                    delete[] imp_set.x_title;
                imp_set.x_title=new char[size+1];
                strcpy(imp_set.x_title,stringText);
                break;
            case IMPORT_TO_YTITLE:
                if (imp_set.y_title!=NULL)
                    delete[] imp_set.y_title;
                imp_set.y_title=new char[size+1];
                strcpy(imp_set.y_title,stringText);
                break;
            case IMPORT_TO_XFACTOR:
                if (integer_type)
                    imp_set.factors[0]*=headerDatas[i];
                else
                    imp_set.factors[0]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_YFACTOR:
                if (integer_type)
                    imp_set.factors[1]*=headerDatas[i];
                else
                    imp_set.factors[1]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y1FACTOR:
                if (integer_type)
                    imp_set.factors[2]*=headerDatas[i];
                else
                    imp_set.factors[2]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y2FACTOR:
                if (integer_type)
                    imp_set.factors[3]*=headerDatas[i];
                else
                    imp_set.factors[3]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y3FACTOR:
                if (integer_type)
                    imp_set.factors[4]*=headerDatas[i];
                else
                    imp_set.factors[4]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y4FACTOR:
                if (integer_type)
                    imp_set.factors[5]*=headerDatas[i];
                else
                    imp_set.factors[5]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y_OFFSET:
                if (integer_type)
                    imp_set.offsets[1]*=headerDatas[i];
                else
                    imp_set.offsets[1]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y1_OFFSET:
                if (integer_type)
                    imp_set.offsets[2]*=headerDatas[i];
                else
                    imp_set.offsets[2]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y2_OFFSET:
                if (integer_type)
                    imp_set.offsets[3]*=headerDatas[i];
                else
                    imp_set.offsets[3]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y3_OFFSET:
                if (integer_type)
                    imp_set.offsets[4]*=headerDatas[i];
                else
                    imp_set.offsets[4]*=ldHeaderDatas[i];
                break;
            case IMPORT_TO_Y4_OFFSET:
                if (integer_type)
                    imp_set.offsets[5]*=headerDatas[i];
                else
                    imp_set.offsets[5]*=ldHeaderDatas[i];
                break;
            /*case IMPORT_TO_TRIGGER_FACTOR:
                if (integer_type)
                    imp_set.factors[6]*=headerDatas[i];
                else
                    imp_set.factors[6]*=ldHeaderDatas[i];
                break;*/
            case IMPORT_TO_SUBTITLE:
                delete[] imp_set.subtitle;
                imp_set.subtitle=new char[size+1];
                strcpy(imp_set.subtitle,stringText);
                break;
            case IMPORT_TO_NUMBER_OF_DATA:
                imp_set.points=headerDatas[i];
                break;
            case IMPORT_TO_NUMBER_OF_CHANNELS:
                imp_set.channels=headerDatas[i];
                break;
            case IMPORT_TO_DATA_SIZE:
                imp_set.bytesize=headerDatas[i];
                break;
            case IMPORT_TO_DATA_SIZE_BIT:
                imp_set.bitsize=headerDatas[i];
                break;
            case IMPORT_TO_DATA_SAMPLING_RATE:
                if (integer_type)
                    imp_set.f=headerDatas[i];
                else
                    imp_set.f=ldHeaderDatas[i];
                imp_set.fset=true;
                break;
            case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
                imp_set.whole_size=headerDatas[i];
                break;
            case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
                imp_set.single_size=headerDatas[i];
                break;
            }
    }//end loop through lines
ifi.close();
// 3) postprocess to get clean settings
if (imp_set.header_format==HEADER_FORMAT_DATA_FILE)//header in binary data file
{
imp_set.headersize=global_size;
}
else
{
imp_set.headersize=0;//we have to set this to zero to start reading the data file at the beginning
}

/*qDebug() << "Global size=" << global_size << " header_size=" << imp_set.headersize;*/

/*qDebug() << "before postprocessing:";
qDebug() << "imp_set.channels=" << imp_set.channels;
qDebug() << "imp_set.points=" << imp_set.points;
qDebug() << "imp_set.bitsize=" << imp_set.bitsize;
qDebug() << "imp_set.bytesize=" << imp_set.bytesize;
qDebug() << "imp_set.whole_size=" << imp_set.whole_size;
qDebug() << "imp_set.single_size=" << imp_set.single_size;*/

if (imp_set.whole_size<0 && imp_set.channels>0 && imp_set.points>0)//a special case: we know the number of channels and data points, but not the whole data-block-size --> try to guess point-sizes by file-size
{
QFileInfo fi1(imp_set.DataFile);
imp_set.whole_size=fi1.size()-imp_set.headersize;
}

complete_channel_settings(imp_set);

/*qDebug() << "after postprocessing:";
qDebug() << "imp_set.channels=" << imp_set.channels;
qDebug() << "imp_set.points=" << imp_set.points;
qDebug() << "imp_set.bitsize=" << imp_set.bitsize;
qDebug() << "imp_set.bytesize=" << imp_set.bytesize;
qDebug() << "imp_set.whole_size=" << imp_set.whole_size;
qDebug() << "imp_set.single_size=" << imp_set.single_size;*/

// 4) set the channel formats according to the schema
if (imp_set.format_suggestion!=NULL) delete[] imp_set.format_suggestion;
imp_set.format_suggestion=new int[imp_set.channels+1];
if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
imp_set.channel_format=new int[imp_set.channels+1];
if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
imp_set.channel_size=new int[imp_set.channels+1];
if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
imp_set.channel_target=new int[imp_set.channels+1];
    for (int i=0;i<imp_set.channels;i++)
    {
    imp_set.channel_target[i]=IMPORT_TO_Y;//binary-header->choose y for all channels (as default)
        if (imp_schema.channels>=i)
        {
            if (imp_schema.channel_size[i]==imp_set.bytesize)
            {
            imp_set.channel_size[i]=imp_schema.channel_size[i];
            imp_set.channel_format[i]=imp_schema.channel_format[i];
            }
            else
            {
            imp_set.channel_size[i]=imp_set.bytesize;
            imp_set.channel_format[i]=guess_bin_channel_import_format(imp_set.bytesize);
            }
        imp_set.format_suggestion[i]=imp_set.channel_format[i];
        imp_set.channel_target[i]=imp_schema.channel_target[i];//if there is a target - use it
        }
        else
        {
        imp_set.channel_size[i]=imp_set.bytesize;
        imp_set.channel_format[i]=guess_bin_channel_import_format(imp_set.bytesize);
            if (imp_schema.channels-1>=0)
            imp_set.format_suggestion[i]=imp_set.format_suggestion[imp_schema.channels-1];
            else
            imp_set.format_suggestion[i]=imp_set.channel_format[i];
        }
        //cout << "target=" << imp_set.channel_target[i] << " size=" << imp_set.channel_size[i] << " format=" << imp_set.channel_format[i] << endl;
    }
    imp_set.ReadFromHeader=imp_set.HeaderFile;
delete [] headerDatas;
delete [] ldHeaderDatas;
}

void read_ASCII_header(struct importSettings & imp_set,struct importSettings & imp_schema)//imp_set should contain the header-file-name
{
// 0) set some basics from the imp_schema
//basic settings
copy_basic_scheme_data(imp_set,imp_schema);


imp_set.ReadFromHeader=imp_set.HeaderFile;
}

void compare_INI_settings_with_schema(struct importSettings & imp_set,struct importSettings & imp_schema)
{
//look for the imp_set-settings in the schema to match it with the import-destinations
    imp_set.import_dest.clear();
    imp_set.import_channel_dest.clear();
    int destination,pos,destination_channel;
    char tmp_target_name[1024];
    if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
    imp_set.token_target=new int[1+imp_set.keys.length()];
    for (int i=0;i<imp_set.keys.length();i++)
    {
        pos=imp_schema.keys.indexOf(imp_set.keys.at(i));
        //cout << "Looking for " << imp_set.keys.at(i).toLocal8Bit().constData() << " found=" << imp_schema.keys.at(pos).toLocal8Bit().constData() << endl;
        destination=IMPORT_TO_NONE;
            if (pos>=0)
            {
            strcpy(tmp_target_name,imp_schema.vals.at(pos).toLocal8Bit().constData());
            destination = find_import_destination(tmp_target_name,1);//'1' means look only for data read from header
            destination_channel = imp_schema.import_channel_dest.at(pos);
            }
        if (pos<0 || destination<0)//not found
        {
            //cout << "Destination NOT found" << endl;
        imp_set.import_dest << IMPORT_TO_NONE;
        imp_set.import_channel_dest << -1;
        }
        else
        {
            //cout << "Destination found: " << imp_set.keys.at(i).toLocal8Bit().constData() << " --> channel=" << destination_channel << " to " << ImportDestinationName[destination] << endl;
        imp_set.import_dest << destination;
        imp_set.import_channel_dest << destination_channel;
        }
        imp_set.token_target[i]=imp_set.import_dest.last();
    }
}

int guess_suitable_import_format(int suggestion,int actualsize)//guess the most suitable import format if the size in bytes does not match the type-suggestion --> will return the suggestion, if nothing better is found
{
int ret=suggestion;
switch (suggestion)
{
case COLUMN_SIG_CHAR:
case COLUMN_SIG_SHORT:
case COLUMN_SIG_INT:
case COLUMN_SIG_LONG:
    if (binaryImportFormat[COLUMN_SIG_CHAR].size==actualsize)
    {
    ret=COLUMN_SIG_CHAR;
    }
    else if (binaryImportFormat[COLUMN_SIG_SHORT].size==actualsize)
    {
    ret=COLUMN_SIG_SHORT;
    }
    else if (binaryImportFormat[COLUMN_SIG_INT].size==actualsize)
    {
    ret=COLUMN_SIG_INT;
    }
    else if (binaryImportFormat[COLUMN_SIG_LONG].size==actualsize)
    {
    ret=COLUMN_SIG_LONG;
    }
break;
case COLUMN_USIG_CHAR:
case COLUMN_USIG_SHORT:
case COLUMN_USIG_INT:
case COLUMN_USIG_LONG:
    if (binaryImportFormat[COLUMN_USIG_CHAR].size==actualsize)
    {
    ret=COLUMN_USIG_CHAR;
    }
    else if (binaryImportFormat[COLUMN_USIG_SHORT].size==actualsize)
    {
    ret=COLUMN_USIG_SHORT;
    }
    else if (binaryImportFormat[COLUMN_USIG_INT].size==actualsize)
    {
    ret=COLUMN_USIG_INT;
    }
    else if (binaryImportFormat[COLUMN_USIG_LONG].size==actualsize)
    {
    ret=COLUMN_USIG_LONG;
    }
break;
case COLUMN_FLOAT:
case COLUMN_DOUBLE:
case COLUMN_LONG_DOUBLE:
    if (binaryImportFormat[COLUMN_FLOAT].size==actualsize)
    {
    ret=COLUMN_FLOAT;
    }
    else if (binaryImportFormat[COLUMN_DOUBLE].size==actualsize)
    {
    ret=COLUMN_DOUBLE;
    }
    else if (binaryImportFormat[COLUMN_LONG_DOUBLE].size==actualsize)
    {
    ret=COLUMN_LONG_DOUBLE;
    }
break;
}
return ret;
}

void read_INI_header(struct importSettings & imp_set,struct importSettings & imp_schema)//imp_set should contain the header-file-name
{
//cout << "INI-Header-File" << endl;
// 0) set some basics from the imp_schema
//basic settings
copy_basic_scheme_data(imp_set,imp_schema);
// 1) read all the ini-tokens from the header
get_all_settings_from_ini_file(imp_set.HeaderFile,imp_set.keys,imp_set.vals,imp_set.import_channel_dest);
imp_set.nr_of_import_tokens=imp_set.keys.length();
// 2) compare the tokens with the schema and set the targets (where to put the data read from the header)
// the tokens we have to look for are in the imp_schema; any import-key in imp_set that is not part of imp_schema will be market with a 0 (IMPORT_TO_NONE)

/*
cout << "schema data:" << endl;
for (int i=0;i<imp_schema.keys.length();i++)
{
cout << "#" << imp_schema.keys.at(i).toLocal8Bit().constData() << "#-->#" << imp_schema.vals.at(i).toLocal8Bit().constData() << "#" << endl;
}*/
imp_set.import_channel_dest.clear();
imp_set.import_dest.clear();
//cout << "imported data:" << endl;
for (int i=0;i<imp_set.keys.length();i++)
{
//cout << "#" << imp_set.keys.at(i).toLocal8Bit().constData() << "#-->#" << imp_set.vals.at(i).toLocal8Bit().constData() << "#" << endl;
imp_set.import_channel_dest << -1;
imp_set.import_dest << IMPORT_TO_NONE;
}

prepare_imp_settings_for_header_import(imp_set);

if (imp_schema.valid_status!=-1)
{
    //cout << "START comparing" << endl;
compare_INI_settings_with_schema(imp_set,imp_schema);
    //cout << "STOP comparing" << endl;
}
else
{
    //cout << "just read" << endl;
return;//invalid schema-->do not try anything more
}

char tmp_target_name[1024];

/*imp_set.import_dest.clear();
int destination,pos,destination_channel;
if (imp_set.token_target!=NULL) delete[] imp_set.token_target;
imp_set.token_target=new int[1+imp_set.keys.length()];
for (int i=0;i<imp_set.keys.length();i++)
{
    pos=imp_schema.keys.indexOf(imp_set.keys.at(i));
    destination=IMPORT_TO_NONE;
        if (pos>=0)
        {
        strcpy(tmp_target_name,imp_schema.vals.at(pos).toLocal8Bit().constData());
        destination = find_import_destination(tmp_target_name,1);//'1' means look only for data read from header
        destination_channel = imp_schema.import_channel_dest.at(pos);
        }
    if (pos<0 || destination<0)//not found
    {
    imp_set.import_dest << IMPORT_TO_NONE;
    imp_set.import_channel_dest << -1;
    }
    else
    {
    imp_set.import_dest << destination;
    imp_set.import_channel_dest << destination_channel;
    }
    imp_set.token_target[i]=imp_set.import_dest.last();
}*/

// test-output
/*cout << "schema: header data to import" << endl;
for (int i=0;i<imp_schema.keys.length();i++)
cout << imp_schema.keys.at(i).toLocal8Bit().constData() << "-->" << imp_schema.vals.at(i).toLocal8Bit().constData() << endl;
*/

/*
cout << "imp_set: suitable header data found" << endl;
for (int i=0;i<imp_set.keys.length();i++)
{
cout << imp_set.keys.at(i).toLocal8Bit().constData() << "-->" << imp_set.vals.at(i).toLocal8Bit().constData() << " --> " << imp_set.import_dest.at(i) << " -- ch=" << imp_set.import_channel_dest.at(i) << endl;
}
*/

// 3) prepare the control variables in the imp_set
/*imp_set.x0set=false;
imp_set.deltaxset=false;
imp_set.fset=false;
    for (int i=0;i<7;i++)
    imp_set.factors[i]=1.0;
        for (int i=0;i<16;i++)
        {
        imp_set.channel_factors[i]=1.0;
        imp_set.channel_offsets[i]=0.0;
        }*/

    /*cout << "A) 16-channel_factors=" << endl;
    for (int i=0;i<16;i++)
    {
    cout << imp_set.channel_offsets[i] << " | " << imp_set.channel_factors[i] << endl;
    }*/

// 4) put the data read where it belongs!
double d_value;
///bool x_axis_implicit=false;//is true, if x0, dx or f is set, false means: set first channel to x
for (int i=0;i<imp_set.keys.length();i++)
{
if (imp_set.import_dest.at(i)==IMPORT_TO_NONE) continue;
    strcpy(tmp_target_name,imp_set.vals.at(i).toLocal8Bit().constData());//tabHeader->readValues[i].toLocal8Bit());
    d_value=atof(tmp_target_name);
//cout << "val=" << tmp_target_name << " --> atof=" << d_value << " imp_dest=" << imp_set.import_dest.at(i) << endl;
    switch (imp_set.import_dest.at(i))
    {
    case IMPORT_TO_X0:
        imp_set.x0=d_value;
        imp_set.x0set=true;
        break;
    case IMPORT_TO_DELTAX:
        imp_set.deltax=d_value;
        imp_set.deltaxset=true;
        break;
    case IMPORT_TO_DATA_SAMPLING_RATE:
        imp_set.f=d_value;
        imp_set.fset=true;
        break;
    case IMPORT_TO_NUMBER_OF_DATA:
        imp_set.points=atoi(tmp_target_name);
        break;
    case IMPORT_TO_NUMBER_OF_CHANNELS:
        imp_set.channels=atoi(tmp_target_name);
        break;
    case IMPORT_TO_DATA_SIZE:
        imp_set.bytesize=atoi(tmp_target_name);
        break;
    case IMPORT_TO_DATA_SIZE_BIT:
        imp_set.bitsize=atoi(tmp_target_name);
        break;
    case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
        imp_set.whole_size=atoi(tmp_target_name);
        break;
    case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
        imp_set.single_size=atoi(tmp_target_name);
        break;
    case IMPORT_TO_TITLE:
        if (imp_set.title!=NULL)
            delete[] imp_set.title;
        imp_set.title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.title,tmp_target_name);
        break;
    case IMPORT_TO_SET_LEGEND:
        if (imp_set.import_channel_dest.at(i)==-1)//all
        {
            for (int k=0;k<MAX_BIN_IMPORT_CHANNELS;k++)
            {
                if (imp_set.set_title[k]!=NULL)
                    delete[] imp_set.set_title[k];
                imp_set.set_title[k]=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                strcpy(imp_set.set_title[k],tmp_target_name);
            }
        }
        else
        {
        if (imp_set.set_title[imp_set.import_channel_dest.at(i)]!=NULL)
            delete[] imp_set.set_title[imp_set.import_channel_dest.at(i)];
        imp_set.set_title[imp_set.import_channel_dest.at(i)]=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.set_title[imp_set.import_channel_dest.at(i)],tmp_target_name);
        }
        break;
    case IMPORT_TO_XTITLE:
        if (imp_set.x_title!=NULL)
            delete[] imp_set.x_title;
        imp_set.x_title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.x_title,tmp_target_name);
        break;
    case IMPORT_TO_YTITLE:
        if (imp_set.y_title!=NULL)
            delete[] imp_set.y_title;
        imp_set.y_title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.y_title,tmp_target_name);
        break;
    case IMPORT_TO_SUBTITLE:
        if (imp_set.subtitle!=NULL)
            delete[] imp_set.subtitle;
        imp_set.subtitle=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
        strcpy(imp_set.subtitle,tmp_target_name);
        break;
    /*case IMPORT_TO_TRIGGER_FACTOR:
        imp_set.factors[6]*=d_value;
        break;*/
    }
    if (imp_set.import_dest.at(i)>=IMPORT_TO_XFACTOR && imp_set.import_dest.at(i)<=IMPORT_TO_Y4FACTOR)
    {
    //imp_set.factors[imp_set.import_dest.at(i)-IMPORT_TO_XFACTOR]*=d_value;
        if (imp_set.import_channel_dest.at(i)==-1)//all
        imp_set.factors[imp_set.import_dest.at(i)-IMPORT_TO_XFACTOR]*=d_value;
        else//just one channel
        imp_set.channel_factors[imp_set.import_channel_dest.at(i)]*=d_value;
    }
    else if (imp_set.import_dest.at(i)>=IMPORT_TO_Y_OFFSET && imp_set.import_dest.at(i)<=IMPORT_TO_Y4_OFFSET)
    {
        if (imp_set.import_channel_dest.at(i)==-1)//all
        imp_set.offsets[imp_set.import_dest.at(i)-IMPORT_TO_Y_OFFSET]+=d_value;
        else//just one channel
        imp_set.channel_offsets[imp_set.import_channel_dest.at(i)]+=d_value;
    }

    /*
    else if (imp_set.import_dest.at(i)>=IMPORT_TO_CHANNEL0_FACTOR && imp_set.import_dest.at(i)<=IMPORT_TO_CHANNEL15_FACTOR)
    {
    imp_set.channel_factors[imp_set.import_dest.at(i)-IMPORT_TO_CHANNEL0_FACTOR]*=d_value;
    }
    else if (imp_set.import_dest.at(i)>=IMPORT_TO_CHANNEL0_OFFSET && imp_set.import_dest.at(i)<=IMPORT_TO_CHANNEL15_OFFSET)
    {
    imp_set.channel_offsets[imp_set.import_dest.at(i)-IMPORT_TO_CHANNEL0_OFFSET]+=d_value;
    }*/
    //cout << "0-factor=" << imp_set.channel_factors[0] << endl;
}

/*cout << "B) 16-channel_factors=" << endl;
for (int i=0;i<16;i++)
{
cout << imp_set.channel_offsets[i] << " | " << imp_set.channel_factors[i] << endl;
}*/

complete_channel_settings(imp_set);

// 5) postprocess header information: crosscheck for completeness, guess cokumn-formats
if (imp_set.deltaxset==true || (imp_set.fset==true && imp_set.f!=0.0))//we have an iplicit x-axis --> we do not need a x-channel
{
    if (imp_set.x0set==false)
    {
    imp_set.x0=0.0;
    }
    if (imp_set.deltaxset==false)
    {
    imp_set.deltax=1.0/imp_set.f;
    }
    ///x_axis_implicit=true;
}

if (imp_set.channels<=0)
{
    errmsg(QObject::tr("Nr of channels not found in ini-file, setting channel count to 1").toLocal8Bit().constData());
    imp_set.channels=1;
}
int bsize;//only one byte-size for all channels
if (imp_set.bitsize!=-1)
{
bsize=imp_set.bitsize/8;
    if(bsize*8!=imp_set.bitsize)
    {
    errmsg(QObject::tr("size in bits no power of 8, bitsize increased to next power of 8").toLocal8Bit().constData());
    bsize++;
    imp_set.bytesize=bsize;
    imp_set.bitsize=imp_set.bytesize*8;
    }
imp_set.bytesize=bsize;
}
else if (imp_set.bytesize!=-1)
{
bsize=imp_set.bytesize;
imp_set.bitsize=imp_set.bytesize*8;
imp_set.bytesize=bsize;
}
else
bsize=-1;//invalid --> we look in the schema

//imp_set.first_suggestion=guess_bin_channel_import_format(bsize);
imp_set.contains_trigger=false;

//the actual import format for all channels
if (imp_set.format_suggestion!=NULL)delete[] imp_set.format_suggestion;
if (imp_set.channel_format!=NULL) delete[] imp_set.channel_format;
if (imp_set.channel_size!=NULL) delete[] imp_set.channel_size;
if (imp_set.channel_target!=NULL) delete[] imp_set.channel_target;
imp_set.format_suggestion=new int[1+imp_set.channels];
imp_set.channel_format=new int[1+imp_set.channels];
imp_set.channel_size=new int[1+imp_set.channels];
imp_set.channel_target=new int[1+imp_set.channels];

for (int i=0;i<imp_set.channels;i++)//go through all channels and set the import-format (if possible)
{
    if (imp_schema.channels>=i)//there is a suitable import-setting - maybe (we presume so...we hope the user knows best...)
    {
        imp_set.format_suggestion[i]=imp_set.channel_format[i]=imp_schema.channel_format[i];
        imp_set.channel_size[i]=imp_schema.channel_size[i];
        imp_set.channel_target[i]=imp_schema.channel_target[i];
        if (imp_set.channel_size[i]<=0) imp_set.channel_size[i]=binaryImportFormat[imp_set.channel_format[i]].size;
    }
    else//more channels than formats in schema
    {
        imp_set.channel_size[i]=bsize>0?bsize:1;
        if (imp_schema.channels-1>=0) imp_set.channel_format[i]=imp_set.format_suggestion[imp_schema.channels-1];
        else imp_set.channel_format[i]=guess_bin_channel_import_format(bsize);
        if (imp_set.channel_format[i]>=0)
        {
        imp_set.channel_format[i]=binaryImportFormat[imp_set.channel_format[i]].format;
        imp_set.channel_target[i]=IMPORT_TO_Y;//unknown is always Y
        }
        else
        {
        imp_set.channel_format[i]=COLUMN_OFFSET;
        imp_set.channel_target[i]=IMPORT_TO_NONE;
        }
    }
    imp_set.format_suggestion[i]=imp_set.channel_format[i];
    if (imp_set.channel_target[i]==IMPORT_TO_TRIGGER) imp_set.contains_trigger=true;
}

//cout << "first_suggestion=" << first_suggestion << endl;
//cout << imp_set.points << " " << imp_set.whole_size << " " << imp_set.bytesize << " " << imp_set.bitsize << endl;
if (imp_set.points<=0 && imp_set.whole_size!=-1 && (imp_set.bytesize!=-1 || imp_set.bitsize!=-1))
{
    int size=imp_set.bytesize!=-1?imp_set.bytesize:imp_set.bitsize/8;
    imp_set.points=imp_set.whole_size/size;
    if (imp_set.channels>0)
        imp_set.points/=imp_set.channels;
}

//cout << "points=" << imp_set.points << " whole=" << imp_set.whole_size << " byte=" << imp_set.bytesize << " bit=" << imp_set.bitsize << " global_size=" << global_size << endl;
/// imp_set.headersize=global_size;
imp_set.headersize=0;//no header in bin-file because header is in separate ini-file

/*cout << "C) 16-channel_factors=" << endl;
for (int i=0;i<16;i++)
{
cout << imp_set.channel_offsets[i] << " | " << imp_set.channel_factors[i] << endl;
}*/

/*
cout << "Faktors=" << endl;
for (int i=0;i<7;i++)
cout << "f[" << i << "]=" << imp_set.factors[i] << endl;
for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
cout << "ch_f[" << i << "]=" << imp_set.channel_factors[i] << endl;
*/

//we check the byte-size of the import-format here (only if a channel size in bytes is set)
if (bsize>0)
{
for (int i=0;i<imp_set.channels;i++)
{
    if (binaryImportFormat[imp_set.channel_format[i]].size!=bsize)
    {
    //cout << "Having to reguess Format of channel " << i << endl;
    //cout << "Original Suggestion: " << binaryImportFormatName[imp_set.channel_format[i]] << endl;
    imp_set.channel_format[i]=guess_suitable_import_format(imp_set.channel_format[i],bsize);
    //cout << "New Suggestion: " << binaryImportFormatName[imp_set.channel_format[i]] << endl;
    imp_set.channel_size[i]=binaryImportFormat[imp_set.channel_format[i]].size;
    imp_set.format_suggestion[i]=imp_set.channel_format[i];
    }
}
}
imp_set.ReadFromHeader=imp_set.HeaderFile;
//now we have read everything we could from the header!
//now we should read the data
}

int postprocess_bin_import_data(struct importSettings & imp_set,int & nr_of_new_sets,int ** n_gnos,int ** n_snos)
{
QString set_identifier;
char set_identifier_string[MAX_STRING_LENGTH];
nr_of_new_sets=0;
if (*n_gnos!=NULL) delete[] *n_gnos;
if (*n_snos!=NULL) delete[] *n_snos;

int number_of_sets_with_column[6]={0,0,0,0,0,0};
int number_of_x_columns=0;
int triggerChannel=-1;
int x_Channel=-1;
int triggerSet=-1;

for (int i=0;i<imp_set.channels;i++)
{
    if (imp_set.channel_target[i]==IMPORT_TO_X)
    {
        if (x_Channel==-1)
        x_Channel=i;
        else
        imp_set.channel_target[i]=IMPORT_TO_NONE;
    }
}

for (int i=0;i<imp_set.channels;i++)
{
    if (imp_set.channel_target[i]!=IMPORT_TO_NONE)
    {
        if (imp_set.channel_target[i]==IMPORT_TO_X)
            number_of_sets_with_column[0]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y)
            number_of_sets_with_column[1]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y1)
            number_of_sets_with_column[2]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y2)
            number_of_sets_with_column[3]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y3)
            number_of_sets_with_column[4]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_Y4)
            number_of_sets_with_column[5]++;
        else if (imp_set.channel_target[i]==IMPORT_TO_TRIGGER)
        {
            triggerChannel=i;
            if (imp_set.keep_trigger==true)//the trigger-channel counts as an additional Y-channel
            {
            number_of_sets_with_column[1]++;
            }
        }
    }
    //if (imp_set.set_title[i]!=NULL)
    //cout << "postprocessing: setTitle=#" << imp_set.set_title[i] << "#" << endl;
    //else
    //cout << "postprocessing: setTitle"<< i << " = NULL" << endl;
}
number_of_x_columns=number_of_sets_with_column[0];//save this, because we need to know it and the array will be a counter in future
int max_nr_of_sets=0;
int col_count_import_set=settype_cols(imp_set.set_type);
//cout << "col_count_import_set=" << col_count_import_set << endl;
for (int i=0;i<6;i++)
{
    //cout << i << " = " << number_of_sets_with_column[i] << endl;
    if (number_of_sets_with_column[i] > 0 && i >= col_count_import_set)
    {
        sprintf(dummy,"[Warning] Maximum number of columns for import-set-type %s = %d. The column %s will not be imported!",set_types(imp_set.set_type),col_count_import_set,dataset_colname(i));
        stufftext(dummy);
    }
    if (max_nr_of_sets<number_of_sets_with_column[i]) max_nr_of_sets=number_of_sets_with_column[i];
    number_of_sets_with_column[i]=0;//we will need this as a counter...
}
//cout << "Import from file: " << imp_set.DataFile.toLocal8Bit().constData() << " number_of_new_sets=" << max_nr_of_sets << " to be allocated" << endl;

*n_snos=new int[max_nr_of_sets+2];
*n_gnos=new int[max_nr_of_sets+2];
//labels labs;
//tickmarks *t;
int setno;//,ret;

if (imp_set.title!=NULL)
{
    //set_plotstr_string(&labs.title,imp_set.title);
    set_plotstr_string(&(g[imp_set.target_gno].labs.title),imp_set.title);
}
if (imp_set.subtitle!=NULL)
{
    //set_plotstr_string(&labs.stitle,imp_set.subtitle);
    set_plotstr_string(&(g[imp_set.target_gno].labs.stitle),imp_set.subtitle);
}
if (imp_set.x_title!=NULL)
{
    //t = get_graph_tickmarks(imp_set.target_gno, 0);//X
    //set_plotstr_string(&t->label, imp_set.x_title);
    set_plotstr_string(&(g[imp_set.target_gno].t[0]->label), imp_set.x_title);
}
if (imp_set.y_title!=NULL)
{
    //t = get_graph_tickmarks(imp_set.target_gno, 1);//Y
    //set_plotstr_string(&t->label, imp_set.y_title);
    set_plotstr_string(&(g[imp_set.target_gno].t[1]->label), imp_set.y_title);
}
/*
for (int i=0;i<imp_set.channels;i++)
cout<< "Channel[" << i << "]=" << imp_set.set_title[i] << endl;
*/
for (int i=0;i<max_nr_of_sets;i++)
{
setno = nextset(imp_set.target_gno);//allocate new sets
    (*n_snos)[i] = setno;
    (*n_gnos)[i] = imp_set.target_gno;
        set_set_hidden(imp_set.target_gno, setno, FALSE);
        //get_graph_labels(imp_set.target_gno, &labs);
    (void)setlength(imp_set.target_gno,setno,imp_set.points_read);
    (void)set_dataset_type(imp_set.target_gno,setno,imp_set.set_type);
    if (imp_set.keep_trigger==true && triggerChannel==i) triggerSet=setno;
//cout << "setno=" << setno << " len=" << getsetlength(imp_set.target_gno,setno) << " set_type=" << imp_set.set_type << endl;
}//end for-loop over all new sets
if (triggerChannel>-1 && imp_set.keep_trigger==false)//we need an extra set or the trigger channel, that will be deleted later
{
    triggerSet=nextset(imp_set.target_gno);
    (void)setlength(imp_set.target_gno,triggerSet,imp_set.points_read);
    (void)set_dataset_type(imp_set.target_gno,triggerSet,SET_XY);
    (*n_snos)[max_nr_of_sets] = triggerSet;
    (*n_gnos)[max_nr_of_sets] = imp_set.target_gno;
}
//now we have generated more than one set!
int col=0,legend_shift=0;
bool contains_x=false;
for (int i=0;i<imp_set.channels;i++)
{
    if (imp_set.channel_target[i]!=IMPORT_TO_NONE)
    {
        /*if (imp_set.channel_target[i]==IMPORT_TO_TRIGGER && imp_set.keep_trigger==false)
        {
            memcpy(g[imp_set.target_gno].p[triggerSet].data.ex[1],imp_set.first_data[i],sizeof(double)*imp_set.points_read);
            continue;
        }*/
    //double * n_data=(double*)malloc(sizeof(double)*points_read);
    //memcpy(n_data,imp_set.first_data[i],sizeof(double)*points_read);
        switch (imp_set.channel_target[i])
        {
        case IMPORT_TO_X:
            col=0;
            contains_x=true;
            legend_shift++;
            break;
        case IMPORT_TO_Y:
            col=1;
            break;
        case IMPORT_TO_TRIGGER://trigger-channel is always interpreted as Y
            col=1;
                if (imp_set.keep_trigger==false)
                legend_shift++;
            break;
        case IMPORT_TO_Y1:
            col=2;
            break;
        case IMPORT_TO_Y2:
            col=3;
            break;
        case IMPORT_TO_Y3:
            col=4;
            break;
        case IMPORT_TO_Y4:
            col=5;
            break;
        default:
            col=-1;
            break;
        }
        if (col>=col_count_import_set || col<0)
        {
            continue;//go to next channel because the allocated set does not have enough space for this column
        }
    memcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].data.ex[col],imp_set.first_data[i],sizeof(double)*imp_set.points_read);
    ///memcpy(g[target_gno].p[setno].data.ex[col],imp_set.first_data[i],sizeof(double)*points_read);
//cout << "Channel=" << i << " number_o_ch=" << number_of_sets_with_column[col] << " Legend=" << imp_set.set_title[i] << endl;
        //if (imp_set.channel_target[i]==IMPORT_TO_Y || (imp_set.channel_target[i]==IMPORT_TO_TRIGGER && imp_set.keep_trigger==true))// && imp_set.keep_trigger==true))
        if (col==1 || (imp_set.channel_target[i]==IMPORT_TO_TRIGGER && imp_set.keep_trigger==true))
        {
            QFileInfo fi(imp_set.DataFile);
            set_identifier=fi.filePath()+QObject::tr(", Channel ")+QString::number(i);
            //if (imp_set.set_title[imp_set.import_dest.at(i)]!=NULL)
            /*if (imp_set.set_title[i]!=NULL && (i<triggerChannel || (i>=triggerChannel && imp_set.keep_trigger==true) ) )
            {
               strcpy(set_identifier_string,imp_set.set_title[i]);
            }
            else if (imp_set.set_title[i]!=NULL && i>triggerChannel && i<max_nr_of_sets)
            {
                strcpy(set_identifier_string,imp_set.set_title[i+1]);
            }*/
            if (imp_set.set_title[i+legend_shift]!=NULL)
            {
               strcpy(set_identifier_string,imp_set.set_title[i+legend_shift]);
            }
            else
            {
                sprintf(set_identifier_string,"binary import from: %s",set_identifier.toLatin1().constData());
            }

            strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].lstr,set_identifier_string);
            strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].orig_lstr,set_identifier_string);
            strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].comments,set_identifier.toLocal8Bit().constData());
            strcpy(g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].orig_comments,set_identifier.toLocal8Bit().constData());
        }
//cout << "channel " << i << " factor=" << imp_set.channel_factors[i] << " offset=" << imp_set.channel_offsets[i] << " col_factor=" << imp_set.factors[col] << endl;
        //if (imp_set.factors[col]!=1.0)
            for (int k=0;k<imp_set.points_read;k++)
            {
            g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].data.ex[col][k]
            =
            g[imp_set.target_gno].p[(*n_snos)[number_of_sets_with_column[col]]].data.ex[col][k]*imp_set.factors[col]*imp_set.channel_factors[i]
            +imp_set.channel_offsets[i];
            }
        ///g[target_gno].p[setno].data.ex[col][k]*=imp_set.factors[col];
        number_of_sets_with_column[col]++;
    }
}//data imported into sets
if (contains_x==false)//no X-column set --> initialize every X in every set with header-data
{
    col=0;//x-axis
    double dx=1.0;
    double X0=0.0;
    if (imp_set.deltaxset==false && imp_set.fset==true)
    {
        dx=1.0/imp_set.f;
    }
    else if (imp_set.deltaxset==true && imp_set.fset==false)
    {
        dx=imp_set.deltax;
    }
    else if (imp_set.deltaxset==true && imp_set.fset==true)
    {
        dx=imp_set.deltax;
    }
    if (imp_set.x0set==true) X0=imp_set.x0;
    for (int j=0;j<max_nr_of_sets;j++)//generate an x-axis for all sets
    {
        for (int i=0;i<imp_set.points_read;i++)
        {
            g[imp_set.target_gno].p[(*n_snos)[j]].data.ex[col][i]=i*dx+X0;
        }
    }
}//ende contains_x==false
else//at least one x-column
{
    if (number_of_x_columns==1)//only one X for all sets --> all sets get this column
    {
        for (int j=1;j<max_nr_of_sets;j++)
        {
            memcpy(g[imp_set.target_gno].p[(*n_snos)[j]].data.ex[0],g[imp_set.target_gno].p[(*n_snos)[0]].data.ex[0],sizeof(double)*imp_set.points_read);//copy X-column
        }
    }
    else //some X have been imported and some others not --> give the rest an index as X-column
    {
        for (int j=number_of_x_columns;j<max_nr_of_sets;j++)
        {
            for (int i=0;i<imp_set.points_read;i++)
            {
                g[imp_set.target_gno].p[(*n_snos)[j]].data.ex[col][i]=i*1.0;//write only index numbers into X-columns
            }
        }
    }
}

//do trigger-channel-actions
if (triggerChannel>-1 && imp_set.trigger_type>=0)
{
    /*char fstr2[64];
    int resno;
    char *rarray;*/
    double trigger_shift=0.0;
    /*resno = get_restriction_array(imp_set.target_gno,triggerSet,RESTRICT_NONE,0,&rarray);
    sprintf(fstr2,"G%d.S%d.X=G%d.S%d.X",imp_set.target_gno,triggerSet,imp_set.target_gno,(*n_snos)[0]);
    //copy X-values from first set
    resno = do_compute(imp_set.target_gno, triggerSet, imp_set.target_gno, triggerSet, rarray, fstr2);*/

    /// TODO: moegliches Problem: nur ein Trigger-Kanal, aber kein echter Kanal!???
        //copy X-values from first set
        if (imp_set.keep_trigger==false)
        CopySetAxis(imp_set.target_gno,(*n_snos)[0],DATA_X,imp_set.target_gno,triggerSet,DATA_X);
    if (imp_set.factors[6]!=1.0)//a special additional factor for the trigger
    {
    MultiplySetAxis(imp_set.target_gno,triggerSet,imp_set.factors[6],DATA_Y);
        /*sprintf(fstr2,"G%d.S%d.Y=G%d.S%d.Y*%lf",imp_set.target_gno,triggerSet,imp_set.target_gno,(*n_snos)[0],imp_set.factors[6]);
        //rescale trigger-channel
        resno = do_compute(imp_set.target_gno, triggerSet, imp_set.target_gno, triggerSet, rarray, fstr2);*/
    }
    if (imp_set.trigger_type==0)//rising edge
    {
        for (int lll=1;lll<getsetlength(imp_set.target_gno,triggerSet);lll++)
        {
            if (g[imp_set.target_gno].p[triggerSet].data.ex[1][lll-1]<imp_set.triggervalue && g[imp_set.target_gno].p[triggerSet].data.ex[1][lll]>=imp_set.triggervalue)
            {
                trigger_shift=g[imp_set.target_gno].p[triggerSet].data.ex[0][lll];
                break;
            }
        }
    }
    else if (imp_set.trigger_type==1)//falling edge
    {
        for (int lll=1;lll<getsetlength(imp_set.target_gno,triggerSet);lll++)
        {
            if (g[imp_set.target_gno].p[triggerSet].data.ex[1][lll-1]>=imp_set.triggervalue && g[imp_set.target_gno].p[triggerSet].data.ex[1][lll]<imp_set.triggervalue)
            {
                trigger_shift=g[imp_set.target_gno].p[triggerSet].data.ex[0][lll];
                break;
            }
        }
    }
    else//either edge
    {
        for (int lll=1;lll<getsetlength(imp_set.target_gno,triggerSet);lll++)
        {
            if ((g[imp_set.target_gno].p[triggerSet].data.ex[1][lll-1]>=imp_set.triggervalue && g[imp_set.target_gno].p[triggerSet].data.ex[1][lll]<imp_set.triggervalue) || (g[imp_set.target_gno].p[triggerSet].data.ex[1][lll-1]<imp_set.triggervalue && g[imp_set.target_gno].p[triggerSet].data.ex[1][lll]>=imp_set.triggervalue))
            {
                trigger_shift=g[imp_set.target_gno].p[triggerSet].data.ex[0][lll];
                break;
            }
        }
    }
//cout << "trigger_set=" << triggerSet << " trigger_shift=" << trigger_shift << endl;
    for (int lll=0;lll<max_nr_of_sets;lll++)
    {
    ShiftSetAxis(imp_set.target_gno,(*n_snos)[lll],-trigger_shift,DATA_X);
        /*resno = get_restriction_array(imp_set.target_gno,(*n_snos)[lll],RESTRICT_NONE,0,&rarray);
        sprintf(fstr2,"G%d.S%d.X=G%d.S%d.X-%lf",imp_set.target_gno,(*n_snos)[lll],imp_set.target_gno,(*n_snos)[lll],trigger_shift);
        resno = do_compute(imp_set.target_gno,(*n_snos)[lll], imp_set.target_gno,(*n_snos)[lll], rarray, fstr2);*/
    }
        if (imp_set.keep_trigger==false)
        {
        killset(imp_set.target_gno, triggerSet);
        }
        else
        {
        // ShiftSetAxis(imp_set.target_gno,triggerSet,-trigger_shift,DATA_X);
        /*resno = get_restriction_array(imp_set.target_gno,triggerSet,RESTRICT_NONE,0,&rarray);
        sprintf(fstr2,"G%d.S%d.X=G%d.S%d.X-%lf",imp_set.target_gno,triggerSet,imp_set.target_gno,triggerSet,trigger_shift);
        resno = do_compute(imp_set.target_gno, triggerSet, imp_set.target_gno, triggerSet, rarray, fstr2);*/
        }
}

/*
append_to_storage(&collect_nr_of_sets,&col_gnos,max_nr_of_sets,gnos);//save the set-ids for the undo-operations
collect_nr_of_sets-=max_nr_of_sets;//because collect_nr_of_sets has to be increased in the next function
append_to_storage(&collect_nr_of_sets,&col_snos,max_nr_of_sets,snos);
*/

nr_of_new_sets=max_nr_of_sets;

return RETURN_SUCCESS;
}

///do Read Header not working at the moment for ini-files
void doReadDataFromHeader(ifstream & ifi,struct importSettings & imp_set)
{
    char dummy[512];
    bool integer_type;
    double d_value;
    char buffer[16];
    char * stringText=new char[2];
    int size,readbytes,global_size=0;
//imp_set.first_suggestion=0;/// should be in the parent widget (somehow)

    if (imp_set.header_present==true && imp_set.header_format==HEADER_FORMAT_INI_FILE)
    //if (cmbFormatSource->currentIndex()==2 && cmbHeaderFileFormat->currentIndex()==1)
    {//ini-header in separate file
    /// INI
        /// so viele inits braucht man eigentlich nicht (bzw. man sollte in init unterscheiden, welche Daten man zuruecksetzen will --> nur die gelesenen Daten und nicht die Einstellungen zum Lesen
        /// initSettings(imp_set);
        get_all_settings_from_ini_file(imp_set.HeaderFile,imp_set.keys,imp_set.vals,imp_set.import_channel_dest);
        imp_set.token_target=new int[imp_set.keys.length()+1];

        //for (int i=0;i<tabHeader->nr_of_sels;i++)
        for (int i=0;i<imp_set.nr_of_header_values;i++)
        {
            if (imp_set.header_value_import[i]!=IMPORT_TO_NONE)//tabHeader->sels[i]->currentValue()!=IMPORT_TO_NONE)
            {
                strcpy(dummy,imp_set.vals.at(i).toLocal8Bit().constData());//tabHeader->readValues[i].toLocal8Bit());
                d_value=atof(dummy);
                switch (imp_set.header_value_import[i])//tabHeader->sels[i]->currentValue())
                {
                case IMPORT_TO_TITLE:
                    if (imp_set.title!=NULL)
                        delete[] imp_set.title;
                    imp_set.title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.title,dummy);
                    break;
                case IMPORT_TO_SET_LEGEND:
                    if (imp_set.set_title[imp_set.import_dest.at(i)]!=NULL)
                        delete[] imp_set.set_title[imp_set.import_dest.at(i)];
                    imp_set.set_title[imp_set.import_dest.at(i)]=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.set_title[imp_set.import_dest.at(i)],dummy);
                    break;
                case IMPORT_TO_X0:
                    imp_set.x0=d_value;
                    imp_set.x0set=true;
                    break;
                case IMPORT_TO_DELTAX:
                    imp_set.deltax=d_value;
                    imp_set.deltaxset=true;
                    break;
                case IMPORT_TO_XTITLE:
                    if (imp_set.x_title!=NULL)
                        delete[] imp_set.x_title;
                    imp_set.x_title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.x_title,dummy);
                    break;
                case IMPORT_TO_YTITLE:
                    if (imp_set.y_title!=NULL)
                        delete[] imp_set.y_title;
                    imp_set.y_title=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.y_title,dummy);
                    break;
                case IMPORT_TO_XFACTOR:
                    imp_set.factors[0]*=d_value;
                    break;
                case IMPORT_TO_YFACTOR:
                    imp_set.factors[1]*=d_value;
                    break;
                case IMPORT_TO_Y1FACTOR:
                    imp_set.factors[2]*=d_value;
                    break;
                case IMPORT_TO_Y2FACTOR:
                    imp_set.factors[3]*=d_value;
                    break;
                case IMPORT_TO_Y3FACTOR:
                    imp_set.factors[4]*=d_value;
                    break;
                case IMPORT_TO_Y4FACTOR:
                    imp_set.factors[5]*=d_value;
                    break;
                /*case IMPORT_TO_TRIGGER_FACTOR:
                    imp_set.factors[6]*=d_value;
                    break;*/
                case IMPORT_TO_SUBTITLE:
                    if (imp_set.subtitle!=NULL)
                        delete[] imp_set.subtitle;
                    imp_set.subtitle=new char[imp_set.vals.at(i).length()+1];//tabHeader->readValues[i].length()+1];
                    strcpy(imp_set.subtitle,dummy);
                    break;
                case IMPORT_TO_NUMBER_OF_DATA:
                    imp_set.points=atoi(dummy);
                    break;
                case IMPORT_TO_NUMBER_OF_CHANNELS:
                    imp_set.channels=atoi(dummy);
                    break;
                case IMPORT_TO_DATA_SIZE:
                    imp_set.bytesize=atoi(dummy);
                    break;
                case IMPORT_TO_DATA_SIZE_BIT:
                    imp_set.bitsize=atoi(dummy);
                    break;
                case IMPORT_TO_DATA_SAMPLING_RATE:
                    imp_set.f=d_value;
                    imp_set.fset=true;
                    break;
                case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
                    imp_set.whole_size=atoi(dummy);
                    break;
                case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
                    imp_set.single_size=atoi(dummy);
                    break;
                }
            }
        }
    }
    else if (imp_set.header_present==true && imp_set.header_format==HEADER_FORMAT_DATA_FILE)//binary header
    {
//cout << "HEADER IN A BIN-DATA FILE" << endl;
    long * headerDatas=new long[imp_set.nr_of_header_values];
    long double * ldHeaderDatas=new long double[imp_set.nr_of_header_values];
        for (int i=0;i<imp_set.nr_of_header_values;i++)//tabHeader->number_of_lines;i++)
        {
            size=imp_set.header_value_size[i];//tabHeader->inFormats[i]->getSize();
            global_size+=size;
            //if (tabHeader->inFormats[i]->getType()!=COLUMN_OFFSET && tabHeader->inFormats[i]->getType()!=COLUMN_STRING)
            if (imp_set.header_value_format[i]!=COLUMN_OFFSET && imp_set.header_value_format[i]!=COLUMN_STRING)
            {
                ifi.read(buffer,size);
                readbytes=(int)(ifi.gcount());
                if (readbytes!=size)
                {
                    sprintf(dummy,"[Information] Stopped reading header item after import of %d Bytes (of %d bytes).",readbytes,size);
                    stufftext(dummy);
                }
            }
            switch (imp_set.header_value_format[i])//tabHeader->inFormats[i]->getType())
            {
            case COLUMN_OFFSET:
            default:
                integer_type=false;
                for (int j=0;j<size;j++)
                    ifi.read(buffer,1);//read byte after byte into the same buffer (we dont need it)
                break;
            case COLUMN_SIG_CHAR:
                integer_type=true;
                headerDatas[i]=(long)(*((signed char*)((void*)buffer)));
                break;
            case COLUMN_USIG_CHAR:
                integer_type=true;
                headerDatas[i]=(long)(*((unsigned char*)((void*)buffer)));
                break;
            case COLUMN_SIG_SHORT:
                integer_type=true;
                headerDatas[i]=(long)(*((signed short*)((void*)buffer)));
                break;
            case COLUMN_USIG_SHORT:
                integer_type=true;
                headerDatas[i]=(long)(*((unsigned short*)((void*)buffer)));
                break;
            case COLUMN_SIG_INT:
                integer_type=true;
                headerDatas[i]=(long)(*((signed int*)((void*)buffer)));
                break;
            case COLUMN_USIG_INT:
                integer_type=true;
                headerDatas[i]=(long)(*((unsigned int*)((void*)buffer)));
                break;
            case COLUMN_SIG_LONG:
                integer_type=true;
                headerDatas[i]=(long)(*((signed long*)((void*)buffer)));
                break;
            case COLUMN_USIG_LONG:
                integer_type=true;
                headerDatas[i]=(long)(*((unsigned long*)((void*)buffer)));
                break;
            case COLUMN_FLOAT:
                integer_type=false;
                ldHeaderDatas[i]=(long double)(*((float*)((void*)buffer)));
                break;
            case COLUMN_DOUBLE:
                integer_type=false;
                ldHeaderDatas[i]=(long double)(*((double*)((void*)buffer)));
                break;
            case COLUMN_LONG_DOUBLE:
                integer_type=false;
                ldHeaderDatas[i]=(long double)(*((long double*)((void*)buffer)));
                break;
            case COLUMN_STRING:
                integer_type=false;
                if (imp_set.determine_string_size==true)
                {
                    int res=16;
                    int read_s=0;
                    char * targ=new char[res+1];
                    char read_c=imp_set.string_end_char-1;
                    while (read_c!=imp_set.string_end_char)
                    {
                        ifi.read(&read_c,1);
                        targ[read_s]=read_c;
                        read_s++;
                        if (read_s==res)
                        {
                            char * targ2=new char[res+17];
                            memcpy(targ2,targ,sizeof(char)*read_s);
                            delete[] targ;
                            targ=targ2;
                            res+=16;
                        }
                    }
                    targ[read_s]='\0';
                    global_size-=size;
                    size=read_s;
                    /// tabHeader->inFormats[i]->spnSize->setValue(size);
                    global_size+=size;
                    delete[] stringText;
                    stringText=new char[size+2];
                    strcpy(stringText,targ);
                }
                else
                {
                    delete[] stringText;
                    stringText=new char[size+2];
                    ifi.read(stringText,size);
                    stringText[size]='\0';
                    readbytes=(int)(ifi.gcount());
                    if (readbytes!=size)
                    {
                        sprintf(dummy,"[Information] Stopped reading header item after import of %d Bytes (of %d bytes).",readbytes,size);
                        stufftext(dummy);
                    }
                }
                break;
            }//end switch-block

            //if (tabHeader->inFormats[i]->getTarget()!=IMPORT_TO_NONE)
                switch (imp_set.header_value_import[i])
                {
                case IMPORT_TO_NONE:
                    break;
                case IMPORT_TO_TITLE:
                    if (imp_set.title!=NULL)
                        delete[] imp_set.title;
                    imp_set.title=new char[size+1];
                    strcpy(imp_set.title,stringText);
                    break;
                case IMPORT_TO_SET_LEGEND:
                    if (imp_set.set_title[imp_set.import_dest.at(i)]!=NULL)
                        delete[] imp_set.set_title[imp_set.import_dest.at(i)];
                    imp_set.set_title[imp_set.import_dest.at(i)]=new char[size+1];
                    strcpy(imp_set.set_title[imp_set.import_dest.at(i)],stringText);
                    break;
                case IMPORT_TO_X0:
                    if (integer_type)
                        imp_set.x0=headerDatas[i];
                    else
                        imp_set.x0=ldHeaderDatas[i];
                    imp_set.x0set=true;
                    break;
                case IMPORT_TO_DELTAX:
                    if (integer_type)
                        imp_set.deltax=headerDatas[i];
                    else
                        imp_set.deltax=ldHeaderDatas[i];
                    imp_set.deltaxset=true;
                    break;
                case IMPORT_TO_XTITLE:
                    if (imp_set.x_title!=NULL)
                        delete[] imp_set.x_title;
                    imp_set.x_title=new char[size+1];
                    strcpy(imp_set.x_title,stringText);
                    break;
                case IMPORT_TO_YTITLE:
                    if (imp_set.y_title!=NULL)
                        delete[] imp_set.y_title;
                    imp_set.y_title=new char[size+1];
                    strcpy(imp_set.y_title,stringText);
                    break;
                case IMPORT_TO_XFACTOR:
                    if (integer_type)
                        imp_set.factors[0]*=headerDatas[i];
                    else
                        imp_set.factors[0]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_YFACTOR:
                    if (integer_type)
                        imp_set.factors[1]*=headerDatas[i];
                    else
                        imp_set.factors[1]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y1FACTOR:
                    if (integer_type)
                        imp_set.factors[2]*=headerDatas[i];
                    else
                        imp_set.factors[2]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y2FACTOR:
                    if (integer_type)
                        imp_set.factors[3]*=headerDatas[i];
                    else
                        imp_set.factors[3]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y3FACTOR:
                    if (integer_type)
                        imp_set.factors[4]*=headerDatas[i];
                    else
                        imp_set.factors[4]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y4FACTOR:
                    if (integer_type)
                        imp_set.factors[5]*=headerDatas[i];
                    else
                        imp_set.factors[5]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y_OFFSET:
                    if (integer_type)
                        imp_set.offsets[1]*=headerDatas[i];
                    else
                        imp_set.offsets[1]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y1_OFFSET:
                    if (integer_type)
                        imp_set.offsets[2]*=headerDatas[i];
                    else
                        imp_set.offsets[2]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y2_OFFSET:
                    if (integer_type)
                        imp_set.offsets[3]*=headerDatas[i];
                    else
                        imp_set.offsets[3]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y3_OFFSET:
                    if (integer_type)
                        imp_set.offsets[4]*=headerDatas[i];
                    else
                        imp_set.offsets[4]*=ldHeaderDatas[i];
                    break;
                case IMPORT_TO_Y4_OFFSET:
                    if (integer_type)
                        imp_set.offsets[5]*=headerDatas[i];
                    else
                        imp_set.offsets[5]*=ldHeaderDatas[i];
                    break;
                /*case IMPORT_TO_TRIGGER_FACTOR:
                    if (integer_type)
                        imp_set.factors[6]*=headerDatas[i];
                    else
                        imp_set.factors[6]*=ldHeaderDatas[i];
                    break;*/
                case IMPORT_TO_SUBTITLE:
                    delete[] imp_set.subtitle;
                    imp_set.subtitle=new char[size+1];
                    strcpy(imp_set.subtitle,stringText);
                    break;
                case IMPORT_TO_NUMBER_OF_DATA:
                    imp_set.points=headerDatas[i];
                    break;
                case IMPORT_TO_NUMBER_OF_CHANNELS:
                    imp_set.channels=headerDatas[i];
                    break;
                case IMPORT_TO_DATA_SIZE:
                    imp_set.bytesize=headerDatas[i];
                    break;
                case IMPORT_TO_DATA_SIZE_BIT:
                    imp_set.bitsize=headerDatas[i];
                    break;
                case IMPORT_TO_DATA_SAMPLING_RATE:
                    if (integer_type)
                        imp_set.f=headerDatas[i];
                    else
                        imp_set.f=ldHeaderDatas[i];
                    imp_set.fset=true;
                    break;
                case IMPORT_TO_WHOLE_DATA_BLOCK_SIZE:
                    imp_set.whole_size=headerDatas[i];
                    break;
                case IMPORT_TO_SINGLE_DATA_BLOCK_SIZE:
                    imp_set.single_size=headerDatas[i];
                    break;
                }
        }//end loop through lines
        delete [] headerDatas;
        delete [] ldHeaderDatas;
    }//end reading binary header
    else//ascii-header
    {

    }

    delete[] stringText;
    //int bsize;
//cout << "first_suggestion=" << first_suggestion << " bits=" << imp_set.bitsize << endl;

    /*imp_set.first_suggestion=-1;
    if (imp_set.bitsize!=-1)
    {
        bsize=imp_set.bitsize/8;
        if (bsize*8==imp_set.bitsize)//add suggestions for import
        {
            for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
            {
                if (binaryImportFormat[i].size==bsize)
                {
                    if (imp_set.first_suggestion==-1)
                    imp_set.first_suggestion=i;
                }
            }
        }
    }*/

//cout << "first_suggestion=" << first_suggestion << " bytes=" << imp_set.bytesize << endl;

    /*if (imp_set.bytesize!=-1)
    {
        imp_set.first_suggestion=-1;
        for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
        {
            if (binaryImportFormat[i].size==imp_set.bytesize)
            {
                if (imp_set.first_suggestion==-1)
                    imp_set.first_suggestion=i;
            }
        }
    }*/

//cout << "first_suggestion=" << first_suggestion << endl;
//cout << imp_set.points << " " << imp_set.whole_size << " " << imp_set.bytesize << " " << imp_set.bitsize << endl;
    if (imp_set.points<=0 && imp_set.whole_size!=-1 && (imp_set.bytesize!=-1 || imp_set.bitsize!=-1))
    {
        int size=imp_set.bytesize!=-1?imp_set.bytesize:imp_set.bitsize/8;
        imp_set.points=imp_set.whole_size/size;
        if (imp_set.channels>0)
            imp_set.points/=imp_set.channels;
    }
//cout << "points=" << imp_set.points << " whole=" << imp_set.whole_size << " byte=" << imp_set.bytesize << " bit=" << imp_set.bitsize << " global_size=" << global_size << endl;
    imp_set.headersize=global_size;
}

void binary_load_Phase1(QString Header_Filename,QString Data_Filename,struct importSettings & imp_set,struct importSettings & imp_scheme)//load header and initialize imp_set
{
insert_filenames_in_settings(imp_set,imp_scheme,Header_Filename,Data_Filename);
readHeaderData(imp_set,imp_scheme);
}

/*void binary_load_Phase2(struct importSettings & imp_set,struct importSettings & imp_scheme)//compare imp_set with imp_schema to prepare for binary import
{

}*/

void binary_load_Phase3(struct importSettings & imp_set)//the actual import (just reading the data)
{
ifstream ifi;
ifi.open(imp_set.DataFile.toLocal8Bit().constData(),ios::binary);
readBinaryFromFile(ifi,imp_set,&imp_set.first_data);
ifi.close();
}

void binary_load_Phase4(struct importSettings & imp_set,int & nr_of_new_sets,int ** n_gnos,int ** n_snos)//the postprocessing of the data
{
int ret=postprocess_bin_import_data(imp_set,nr_of_new_sets,n_gnos,n_snos);
    if (ret!=RETURN_SUCCESS)
    {
    cout << "Problem during binary postprocessing!" << endl;
    }
}

void frmBinaryFormatInput::transmitInfos(void)//this function is used after data has been read from a header to update the settings in the gui
{
    QByteArray ba;
    if (tabFileInfo->DatFile!=NULL) delete[] tabFileInfo->DatFile;
    if (tabFileInfo->HeaderFile!=NULL) delete[] tabFileInfo->HeaderFile;
//cout << "bin_file_nr_to_import=" << bin_file_nr_to_import << endl;
//cout << "datFileNames.length()=" << datFileNames.length() << endl;
    if (datFileNames.length()<=bin_file_nr_to_import || bin_file_nr_to_import<0)
    {
    tabFileInfo->DatFile=NULL;
    }
    else
    {
    ba=datFileNames.at(bin_file_nr_to_import).toLocal8Bit();
    tabFileInfo->DatFile=new char[ba.length()+8];
    strcpy(tabFileInfo->DatFile,ba.constData());
    }
    if (headerFileNames.length()<=bin_file_nr_to_import || bin_file_nr_to_import<0)
    {
    tabFileInfo->HeaderFile=NULL;
    }
    else
    {
    ba=headerFileNames.at(bin_file_nr_to_import).toLocal8Bit();
    tabFileInfo->HeaderFile=new char[ba.length()+8];
    strcpy(tabFileInfo->HeaderFile,ba.constData());
    }
    convertSettingsToString();
    tabFileInfo->headerContents=settingString;
    tabFileInfo->ShowInfos();
//cout << "channels=" << imp_set.channels << endl;
    if (imp_set.channels>0) tabDataInfo->spnChannelCount->setValue(imp_set.channels);
    else tabDataInfo->spnChannelCount->setValue(0);
    tabDataInfo->channelCountChanged(tabDataInfo->spnChannelCount->value());
    if (imp_set.points>0) tabDataInfo->spnDataSetCount->setValue(imp_set.points);
    else tabDataInfo->spnDataSetCount->setValue(0);
    qApp->processEvents();
    tabDataInfo->selOrder->setCurrentValue(imp_set.setorder);
    tabDataInfo->selTriggerType->setCurrentValue(imp_set.trigger_type);
    tabDataInfo->selTriggerValue->setValue(imp_set.triggervalue);
//cout << "NumberOfLines=" << tabDataInfo->number_of_lines << endl;
    qApp->processEvents();
        for (int i=0;i<tabDataInfo->number_of_lines;i++)
        {
        tabDataInfo->inFormats[i]->cmbFormat->setCurrentIndex(imp_set.format_suggestion[i]);
        tabDataInfo->inFormats[i]->spnSize->setValue(imp_set.channel_size[i]);
        tabDataInfo->inFormats[i]->cmbImportAs->setCurrentIndex(imp_set.channel_target[i]-1);
        }

    return;

/// Function ends here

    if (!lenDataFile->text().isEmpty())
    {
        //strcpy(datFileName,lenDataFile->text().toLocal8Bit());
        //tabFileInfo->DatFile=datFileName;
    }
    else
    {
        //tabFileInfo->DatFile=NULL;
        //datFileName[0]='\0';
    }

    if (cmbFormatSource->currentIndex()==2)
    {
        if (!lenHeaderFile->text().isEmpty())
        {
            //strcpy(headerFileName,lenHeaderFile->text().toLocal8Bit());
            //tabFileInfo->HeaderFile=headerFileName;
            ifstream ifi;
            //ifi.open(headerFileName,ios::binary);
            ifi.open(headerFileNames.at(bin_file_nr_to_import).toLocal8Bit().constData(),ios::binary);
            doReadDataFromHeader(ifi,imp_set);
            ifi.close();
            convertSettingsToString();
            tabFileInfo->headerContents=settingString;
            if (imp_set.channels>0) tabDataInfo->spnChannelCount->setValue(imp_set.channels);
            if (imp_set.points>0) tabDataInfo->spnDataSetCount->setValue(imp_set.points);
            qApp->processEvents();
            if (first_suggestion!=-1)
            {
                for (int i=0;i<tabDataInfo->number_of_lines;i++)
                {
                    tabDataInfo->inFormats[i]->cmbFormat->setCurrentIndex(first_suggestion);
                }
            }
        }
        else
        {
            tabFileInfo->HeaderFile=NULL;
            //headerFileName[0]='\0';
        }
    }
    else if (cmbFormatSource->currentIndex()==1)
    {
        tabFileInfo->HeaderFile=tabFileInfo->DatFile;
        //strcpy(headerFileName,datFileName);
    }
    else
    {
        tabFileInfo->HeaderFile=NULL;
        //headerFileName[0]='\0';
    }

}

void frmBinaryFormatInput::convertSettingsToString(void)
{
    int bsize;
    first_suggestion=-1;
    char dummy[512];
    char dummy2[4];
    QString result(tr("Data read from Header:\n"));
    result.append(tr("Header size= ")+QString::number(imp_set.headersize)+QString(" bytes\n"));
    if (imp_set.title!=NULL)
        if (imp_set.title[0]!='\0')
            result.append(tr("Set title= ")+QString(imp_set.title)+QString("\n"));
    if (imp_set.subtitle!=NULL)
        if (imp_set.subtitle[0]!='\0')
            result.append(tr("Set subtitle= ")+QString(imp_set.subtitle)+QString("\n"));
    if (imp_set.x_title!=NULL)
        if (imp_set.x_title[0]!='\0')
            result.append(tr("Set x-title= ")+QString(imp_set.x_title)+QString("\n"));
    if (imp_set.y_title!=NULL)
        if (imp_set.y_title[0]!='\0')
            result.append(tr("Set y-title= ")+QString(imp_set.y_title)+QString("\n"));
    /*if (imp_set.set_title!=NULL)
        if (imp_set.set_title[0]!='\0')
            result.append(tr("Set-title= ")+QString(imp_set.set_title)+QString("\n"));*/
    for (int i=0;i<MAX_BIN_IMPORT_CHANNELS;i++)
    {
    if (imp_set.set_title[i]!=NULL)
        if (imp_set.set_title[i][0]!='\0')
            result.append(tr("Set-title[")+QString::number(i)+QString("]= ")+QString(imp_set.set_title[i])+QString("\n"));
    }

    if (imp_set.x0set)
    {
        sprintf(dummy,"%g\n",imp_set.x0);
        result.append(tr("X0= ")+QString(dummy));
    }
    if (imp_set.deltaxset)
    {
        sprintf(dummy,"%g\n",imp_set.deltax);
        result.append(tr("deltaX= ")+QString(dummy));
    }
    if (imp_set.fset)
    {
        sprintf(dummy,"%g samples/sec\n",imp_set.f);
        result.append(tr("Sampling rate= ")+QString(dummy));
    }
    if (imp_set.channels!=-1)
    {
        sprintf(dummy,"%d\n",imp_set.channels);
        result.append(tr("Channels= ")+QString(dummy));
    }
    if (imp_set.points!=-1)
    {
        sprintf(dummy,"%d\n",imp_set.points);
        result.append(tr("Sample count= ")+QString(dummy));
    }
    for (int i=0;i<6;i++)
    {
        if (i==0) strcpy(dummy2,"X");
        else if (i==1) strcpy(dummy2,"Y");
        else sprintf(dummy2,"Y%d",i-1);
        if (imp_set.factors[i]!=1.0)
        {
            sprintf(dummy,"Factor for %s = %g\n",dummy2,imp_set.factors[i]);
            result.append(QString(dummy));
        }
    }
    if (imp_set.bitsize!=-1 && imp_set.bytesize==-1)
    {
        bsize=imp_set.bitsize/8;
        if (bsize*8==imp_set.bitsize)
            sprintf(dummy,"%d bits = %d bytes\n",imp_set.bitsize,imp_set.bytesize);
        else
            sprintf(dummy,"%d bits (not a multiple of 8)\n",imp_set.bitsize);
        result.append(tr("Size of sample= ")+QString(dummy));
        if (bsize*8==imp_set.bitsize)//add suggestions for import
        {
            for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
            {
                if (binaryImportFormat[i].size==bsize)
                {
                    result.append(tr("Suggested import format= ")+QString(binaryImportFormatName[binaryImportFormat[i].format])+QString("\n"));
                    if (first_suggestion==-1)
                        first_suggestion=i;
                }
            }
        }
    }
    if (imp_set.bytesize!=-1)
    {
        first_suggestion=-1;
        sprintf(dummy,"%d bytes\n",imp_set.bytesize);
        result.append(tr("Size of sample= ")+QString(dummy));
        for (int i=0;i<NUMBER_OF_COLUMN_FORMATS;i++)
        {
            if (binaryImportFormat[i].size==imp_set.bytesize)
            {
                result.append(tr("Suggested import format= ")+QString(binaryImportFormatName[binaryImportFormat[i].format])+QString("\n"));
                if (first_suggestion==-1)
                    first_suggestion=i;
            }
        }
    }

    if ((imp_set.bytesize!=-1 || imp_set.bitsize!=-1) && imp_set.channels!=-1 && imp_set.points!=-1)
    {
        int bsize=imp_set.bytesize!=-1?imp_set.bytesize:imp_set.bitsize/8;
        int whole=bsize*imp_set.channels*imp_set.points;
        sprintf(dummy,"Data block size= %d Bytes\n",whole);
        result.append(QString(dummy));
        sprintf(dummy,"File section to be read= %d Bytes\n",whole+imp_set.headersize);
        result.append(QString(dummy));
    }

    if (imp_set.first_data!=NULL)
    {
        result.append(QString("\n"));
        result.append(tr("First 10 datapoints:\n"));
        QString strli=QString("Nr.:\t");
        for (int i=0;i<imp_set.channels;i++)
        {
            sprintf(dummy,"ch%d\t",i);
            strli=strli+QString(dummy);
        }
        strli=strli+QString("\n");
        result.append(strli);
        for (int j=0;j<10;j++)
        {
            sprintf(dummy,"%d:\t",j);
            strli=QString(dummy);
            for (int i=0;i<imp_set.channels;i++)
            {
                sprintf(dummy,"%g\t",imp_set.first_data[i][j]);
                strli=strli+QString(dummy);
            }
            strli=strli+QString("\n");
            result.append(strli);
        }
    }
    settingString=result;
}

void readBinaryFromFile(ifstream & ifi,importSettings & imp_set,double *** data)
{
    char buffer[64];
    (*data)=new double*[imp_set.channels];
    long position=ifi.tellg();//current position (assuming we already have read the header)
    long length;
    ifi.seekg(0,ios::end);
    length=ifi.tellg();//length complete
    if (position!=imp_set.headersize) position=imp_set.headersize;
//cout << "length=" << length << " position=" << position << endl;
    length-=position;//length without header
    ifi.seekg(position);//go to first byte after header
//cout << "resulting length=" << length << endl;
    long size_of_one_point=0;
    long * size_of_one_set=new long[imp_set.channels];
    long calc_samp_count;
    for (int i=0;i<imp_set.channels;i++)
        size_of_one_point+=(long)(imp_set.channel_size[i]);
    calc_samp_count=length/(size_of_one_point);
    if (imp_set.points>=0 && imp_set.points<calc_samp_count)
        imp_set.points_read=imp_set.points;
    else
        imp_set.points_read=calc_samp_count;
    if (imp_set.read_to_eof==true) imp_set.points_read=calc_samp_count;
#ifndef WINDOWS_SYSTEM
        try
        {
#endif
            for (int i=0;i<imp_set.channels;i++)
            (*data)[i]=new double[imp_set.points_read+1];//we need a bit more space because we need to store extra data into dummy location
#ifndef WINDOWS_SYSTEM
        }
        catch (bad_alloc)
        {
            errwin(QObject::tr("Unable to allocate enough memory to import binary data.").toLocal8Bit().constData());
            return;
        }
#endif
    for (int i=0;i<imp_set.channels;i++)
        size_of_one_set[i]=calc_samp_count*imp_set.channel_size[i];//the byte-size in the file
//cout << "size_of_one_point=" << size_of_one_point << " calc.samp.count=" << calc_samp_count << endl;
    imp_set.columns_read=imp_set.channels;
    int i=0;//channel_nr
    int read=0;//current number of read data
    int real_read=0;//counts on even, if the channel has more data than is to be read
    //start reading with channel=0 and read=0
    while (!ifi.eof())
    {
        ifi.read(buffer,imp_set.channel_size[i]);//read current input
        //and save it as double in the right position
        switch (imp_set.channel_format[i])
        {
        case COLUMN_OFFSET:
        case COLUMN_STRING:
            (*data)[i][read]=0.0;
            break;
        case COLUMN_SIG_CHAR:
            (*data)[i][read]=(double)(*((signed char*)((void*)(buffer))));
            break;
        case COLUMN_USIG_CHAR:
            (*data)[i][read]=(double)(*((unsigned char*)((void*)(buffer))));
            break;
        case COLUMN_SIG_SHORT:
            (*data)[i][read]=(double)(*((signed short*)((void*)(buffer))));
            break;
        case COLUMN_USIG_SHORT:
            (*data)[i][read]=(double)(*((unsigned short*)((void*)(buffer))));
            break;
        case COLUMN_SIG_INT:
            (*data)[i][read]=(double)(*((signed int*)((void*)(buffer))));
            break;
        case COLUMN_USIG_INT:
            (*data)[i][read]=(double)(*((unsigned int*)((void*)(buffer))));
            break;
        case COLUMN_SIG_LONG:
            (*data)[i][read]=(double)(*((signed long*)((void*)(buffer))));
            break;
        case COLUMN_USIG_LONG:
            (*data)[i][read]=(double)(*((unsigned long*)((void*)(buffer))));
            break;
        case COLUMN_FLOAT:
            (*data)[i][read]=(double)(*((float*)((void*)(buffer))));
            break;
        case COLUMN_DOUBLE:
            (*data)[i][read]=(double)(*((double*)((void*)(buffer))));
            break;
        case COLUMN_LONG_DOUBLE:
            (*data)[i][read]=(double)(*((long double*)((void*)(buffer))));
            break;
        }//end switch
        if (imp_set.setorder==1)//channel1|channel2|channel3| etc.
        {
            //next point in channel
            real_read++;//this counts the sample-points actually read
            if (real_read>=imp_set.points_read)//we have reached a point where there is no more data for this channel that is to be read
            {
                if (calc_samp_count>imp_set.points_read)//there is more data in the file than we actually need to read
                {
                    if (real_read>=calc_samp_count)//we have read enough
                    {
                        read=real_read=0;
                        i++;//next channel
                    }
                    else
                        read=imp_set.points_read;//we write all new data to the space just outside the read data we actually need
                }
                else//calc_samp_count==*points_read --> we are actually at the end of the data for one channel
                {
                    real_read=read=0;
                    i++;
                }

                if (i>=imp_set.channels)//no more channels available
                {
                    read=imp_set.points_read;
                    break;
                }
            }
            else
                read++;//no problems here --> read_count is identical to real_read_count
        }
        else //x1y1z1|x2y2z2|x3y3z3|x4y4z4| etc.
        {
            //read one point after the other
            //next channel
            i++;
            if (i>=imp_set.channels)//next point will start
            {
                i=0;//next point starts with ch0
                if (read<imp_set.points_read)//we have read less points than needed
                    read++;//read next point
                else
                    break;//we have read enough --> stop reading
            }
        }//ende channel_order
    }//end while(!eof)
    if (read!=imp_set.points_read)
    {
        cout << "error in reading: wrong count after eof: read=" << read << " points=" << imp_set.points_read << endl;
        imp_set.points_read=read;
    }
    delete[] size_of_one_set;
}

frmSetEditor::frmSetEditor(QWidget * parent):QDialog(parent)
{
    fname=new char[GR_MAXPATHLEN];
    fname[0]='\0';
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: SetEditor"));
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    layout1=new QHBoxLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    empty=new QWidget;
    empty->setLayout(layout1);
    lenFromGraph=new QLineEdit(QString("0"),empty);
    lenFromSet=new QLineEdit(QString("0"),empty);
    labDataFrom1=new QLabel(tr("Data in Set G"),empty);
    labDataFrom2=new QLabel(QString(".S"),empty);
    layout1->addWidget(labDataFrom1);
    layout1->addWidget(lenFromGraph);
    layout1->addWidget(labDataFrom2);
    layout1->addWidget(lenFromSet);
    text=new QTextEdit(this);
    aac=new stdButtonGroup(this,true,false,false);
    aac->cmdApply->setText(tr("Update"));
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doUpdate()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    gno=0;
    setno=0;
    layout->addWidget(empty);
    layout->addWidget(text);
    layout->addWidget(aac);
    setLayout(layout);
    resize(LastSize_FormSetEditor);
}

frmSetEditor::~frmSetEditor()
{
    delete[] fname;
    LastSize_FormSetEditor=this->size();
}

void frmSetEditor::init(int g_no,int set_no)
{
    //write set data to file and read file contents
    char dummy[512];
    gno=g_no;
    setno=set_no;
    if (fname[0]=='\0')
    {
        QTemporaryFile * temp_file=new QTemporaryFile;
        if (temp_file->open())
        {
            delete[] fname;
            fname=new char[temp_file->fileName().size()+8];
            strcpy(fname,temp_file->fileName().toLocal8Bit());
            temp_file->close();
            delete temp_file;
        }
    }
    QFile * fi=new QFile(QString(fname));
    fi->remove();
    delete fi;
    //fname = tmpnam(NULL);//get a temporary file name
    sprintf(dummy,"%d",g_no);
    lenFromGraph->setText(QString(dummy));
    sprintf(dummy,"%d",set_no);
    lenFromSet->setText(QString(dummy));
    FILE *cp;
    cp = grace_openw(fname);
    if (cp == NULL)
    {
        return;
    }
    write_set(gno, setno, cp, sformat, FALSE);
    grace_close(cp);
    QString str("");
    dummy[0]='\0';
    int counter=0;
    FILE * ifi;
    ifi=fopen(fname,"r");
    while (!feof(ifi))
    {
        if (fscanf(ifi,"%c",dummy+counter++)<=0) continue;
        dummy[511]='\0';
        if (counter==511)
        {
            str=str+QString(dummy);
            counter=0;
        }
    }
    dummy[counter-1]='\0';
    str=str+QString(dummy);
    fclose(ifi);
    text->setText(str);
    if (DecimalPointToUse==',')
        convertText('.',',');
}

void frmSetEditor::doUpdate(void)
{
    //write data from QTextEdit to file and read file into Grace
    if (DecimalPointToUse==',') convertText(',','.');
    QString content=text->toPlainText();
    if (DecimalPointToUse==',') convertText('.',',');
    xv_evalexpri(lenFromGraph,&gno);
    xv_evalexpri(lenFromSet,&setno);
    char * dummy;
    int target_index=content.indexOf(QString("@target"));
    bool target_defined=(target_index==-1)?false:true;
    dummy=new char[256];
    sprintf(dummy,"@target G%d.S%d",gno,setno);
    QStringList st1=content.split('\n');
    ofstream ofi;
    ofi.open(fname);
    if (target_defined==false)
    {
        ofi << dummy << endl << content.toLocal8Bit().constData() << endl << "&" << endl;
    }
    else//target defined --> replace it with the set-id
    {
        content.clear();
        for (int i=0;i<st1.length();i++)
        {
            if (st1.at(i).length()>0)
            {
                if (st1.at(i).indexOf(QString("@target"))>=0)
                {
                    content.append(QString(dummy)+QString('\n'));
                    ofi << dummy << endl;
                }
                else
                {
                    content.append(st1.at(i)+QString('\n'));
                    ofi << st1.at(i).toLocal8Bit().constData() << endl;
                }
            }
        }
        text->setText(content);
        if (DecimalPointToUse==',') convertText('.',',');
    }
    ofi.close();

    /* temporarily disable autoscale */
    int save_autos = autoscale_onread;
    autoscale_onread = AUTOSCALE_NONE;
    int gnos[2],snos[2],created;
    gnos[0]=gno;
    snos[0]=setno;
    //it has been here
    if ((bool)(created=is_set_active(gno, setno)))//if set already exists: delete data
    {
        SaveSetStatesPrevious(1,gnos,snos,UNDO_COMPLETE);
        curtype = dataset_type(gno, setno);
        killsetdata(gno, setno);
    }
    prepare_strings_for_saving();
    getdata(gno, fname, SOURCE_DISK, LOAD_SINGLE);
    resume_strings_after_load_or_save();
    setcomment(gno, setno, "Editor");
    autoscale_onread = save_autos;
    if (created==TRUE)//'created' is not the right word...
    {
        SetsModified(1,gnos,snos,UNDO_COMPLETE);
    }
    else
    {
        SetsCreated(1,gnos,snos,UNDO_COMPLETE);
    }
    sprintf(dummy," [G%d.S%d]",gno,setno);
    if (!created==false)
        addAditionalDescriptionToLastNode(-1,QObject::tr("Edit set in text editor")+QString(dummy),QString(),-1);
    else
        addAditionalDescriptionToLastNode(-1,QObject::tr("Create set in text editor")+QString(dummy),QString(),-1);
    delete[] dummy;
    mainWin->mainArea->completeRedraw();
}

void frmSetEditor::doClose(void)
{
    //delete files and all entries and hide this Window
    hide();
    text->clear();
    //fname=NULL;
}

void frmSetEditor::convertText(char oldDecSep,char newDecSep)
{
    if (oldDecSep==newDecSep) return;
    QString nl('\n');
    QString st=text->toPlainText(),st2;
    QStringList l1=st.split(QChar('\n'));
    st.clear();
    for (int i=0;i<l1.length();i++)
    {
        if (l1.at(i).length()>0)
        {
            if (l1.at(i).at(0)=='&' || l1.at(i).at(0)=='@')
            {
                st.append(l1.at(i)+nl);
            }
            else
            {
                st2=l1.at(i);
                if (oldDecSep=='.')//.-->,
                {
                st2.replace(QChar(','),QChar('|'));
                st2.replace(oldDecSep,newDecSep);
                }
                else
                {
                st2.replace(oldDecSep,newDecSep);
                st2.replace(QChar('|'),QChar(','));
                }
                st.append(st2+nl);
            }
        }
    }
    text->setText(st);
}

frmUndoList::frmUndoList(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: UndoList"));
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    list=new QListWidget(this);
    list->setSelectionMode(QAbstractItemView::ExtendedSelection);

    aac=new stdButtonGroup(this,true,true,false);
    aac->cmdApply->setText(tr("Undo"));
    aac->cmdAccept->setText(tr("Redo"));

    cmdCommands=new QPushButton(tr("Translate selection to commands"),this);
    connect(cmdCommands,SIGNAL(clicked()),SLOT(doCommands()));

    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doUndo()));
    connect(aac->cmdAccept,SIGNAL(clicked()),SLOT(doRedo()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    chkActive=new QCheckBox(tr("Undo active"),this);
    connect(chkActive,SIGNAL(stateChanged(int)),SLOT(doToggleActive(int)));
    layout->addWidget(chkActive);
    layout->addWidget(list);
    layout->addWidget(cmdCommands);
    layout->addWidget(aac);
    setLayout(layout);
    resize(LastSize_FormUndoList);
}

frmUndoList::~frmUndoList()
{
    LastSize_FormUndoList=this->size();
}

void frmUndoList::init(void)
{
    int nr_of_Nodes=getNrOfNodes();
    list->clear();
//cout << "nr_of_Nodes=" << nr_of_Nodes << " Count=" << list->count() << endl;
    chkActive->blockSignals(true);
    chkActive->setChecked(undo_active);
    chkActive->blockSignals(false);
//cout << "nr_of_Nodes=" << nr_of_Nodes << " Count=" << list->count() << endl;
    QStringList StrList;
    char dummy[256];
    sprintf(dummy," (%d / %d)",nr_of_Nodes,max_node_nr);
    setWindowTitle(tr("QtGrace: UndoList")+QString(dummy));
    for (int i=0;i<nr_of_Nodes;i++)
    {
        StrList << getNodeDescription(i);
    }
    list->addItems(StrList);
    list->update(list->model()->index(0,0));
    list->repaint();
//cout << "count=" << list->count() << endl;
}

void frmUndoList::doUndo(void)
{
    if (undo_active==FALSE)
    {
    errmsg(tr("Undo not activated.").toLocal8Bit().constData());
    return;
    }
    int nr=list->count();
    int * selection=new int[nr>0?nr:2];
    int index=0;
    int sav_und_act=undo_active;
    bool old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    undo_active=FALSE;
    for (int i=0;i<nr;i++)
    {
        if (list->item(i)->isSelected()==true)
        {
            selection[index++]=i;
        }
    }
    wait_till_update=true;
    for (int i=index-1;i>=0;i--)
    {
        RestoreNode(selection[i]);
    }
    init();
    for (int i=0;i<index;i++)
    {
        list->item(selection[i])->setSelected(true);
    }
    delete[] selection;
    undo_active=sav_und_act;
    wait_till_update=false;
    chkActive->setChecked(undo_active);
    immediateUpdate=old_upd;
    updateRunning=false;
    mainWin->mainArea->completeRedraw();
}

void frmUndoList::doRedo(void)
{
    if (undo_active==FALSE)
    {
    errmsg(tr("Undo not activated.").toLocal8Bit().constData());
    return;
    }
    int nr=list->count();
    int * selection=new int[nr>0?nr:2];
    int index=0;
    int sav_und_act=undo_active;
    bool old_upd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    undo_active=FALSE;
    for (int i=0;i<nr;i++)
    {
        if (list->item(i)->isSelected()==true)
        {
            selection[index++]=i;
        }
    }
    wait_till_update=true;
    for (int i=0;i<index;i++)
    {
        RestoreNode(selection[i]);
    }
    init();
    for (int i=0;i<index;i++)
    {
        list->item(selection[i])->setSelected(true);
    }
    delete[] selection;
    mainWin->mainArea->completeRedraw();
    undo_active=sav_und_act;
    wait_till_update=false;
    chkActive->setChecked(undo_active);
    immediateUpdate=old_upd;
    updateRunning=false;
}

void frmUndoList::doCommands(void)
{
    undo_node * Node;
    int nr=list->count(),read_count;
    int * selection=new int[nr>0?nr:2];
    int index=0,gr_n,new_n;
    for (int i=0;i<nr;i++)
    {
        if (list->item(i)->isSelected()==true)
        {
            selection[index++]=i;
        }
    }
    //index = number of selected entries, selection = indices of selection
    if (FormCommands==NULL)
    {
        FormCommands=new frmCommands(mainWin);
        update_all();
    }
    new_n=gr_n=-1;//current graph number is invalid; in this way the first 'with'-command is included!
    for (int i=0;i<index;i++)
    {
        Node=getNodeByNr(selection[i]);
        nr=nr_of_true_changes(Node->Changes);
        if (nr>0)
        {
            for (int j=0;j<Node->Changes.length();j++)
            {
                if (Node->Changes.at(j).indexOf("with")==0)//commands begins with 'with' --> new graph-nr?
                {
                    strcpy(dummy,Node->Changes.at(j).toLocal8Bit());
                    read_count=sscanf(dummy,"with G%d",&new_n);
                    if (new_n!=gr_n || read_count<=0)//include 'with'-commands only if there is really a new graph-nr
                    {
                        FormCommands->list->addItem(Node->Changes.at(j));
                        gr_n=new_n;
                    }
                }
                else//command does not begin with 'with'
                {
                    FormCommands->list->addItem(Node->Changes.at(j));
                }
            }
        }
    }
    FormCommands->show();
    FormCommands->raise();
    FormCommands->activateWindow();
}

void frmUndoList::doClose(void)
{
    hide();
}

void frmUndoList::doToggleActive(int state)
{
    (void)state;
//cout << "Start Toggled" << endl;
    undo_active=chkActive->isChecked();
    if (Form_Preferences!=NULL)
    {
    Form_Preferences->chkUndoActive->blockSignals(true);
    Form_Preferences->chkUndoActive->setChecked(undo_active);
    Form_Preferences->chkUndoActive->blockSignals(false);
    }
    if (undo_active==FALSE)
    {
    mainWin->cmdUndo->setEnabled(false);
    mainWin->cmdRedo->setEnabled(false);
    mainWin->actUndo->setEnabled(false);
    mainWin->actRedo->setEnabled(false);
    }
    else
    {
    CheckActive();
    }
//cout << "End Toggled" << endl;
}

frmExplorer::frmExplorer(QWidget * parent):QDialog(parent)
{
    GlobalInhibitor=true;
    oldSetting='0';
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Explorer"));
    setWindowIcon(QIcon(*GraceIcon));
    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    tree=new treeView(this);
    tree->popup->par2=this;
    connect(tree,SIGNAL(newItemClicked(char,int,int)),this,SLOT(itemClickedInTree(char,int,int)));
    lblTest=new QLabel("Nothing selected!",this);

    LineProperties=new frmLine_Props(this,true);
    LineProperties->buttonGroup->hide();
    LineProperties->hide();
    TextProperties=new frmText_Props(this,true);
    TextProperties->buttonGroup->hide();
    TextProperties->hide();
    EllipseProperties=new frmEllipse_Props(this,true,true);
    EllipseProperties->buttonGroup->hide();
    EllipseProperties->hide();
    BoxProperties=new frmEllipse_Props(this,true,false);
    BoxProperties->buttonGroup->hide();
    BoxProperties->hide();

    AxisProperties=new frmAxis_Prop(this);
    AxisProperties->buttonGroup->hide();
    AxisProperties->hide();
    AxisProperties->chkActive->hide();
    AxisProperties->selEdit->hide();

    SetProperties=new frmSet_Appearance(this);
    SetProperties->menuBar->hide();
    SetProperties->buttonGroup->hide();
    SetProperties->hide();
    SetProperties->listSet->hide();
    SetProperties->lblSelSet->hide();
    SetProperties->listSet->prevent_from_autoupdate=true;

    GraphProperties=new frmGraph_App(this);
    GraphProperties->menuBar->hide();
    GraphProperties->buttonGroup->hide();
    GraphProperties->hide();
    GraphProperties->listGraph->hide();
    GraphProperties->lblTitle->hide();
    GraphProperties->listGraph->prevent_from_autoupdate=true;
    GraphProperties->tabMain->grpDispOpt->hide();
    //GraphProp TabMain Title und Subtitle
    GraphProperties->tabTitles->grpTitle->setTitle(tr("Settings"));
    GraphProperties->tabTitles->grpSubTitle->setTitle(tr("Settings"));
    GraphProperties->tabMain->grpTitles->setTitle(tr("String"));
    GraphProperties->tabMain->layout->addWidget(GraphProperties->tabTitles->grpTitle);
    GraphProperties->tabMain->layout->addWidget(GraphProperties->tabTitles->grpSubTitle);
    empty=new QWidget(GraphProperties);
    empty->setMinimumHeight(100);
    GraphProperties->tabMain->layout->addWidget(empty);

    PlotAppearance=new frmPlot_Appearance(this);
    PlotAppearance->buttonGroup->hide();
    PlotAppearance->hide();

    aac=new stdButtonGroup(this);
    connect(aac->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    layout->addWidget(tree,0,0,1,1);

    connect(AxisProperties,SIGNAL(closeWish()),SLOT(doClose()));
    connect(SetProperties,SIGNAL(closeWish()),SLOT(doClose()));
    connect(GraphProperties,SIGNAL(closeWish()),SLOT(doClose()));

    layout->addWidget(lblTest,0,1,1,1);
    layout->addWidget(LineProperties,0,1,1,1);
    layout->addWidget(TextProperties,0,1,1,1);
    layout->addWidget(EllipseProperties,0,1,1,1);
    layout->addWidget(BoxProperties,0,1,1,1);
    layout->addWidget(AxisProperties,0,1,1,1);
    layout->addWidget(SetProperties,0,1,1,1);
    layout->addWidget(GraphProperties,0,1,1,1);
    layout->addWidget(PlotAppearance,0,1,1,1);

    layout->addWidget(aac,1,0,1,2);
    setLayout(layout);
    aac->cmdApply->setDefault(true);
    GlobalInhibitor=false;
    resize(LastSize_FormExplorer);
}

frmExplorer::~frmExplorer()
{
    LastSize_FormExplorer=this->size();
}

void frmExplorer::init(void)
{
    tree->RecreateCompleteTree();
    QTreeWidgetItem * item=tree->findItem('R',-1,-1);
    if (item!=NULL)
    {
        tree->clearSelection();
        tree->itemClickedAt(item,0);
        item->setSelected(true);
    }
}

void frmExplorer::doApply(void)
{
    ApplyError=false;

    switch (oldSetting)
    {
    default:
    case (int)'0'://nothing
        ;
        break;
    case (int)'N'://String-Object
        TextProperties->doAccept();
        break;
    case (int)'I'://Line-Object
        LineProperties->doAccept();
        break;
    case (int)'B'://Box-Object
        BoxProperties->doAccept();
        break;
    case (int)'P'://Ellipse-Object
        EllipseProperties->doAccept();
        break;
    case (int)'E'://Legend
        GraphProperties->doApply();
        break;
    case (int)'S'://Set
        SetProperties->doApply();
        break;
    case (int)'A'://Axis
        AxisProperties->doApply();
        break;
    case (int)'R'://General Settings
        PlotAppearance->doApply();
        break;
    case (int)'G'://Graph
        GraphProperties->doApply();
        break;
    case (int)'L'://Label/Title
        GraphProperties->doApply();
        break;
    }

}

void frmExplorer::doAccept(void)
{
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmExplorer::doClose(void)
{
    hide();
}

void frmExplorer::setItemVisible(char type, bool vis,int gno,int sno)
{
    int ty=(int)type;
    (void)gno;
    switch (ty)
    {
    default:
    case (int)'0'://nothing
        lblTest->setVisible(vis);
        break;
    case (int)'N'://String-Object
        TextProperties->setVisible(vis);
        break;
    case (int)'I'://Line-Object
        LineProperties->setVisible(vis);
        break;
    case (int)'B'://Box-Object
        BoxProperties->setVisible(vis);
        break;
    case (int)'P'://Ellipse-Object
        EllipseProperties->setVisible(vis);
        break;
    case (int)'E'://Legend
        GraphProperties->tabs->clear();
        if (vis==true)
        {
            //GraphProperties->tabFrame->setVisible(false);
            GraphProperties->tabs->addTab(GraphProperties->tabLegBox, tr("Leg. box"));
            GraphProperties->tabs->addTab(GraphProperties->tabLegends, tr("Legends"));
            //GraphProperties->tabMain->setVisible(false);
            //GraphProperties->tabSpec->setVisible(false);
            //GraphProperties->tabTitles->setVisible(false);
        }
        GraphProperties->tabMain->grpDispOpt->hide();
        GraphProperties->setVisible(vis);
        break;
    case (int)'S'://Set
        SetProperties->setVisible(vis);
        break;
    case (int)'A'://Axis
        AxisProperties->setVisible(vis);
        break;
    case (int)'R'://General Settings
        PlotAppearance->setVisible(vis);
        break;
    case (int)'G'://Graph
        GraphProperties->tabs->clear();
        if (vis==true)
        {
            GraphProperties->tabMain->grpViewport->show();
            GraphProperties->tabMain->grpDispOpt->show();
            GraphProperties->tabMain->grpPres->show();
            GraphProperties->tabMain->grpTitles->hide();
            GraphProperties->tabs->addTab(GraphProperties->tabMain, tr("Main"));
            GraphProperties->tabs->addTab(GraphProperties->tabFrame, tr("Frame"));
            //GraphProperties->tabLegBox->setVisible(false);
            //GraphProperties->tabLegends->setVisible(false);
            GraphProperties->tabs->addTab(GraphProperties->tabSpec, tr("Special"));
            //GraphProperties->tabTitles->setVisible(false);
        }
        GraphProperties->tabMain->grpDispOpt->hide();
        GraphProperties->setVisible(vis);
        break;
    case (int)'L'://Label/Title
        GraphProperties->tabs->clear();
        if (vis==true)
        {
            //GraphProperties->tabFrame->setVisible(false);
            //GraphProperties->tabLegBox->setVisible(false);
            //GraphProperties->tabLegends->setVisible(false);
            GraphProperties->tabMain->grpViewport->hide();
            GraphProperties->tabMain->grpDispOpt->hide();
            GraphProperties->tabMain->grpPres->hide();
            GraphProperties->tabMain->grpTitles->show();
            if (sno==0)
            {
                GraphProperties->tabMain->ledTitle->show();
                GraphProperties->tabMain->ledSubtitle->hide();
                GraphProperties->tabTitles->grpTitle->show();
                GraphProperties->tabTitles->grpSubTitle->hide();
                GraphProperties->tabs->addTab(GraphProperties->tabMain, tr("Title-Properties"));
            }
            else
            {
                GraphProperties->tabMain->ledTitle->hide();
                GraphProperties->tabMain->ledSubtitle->show();
                GraphProperties->tabTitles->grpTitle->hide();
                GraphProperties->tabTitles->grpSubTitle->show();
                GraphProperties->tabs->addTab(GraphProperties->tabMain, tr("SubTitle-Properties"));
            }

            //GraphProperties->tabSpec->setVisible(false);
            //GraphProperties->tabs->addTab(GraphProperties->tabTitles, tr("Titles"));
        }
        GraphProperties->tabMain->grpDispOpt->hide();
        GraphProperties->setVisible(vis);
        break;
    }
}

void frmExplorer::initItem(char type,int gno,int sno)
{
    bool imUpd=immediateUpdate;
    immediateUpdate=false;
    updateRunning=true;
    int ty=(int)type;
    switch (ty)
    {
    default:
    case (int)'0'://nothing
        ;
        break;
    case (int)'N'://String-Object
        TextProperties->init(gno);
        break;
    case (int)'I'://Line-Object
        LineProperties->init(gno);
        break;
    case (int)'B'://Box-Object
        BoxProperties->init(gno);
        break;
    case (int)'P'://Ellipse-Object
        EllipseProperties->init(gno);
        break;
    case (int)'E'://Legend
        GraphProperties->show_graph_data_external(gno);
        break;
    case (int)'S'://Set
        SetProperties->ShowSetData_external(gno,sno);
        break;
    case (int)'A'://Axis
        AxisProperties->curaxis = sno;
        AxisProperties->update_ticks(gno);
        break;
    case (int)'R'://General Settings
        PlotAppearance->init();
        break;
    case (int)'G'://Graph
        GraphProperties->show_graph_data_external(gno);
        break;
    case (int)'L'://Label/Title
        GraphProperties->show_graph_data_external(gno);
        break;
    }
    immediateUpdate=imUpd;
    updateRunning=false;
}

void frmExplorer::itemClickedInTree(char type,int gno,int sno)
{

    switch_current_graph(gno);

    setItemVisible(oldSetting,false,gno,sno);
    initItem(type,gno,sno);
    setItemVisible(type,true,gno,sno);

    oldSetting=type;
}

static CMap_entry base_colors[8] = {
    /*0 black  */
    {{0, 0, 0}, NULL, COLOR_MAIN, 0},
    /*1 red    */
    {{255, 0, 0}, NULL, COLOR_MAIN, 0},
    /*2 green  */
    {{0, 255, 0}, NULL, COLOR_MAIN, 0},
    /*3 yellow */
    {{255, 255, 0}, NULL, COLOR_MAIN, 0},
    /*4 blue   */
    {{0, 0, 255}, NULL, COLOR_MAIN, 0},
    /*5 magenta*/
    {{255, 0, 255}, NULL, COLOR_MAIN, 0},
    /*6 white  */
    {{255, 255, 255}, NULL, COLOR_MAIN, 0},
    /*7 cyan   */
    {{0, 255, 255}, NULL, COLOR_MAIN, 0}
};

char base_color_names[8][16];

frmColorManagement::frmColorManagement(QWidget * parent):QWidget(parent)
{
    int number,row;
    QString * entr;

strcpy(base_color_names[0],QString("black").toLatin1().constData());
strcpy(base_color_names[1],QString("red").toLatin1().constData());
strcpy(base_color_names[2],QString("green").toLatin1().constData());
strcpy(base_color_names[3],QString("yellow").toLatin1().constData());
strcpy(base_color_names[4],QString("blue").toLatin1().constData());
strcpy(base_color_names[5],QString("magenta").toLatin1().constData());
strcpy(base_color_names[6],QString("white").toLatin1().constData());
strcpy(base_color_names[7],QString("cyan").toLatin1().constData());
for (int i=0;i<8;i++) base_colors[i].cname=copy_string(base_colors[i].cname,base_color_names[i]);

    local_cmap_table=NULL;
    allocated_loc_colors=temp_spec_lenght=spectrum_path_length=0;
    temp_spec=NULL;
    path_positions=NULL;
    locColorIcons=NULL;
    locColorPixmaps=NULL;
    locColorNames=NULL;
    tmp_path_length=2;
    tmp_path_pos=new int[2];
    tmp_path_pos[0]=0;
    tmp_path_pos[1]=6;
    tmp_path_point_shown=0;

//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Color Management"));
    setWindowIcon(QIcon(*GraceIcon));
    colorsel=new ColorSelector(this);//shows current palette
    colorsel->setAlpha(255);
    colorsel->alphaSelector->hide();
    colorsel->lblText->setText(tr("Current color palette:"));
    colorsel->prevent_from_update=true;
    connect(colorsel,SIGNAL(currentIndexChanged(int)),SLOT(curColorChanged(int)));
    colDial=new QColorDialog(this);
    colDial->hide();

    row=0;
    grpCurCol=new QGroupBox(tr("Single Color"),this);
    lblInstructions=new QLabel(tr("Edit single color in color palette."),this);
    lblIllustration=new QLabel("",this);
    ledRed=new stdIntSelector(this,tr("Red:"),0,255);
    ledGreen=new stdIntSelector(this,tr("Green:"),0,255);
    ledBlue=new stdIntSelector(this,tr("Blue:"),0,255);
    connect(ledRed,SIGNAL(currentValueChanged(int)),SLOT(colorCompositionChanged(int)));
    connect(ledGreen,SIGNAL(currentValueChanged(int)),SLOT(colorCompositionChanged(int)));
    connect(ledBlue,SIGNAL(currentValueChanged(int)),SLOT(colorCompositionChanged(int)));
    ledColName=new stdLineEdit(this,tr("Name:"));
    connect(ledColName,SIGNAL(changed()),SLOT(colorNameChanged()));
    cmdDelColor=new QPushButton(tr("Delete color"),this);
    connect(cmdDelColor,SIGNAL(clicked()),SLOT(doDelColor()));
    cmdAddColor=new QPushButton(tr("Add color"),this);
    connect(cmdAddColor,SIGNAL(clicked()),SLOT(doAddColor()));
    cmdEditColor=new QPushButton(tr("Edit color"),this);
    connect(cmdEditColor,SIGNAL(clicked()),SLOT(doEditColor()));
    cmdSelNewColor=new QPushButton(tr("Define a color"),this);
    connect(cmdSelNewColor,SIGNAL(clicked()),SLOT(doSelColor()));
    lblColNumber=new QLabel(tr("Number = -1"),this);
    layout0=new QGridLayout;
    layout0->setMargin(STD_MARGIN);
    layout0->setSpacing(STD_SPACING);
    layout0->addWidget(lblInstructions,row,0,1,1);
    layout0->addWidget(lblColNumber,row++,1,1,1);

    layout0->addWidget(ledRed,row,0,1,1);
    layout0->addWidget(ledGreen,row++,1,1,1);
    layout0->addWidget(ledBlue,row,0,1,1);
    layout0->addWidget(ledColName,row++,1,1,1);

    layout0->addWidget(lblIllustration,row++,0,1,2,Qt::AlignHCenter);

    layout0->addWidget(cmdAddColor,row,0,1,1);
    layout0->addWidget(cmdDelColor,row++,1,1,1);
    layout0->addWidget(cmdEditColor,row,0,1,1);
    layout0->addWidget(cmdSelNewColor,row++,1,1,1);

    grpCurCol->setLayout(layout0);

    row=0;
    grpColSpectra=new QGroupBox(tr("Color Spectrum"),this);
    lblInstructions2=new QLabel(tr("Replace whole color palette with specified spectrum."),this);
    lblIllustration2=new QLabel("",this);
    cmdStdCols=new QPushButton(tr("Set standard Grace colors"),this);
    connect(cmdStdCols,SIGNAL(clicked()),SLOT(doSetStdColors()));
    cmdSetSpectrum=new QPushButton(tr("Set Spectrum"),this);
    connect(cmdSetSpectrum,SIGNAL(clicked()),SLOT(doSetSpectrum()));
    number=4;
    entr=new QString[number];
    entr[0]=QString("Color-spectrum");
    entr[1]=QString("Black-White-spectrum");
    entr[2]=QString("Cold-Hot-spectrum");
    entr[3]=QString("Custom...");
    selStdSpectra=new StdSelector(this,tr("Define spectrum:"),number,entr);
    connect(selStdSpectra,SIGNAL(currentIndexChanged(int)),SLOT(curSpectrumChanged(int)));
    chkInvert=new QCheckBox(tr("Invert spectrum"),this);
    connect(chkInvert,SIGNAL(toggled(bool)),SLOT(changedInvert(bool)));
    selNumberOfColors=new stdIntSelector(this,tr("Number of colors in spectrum:"),10,256);
    selNumberOfColors->setValue(256);
    connect(selNumberOfColors,SIGNAL(currentValueChanged(int)),SLOT(curNumberOfColorsChanged(int)));

    selNumberOfPathPoints=new stdIntSelector(this,tr("Path points:"),2,32);
    connect(selNumberOfPathPoints,SIGNAL(currentValueChanged(int)),SLOT(NrOfPathPointsChanged(int)));
    selNumberOfCurPathPoint=new stdIntSelector(this,tr("Current path point:"),0,1);
    connect(selNumberOfCurPathPoint,SIGNAL(currentValueChanged(int)),SLOT(CurrentPathPointChanged(int)));
    selPathCol=new ColorSelector(this);
    selPathCol->setAlpha(255);
    selPathCol->alphaSelector->hide();
    init_color_icons(8,base_colors,allocated_loc_colors,&locColorIcons,&locColorPixmaps,&locColorNames);
    selPathCol->updateColorIcons(8,locColorPixmaps,locColorNames);
    connect(selPathCol,SIGNAL(currentIndexChanged(int)),SLOT(CurrentPathColorChanged(int)));

    locColorIcons=NULL;
    locColorPixmaps=NULL;
    locColorNames=NULL;

    layout1=new QGridLayout;
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
    layout1->addWidget(lblInstructions2,row++,0,1,2);
    layout1->addWidget(selStdSpectra,row++,0,1,2);

    layout1->addWidget(selNumberOfColors,row,0,1,1);
    layout1->addWidget(chkInvert,row++,1,1,1);

    layout1->addWidget(selNumberOfPathPoints,row,0,1,1);
    layout1->addWidget(selNumberOfCurPathPoint,row++,1,1,1);
    layout1->addWidget(selPathCol,row++,0,1,2);

    layout1->addWidget(lblIllustration2,row++,0,1,2,Qt::AlignHCenter);
    layout1->addWidget(cmdSetSpectrum,row,0,1,1);
    layout1->addWidget(cmdStdCols,row++,1,1,1);
    grpColSpectra->setLayout(layout1);

    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);

    cmdInverseColor=new QPushButton(tr("Invert color palette"),this);
    cmdInverseColor->setToolTip(tr("Invert all colors (has immediate effect)"));
    connect(cmdInverseColor,SIGNAL(clicked()),SLOT(doInvertColors()));

    aac=new stdButtonGroup(this,true,true,false);
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
    connect(aac->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    layout->addWidget(colorsel);
    layout->addWidget(grpCurCol);
    layout->addWidget(grpColSpectra);
    layout->addWidget(cmdInverseColor);
    layout->addStretch(2);
    layout->addWidget(aac);
    setLayout(layout);

colorsel->setToolTip(tr("The currently active color palette"));
grpCurCol->setToolTip(tr("The settings in this group are used to define or edit single colors"));
//lblInstructions->setToolTip(tr(""));
lblIllustration->setToolTip(tr("How the current color looks like"));
ledRed->setToolTip(tr("Red component of the current color"));
ledGreen->setToolTip(tr("Green component of the current color"));
ledBlue->setToolTip(tr("Blue component of the current color"));
ledColName->setToolTip(tr("Define name of color"));
cmdSelNewColor->setToolTip(tr("Select a new color from the color-selector of the operating system"));
cmdDelColor->setToolTip(tr("Delete the color at the current postion from the list"));
cmdAddColor->setToolTip(tr("Append the displayed color at the end of the list"));
cmdEditColor->setToolTip(tr("Set the color in the list at the current position to the color displayed here"));
lblColNumber->setToolTip(tr("Number of the color currently displayed / current position"));
grpColSpectra->setToolTip(tr("The settings in this dialog alter the whole list of colors at once"));
//lblInstructions2->setToolTip(tr(""));
lblIllustration2->setToolTip(tr("Displays the new colors as a spectrum"));
cmdStdCols->setToolTip(tr("Resets the colors to the default list used in Grace"));
cmdSetSpectrum->setToolTip(tr("Sets the currently displayed spectrum as the new list of colors for this project"));
selStdSpectra->setToolTip(tr("Select the type of spectrum to be used (predefined or Custom)"));
chkInvert->setToolTip(tr("Reverses the order the colors are put into the list"));
selNumberOfColors->setToolTip(tr("Number of colors to be put into the new list of colors"));
selNumberOfPathPoints->setToolTip(tr("Number of points to use as a direction for generating the spectrum\nOnly used if Custom-spectrum is to be defined"));
selNumberOfCurPathPoint->setToolTip(tr("Color point in the path that is to be eddited\nOnly used if Custom-spectrum is to be defined"));
selPathCol->setToolTip(tr("Select color for current path-point\nOnly used if Custom-spectrum is to be defined"));

    init();
    colorsel->setCurrentIndex(0);

    QPushButton * emptyButton=new QPushButton("",this);
    emptyButton->setDefault(true);
    emptyButton->hide();
    curColorChanged(0);
    curSpectrumChanged(0);
}

void frmColorManagement::doInvertColors(void)
{
reverse_video();
ReqUpdateColorSel=TRUE;
mainWin->mainArea->completeRedraw();
init();
set_dirtystate();
}

void frmColorManagement::generateSpectrum(int nr)
{
    if (path_positions!=NULL) delete[] path_positions;
    switch (nr)
    {
    case STD_COL_SPECTRUM:
        spectrum_path_length=5;
        path_positions=new int[spectrum_path_length];
        path_positions[0]=4;
        path_positions[1]=7;
        path_positions[2]=2;
        path_positions[3]=3;
        path_positions[4]=1;
        break;
    case BW_SPECTRUM:
        spectrum_path_length=2;
        path_positions=new int[spectrum_path_length];
        path_positions[0]=0;
        path_positions[1]=6;
        break;
    case COLD_HOT_SPECTRUM:
        spectrum_path_length=2;
        path_positions=new int[spectrum_path_length];
        path_positions[0]=4;
        path_positions[1]=1;
        break;
    default:
    case CUSTOM_SPECTRUM:
        spectrum_path_length=tmp_path_length;
        path_positions=new int[tmp_path_length];
        memcpy(path_positions,tmp_path_pos,sizeof(int)*tmp_path_length);
        break;
    }
    temp_spec_lenght=selNumberOfColors->value();
    int segments=spectrum_path_length-1;
    int points_per_segment=(temp_spec_lenght-2)/segments;
    int points_last_segment=temp_spec_lenght-2-(segments-1)*points_per_segment;
    if (temp_spec!=NULL) delete[] temp_spec;
    temp_spec=new CMap_entry[temp_spec_lenght];
    memcpy(temp_spec+0,base_colors+6,sizeof(CMap_entry));//white
    memcpy(temp_spec+1,base_colors+0,sizeof(CMap_entry));//black
    CMap_entry entry;
    memcpy(&entry,base_colors+6,sizeof(CMap_entry));//copy white as default
    int counter=2;
    char col_dummy[64];
    double z=0.0;
    int r0,r1,g0,g1,b0,b1;
    /*
cout << "temp_spec_lenght=" << temp_spec_lenght << endl;
cout << "segments=" << segments << endl;
cout << "points_per_segment=" << points_per_segment << endl;
cout << "points_last_segment=" << points_last_segment << endl;
cout << "count_ziel=" << (segments-1)*points_per_segment+points_last_segment+2 << endl;
*/
    double z0=0.0,z1=1.0,dz=1.0/(points_per_segment);
    for (int s=0;s<segments-1;s++)//go through all segments except the last one
    {
        r0=base_colors[path_positions[s]].rgb.red;
        g0=base_colors[path_positions[s]].rgb.green;
        b0=base_colors[path_positions[s]].rgb.blue;
        r1=base_colors[path_positions[s+1]].rgb.red;
        g1=base_colors[path_positions[s+1]].rgb.green;
        b1=base_colors[path_positions[s+1]].rgb.blue;
        //cout << "{" << r0 << "|" << g0 << "|" << b0 << "}-->{" << r1 << "|" << g1 << "|" << b1 << "}" << endl;
        for (z=z0;z<z1;z+=dz)
        {
            entry.rgb.red=int(r0*(1.0-z)+r1*z);
            entry.rgb.green=int(g0*(1.0-z)+g1*z);
            entry.rgb.blue=int(b0*(1.0-z)+b1*z);
            /*entry.cname=new char[16];
            sprintf(entry.cname,"Color %d",counter);*/
            entry.cname=NULL;
            sprintf(col_dummy,"Color %d",counter);
            entry.cname = copy_string(entry.cname,col_dummy);
            memcpy(temp_spec+counter,&entry,sizeof(CMap_entry));
            counter++;
        }
    }
    //last segment
    r0=base_colors[path_positions[segments-1]].rgb.red;
    g0=base_colors[path_positions[segments-1]].rgb.green;
    b0=base_colors[path_positions[segments-1]].rgb.blue;
    r1=base_colors[path_positions[segments]].rgb.red;
    g1=base_colors[path_positions[segments]].rgb.green;
    b1=base_colors[path_positions[segments]].rgb.blue;
    points_last_segment=(segments-1)*points_per_segment+points_last_segment+2-counter;
    dz=1.0/(points_last_segment-1.0);
    for (z=0.0;z<=1.0;z+=1.0/(points_last_segment-1.0))
    {
        entry.rgb.red=int(r0*(1.0-z)+r1*z);
        entry.rgb.green=int(g0*(1.0-z)+g1*z);
        entry.rgb.blue=int(b0*(1.0-z)+b1*z);
        /*entry.cname=new char[16];
        sprintf(entry.cname,"Color %d",counter);*/
        entry.cname=NULL;
        sprintf(col_dummy,"Color %d",counter);
        entry.cname = copy_string(entry.cname,col_dummy);
        memcpy(temp_spec+counter,&entry,sizeof(CMap_entry));
        counter++;
        if (counter==temp_spec_lenght) break;
    }
    //cout << "counter0=" << counter << endl;
    while (counter<temp_spec_lenght)
    {
        entry.rgb.red=int(r1);
        entry.rgb.green=int(g1);
        entry.rgb.blue=int(b1);
        /*entry.cname=new char[16];
        sprintf(entry.cname,"Color %d",counter);*/
        entry.cname=NULL;
        sprintf(col_dummy,"Color %d",counter);
        entry.cname = copy_string(entry.cname,col_dummy);
        memcpy(temp_spec+counter,&entry,sizeof(CMap_entry));
        counter++;
    }
    //cout << "counter1=" << counter << endl;
    if (chkInvert->isChecked()==true)
    {
        //cout << "spektrum invers" << endl;
        for (int i=2;i<(temp_spec_lenght-2)/2;i++)
        {
            memcpy(&entry,temp_spec+i,sizeof(CMap_entry));
            memcpy(temp_spec+i,temp_spec+(temp_spec_lenght-i+1),sizeof(CMap_entry));
            memcpy(temp_spec+(temp_spec_lenght-i+1),&entry,sizeof(CMap_entry));
        }
    }
}

void frmColorManagement::showTempSpectrum(void)
{
    int target_length=2*256;
    int col_length=int(target_length*1.0/temp_spec_lenght);
    target_length=col_length*temp_spec_lenght;
    QColor colo;
    QPixmap pix(target_length,20);
    QPainter paint(&pix);
    for (int i=0;i<temp_spec_lenght;i++)
    {
        colo=QColor(temp_spec[i].rgb.red,temp_spec[i].rgb.green,temp_spec[i].rgb.blue);
        paint.setPen(colo);
        paint.setBrush(colo);
        paint.fillRect(i*col_length,0,col_length,20,colo);
    }
    paint.end();
    lblIllustration2->setPixmap(pix);
}

void frmColorManagement::doAddColor(void)
{
    CMap_entry cmap=constructColor();
    addColorToLocal(&cmap);
    //cout << "add new color: " << map_entries-1 << endl;
    cur_col_num=map_entries-1;
    colorsel->updateColorIcons(allocated_loc_colors,locColorPixmaps,locColorNames);
    char dummy[8];
    sprintf(dummy,"%d",cur_col_num);
    lblColNumber->setText(tr("Number = ")+QString(dummy));
    //colorsel->update_color_panels();//wrong--> this would update the selector with the current palette not the new one!
}

void frmColorManagement::doDelColor(void)
{
    //cout << "delete current color: " << cur_col_num << endl;
    //delete_color(cur_col_num);
    delColorToLocal(cur_col_num);
    //init_color_icons();
    colorsel->updateColorIcons(allocated_loc_colors,locColorPixmaps,locColorNames);
    colorsel->setCurrentIndex(0);
    init_with_color(0);
}

void frmColorManagement::doEditColor(void)
{
    CMap_entry cmap=constructColor();
    editColorToLocal(&cmap,cur_col_num);
    //cout << "edit current color" << endl;
    //memcpy(&(cmap_table[cur_col_num].rgb),&(cmap.rgb),sizeof(RGB));
    //copy_string(cmap_table[cur_col_num].cname,cmap.cname);
    colorsel->updateColorIcons(allocated_loc_colors,locColorPixmaps,locColorNames);
    colorsel->setCurrentIndex(cur_col_num);
}

void frmColorManagement::doSelColor(void)
{
    //cout << "select a new color" << endl;
    CMap_entry entry=constructColor();
    QColor col(entry.rgb.red,entry.rgb.green,entry.rgb.blue);
    QColor newCol=colDial->getColor(col,this);
    //cout << newCol.red() << " " << newCol.green() << " " << newCol.blue() << endl;
    GlobalInhibitor=true;
    ledRed->setValue(newCol.red());
    ledGreen->setValue(newCol.green());
    ledBlue->setValue(newCol.blue());
    GlobalInhibitor=false;
    showSingleColor();
}

void frmColorManagement::doSetStdColors(void)
{
    for (int i=0;i<map_entries;i++)
    {
        local_cmap_table[i].cname = copy_string(local_cmap_table[i].cname,NULL);
        //delete[] local_cmap_table[i].cname;
    }
    delete[] local_cmap_table;
    map_entries=sizeof(cmap_init)/sizeof(CMap_entry);
    //cout << "set std colors: " << map_entries << endl;
    local_cmap_table=new CMap_entry[map_entries];
    for (int i=0;i<map_entries;i++)
    {
        memcpy(local_cmap_table+i,cmap_init+i,sizeof(CMap_entry));
        /*local_cmap_table[i].cname=new char[2+strlen(cmap_init[i].cname)];
        strcpy(local_cmap_table[i].cname,cmap_init[i].cname);*/
        local_cmap_table[i].cname = NULL;
        local_cmap_table[i].cname = copy_string(local_cmap_table[i].cname,cmap_init[i].cname);
    }
    init_color_icons(map_entries,local_cmap_table,allocated_loc_colors,&locColorIcons,&locColorPixmaps,&locColorNames);
    colorsel->updateColorIcons(map_entries,locColorPixmaps,locColorNames);
}

void frmColorManagement::doSetSpectrum(void)
{
    //cout << "set spectrum" << endl;
    generateSpectrum(selStdSpectra->currentIndex());
    showTempSpectrum();
    for (int i=0;i<map_entries;i++)
    {
        local_cmap_table[i].cname = copy_string(local_cmap_table[i].cname,NULL);
        //delete[] local_cmap_table[i].cname;
    }
    delete[] local_cmap_table;
    map_entries=temp_spec_lenght;
    local_cmap_table=new CMap_entry[map_entries];
    for (int i=0;i<map_entries;i++)
    {
        memcpy(local_cmap_table+i,temp_spec+i,sizeof(CMap_entry));
        /*local_cmap_table[i].cname=new char[2+strlen(temp_spec[i].cname)];
        strcpy(local_cmap_table[i].cname,temp_spec[i].cname);*/
        local_cmap_table[i].cname = NULL;
        local_cmap_table[i].cname = copy_string(local_cmap_table[i].cname,temp_spec[i].cname);
    }
    init_color_icons(map_entries,local_cmap_table,allocated_loc_colors,&locColorIcons,&locColorPixmaps,&locColorNames);
    colorsel->updateColorIcons(map_entries,locColorPixmaps,locColorNames);
}

void frmColorManagement::curColorChanged(int nr)
{
    if (GlobalInhibitor==true) return;
    //cout << "cur color changed --> " << nr << endl;
    init_with_color(nr);
    showSingleColor();
}

void frmColorManagement::curSpectrumChanged(int nr)
{
    if (GlobalInhibitor==true) return;
    //cout << "spectrum changed" << endl;
    generateSpectrum(nr);
    showTempSpectrum();
    if (nr==3)
    {
    selNumberOfPathPoints->setEnabled(true);
    selNumberOfCurPathPoint->setEnabled(true);
    selPathCol->setEnabled(true);
    }
    else
    {
    selNumberOfPathPoints->setEnabled(false);
    selNumberOfCurPathPoint->setEnabled(false);
    selPathCol->setEnabled(false);
    }
}

void frmColorManagement::curNumberOfColorsChanged(int nr)
{
    (void)nr;
    if (GlobalInhibitor==true) return;
    //cout << "color count changed " << nr << endl;
    curSpectrumChanged(selStdSpectra->currentIndex());
}

void frmColorManagement::changedInvert(bool nr)
{
    (void)nr;
    curSpectrumChanged(selStdSpectra->currentIndex());
}

void frmColorManagement::colorCompositionChanged(int nr)
{
    (void)nr;
    if (GlobalInhibitor==true) return;
    //cout << "color composition changed" << endl;
    showSingleColor();
}

void frmColorManagement::colorNameChanged(void)
{
    if (GlobalInhibitor==true) return;
    //cout << "color name changed" << endl;
}

void frmColorManagement::showSingleColor(void)
{
    CMap_entry entry=constructColor();
    QColor colo(entry.rgb.red,entry.rgb.green,entry.rgb.blue);
    QPixmap pix(300,20);
    QPainter paint(&pix);
    paint.setPen(colo);
    paint.setBrush(colo);
    paint.fillRect(0,0,300,20,colo);
    paint.end();
    lblIllustration->setPixmap(pix);
}

void frmColorManagement::addColorToLocal(CMap_entry * entry)
{
    //cout << "old map_entries=" << map_entries << endl;
    CMap_entry * n_table=new CMap_entry[map_entries+1];
    memcpy(n_table,local_cmap_table,sizeof(CMap_entry)*map_entries);
    memcpy(n_table+map_entries,entry,sizeof(CMap_entry));
    delete[] local_cmap_table;
    local_cmap_table=n_table;
    map_entries++;
    //cout << "new map_entries=" << map_entries << endl;
    init_color_icons(map_entries,local_cmap_table,allocated_loc_colors,&locColorIcons,&locColorPixmaps,&locColorNames);
}

void frmColorManagement::editColorToLocal(CMap_entry * entry,int nr)
{
    memcpy(local_cmap_table+nr,entry,sizeof(CMap_entry));
    init_color_icons(map_entries,local_cmap_table,allocated_loc_colors,&locColorIcons,&locColorPixmaps,&locColorNames);
}

void frmColorManagement::delColorToLocal(int nr)
{
    CMap_entry * n_table=new CMap_entry[map_entries-1];
    int counter=0;
    for (int i=0;i<map_entries;i++)
    {
        if (i!=nr)
        {
            memcpy(n_table+counter,local_cmap_table+i,sizeof(CMap_entry));
            counter++;
        }
    }
    delete[] local_cmap_table;
    local_cmap_table=n_table;
    map_entries--;
    init_color_icons(map_entries,local_cmap_table,allocated_loc_colors,&locColorIcons,&locColorPixmaps,&locColorNames);
}

void frmColorManagement::NrOfPathPointsChanged(int nr)
{
    int * tmp_pointer=new int[nr];
    if (nr<tmp_path_length)
    {
        memcpy(tmp_pointer,tmp_path_pos,sizeof(int)*nr);
        delete[] tmp_path_pos;
        tmp_path_pos=tmp_pointer;
    }
    else//nr>=tmp_path_length
    {
        memcpy(tmp_pointer,tmp_path_pos,sizeof(int)*tmp_path_length);
        for (int i=tmp_path_length;i<nr;i++)
            tmp_pointer[i]=tmp_pointer[tmp_path_length-1];
        delete[] tmp_path_pos;
        tmp_path_pos=tmp_pointer;
    }
    tmp_path_length=nr;
    selNumberOfCurPathPoint->spnInt->setMaximum(nr-1);
    selNumberOfColors->spnInt->setMinimum(nr+2);
    if (selStdSpectra->currentIndex()==CUSTOM_SPECTRUM)
    {
        curSpectrumChanged(CUSTOM_SPECTRUM);
    }
}

void frmColorManagement::CurrentPathPointChanged(int nr)
{
    tmp_path_pos[tmp_path_point_shown]=selPathCol->currentIndex();
    selPathCol->setCurrentIndex(tmp_path_pos[nr]);
    tmp_path_point_shown=nr;
}

void frmColorManagement::CurrentPathColorChanged(int nr)
{
    tmp_path_pos[tmp_path_point_shown]=nr;
    if (selStdSpectra->currentIndex()==CUSTOM_SPECTRUM)
    {
        curSpectrumChanged(CUSTOM_SPECTRUM);
    }
}

CMap_entry frmColorManagement::constructColor(void)
{
    CMap_entry entry;
    entry.rgb.red=ledRed->value();
    entry.rgb.blue=ledBlue->value();
    entry.rgb.green=ledGreen->value();
    entry.ctype=COLOR_MAIN;
    entry.tstamp=0;
    entry.cname = NULL;
    entry.cname = copy_string(entry.cname,ledColName->text().toLocal8Bit().constData());
    /*entry.cname=new char[ledColName->text().length()+2];
    strcpy(entry.cname,ledColName->text().toLocal8Bit().constData());*/
    return entry;
}

void frmColorManagement::init_with_color(int nr)
{
    GlobalInhibitor=true;
    cur_col_num=nr;
    CMap_entry * entry=local_cmap_table+nr;
    ledRed->setValue(entry->rgb.red);
    ledBlue->setValue(entry->rgb.blue);
    ledGreen->setValue(entry->rgb.green);
        if (entry->cname)
        ledColName->setText(QString(entry->cname));
        else
        ledColName->setText(QString(""));
    char dummy[8];
    sprintf(dummy,"%d",nr);
    lblColNumber->setText(tr("Number = ")+QString(dummy));
    GlobalInhibitor=false;
}

void frmColorManagement::init(void)
{
    int * real_colors=new int[4];
    int nr_of_aux_cols;
    map_entries=get_main_color_indices(&real_colors,&nr_of_aux_cols);
    //cout << "init: " << map_entries << endl;
    if (local_cmap_table!=NULL)
    {
        for (int i=0;i<map_entries;i++)
        {
            local_cmap_table[i].cname = copy_string(local_cmap_table[i].cname,NULL);
            //delete[] local_cmap_table[i].cname;
        }
        delete[] local_cmap_table;
    }
    local_cmap_table=new CMap_entry[map_entries];
    for (int i=0;i<map_entries;i++)
    {
        memcpy(local_cmap_table+i,cmap_table+real_colors[i],sizeof(CMap_entry));
        /*local_cmap_table[i].cname=new char[strlen(cmap_table[real_colors[i]].cname)+2];
        strcpy(local_cmap_table[i].cname,cmap_table[real_colors[i]].cname);*/
        local_cmap_table[i].cname = NULL;
        local_cmap_table[i].cname = copy_string(local_cmap_table[i].cname,cmap_table[real_colors[i]].cname);
    }
    init_color_icons(map_entries,local_cmap_table,allocated_loc_colors,&locColorIcons,&locColorPixmaps,&locColorNames);
    //Local colors are only main colors
    colorsel->updateColorIcons(map_entries,locColorPixmaps,locColorNames);
}

void frmColorManagement::doApply(void)
{
    int ret=QMessageBox::question(this,tr("Change color palette?"),tr("Do you really want to change the current color palette?"),QMessageBox::Ok,QMessageBox::Cancel);
    if (ret==QMessageBox::Ok)
    {
        //cout << "apply to color palette" << endl;
        SaveCurrentColorMap();
        //first: save aux colors
        int * real_colors=new int[4];
        int nr_of_aux_colors;//,new_nr_of_colors;
        (void)get_main_color_indices(&real_colors,&nr_of_aux_colors);
        //int real_map_entries=get_main_color_indices(&real_colors,&nr_of_aux_colors);
        int * aux_colors=new int[2+nr_of_aux_colors];//the old color-indices of auxilliary colors
        CMap_entry * aux_map_entries=new CMap_entry[2+nr_of_aux_colors];//the auxilliary colors
        //cout << "nr_of_aux_colors=" << nr_of_aux_colors << endl;
        nr_of_aux_colors=0;
        for (unsigned int i=0;i<number_of_colors();i++)
        {
            if (cmap_table[i].ctype!=COLOR_MAIN)
            {
                memcpy(aux_map_entries+nr_of_aux_colors,cmap_table+i,sizeof(CMap_entry));
                /*aux_map_entries[nr_of_aux_colors].cname=new char[2+sizeof(cmap_table[i].cname)];
                strcpy(aux_map_entries[nr_of_aux_colors].cname,cmap_table[i].cname);*/
                aux_map_entries[nr_of_aux_colors].cname = NULL;
                aux_map_entries[nr_of_aux_colors].cname = copy_string(aux_map_entries[nr_of_aux_colors].cname,cmap_table[i].cname);
                aux_colors[nr_of_aux_colors]=i;
                //cout << i << endl;
                nr_of_aux_colors++;
            }
        }
        /// the following two commands seem to be important for the t1-fonts
        nr_of_aux_colors=0;
        AAGrayLevelsOK = FALSE;
        /// we leave them in here because otherwise the grayscale-colors are not stored with the correct indices --> at the next redraw the grayscale colors will be reinstalled
        int number_of_new_cols=nr_of_aux_colors+map_entries;//aux-colors+(new)main-colors
        if (number_of_new_cols>MAXCOLORS) number_of_new_cols=MAXCOLORS;
        //cout << "nr_of_aux_colors=" << nr_of_aux_colors << " number_of_new_cols=" << number_of_new_cols << endl;
        realloc_colors(number_of_new_cols);
        int aux_counter=0,colors_counter=0;
        char * old_cname;
        for (int i=0;i<number_of_new_cols;i++)//fill new color table with new colors
        {
            if (aux_counter>=nr_of_aux_colors)//space for a main color
            {
                old_cname=cmap_table[i].cname;
                memcpy(cmap_table+i,local_cmap_table+colors_counter,sizeof(CMap_entry));
                cmap_table[i].cname = old_cname;
                cmap_table[i].cname = copy_string(cmap_table[i].cname, local_cmap_table[colors_counter].cname);
                colors_counter++;
            }
            else if (aux_colors[aux_counter]==i)//current number has been an aux-color
            {
                old_cname=cmap_table[i].cname;
                memcpy(cmap_table+i,aux_map_entries+aux_counter,sizeof(CMap_entry));
                cmap_table[i].cname = old_cname;
                cmap_table[i].cname = copy_string(cmap_table[i].cname, aux_map_entries[aux_counter].cname);
                aux_counter++;
            }
            else//space for a main color
            {
                old_cname=cmap_table[i].cname;
                memcpy(cmap_table+i,local_cmap_table+colors_counter,sizeof(CMap_entry));
                cmap_table[i].cname = old_cname;
                cmap_table[i].cname = copy_string(cmap_table[i].cname, local_cmap_table[colors_counter].cname);
                colors_counter++;
            }
        }
        ReqUpdateColorSel = TRUE;
        /*IntstallColorMap(map_entries,local_cmap_table);*/
        CurrentColorMapChanged();
        mainWin->mainArea->completeRedraw();
    }
    //else
    //cout << "do not change color palette" << endl;
}

void frmColorManagement::doAccept(void)
{
    ApplyError=false;
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmColorManagement::doClose(void)
{
    emit(close_wish());
    //hide();
}

frmRealTimeInputManager::frmRealTimeInputManager(QWidget * parent):QDialog(parent)
{
//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: Real Time Input"));
    setWindowIcon(QIcon(*GraceIcon));
    frmOpen=NULL;
    layout=new QVBoxLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);

    selTimeout=new stdIntSelector(this,tr("Update interval (ms):"),10,10000);
    selTimeout->setValue(rtiCheckTime);
    selTimeout->spnInt->setSingleStep(100);
    lstInputs=new uniList(TEXTLIST,this);

    lblRTI=new QLabel(tr("Registered real time input pipes"),this);
    chkRTIactive=new QCheckBox(tr("Real time input active"),this);
    connect(chkRTIactive,SIGNAL(toggled(bool)),SLOT(toggle_RTI(bool)));
    aac=new stdButtonGroup(this,true,true,false);
    aac->cmdApply->setText(tr("Open pipe"));
    aac->cmdAccept->setText(tr("Close pipe"));
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doOpen()));
    connect(aac->cmdAccept,SIGNAL(clicked()),SLOT(doDelete()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));
    layout->addWidget(lblRTI);
    layout->addWidget(lstInputs);
    layout->addWidget(chkRTIactive);
    layout->addWidget(selTimeout);
    layout->addWidget(aac);
    setLayout(layout);
    resize(LastSize_FormRTIManage);
}

frmRealTimeInputManager::~frmRealTimeInputManager()
{
    LastSize_FormRTIManage=this->size();
}

void frmRealTimeInputManager::updateRTIs(void)
{
    lstInputs->clear();
    //nb_rt   (ib_tblsize)   ib_tbl
    for (int i=0;i<nb_rt;i++)
    {
        if (ib_tbl[i].name!=NULL)
        {
            lstInputs->add_Item(QString(ib_tbl[i].name));
        }
    }
    int index=0;
    for (int i=0;i<nb_rt;i++)
    {
        if (ib_tbl[i].name!=NULL)
        {
            lstInputs->entries[index++]=i;
        }
    }

    selTimeout->setValue(rtiCheckTime);
}

void frmRealTimeInputManager::toggle_RTI(bool s)
{
    mainWin->rtiTimer->stop();//we stop in any case
    rtiCheckTime=selTimeout->value();
    if (s==true)
    {
        mainWin->rtiTimer->start(rtiCheckTime);
    }
}

void frmRealTimeInputManager::init(void)
{
    updateRTIs();
}

void frmRealTimeInputManager::doOpen(void)
{
    int fd;
    char * dummy;
    if (frmOpen==NULL)
    {
        frmOpen=new QFileDialog(this);
    }
    QString fname=frmOpen->getOpenFileName(this,tr("Open pipe"));
    if (fname.isEmpty())
    {
        return;
    }
    dummy=new char[fname.size()+2];
    strcpy(dummy,fname.toLocal8Bit().constData());
    if (openPipe(dummy,&fd)!=RETURN_SUCCESS)
    {
        errmsg(tr("Unable to open pipe!").toLocal8Bit().constData());
    }
    updateRTIs();
    delete[] dummy;
}

void frmRealTimeInputManager::doDelete(void)
{
    int nr_of_selected_elements,*el_nr=new int[2];
    lstInputs->get_selection(&nr_of_selected_elements,&el_nr);
    for (int i=nr_of_selected_elements-1;i>=0;i--)
    {
        unregister_real_time_input(ib_tbl[el_nr[i]].name);
    }
    delete[] el_nr;
}

void frmRealTimeInputManager::doClose(void)
{
    hide();
}

#define MAX_INPUT_LINE_LENGTH 2048
char linebuffer[MAX_INPUT_LINE_LENGTH];
int nextlinebufferpos=0;

int readLineFromFile(QFile * fi,struct cvs_import_infos & import_info,char ** tline)
{//read from fi until EOF is reached or a lineSeparator-char is found (uses linebuffer if lineSeparator!='\n')
    static int counter,stringcounter,tokenlength,colcounter;
    static QByteArray line;
    static char * tmp_pointer;
    tmp_pointer=NULL;
    tokenlength=stringcounter=counter=0;//stringcounter counts '"', counter counts tokens (only 0 or 1 token read)
    if (fi->atEnd()==true && nextlinebufferpos==0)
    {
        //cout << "File at End !" << endl;
        return RETURN_FAILURE;//EOF and no more data in buffer
    }
    if (import_info.datsep=='\n')//simple case
    {
        //cout << "simple case" << endl;
        while (!fi->atEnd() && counter<1)
        {
            line = fi->readLine(MAX_INPUT_LINE_LENGTH);
            if (line.length()<1) return RETURN_FAILURE;
            delete[] *tline;
            (*tline)=new char[line.length()+2];
            strncpy(*tline,line.constData(),line.length());
            (*tline)[line.length()-1]='\0';//-1 because new-line-character is included and we don't need it!
            (*tline)[line.length()]='\0';
            (*tline)[line.length()+1]='\0';
            counter++;
        }
    }
    else//special character for line-separation
    {
        //cout << "complex case = #" << linebuffer << "#" << endl;
        while ((!fi->atEnd() || nextlinebufferpos>0) && counter<1)
        {
            if (!fi->atEnd())//more data in file-->read data to buffer
            {
                line = fi->readLine(MAX_INPUT_LINE_LENGTH-nextlinebufferpos);
                strncpy(linebuffer+nextlinebufferpos,line.constData(),line.length());/// Possible Problem: line.length() > MAX_INPUT_LINE_LENGTH !!
                nextlinebufferpos+=line.length();
                if (nextlinebufferpos>MAX_INPUT_LINE_LENGTH-1) nextlinebufferpos=MAX_INPUT_LINE_LENGTH-1;//if this is necessary, the program will crash anyway
                linebuffer[nextlinebufferpos]='\0';
                //cout << "new Linebuffer = #" << linebuffer << "#" << endl;
            }
            //nextlinebufferpos is the amount of data still present in linebuffer
            //use linebuffer to get data
            colcounter=0;
            //now we have to look for a suitable lineSeparator
            for (int k=0;k<nextlinebufferpos;k++)
            {
                if (linebuffer[k]==import_info.textsep)
                {
                    stringcounter++;
                }
                else if (linebuffer[k]==import_info.colsep)
                {
                    colcounter++;
                }
                else if (linebuffer[k]==import_info.datsep && stringcounter%2==0)
                {
                    /// TODO: INSERT MISSING SEARCH RESTRICTIONS ABOUT string-separators
                    tokenlength=k;
                    break;
                }
            }
            //tokenlength should now give an indication how long a line is
            if (tokenlength<1 && colcounter>0)
            {
                //cout << "colcounter>0 nextlinebufpos=" << nextlinebufferpos << endl;
                tokenlength=nextlinebufferpos-1;
            }
            else if (tokenlength<1)
            {
                return RETURN_FAILURE;
            }
            delete[] *tline;
            (*tline)=new char[tokenlength+2];
            strncpy(*tline,linebuffer,tokenlength);
            (*tline)[tokenlength]='\0';
            (*tline)[tokenlength+1]='\0';
            tmp_pointer=new char[nextlinebufferpos+2];
            strncpy(tmp_pointer,linebuffer+tokenlength+1,nextlinebufferpos);
            tmp_pointer[nextlinebufferpos]='\0';
            strncpy(linebuffer,tmp_pointer,nextlinebufferpos-tokenlength-1);
            linebuffer[nextlinebufferpos-tokenlength-1]='\0';
            nextlinebufferpos-=tokenlength+1;
            delete[] tmp_pointer;
            counter++;
        }//end while data present
    }//end if (complex-case)
    return RETURN_SUCCESS;
}

int get_next_token(char * tokenline,struct cvs_import_infos & import_info,char * n_token,int * read_token_length)
{//searches for the next token and replaces the text-separator if neccessary
    static int len,stringcounter,dat_sep_occurrance,index;
    static char * tmp_string;
    len=strlen(tokenline);
    if (len<1) return RETURN_FAILURE;
    tmp_string=new char[2*len+2];
    dat_sep_occurrance=0;
    stringcounter=0;
    for ((*read_token_length)=0;(*read_token_length)<len;(*read_token_length)++)
    {
        if (tokenline[*read_token_length]==import_info.textsep)
        {
            stringcounter++;
        }
        else if (tokenline[*read_token_length]==import_info.colsep && stringcounter%2==0)
        {
            dat_sep_occurrance++;
            //(*read_token_length)++;
            break;
        }
    }
    strncpy(tmp_string,tokenline,(*read_token_length));
    tmp_string[(*read_token_length)]='\0';
    (*read_token_length)++;
    dat_sep_occurrance=stringcounter;
    stringcounter=0;
    len=strlen(tmp_string);
    index=0;
    if (dat_sep_occurrance>0)
    {
        for (int i=0;i<len;i++)
        {
            if (tmp_string[i]==import_info.textsep)
            {
                stringcounter++;
                if (stringcounter==1 || stringcounter==dat_sep_occurrance)
                {
                    n_token[index++]='"';
                }
                else
                {
                    n_token[index++]=tmp_string[i];
                }
            }
            else
            {
                n_token[index++]=tmp_string[i];
            }
        }
    }
    else
    {
        strcpy(n_token,tmp_string);
    }
    len=strlen(n_token);
    for (int l=0;l<4;l++)
    {
        n_token[len+l]='\0';
    }
    delete[] tmp_string;
    return RETURN_SUCCESS;
}

void redesign_tokenline(char * tokenline,struct cvs_import_infos & import_info)
{
    static int stringcounter,len,index;
    char * newtokenline;
    index=stringcounter=0;
    len=strlen(tokenline);
    newtokenline=new char[2*len+2];
    newtokenline[index++]=import_info.textsep;
    for (int i=0;i<len;i++)
    {
        if (tokenline[i]==import_info.textsep)
        {
            stringcounter++;
            newtokenline[index++]=tokenline[i];
        }
        else if (tokenline[i]==import_info.datsep && stringcounter%2==0)
        {
            newtokenline[index++]=import_info.textsep;
            newtokenline[index++]=' ';
            newtokenline[index++]=import_info.textsep;
        }
        else
        {
            newtokenline[index++]=tokenline[i];
        }
    }
    newtokenline[index++]=import_info.textsep;
    newtokenline[index++]='\0';
    strcpy(tokenline,newtokenline);
    delete[] newtokenline;
}

int guess_column_format(struct cvs_import_infos & import_info, int * ncols, int ** formats)
{
    char * tokenline=new char[MAX_INPUT_LINE_LENGTH*2+4];
    char * linetoken=new char[2];
    char * n_token=new char[MAX_INPUT_LINE_LENGTH];
    char * token;
    int counter,quoted,reserved,len;
    double value;
    (*ncols)=0;
    reserved=2;
    delete[] (*formats);
    (*formats)=new int[reserved];
    Dates_format df_pref, ddummy;
    const char *sdummy;
    int read_token_length,offset;
    int * int_tmp;
    int * old_format=NULL,old_f_cols;
    QByteArray line;
    QFile * file=new QFile(import_info.filename);
    df_pref=get_date_hint();
    counter=0;
    nextlinebufferpos=0;
    if (!file->open(QIODevice::ReadOnly | QIODevice::Text))
    {
        errmsg(QObject::tr("Unable to open csv-file.").toLocal8Bit().constData());
        delete[] tokenline;
        delete[] linetoken;
        delete[] n_token;
        return RETURN_FAILURE;
    }
    while (!file->atEnd() && counter<import_info.headerlines)//read header and ignore it!
    {
        line = file->readLine(MAX_INPUT_LINE_LENGTH);
        counter++;
    }
    counter=0;
    old_f_cols=0;
    while (readLineFromFile(file,import_info,&linetoken)==RETURN_SUCCESS && counter<3)//read max three lines!
    {
        *ncols=0;
        //cout << "Line " << counter << ": linetoken=#" << linetoken << "#" << endl;
        strcpy(tokenline,linetoken);
        len=strlen(tokenline);
        for (int l=0;l<4;l++)
        {
            tokenline[len+l]='\0';
        }
        offset=0;
        while (get_next_token(tokenline+offset,import_info,n_token,&read_token_length)==RETURN_SUCCESS)
        {//loop through tokens in one line
            offset+=read_token_length;
            //cout << "vor exchange:  n_token=#" << n_token << "#" << int('\n') << endl;
            if (import_info.dec_sep_komma==true) exchangePointComma(n_token);
            //cout << "nach exchange: n_token=#" << n_token << "#" << tokenline+offset << "#" << int(tokenline[offset]) << endl;
            //cout << "n_token=#" << n_token << "# next=#" << tokenline+offset << "#" << endl;
            next_token(n_token, &token, &quoted);
            if (quoted)
            {
                (*formats)[*ncols] = FFORMAT_STRING;
                (*ncols)++;
            }
            else if (parse_date(token, df_pref, FALSE, &value, &ddummy) == RETURN_SUCCESS)
            {
                (*formats)[*ncols] = FFORMAT_DATE;
                (*ncols)++;
            }
            else if (parse_float(token, &value, &sdummy) == RETURN_SUCCESS)
            {
                (*formats)[*ncols] = FFORMAT_NUMBER;
                (*ncols)++;
            }
            else
            {
                /* last resort - treat the field as string, even if not quoted */
                (*formats)[*ncols] = FFORMAT_STRING;
                (*ncols)++;
            }
            //cout << "token=#" << n_token << "# Format=" << (*formats)[(*ncols)-1] << endl;
            if (*ncols==reserved)//expand space for formats
            {
                int_tmp=new int[reserved*2];
                memcpy(int_tmp,*formats,sizeof(int)*(reserved));
                reserved*=2;
                delete[] (*formats);
                *formats=int_tmp;
            }
        }//end loop through tokens in one line
        //we have read one line!
        if (counter==0)
        {
            old_format=new int[*ncols];
            old_f_cols=*ncols;
            memcpy(old_format,*formats,sizeof(int)*(*ncols));//save format of first lines
        }
        else
        {
            if (old_f_cols!=*ncols) goto end_guess_col_f;
            for (int l=0;l<*ncols;l++)
            {
                if (((*formats)[l])!=old_format[l]) goto end_guess_col_f;
            }
        }
        counter++;//line-counter
    }
    file->close();//we opended the file for guessing only
    delete file;
    if (old_format!=NULL) delete[] old_format;
    delete[] tokenline;
    delete[] linetoken;
    delete[] n_token;
    return RETURN_SUCCESS;
end_guess_col_f:
    if (old_format!=NULL) delete[] old_format;
    delete[] tokenline;
    delete[] linetoken;
    delete[] n_token;
    return RETURN_FAILURE;
}

int csvImport(struct cvs_import_infos & import_info)
{
    nextlinebufferpos=0;
    //first action: activate sets to have access to memory for results
    //cout << "Import: Activating sets nr=" << import_info.nr_of_target_sets << endl;
    for (int i=0;i<import_info.nr_of_target_sets;i++)
    {
        import_info.target_sets[i]=nextset(import_info.gno);
        setlength(import_info.gno,import_info.target_sets[i],1024);//we set a default length
        qDebug() << "File=" << import_info.filename << " i=" << i << ": set=" << import_info.target_sets[i] << " length=" << getsetlength(import_info.gno,import_info.target_sets[i]);
        if (import_info.max_col_per_set[i]==2)
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XY);
        else if (import_info.max_col_per_set[i]==3)
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XYDY);
        else if (import_info.max_col_per_set[i]==4)
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XYDXDY);
        else if (import_info.max_col_per_set[i]==5)
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XYHILO);
        else
            set_dataset_type(import_info.gno,import_info.target_sets[i],SET_XYDXDXDYDY);
    }
    char * tokenline=new char[MAX_INPUT_LINE_LENGTH*2+4];
    char * linetoken=new char[2];
    char * n_token=new char[MAX_INPUT_LINE_LENGTH];
    int counter,col_counter,len;
    double value;
    Dates_format df_pref, ddummy;
    const char *sdummy;
    int read_token_length,offset;
    QByteArray line;
    QFile * file=new QFile(import_info.filename);
    counter=0;
    df_pref=get_date_hint();
    //second action: try to actually open file
    if (!file->open(QIODevice::ReadOnly | QIODevice::Text))
    {
        errmsg(QObject::tr("Unable to open csv-file.").toLocal8Bit().constData());
        delete[] tokenline;
        delete[] linetoken;
        delete[] n_token;
        return RETURN_FAILURE;
    }
    //third action: read and ignore header lines
    while (!file->atEnd() && counter<import_info.headerlines)
    {
        line = file->readLine(MAX_INPUT_LINE_LENGTH);
        counter++;
    }
    counter=0;
    //fourth action: do the import
    while (readLineFromFile(file,import_info,&linetoken)==RETURN_SUCCESS)
    {
        ///cout << "Line " << counter << ": linetoken=#" << linetoken << "#" << endl;
        strcpy(tokenline,linetoken);
        len=strlen(tokenline);
        for (int l=0;l<4;l++)
        {
            tokenline[len+l]='\0';
        }
        offset=0;
        col_counter=0;
        while (get_next_token(tokenline+offset,import_info,n_token,&read_token_length)==RETURN_SUCCESS)
        {//loop through tokens in one line
            offset+=read_token_length;
            ///cout << "n_token=#" << n_token << "# next=#" << tokenline+offset << "#" << endl;
            if (import_info.col_format[col_counter]==FFORMAT_NUMBER)
            {
                //cout << "vor exchange" << endl;
                if (import_info.dec_sep_komma==true) exchangePointComma(n_token);
                value=0.0;
                //cout << "nach exchange#" << n_token << "#" << endl;
                parse_float(n_token, &value, &sdummy);
            }
            else if (import_info.col_format[col_counter]==FFORMAT_DATE)
            {
                parse_date(n_token, df_pref, FALSE, &value, &ddummy);
            }
            else
            {
                /// cout << "TOKEN-STRING=" << n_token << endl;
                value=0.0;
            }
            //we should now have a 'value' for our column-entry
            //cout << "determined value = " << value << endl;
            if (import_info.import_to_set[col_counter]==-2)//all sets
            {
                //cout << "value=" << value << " allsets nr=" << import_info.nr_of_target_sets << endl;
                for (int l=0;l<import_info.nr_of_target_sets;l++)
                {
                    /*if (import_info.target_sets[l]>=0)
                    {
                    cout << "set S" << import_info.target_sets[l] << " value=" << value << endl;*/
                    g[import_info.gno].p[import_info.target_sets[l]].data.ex[import_info.target_cols[col_counter]][counter]=value;
                    /*}
                    else
                    {
                    cout << "ERROR: target < 0" << endl;//this should never happen
                    }*/
                }
            }
            else if (import_info.import_to_set[col_counter]>=0)//normal set numbers
            {
                //cout << "target-set:" << import_info.import_to_set[col_counter] << " target_cols:" << import_info.target_cols[col_counter] << " value=" << value << endl;
                g[import_info.gno].p[import_info.import_to_set[col_counter]].data.ex[import_info.target_cols[col_counter]][counter]=value;
            }
            col_counter++;//column-counter
        }//end loop through tokens in one line
        counter++;//line-counter
        if (counter%1024==0)//we have to expand the amount of space in the sets
        {
            for (int l=0;l<import_info.nr_of_target_sets;l++)
                setlength(import_info.gno,import_info.target_sets[l],1024+getsetlength(import_info.gno,import_info.target_sets[l]));
        }
    }//end loop through lines in file
    for (int l=0;l<import_info.nr_of_target_sets;l++)
    {
        setcomment(import_info.gno,import_info.target_sets[l],import_info.filename);
        setlength(import_info.gno,import_info.target_sets[l],counter);//reset the set-length to the actual number of datapoints read
//qDebug() << "nach lesen: y=" << g[import_info.gno].p[import_info.import_to_set[l]].data.ex[1][1];
    }
    file->close();
    delete file;
    delete[] tokenline;
    delete[] linetoken;
    delete[] n_token;
    return RETURN_SUCCESS;
}

frmCSVImporter::frmCSVImporter(QWidget * parent):QDialog(parent)
{
    import_info.filename=NULL;
    import_info.gno=0;
    import_info.headerlines=0;
    import_info.columns_to_read=0;
    import_info.target_cols=NULL;
    import_info.col_format=NULL;
    import_info.import_to_set=NULL;
    import_info.nr_of_target_sets=0;
    import_info.target_sets=NULL;
    import_info.max_col_per_set=NULL;
    import_info.colsep=';';
    import_info.datsep='\n';
    import_info.textsep='"';
    import_info.dec_sep_komma=false;

//setFont(*stdFont);
    setWindowTitle(tr("QtGrace: CSV-import"));
    setWindowIcon(QIcon(*GraceIcon));
    fileDialog=new QFileDialog(this,tr("Open CSV file"));
    fileDialog->hide();
    layout=new QGridLayout;
    layout->setMargin(STD_MARGIN);
    layout->setSpacing(STD_SPACING);
    cmdOpenFile=new QPushButton(tr("Select CSV file"),this);
    connect(cmdOpenFile,SIGNAL(clicked()),SLOT(doOpen()));
    cmdReguess=new QPushButton(tr("Re-guess columns"),this);
    connect(cmdReguess,SIGNAL(clicked()),SLOT(doReguess()));
    ledFileName=new stdLineEdit(this,tr("Filename:"),false);
    ledFileName->setText(QString(""));
    lblFileContents=new QTextEdit(QString(""),this);
    lblFileContents->setReadOnly(TRUE);
    lblFileContents->setMinimumHeight(120);
    ledColSep=new stdLineEdit(this,tr("Column-separator:"),false);
    ledColSep->setText(QString(";"));
    ledSetSep=new stdLineEdit(this,tr("Data-set-separator:"),false);
    ledSetSep->setText(QString("\\n"));
    ledTextSep=new stdLineEdit(this,tr("Text-separator:"),false);
    ledTextSep->setText(QString("\""));
    selHeaderLines=new stdIntSelector(this,tr("Number of header-lines to ignore:"),0,100);
    connect(selHeaderLines,SIGNAL(currentValueChanged(int)),SLOT(headerLinesChanged(int)));
    selSetsToRead=new stdIntSelector(this,tr("Number of sets to read:"),1,512);
    connect(selSetsToRead,SIGNAL(currentValueChanged(int)),SLOT(setCountChanged(int)));
    graphselector=new uniList(GRAPHLIST,this);
    lblGraphSelector=new QLabel(tr("Target graph:"),this);
    lblFileCont=new QLabel(tr("File contents:"),this);
    chkKommaDecimalSep=new QCheckBox(tr("Decimal separator is ','"),this);
    chkAutoscaleOnRead=new QCheckBox(tr("Autoscale on read"),this);
    chkAutoscaleOnRead->setChecked(true);//autscale is default
    aac=new stdButtonGroup(this,true,true,false);
    connect(aac->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
    connect(aac->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
    connect(aac->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

    int index=0;//,index2=0;
    layout->addWidget(ledFileName,index,0,1,1);
    layout->addWidget(cmdOpenFile,index++,1,1,1);
    layout->addWidget(lblFileCont,index,0,1,1);
    layout->addWidget(lblGraphSelector,index++,1,1,1);
    layout->addWidget(lblFileContents,index,0,1,1);
    layout->addWidget(graphselector,index++,1,1,1);
    layout->addWidget(selHeaderLines,index,0,1,1);
    layout->addWidget(ledSetSep,index++,1,1,1);
    layout->addWidget(ledColSep,index,0,1,1);
    layout->addWidget(ledTextSep,index++,1,1,1);
    layout->addWidget(selSetsToRead,index,0,1,1);
    layout->addWidget(cmdReguess,index++,1,1,1);
    layout->addWidget(chkKommaDecimalSep,index,0,1,1);
    layout->addWidget(chkAutoscaleOnRead,index++,1,1,1);

    scroll=new QScrollArea(this);
    empty=new QLabel(this);
    empty->setMinimumSize(600,100);
    grid1=new QGridLayout(this);
    grid1->setMargin(STD_MARGIN);
    grid1->setSpacing(STD_SPACING);

    lblDescription=NULL;
    recreate_input_selectors();

    empty->setLayout(grid1);
    scroll->setWidget(empty);

    layout->addWidget(scroll,index++,0,1,2);
    layout->addWidget(aac,index++,0,1,2);
    setLayout(layout);
    resize(LastSize_FormCSVImport);
}

frmCSVImporter::~frmCSVImporter()
{
    LastSize_FormCSVImport=this->size();
}

void frmCSVImporter::read_inputs(void)
{
FileNames.clear();
QString testText=ledFileName->text();
QStringList list=testText.split(";");
//qDebug() << "list.length=" << list.length();
    for (int i=0;i<list.length();i++)
    FileNames << list.at(i);
    if (FileNames.length()<1) return;
exists=get_file_infos(FileNames.at(0),readable,writable,size_kB);
if (readable==false || exists==false) return;
    if (import_info.filename!=NULL) delete[] import_info.filename;
    import_info.filename=new char[ledFileName->text().length()+2];
strcpy(import_info.filename,FileNames.at(0).toLocal8Bit().constData());
    //strcpy(import_info.filename,ledFileName->text().toLocal8Bit().constData());
    import_info.headerlines=selHeaderLines->value();
    import_info.colsep=ledColSep->text().at(0).toLatin1();
    if (!ledColSep->text().compare(QString("\\n")))
        import_info.colsep='\n';
    else if (!ledColSep->text().compare(QString("\\t")))
        import_info.colsep='\t';
    import_info.datsep=ledSetSep->text().at(0).toLatin1();
    if (!ledSetSep->text().compare(QString("\\n")))//every data point is in a seperate line
        import_info.datsep='\n';
    else if (!ledSetSep->text().compare(QString("\\t")))
        import_info.datsep='\t';
    import_info.textsep=ledTextSep->text().at(0).toLatin1();
    if (!ledTextSep->text().compare(QString("\\n")))
        import_info.textsep='\n';
    else if (!ledTextSep->text().compare(QString("\\t")))
        import_info.textsep='\t';
    import_info.nr_of_target_sets=selSetsToRead->value();
    import_info.dec_sep_komma=chkKommaDecimalSep->isChecked();
    int nr_of_sel,*sel=new int[2],maxplot,setno,free_sets_found=0;
    graphselector->get_selection(&nr_of_sel,&sel);
    if (nr_of_sel<1)
    {
        errmsg(tr("Please select a single graph!").toLocal8Bit().constData());
        ApplyError=true;
    }
    else if (nr_of_sel>1)
    {
        errmsg(tr("Please select only one graph!").toLocal8Bit().constData());
        ApplyError=true;
    }
    else
    {
        import_info.gno=sel[0];
        if (import_info.target_sets!=NULL) delete[] import_info.target_sets;
        import_info.target_sets=new int[import_info.nr_of_target_sets];
        maxplot = number_of_sets(import_info.gno);
        free_sets_found=0;
        for (setno = 0; setno < maxplot; setno++)
        {
            if (!is_set_active(import_info.gno, setno))
            {
                import_info.target_sets[free_sets_found++]=setno;
            }
            if (import_info.nr_of_target_sets==free_sets_found)//we found enough
                break;
        }
        if (import_info.nr_of_target_sets>free_sets_found)//not enough sets found
        {
            import_info.target_sets[free_sets_found++]=maxplot;//first new set is number of allocated sets
            while (import_info.nr_of_target_sets>free_sets_found)
            {
                import_info.target_sets[free_sets_found]=import_info.target_sets[free_sets_found-1]+1;
                free_sets_found++;
            }
        }
        /*cout << "Predicted set-numbers:" << endl;
    for (int i=0;i<import_info.nr_of_target_sets;i++)
    {
    cout << i << ": S" << import_info.target_sets[i] << endl;
    }*/

    }
}

void frmCSVImporter::read_import_settings(void)//this will only be called directly before reading action begins
{//we have to read the column-import-settings and look for the set-numbers really in use
    FileNames.clear();
    QString testText=ledFileName->text();
    QStringList list=testText.split(";");
    //qDebug() << "list.length=" << list.length();
        for (int i=0;i<list.length();i++)
        FileNames << list.at(i);
        if (FileNames.length()<1) return;
    exists=get_file_infos(FileNames.at(0),readable,writable,size_kB);
//exists=get_file_infos(ledFileName->text(),readable,writable,size_kB);
if (readable==false || exists==false) return;
    if (import_info.col_format!=NULL) delete[] import_info.col_format;
    import_info.col_format=new int[allocated_selectors];//allocated selectors = columns_to_read = guessed number of columns in the file
    if (import_info.target_cols!=NULL) delete[] import_info.target_cols;
    import_info.target_cols=new int[allocated_selectors];
    if (import_info.import_to_set!=NULL) delete[] import_info.import_to_set;
    import_info.import_to_set=new int[allocated_selectors];
    if (import_info.target_sets!=NULL) delete[] import_info.target_sets;
    import_info.target_sets=new int[allocated_selectors];
    if (import_info.max_col_per_set!=NULL) delete[] import_info.max_col_per_set;
    import_info.max_col_per_set=new int[allocated_selectors];
    import_info.nr_of_target_sets=0;
    bool found;
    int j;
    for (int i=0;i<allocated_selectors;i++)//go through the columns
    {
        import_info.target_sets[i]=-1;
        import_info.max_col_per_set[i]=2;//minimum =2 columns per set =XY
        import_info.col_format[i]=selFormat[i]->currentValue();
        import_info.import_to_set[i]=selTargetSet[i]->currentValue();
        import_info.target_cols[i]=selTargetColumn[i]->currentValue();
        if (import_info.import_to_set[i]>=0)//new real set-number
        {
            found=false;
            for (j=0;j<import_info.nr_of_target_sets;j++)//look trough all previous sets for the new set-id
            {
                if (import_info.import_to_set[i]==import_info.target_sets[j])
                {
                    found=true;
                    break;
                }
            }
            if (found==false)//set-id is really new
            {
                import_info.target_sets[import_info.nr_of_target_sets++]=import_info.import_to_set[i];
            }
        }
    }

    sort(import_info.nr_of_target_sets,import_info.target_sets);//sort set-IDs for simplicity

    /*if (import_info.nr_of_target_sets<=0)
    {
    cout << "no suitable set numbers" << endl;
    }
    else*/
    if (import_info.nr_of_target_sets>0)
    {
        //cout << "found set numbers:" << endl;
        for (int i=0;i<import_info.nr_of_target_sets;i++)
        {
            for (j=0;j<allocated_selectors;j++)//look through the selectors for a max-column-number for every set
            {
                if (import_info.import_to_set[j]==import_info.target_sets[i] && import_info.target_cols[j]+1>import_info.max_col_per_set[i]) import_info.max_col_per_set[i]=import_info.target_cols[j]+1;
            }
        }
        /*for (int i=0;i<import_info.nr_of_target_sets;i++)
        {
        cout << "S" << import_info.target_sets[i] << " max_cols=" << import_info.max_col_per_set[i] << endl;
        }*/
    }
}

void frmCSVImporter::recreate_input_selectors(void)
{
    if (import_info.columns_to_read<=0) return;//columns_to_read is the guessed number of columns in the file --> we create new input-selectors for every column
    if (lblDescription!=NULL)//we already had selectors --> delete the old ones
    {
        for (int i=0;i<allocated_selectors;i++)
        {
            delete lblDescription[i];
            delete selFormat[i];
            delete selTargetSet[i];
            delete selTargetColumn[i];
        }
        delete[] lblDescription;
        delete[] selFormat;
        delete[] selTargetSet;
        delete[] selTargetColumn;
    }
    allocated_selectors=import_info.columns_to_read;
    empty->setMinimumSize(this->width()-18,allocated_selectors*30+10);
    empty->setMaximumSize(this->width()-18,allocated_selectors*30+10);
    lblDescription=new QLabel *[allocated_selectors];
    selFormat=new StdSelector *[allocated_selectors];
    selTargetSet=new StdSelector *[allocated_selectors];
    selTargetColumn=new StdSelector *[allocated_selectors];
    QString * entr=new QString[3];
    entr[0]=tr("Number");
    entr[1]=tr("Date/Time");
    entr[2]=tr("String");
    QString * entr2=new QString[2+import_info.nr_of_target_sets];
    int * entry_values2=new int[2+import_info.nr_of_target_sets];
    QString * entr3=new QString[6];
    entr2[0]=QString("None");
    entr2[1]=QString("All");
    entry_values2[0]=-1;
    entry_values2[1]=-2;
    for (int i=0;i<import_info.nr_of_target_sets;i++)
    {
        sprintf(dummy,"G%d.S%d",import_info.gno,import_info.target_sets[i]);
        entr2[i+2]=QString(dummy);
        entry_values2[i+2]=import_info.target_sets[i];
    }
    entr3[0]=QString("X");
    entr3[1]=QString("Y");
    entr3[2]=QString("Y1");
    entr3[3]=QString("Y2");
    entr3[4]=QString("Y3");
    entr3[5]=QString("Y4");
    int entry_values[3]={FFORMAT_NUMBER,FFORMAT_DATE,FFORMAT_STRING};
    int index2=0;
    for (int i=0;i<allocated_selectors;i++)
    {
        sprintf(dummy," %d:",i);
        lblDescription[i]=new QLabel(tr("Column")+QString(dummy),this);
        selFormat[i]=new StdSelector(this,tr("Format:"),3,entr);
        selFormat[i]->setValues(entry_values);
        selTargetSet[i]=new StdSelector(this,tr("Import to set:"),2+import_info.nr_of_target_sets,entr2);
        selTargetSet[i]->setValues(entry_values2);
        selTargetColumn[i]=new StdSelector(this,tr("Import as:"),6,entr3);
        grid1->addWidget(lblDescription[i],index2,0);
        grid1->addWidget(selFormat[i],index2,1);
        grid1->addWidget(selTargetSet[i],index2,2);
        grid1->addWidget(selTargetColumn[i],index2++,3);
        selFormat[i]->setCurrentValue(import_info.col_format[i]);
    }
    if (allocated_selectors>0)
    {
        selTargetSet[0]->setCurrentValue(-2);//All
        selTargetColumn[0]->setCurrentValue(0);//X
        for (int i=1;i<allocated_selectors;i++)
        {
            if (i-1<import_info.nr_of_target_sets)
                selTargetSet[i]->setCurrentValue(import_info.target_sets[i-1]);//the set
            else
                selTargetSet[i]->setCurrentValue(-1);
            selTargetColumn[i]->setCurrentValue(1);//Y
        }
    }
    delete[] entr;
    delete[] entr2;
    delete[] entr3;
    delete[] entry_values2;

}

void frmCSVImporter::doReguess(void)
{
    FileNames.clear();
    QString testText=ledFileName->text();
    QStringList list=testText.split(";");
    //qDebug() << "list.length=" << list.length();
        for (int i=0;i<list.length();i++)
        FileNames << list.at(i);
        if (FileNames.length()<1) return;
    exists=get_file_infos(FileNames.at(0),readable,writable,size_kB);
//exists=get_file_infos(ledFileName->text(),readable,writable,size_kB);
if (readable==false || exists==false) return;
    readFirstLines();
    selSetsToRead->setValue(import_info.columns_to_read-1);
    read_inputs();
    recreate_input_selectors();
}

void frmCSVImporter::doOpen(void)
{
//QString filename=fileDialog->getOpenFileName(this,tr("Open CSV file"));
QString filename;
QStringList filenames=fileDialog->getOpenFileNames(this,tr("Open CSV file"));
if (filenames.length()<1) return;
filename=filenames.at(0);
for (int i=1;i<filenames.length();i++)
{
filename+=QString(";")+filenames.at(i);
}
    //if (!filename.isEmpty())
    //{
        ledFileName->setText(filename);
        readFirstLines();
        selSetsToRead->setValue(import_info.columns_to_read-1);
        read_inputs();
        recreate_input_selectors();
    //}
}

void frmCSVImporter::readFirstLines(void)
{
    read_inputs();
    QByteArray line,firstLine;
    QFile file(import_info.filename);
    QString text1;
    int counter=0,ret;
    lblFileContents->clear();
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        return;
    }
    while (!file.atEnd() && counter<import_info.headerlines)
    {
        line = file.readLine(1024);
        text1=QString(line.constData());
        text1.chop(1);
        lblFileContents->append(text1);
        counter++;
    }
    lblFileContents->append(QString("-#-#-#-#-#-#-#-#-"));
    counter=0;
    while (!file.atEnd() && counter<6)//read at most 6 lines
    {
        line = file.readLine(1024);
        text1=QString(line.constData());
        text1.chop(1);
        lblFileContents->append(text1);
        if (counter==0) firstLine=line;
        counter++;
    }
    lblFileContents->append(QString("..."));
    /*text1=QString(firstLine.constData());
text1.chop(1);
ind=text1.indexOf(import_info.datsep);
if (ind==-1) ind=text1.length();
text1=text1.left(ind);
ind=text1.count(import_info.colsep)+1;
sprintf(dummy,"--> %d data columns found per set",ind);
lblFileContents->append(tr("Analyzed line:"));
lblFileContents->append(text1);
lblFileContents->append(QString(dummy));*/
    file.close();

    int ncols,*colformats=NULL;

    ret=guess_column_format(import_info,&ncols,&colformats);
    //if (colformats==NULL) cout << "colformat==NULL n=" << ncols << endl;
    if (ret==RETURN_FAILURE || colformats==NULL)
    {
        lblFileContents->append(QString("Unable to guess column formats..."));
    }
    else
    {
        import_info.columns_to_read=ncols;
        if (import_info.col_format!=NULL)
            delete[] import_info.col_format;
        import_info.col_format=new int[import_info.columns_to_read];
        memcpy(import_info.col_format,colformats,sizeof(int)*ncols);

        sprintf(dummy,"Guessed number of columns=%d\nGuessed column formats:",ncols);
        lblFileContents->append(QString(dummy));
        for (int i=0;i<ncols;i++)
        {
            if (colformats[i]==FFORMAT_STRING)
            {
                sprintf(dummy,"Column %d = %s",i,"String");
            }
            else if (colformats[i]==FFORMAT_DATE)
            {
                sprintf(dummy,"Column %d = %s",i,"Date/Time");
            }
            else
            {
                sprintf(dummy,"Column %d = %s",i,"Number");
            }
            lblFileContents->append(QString(dummy));
        }
    }
    if (colformats!=NULL)
        delete[] colformats;
}

void frmCSVImporter::init(void)
{
    graphselector->update_number_of_entries();
    graphselector->set_graph_number(get_cg(),false);
}

void frmCSVImporter::headerLinesChanged(int c)
{
    (void)c;
    readFirstLines();
    selSetsToRead->setValue(import_info.columns_to_read-1);
    read_inputs();
    recreate_input_selectors();
}

void frmCSVImporter::setCountChanged(int c)
{
    (void)c;
    read_inputs();
    recreate_input_selectors();
}

void frmCSVImporter::doApply(void)
{
    FileNames.clear();
    QString testText=ledFileName->text();
    QStringList list=testText.split(";");
    //qDebug() << "list.length=" << list.length();
        for (int i=0;i<list.length();i++)
        FileNames << list.at(i);
        if (FileNames.length()<1) return;
    exists=get_file_infos(FileNames.at(0),readable,writable,size_kB);
//exists=get_file_infos(ledFileName->text(),readable,writable,size_kB);
if (readable==false || exists==false)
{
//QMessageBox::information(this,tr("Error"),tr("No CSV-file selected!"));
errmsg(tr("No CSV-file selected!").toLocal8Bit().constData());
ApplyError=true;
return;
}
    ApplyError=false;
    read_inputs();//read all settings
    read_import_settings();//read the import-settings for every column
    if (import_info.nr_of_target_sets<=0)
    {
        errmsg(tr("No suitable target sets for import selected!").toLocal8Bit().constData());
        ApplyError=true;
    }
    if (ApplyError==true) return;
    for (int i=0;i<FileNames.length();i++)
    {
        if (import_info.filename) delete[] import_info.filename;
        import_info.filename=new char[8+FileNames.at(i).toLocal8Bit().length()*2];
        strcpy(import_info.filename,FileNames.at(i).toLocal8Bit().constData());
        /*if (i>0)
        {
            for (int j=0;j<import_info.nr_of_target_sets;j++)
            {
            import_info.target_sets[i]
            }
        }*/
        if (csvImport(import_info)==RETURN_SUCCESS)//do the actual import
        {
            if (chkAutoscaleOnRead->isChecked()) mainWin->doAutoScale();//if import worked --> rescale
            mainWin->mainArea->completeRedraw();//redraw
        }
        else
        {
        ApplyError=true;//tell Accept, than an error occured
        }
    }
}

void frmCSVImporter::doAccept(void)
{
    ApplyError=false;
    doApply();
    if (ApplyError==false)
        doClose();
}

void frmCSVImporter::doClose(void)
{
    hide();
}

frmProgressWin::frmProgressWin(QWidget * parent):QDialog(parent)
{
setWindowTitle(tr("Current progress"));
lblText=new QLabel(QString(""),this);
progress=new QProgressBar(this);
layout=new QVBoxLayout;
layout->setMargin(0);
layout->setSpacing(0);
layout->addWidget(lblText);
layout->addWidget(progress);
setLayout(layout);
resize(LastSize_FormProgress);
}

frmProgressWin::~frmProgressWin()
{
    LastSize_FormProgress=this->size();
}

void frmProgressWin::init(QString text,int max)
{
    if (text.isEmpty())
    {
    lblText->setVisible(false);
    }
    else
    {
    lblText->setText(text);
    lblText->setVisible(true);
    }
progress->setRange(0,max);
progress->setValue(0);
}

void frmProgressWin::increase(void)
{
progress->setValue(progress->value()+1);
qApp->processEvents();
}

void frmProgressWin::setVal(int val)
{
progress->setValue(val);
qApp->processEvents();
}

frmQuestionDialog::frmQuestionDialog(QWidget * parent):QDialog(parent)
{
//lblIcon=new QLabel(this);
//lblIcon->setPixmap(qApp->style()->standardPixmap(QStyle::SP_MessageBoxQuestion));
    lblIcon=new QLabel(this);
    QPixmap pm;
    pm=qApp->style()->standardIcon(QStyle::SP_MessageBoxQuestion).pixmap(50,50);
    lblIcon->setPixmap(pm);

layout=new QGridLayout();
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);
cmdYes=new QPushButton(tr("Yes"),this);
cmdNo=new QPushButton(tr("No"),this);
cmdSave=new QPushButton(tr("Save"),this);
cmdSaveAs=new QPushButton(tr("SaveAs..."),this);
connect(cmdYes,SIGNAL(clicked()),SLOT(doYes()));
connect(cmdNo,SIGNAL(clicked()),SLOT(doNo()));
connect(cmdSave,SIGNAL(clicked()),SLOT(doSave()));
connect(cmdSaveAs,SIGNAL(clicked()),SLOT(doSaveAs()));
lblText=new QLabel("",this);
QFont fnt=lblText->font();
fnt.setPixelSize(16);
lblText->setFont(fnt);

//layout->addWidget(lblIcon,0,0,2,2);
//layout->addWidget(lblText,0,2,2,4);
//layout->addWidget(cmdYes,2,2,1,1);
//layout->addWidget(cmdNo,2,3,1,1);
//layout->addWidget(cmdSave,2,4,1,1);
//layout->addWidget(cmdSaveAs,2,5,1,1);
layout->addWidget(lblIcon,0,0,1,1);
layout->addWidget(lblText,0,1,1,3);
layout->addWidget(cmdYes,1,0,1,1);
layout->addWidget(cmdNo,1,1,1,1);
layout->addWidget(cmdSave,1,2,1,1);
layout->addWidget(cmdSaveAs,1,3,1,1);

setLayout(layout);
resize(LastSize_FormQuestion);
}

frmQuestionDialog::~frmQuestionDialog()
{
    LastSize_FormQuestion=this->size();
}

void frmQuestionDialog::init(QString text,QString title_text,bool show_Save,bool show_SaveAs,bool show_Yes, bool show_No)
{
lblText->setText(text);
setWindowTitle(title_text);
cmdYes->setVisible(show_Yes);
cmdNo->setVisible(show_No);
cmdSave->setVisible(show_Save);
cmdSaveAs->setVisible(show_SaveAs);
}

void frmQuestionDialog::doYes(void)
{
    //done(QMessageBox::Yes);
    done(1);
}

void frmQuestionDialog::doNo(void)
{
    //done(QMessageBox::No);
    done(0);//Cancel
}

void frmQuestionDialog::doSave(void)
{
    if (strcmp (get_docname(), NONAME) != 0)
    {
    bool readable,writeable,overwrite=false;
    long kB;
    bool exists=get_file_infos(QString(get_docname()),readable,writeable,kB);
        if (exists==true)
        {
        int ret=QMessageBox::question(this,tr("Warning! File exists!"),tr("Overwite file ")+QString(get_docname())+tr("?"),QMessageBox::Yes,QMessageBox::No);
            if (ret==QMessageBox::Yes)
            overwrite=true;
            else
            overwrite=false;
        }
        if (exists==false || overwrite==true)
        {
        save_project(get_docname());
        done(1);
        }
        else
        done(0);
    }
    else
    doSaveAs();
}

void frmQuestionDialog::doSaveAs(void)
{
QString filename=QFileDialog::getSaveFileName(this,tr("Save Project"));
//cout << endl << "filename=#" << filename.toLocal8Bit().constData() << "#" << endl;
if (filename.isEmpty())
{
done(0);
return;
}

QFileInfo finfo(filename);
QString suf=finfo.suffix();
if (suf.isEmpty() && auto_set_agr_extension)
{
filename=finfo.path()+QDir::separator()+finfo.completeBaseName()+QString(".agr");
}

bool readable,writeable,overwrite=false;
long kB;
bool exists=get_file_infos(filename,readable,writeable,kB);

if (exists==true)
{
int ret=QMessageBox::question(this,tr("Warning! File exists!"),tr("Overwite file ")+filename+tr("?"),QMessageBox::Yes,QMessageBox::No);
    if (ret==QMessageBox::Yes)
    overwrite=true;
    else
    overwrite=false;
}
if (exists==false || overwrite==true)
{
save_project(filename.toLocal8Bit().data());
done(1);
}
else
done(0);
}

frmSimpleListSelectionDialog::frmSimpleListSelectionDialog(QWidget * parent):QDialog(parent)
{
layout=new QGridLayout();
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);
selNames=new StdSelector(this,tr("Load exisiting standard binary format:"),0,NULL);
ledNewName=new stdLineEdit(this,tr("Enter new name for binary format:"));
cmdCancel=new QPushButton(tr("Cancel"),this);
connect(cmdCancel,SIGNAL(clicked()),SLOT(doCancel()));
cmdSelect=new QPushButton(tr("Load"),this);
connect(cmdSelect,SIGNAL(clicked()),SLOT(doSelect()));
cmdNew=new QPushButton(tr("Use new name"),this);
connect(cmdNew,SIGNAL(clicked()),SLOT(doNew()));
return_name=QString("");
return_nr=-1;//nothing
setWindowTitle(tr("Select standard binary format"));
layout->addWidget(selNames,0,0,1,1);
layout->addWidget(cmdSelect,0,1,1,1);
layout->addWidget(ledNewName,1,0,1,1);
layout->addWidget(cmdNew,1,1,1,1);
layout->addWidget(cmdCancel,2,1,1,1);
setLayout(layout);
resize(LastSize_FormSimpleListSel);
}

frmSimpleListSelectionDialog::~frmSimpleListSelectionDialog()
{
    LastSize_FormSimpleListSel=this->size();
}

void frmSimpleListSelectionDialog::init(QString * name_list,int nr,bool read)
{
selNames->setNewEntries(nr,name_list);
ledNewName->setText("");
    if (read==true)
    {
    selNames->lblText->setText(tr("Load exisiting standard binary format:"));
    ledNewName->setVisible(false);
    cmdNew->setVisible(false);
    cmdSelect->setText(tr("Load"));
    }
    else
    {
    selNames->lblText->setText(tr("Overwrite exisiting standard binary format:"));
    ledNewName->setVisible(true);
    cmdNew->setVisible(true);
    cmdSelect->setText(tr("Save"));
    }
}

void frmSimpleListSelectionDialog::doCancel(void)
{
    return_name=QString("");
    return_nr=-1;
    done(0);
}

void frmSimpleListSelectionDialog::doSelect(void)
{
    return_name=selNames->entries[selNames->currentIndex()];
    return_nr=selNames->currentIndex();
    done(1);
}

void frmSimpleListSelectionDialog::doNew(void)
{
    if (ledNewName->text().isEmpty())
    {
    QMessageBox::warning(this,tr("Error"),tr("Please enter a proper name for the binary format!"));
    }
    else
    {
    QString text=ledNewName->text();
    return_name=text.replace(QString(" "),QString("_"));
    return_nr=-2;//new name/file
    done(1);
    }
}

frmReportOnFitParameters::frmReportOnFitParameters(QWidget * parent):QDialog(parent)
{
layout=new QGridLayout();
layout->setMargin(STD_MARGIN);
layout->setSpacing(0);
int line=0,col=0;
cmdReport=new QPushButton(tr("Report"),this);
cmdUpdate=new QPushButton(tr("Update"),this);
layout->addWidget(cmdUpdate,line,0,1,2);
layout->addWidget(cmdReport,line++,2,1,2);
lblName[0]=new QLabel(tr("Name"),this);
lblName[1]=new QLabel(tr("Name"),this);
lblValue[0]=new QLabel(tr("Value"),this);
lblValue[1]=new QLabel(tr("Value"),this);
    layout->addWidget(lblName[0],line,0);
    layout->addWidget(lblName[1],line,2);
    layout->addWidget(lblValue[0],line,1);
    layout->addWidget(lblValue[1],line++,3);
setWindowTitle(tr("Report on fit parameters"));

/// Decimaltrennzeichen umwandeln (auch in report!)

QLocale newLocale=(DecimalPointToUse=='.')?(*dot_locale):(*comma_locale);
for (int i=0;i<MAXPARM;i++)
{
spnPara[i]=new LineWidthSelector(this);
spnPara[i]->lblText->setText(QString("a")+QString::number(i));
spnPara[i]->spnLineWidth->setDecimals(6);
spnPara[i]->spnLineWidth->setSingleStep(0.0001);
spnPara[i]->spnLineWidth->setRange(-DBL_MAX,DBL_MAX);
spnPara[i]->setLocale(newLocale);
if (i==MAXPARM/2) {col=2;line=2;}
layout->addWidget(spnPara[i],line++,col,1,2);
}
cmdSet=new QPushButton(tr("Set"),this);
cmdClose=new QPushButton(tr("Close"),this);
connect(cmdClose,SIGNAL(clicked()),SLOT(doClose()));
connect(cmdSet,SIGNAL(clicked()),SLOT(doSet()));
connect(cmdReport,SIGNAL(clicked()),SLOT(doReport()));
connect(cmdUpdate,SIGNAL(clicked()),SLOT(init()));
layout->addWidget(cmdSet,line,0,1,2);
layout->addWidget(cmdClose,line++,2,1,2);
setLayout(layout);
resize(LastSize_FormReportFitParameters);
}

frmReportOnFitParameters::~frmReportOnFitParameters()
{
    LastSize_FormReportFitParameters=this->size();
}

void frmReportOnFitParameters::init(void)
{
    for (int i=0;i<MAXPARM;i++)
    {
    spnPara[i]->setValue(nonl_parms[i].value);
    }
}

void frmReportOnFitParameters::doSet(void)
{
    for (int i=0;i<MAXPARM;i++)
    {
    nonl_parms[i].value=spnPara[i]->value();
    }
}

void frmReportOnFitParameters::doReport(void)
{
QString tmptext;
char dummy_vals[128];
    stufftext(tr("Current settings for fit-parameters:").toLocal8Bit().constData());
    for (int i=0;i<MAXPARM;i++)
    {
    tmptext=QString("A")+QString::number(i)+QString("=");
    sprintf(dummy_vals,sformat,nonl_parms[i].value);
    SetDecimalSeparatorToUserValue(dummy_vals,false);
    tmptext+=QString(dummy_vals)+QString("\t ")+tr("Min=");
    sprintf(dummy_vals,sformat,nonl_parms[i].min);
    SetDecimalSeparatorToUserValue(dummy_vals,false);
    tmptext+=QString(dummy_vals)+QString("\t ")+tr("Max=");
    sprintf(dummy_vals,sformat,nonl_parms[i].max);
    SetDecimalSeparatorToUserValue(dummy_vals,false);
    tmptext+=QString(dummy_vals)+QString("\t ")+tr("Use constrains=")+(nonl_parms[i].constr==0?tr("No"):tr("Yes"));
    stufftext(tmptext.toLocal8Bit().constData());
    }
}

void frmReportOnFitParameters::doClose(void)
{
hide();
}

frmGeometricEvaluation::frmGeometricEvaluation(QWidget * parent):QDialog(parent)
{
setWindowTitle(tr("QtGrace: Geometric evaluation"));
int index=0;
layout=new QGridLayout(this);
layout->setSpacing(STD_SPACING);
layout->setMargin(STD_MARGIN);
sourceSelect=new grpSelect(tr("Source:"),this);
sourceSelect->lblGraph->setText(tr("Select one source graph:"));
sourceSelect->lblSet->setText(tr("Select two source sets:"));
int nr_of_entries=2;
QString * entries=new QString[8];

entries[0]=tr("Intersections");
entries[1]=tr("Intersection angles");
selOption=new StdSelector(this,tr("Find:"),nr_of_entries,entries);

nr_of_entries=3;
entries[0]=tr("Intersection-X");
entries[1]=tr("Index");
entries[2]=tr("None / report only");
selLoadX=new StdSelector(this,tr("Load x as:"),nr_of_entries,entries);

nr_of_entries=7;
entries[0]=tr("None");
entries[1]=tr("Region 0");
entries[2]=tr("Region 1");
entries[3]=tr("Region 2");
entries[4]=tr("Region 3");
entries[5]=tr("Region 4");
entries[6]=tr("Inside graph");
selRegion=new StdSelector(this,tr("Restrictions:"),nr_of_entries,entries);
chkInvert=new QCheckBox(tr("Negate region"),this);

delete[] entries;
buttons=new stdButtonGroup(this);
connect(buttons->cmdApply,SIGNAL(clicked()),SLOT(doApply()));
connect(buttons->cmdAccept,SIGNAL(clicked()),SLOT(doAccept()));
connect(buttons->cmdClose,SIGNAL(clicked()),SLOT(doClose()));

layout->addWidget(sourceSelect,index++,0);
layout->addWidget(selOption,index++,0);
layout->addWidget(selLoadX,index++,0);
layout->addWidget(selRegion,index++,0);
layout->addWidget(chkInvert,index++,0);
layout->addWidget(buttons,index++,0);

setLayout(layout);
resize(LastSize_FormGeometricEvaluation);
}

frmGeometricEvaluation::~frmGeometricEvaluation()
{
    LastSize_FormGeometricEvaluation=this->size();
}

void frmGeometricEvaluation::init(void)
{
sourceSelect->update_number_of_entries();
sourceSelect->set_graph_nr(cg);
sourceSelect->listGraph->set_graph_number(cg,false);
}

void frmGeometricEvaluation::doApply(void)
{
int src_g,n_src_sets,*src_s=new int[2];
int option,load_x,sorton,invert_region;
int n_set;
int ret,is_in;
int nr_of_intersections=0,nr_of_points_in_region=0;
char dummy[128];
QString report,n_legend;
double * intersection_x=NULL;
double * intersection_y=NULL;
double * intersection_a=NULL;
double * m1=NULL;
double * m2=NULL;
option=selOption->currentValue();
load_x=selLoadX->currentValue();
switch (selRegion->currentIndex())
{
case 0:
default:
    sorton=RESTRICT_NONE;
    break;
case 1:
    sorton=RESTRICT_REG0;
    break;
case 2:
    sorton=RESTRICT_REG1;
    break;
case 3:
    sorton=RESTRICT_REG2;
    break;
case 4:
    sorton=RESTRICT_REG3;
    break;
case 5:
    sorton=RESTRICT_REG4;
    break;
case 6:
    sorton=RESTRICT_WORLD;
    break;
}
invert_region=chkInvert->isChecked()==true?1:0;
sourceSelect->listGraph->get_selection(&n_src_sets,&src_s);
if (n_src_sets!=1)
{
errwin(tr("Please select a single source-graph.").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}
else src_g=src_s[0];
sourceSelect->listSet->get_selection(&n_src_sets,&src_s);
if (n_src_sets!=2)
{
errwin(tr("Please select two source-sets.").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}

if (getsetlength(src_g,src_s[0])<=1 || getsetlength(src_g,src_s[1])<=1)
{
errwin(tr("Please select two source-sets with more than one point each.").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}

if (option==0 || option==1)
{
ret=get_all_intersection_points_between_two_sets(src_g,src_s[0],src_g,src_s[1],&intersection_x,&intersection_y,&nr_of_intersections);

if (ret==RETURN_FAILURE || intersection_x==NULL || intersection_y==NULL || nr_of_intersections<1)
{
errwin(tr("No Intersections found!").toLocal8Bit().constData());
goto finish_Apply_geomEval;
}

nr_of_points_in_region=0;
new_set_no=-1;
    if (m1!=NULL) delete[] m1;
    m1=new double[nr_of_intersections+1];
    if (m2!=NULL) delete[] m2;
    m2=new double[nr_of_intersections+1];

//reduce intersections to the ones inside the selected region
for (int i=0;i<nr_of_intersections;i++)
{
is_in=inregion(sorton,intersection_x[i],intersection_y[i]);
    if (sorton==RESTRICT_NONE || (is_in && invert_region==false) || (!is_in && invert_region==true))
    {
    m1[nr_of_points_in_region]=intersection_x[i];
    m2[nr_of_points_in_region]=intersection_y[i];
    nr_of_points_in_region++;
    }
}
memcpy(intersection_x,m1,sizeof(double)*nr_of_points_in_region);
memcpy(intersection_y,m2,sizeof(double)*nr_of_points_in_region);
nr_of_intersections=nr_of_points_in_region;
//now we have reduced the intersections to the ones inside the selected region
    if (ret==RETURN_FAILURE || intersection_x==NULL || intersection_y==NULL || nr_of_points_in_region<=0)
    {
    errwin(tr("No Intersections found!").toLocal8Bit().constData());
    goto finish_Apply_geomEval;
    }
}//end optioon 0 || 1

switch (option)
{
case 0://Intersections
n_legend=tr("Intersection points between ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[0])+tr(" and ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[1]);
    if (load_x==2)//report only
    {
    report.clear();
    report+=n_legend+QString(":\n");
        for (int i=0;i<nr_of_intersections;i++)
        {
        is_in=inregion(sorton,intersection_x[i],intersection_y[i]);
            if (sorton==RESTRICT_NONE || (is_in && invert_region==false) || (!is_in && invert_region==true))
            {
            sprintf(dummy,sformat,intersection_x[i]);
            report+=QString("( ")+QString(dummy);
            sprintf(dummy,sformat,intersection_y[i]);
            report+=QString(" | ")+QString(dummy)+QString(" )\n");
            nr_of_points_in_region++;
            }
        }
        if (nr_of_points_in_region<=0)
        {
        report+=tr("No intersection points inside selected region found.\n");
        }
    stufftext(report.toLocal8Bit().data());
    }
    else//create sets
    {
    n_set=nextset(src_g);
    setlength(src_g,n_set,nr_of_intersections);
        if (load_x==0)//x-values
        {
        memcpy(getcol(src_g,n_set,0),intersection_x,sizeof(double)*nr_of_intersections);
        }
        else//just an index
        {
            for (int i=0;i<nr_of_intersections;i++)
            g[src_g].p[n_set].data.ex[0][i]=i;
        }
    memcpy(getcol(src_g,n_set,1),intersection_y,sizeof(double)*nr_of_intersections);
        if (sorton!=RESTRICT_NONE)
        {
        restrict_set_to_region(src_g,n_set,sorton,invert_region);
        }
        if (getsetlength(src_g,n_set)>0)
        {
        set_legend_string(src_g,n_set,n_legend.toLocal8Bit().data());
        SetsCreated(1,&src_g,&n_set,UNDO_COMPLETE);//undo-stuff
        }
    }
break;
case 1://Intersection angles
n_legend=tr("Intersection angles between ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[0])+tr(" and ")+QString("G")+QString::number(src_g)+QString(".S")+QString::number(src_s[1]);
//we already got the inersection points, now we need the angles as well
intersection_a=new double[2+nr_of_intersections];
get_intersection_angles(src_g,src_s[0],src_g,src_s[1],intersection_x,intersection_a,nr_of_intersections);

    if (load_x==2)//report only
    {
    report.clear();
    report+=n_legend+QString(":\n");
        for (int i=0;i<nr_of_intersections;i++)
        {
            sprintf(dummy,sformat,intersection_x[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString("( ")+QString(dummy);
            sprintf(dummy,sformat,intersection_y[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(" | ")+QString(dummy)+QString(" ): ")+tr("angle")+QString("= ");
            sprintf(dummy,sformat,intersection_a[i]);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(dummy)+QString(" rad | ");
            sprintf(dummy,sformat,intersection_a[i]*57.295779513082325);
            if (DecimalPointToUse!='.') SetDecimalSeparatorToUserValue(dummy);
            report+=QString(dummy)+QString(" degrees\n");
        }
    stufftext(report.toLocal8Bit().data());
    }
    else//create set
    {
    n_set=nextset(src_g);
    setlength(src_g,n_set,nr_of_intersections);
        if (load_x==0)
        {
        memcpy(getcol(src_g,n_set,0),intersection_x,sizeof(double)*nr_of_intersections);
        }
        else
        {
            for (int i=0;i<nr_of_intersections;i++)
            g[src_g].p[n_set].data.ex[0][i]=i;
        }
    memcpy(getcol(src_g,n_set,1),intersection_a,sizeof(double)*nr_of_intersections);
        if (getsetlength(src_g,n_set)>0)
        {
        set_legend_string(src_g,n_set,n_legend.toLocal8Bit().data());
        SetsCreated(1,&src_g,&n_set,UNDO_COMPLETE);
        }
    }
break;
}
mainWin->mainArea->completeRedraw();
finish_Apply_geomEval:
if (intersection_x!=NULL) delete[] intersection_x;
if (intersection_y!=NULL) delete[] intersection_y;
if (intersection_a!=NULL) delete[] intersection_a;
if (m1!=NULL) delete[] m1;
if (m2!=NULL) delete[] m2;
if (src_s!=NULL) delete[] src_s;
}

void frmGeometricEvaluation::doAccept(void)
{
ApplyError=false;
doApply();
if (ApplyError==true) doClose();
}

void frmGeometricEvaluation::doClose(void)
{
hide();
}

//padding_type=PROCESSING_INTERPOLATION
//padding_type=PROCESSING_ZERO_PADDING --> include zeros at start and at end
//padding_type=PROCESSING_FIRST_LAST_PADDING --> include the same values at the beginning and at the end
int create_padded_set(int n_gno,int & n_sno,int o_gno,int o_sno,int new_length,int padding_type)//creates new set (n_gno,n_sno) from old set (o_gno,o_sno), they should not be the same!; if n_sno==-1 --> create new set as next set nr
{
    int resno,setlen=getsetlength(o_gno,o_sno);
    int len_diff=new_length-setlen;
    int add_at_beginning=len_diff/2;
    int add_at_end=len_diff-add_at_beginning;
    double y0,y1;
    double xmin,xmax,ymin,ymax;
    double xspace=0.0;
    double * mesh = NULL;
    int error=RETURN_SUCCESS;
    int index;
    if (n_sno==-1)
    {
        n_sno = nextset(n_gno);
    }
    //interpolate or add zeros (get min_x and max_x first)
    resno = getsetminmax(o_gno,o_sno,&xmin,&xmax,&ymin,&ymax, FALSE);
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in computation of min and max").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    bool mono=monospaced_v6(g[o_gno].p[o_sno].data.ex[0], setlen, &xspace);
    if (!mono && (padding_type==PROCESSING_ZERO_PADDING || padding_type==PROCESSING_FIRST_LAST_PADDING))
    {
        errmsg(QObject::tr("Error! Set not monospaced in x! Switching to interpolation!").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    do_copyset(o_gno,o_sno,n_gno,n_sno);//allocate new set
    sortset(n_gno,n_sno,DATA_X,dataset_type(n_gno,n_sno));
    y0=g[o_gno].p[o_sno].data.ex[1][0];
    y1=g[o_gno].p[o_sno].data.ex[1][setlen-1];
    error=setlength(n_gno,n_sno,new_length);
    if (error==RETURN_FAILURE)
    {
        errmsg(QObject::tr("Error! Unable to allocate enough space for set-data!").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    if (padding_type==PROCESSING_ZERO_PADDING && mono==TRUE)
    {
        //zero padding
        index=0;
        for (int i=0;i<add_at_beginning;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=xmin-(add_at_beginning-i)*xspace;
            g[n_gno].p[n_sno].data.ex[1][index++]=0.0;
        }
        for (int i=0;i<setlen;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=g[o_gno].p[o_sno].data.ex[0][i];
            g[n_gno].p[n_sno].data.ex[1][index++]=g[o_gno].p[o_sno].data.ex[1][i];
        }
        for (int i=0;i<add_at_end;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=xmax+(1+i)*xspace;
            g[n_gno].p[n_sno].data.ex[1][index++]=0.0;
        }
        //cout << "zero-padding" << endl;
        sortset(n_gno,n_sno,DATA_X,dataset_type(n_gno,n_sno));
    }
    else if (padding_type==PROCESSING_FIRST_LAST_PADDING && mono==TRUE)
    {
        //start/end-padding
        index=0;
        for (int i=0;i<add_at_beginning;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=xmin-(add_at_beginning-i)*xspace;
            g[n_gno].p[n_sno].data.ex[1][index++]=y0;
        }
        for (int i=0;i<setlen;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=g[o_gno].p[o_sno].data.ex[0][i];
            g[n_gno].p[n_sno].data.ex[1][index++]=g[o_gno].p[o_sno].data.ex[1][i];
        }
        for (int i=0;i<add_at_end;i++)
        {
            g[n_gno].p[n_sno].data.ex[0][index]=xmax+(1+i)*xspace;
            g[n_gno].p[n_sno].data.ex[1][index++]=y1;
        }
        sortset(n_gno,n_sno,DATA_X,dataset_type(n_gno,n_sno));
        //cout << "start/end-padding y=" << y0 << "-" << y1 << endl;
    }
    else
    {
        //interpolation
        mesh = allocate_mesh(xmin, xmax, new_length);
        resno = do_interp(o_gno,o_sno,n_gno,n_sno,mesh,new_length, 0, 0);
        if (resno != RETURN_SUCCESS)
        {
            errmsg(QObject::tr("Error in generation of interpolated set").toLocal8Bit().constData());
            return RETURN_FAILURE;
        }
        //cout << "interpolation" << endl;
    }
    return RETURN_SUCCESS;
}

int do_filter_on_one_set(int n_gno,int n_sno,int o_gno,int o_sno,int type,int realization,int restr_type,int restr_negate,int abs,int debug,char * formula,int point_extension,int oversampling,double ripple,int order1,int order2,double f1,double f2)
{
    if (is_set_active(o_gno,o_sno)==FALSE)//original set does not exist
    {
        sprintf(dummy,"[G%d.S%d]",o_gno,o_sno);
        QString ErrorText=QObject::tr("Error filtering set: Set does not exis! ");
        ErrorText+=QString(dummy);
        errwin(ErrorText.toLatin1().constData());
        return RETURN_FAILURE;
    }
    double factor=1.0;
    if (realization==FILTER_BRICKWALL && abs==1)
    {
        factor=1.0/sqrt(2.0);
    }

    //sprintf(dummy,"Filter: (%d,%d)-->(%d,%d), factor=%f",o_gno,o_sno,n_gno,n_sno,factor);
    //qDebug(dummy);

    int error, resno;/// error benutzen!
    char fstr[256];
    char * rarray;
    int setlen,color=g[o_gno].p[o_sno].linepen.color+1;
    if (color>=(int)number_of_colors()) color=1;//go back to black
    if (is_set_active(n_gno,n_sno)==TRUE) color=g[n_gno].p[n_sno].linepen.color;
    int n_setlen;
    double xspace;
    bool mono;
    int workset0,workset1,workset2,workset3,workset4;/// sets beschriften!
    workset0 = nextset(n_gno);
    do_copyset(o_gno, o_sno, n_gno, workset0);
    int padded_set=nextset(n_gno);
    do_copyset(o_gno, o_sno, n_gno, padded_set);
    int fft_original=nextset(n_gno);
    do_copyset(o_gno, o_sno, n_gno, fft_original);
    workset4=nextset(n_gno);//this is going to be the cut-off/filter-function
    do_copyset(o_gno, o_sno, n_gno, workset4);
    int filtered_data=nextset(n_gno);
    do_copyset(o_gno, o_sno, n_gno, filtered_data);
        setcomment(n_gno, workset0,"");
        setcomment(n_gno, padded_set,"");
        setcomment(n_gno, fft_original,"");
        setcomment(n_gno, workset4,"");
        setcomment(n_gno, filtered_data,"");
    set_legend_string(n_gno, workset0,"");
    set_legend_string(n_gno, padded_set,"");
    set_legend_string(n_gno, fft_original,"");
    set_legend_string(n_gno, workset4,"");
    set_legend_string(n_gno, filtered_data,"");

    double * mesh = NULL;
    double * real_data=NULL;
    double * imag_data=NULL;
    double * cutoff_function=NULL;
    double * cut_r=NULL;
    double * cut_i=NULL;
    struct komplex tmp_ko,tmp_ko2;
    double * cut_r2;
    double * cut_i2;
    int n_pts,nu;
    double amp_correction;
    char * filter_name=new char[1024];
    char * filter_dummy=new char[1024];
    sprintf(filter_name,"Set G%d.S%d filtered with ",o_gno,o_sno);
    switch (type)
    {
    default:
    case FILTER_LOW_PASS:
    sprintf(filter_dummy,"Low-Pass-Filter: CutOff = %g kHz, Order = %d, ",f1/1000.0,order1);
    break;
    case FILTER_BAND_PASS:
    sprintf(filter_dummy,"Band-Pass-Filter: Pass = %g kHz - %g kHz, Order = %d / %d, ",f1/1000.0,f2/1000.0,order1,order2);
    break;
    case FILTER_HIGH_PASS:
    sprintf(filter_dummy,"High-Pass-Filter: CutOff = %g kHz, Order = %d, ",f1/1000.0,order1);
    break;
    case FILTER_BAND_STOP:
    sprintf(filter_dummy,"Band-Stop-Filter: Stop = %g kHz - %g kHz, Order = %d / %d, ",f1/1000.0,f2/1000.0,order1,order2);
    break;
    }
    strcat(filter_name,filter_dummy);
    switch (realization)
    {
    default:
    case FILTER_BRICKWALL:
    strcpy(filter_dummy,"Brickwall");
    break;
    case FILTER_BUTTERWORTH:
    strcpy(filter_dummy,"Butterworth");
    break;
    case FILTER_BESSEL:
    strcpy(filter_dummy,"Bessel");
    break;
    case FILTER_CHEBYCHEV:
    sprintf(filter_dummy,"Chebychev (Ripples = %g dB)",ripple);
    break;
    case FILTER_GAUSSIAN:
        sprintf(filter_name,"Set G%d.S%d filtered with ",o_gno,o_sno);
        switch (type)
        {
        default:
        case FILTER_LOW_PASS:
        sprintf(filter_dummy,"Low-Pass-Filter: CutOff = %g kHz, Gaussian",f1/1000.0);
        break;
        case FILTER_BAND_PASS:
        sprintf(filter_dummy,"Band-Pass-Filter: Pass = %g kHz - %g kHz, Gaussian",f1/1000.0,f2/1000.0);
        break;
        case FILTER_HIGH_PASS:
        sprintf(filter_dummy,"High-Pass-Filter: CutOff = %g kHz, Gaussian",f1/1000.0);
        break;
        case FILTER_BAND_STOP:
        sprintf(filter_dummy,"Band-Stop-Filter: Stop = %g kHz - %g kHz, Gaussian",f1/1000.0,f2/1000.0);
        break;
        }
    break;
    }
    strcat(filter_name,filter_dummy);
    delete[] filter_dummy;
    workset1=workset2=workset3=-1;
    error=0;
    /// fuer debug behalten:
    /// -umgerechnete Funktion mit zero-padding/interpolation
    /// -fft der Funktion
    /// -Filterfunktion
    /// -gefilterte Daten
    //first set to be created is n_sno which will be the set number for the result
    resno = get_restriction_array(o_gno,o_sno,restr_type, restr_negate, &rarray);//generate restriction array
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in evaluation of restriction").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    set_parser_setno(o_gno,o_sno);
    ///STEPS TO DO:
    //Calculate the real X-values (has to be time in seconds) and save them in new set (using the restriction) --> n_sno
    sprintf(fstr,"X=X*(%s)",formula);
    ReplaceDecimalSeparator(fstr);
    resno = do_compute(o_gno,o_sno,n_gno,workset0,rarray,fstr);
    //--> n_sno not interpolated yet! --> x-values will be needed at the end (but restriction has already been applied)
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in evaluation of x-axis conversion").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    setlen=getsetlength(n_gno,workset0);
    n_setlen=1<<((int)ceil(log((double)setlen)/log(2.0)));//get next power of two for interpolation
    if (point_extension==PROCESSING_INTERPOLATION)
        n_setlen*=(1<<oversampling);
    //interpolate or add points --> n_setlen will be new setlength (has to be power of 2 because of FFT)
    workset1 = nextset(n_gno);
    if (create_padded_set(n_gno,workset1,n_gno,workset0,n_setlen,point_extension)==RETURN_FAILURE)
    {
        errmsg(QObject::tr("Error! Unable to raise set length to power of 2!").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    //--> workset1 is a set with the points selected and the length a power of 2 (and possibly padded with extra points), x-axis is time in seconds
    workset2= nextset(n_gno);
    do_copyset(n_gno, workset1, n_gno, workset2);//workset2 is a copy of workset1 (workset1 is kept unchanged for debug reasons)
    workset3= nextset(n_gno);
    do_copyset(n_gno, workset1, n_gno, workset3);//workset3 has the original x-values (the y-values are lost and replaced by the results later)
    //workset4= nextset(n_gno);
    do_copyset(n_gno, workset1, n_gno, workset4);
    do_copyset(n_gno, workset1, n_gno, padded_set);
    n_pts=n_setlen;
    nu=(int)(ceil(log((double)n_setlen)/log(2.0)));
    real_data=new double[n_pts];
    imag_data=new double[n_pts];
    cutoff_function=new double[n_pts];
    cut_r=new double[n_pts];
    cut_i=new double[n_pts];
    //copy y-data into real part for fft
    memset(imag_data,0,sizeof(double)*n_pts);
    memcpy(real_data,g[n_gno].p[workset1].data.ex[1],sizeof(double)*n_pts);
    mono=monospaced_v6(g[n_gno].p[workset1].data.ex[0], n_pts, &xspace);
    if (!mono)
    {
        errmsg(QObject::tr("Error! Set not monospaced in x!").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    /*
    real_data ... ptr. to real part of data to be transformed
    imag_data ... ptr. to imag  "   "   "   "  "      "
    inv ..... Switch to flag normal or inverse transform
    n_pts ... Number of real data points
    nu ...... logarithm in base 2 of n_pts e.g. nu = 5 if n_pts = 32.
    int fft_v6(double *real_data, double *imag_data, int n_pts, int nu, int inv);
    */
    //do fft
    resno = fft_v6(real_data,imag_data,n_pts,nu,0);
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in forward fft").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    //generate cutoff function --> according to Filter-parameters set
    /* amplitude correction due to the zero padding etc. */
    amp_correction = 1.0/sqrt((double)n_pts);
    //we work on workset2 here (not workset1 or the original)
        for (int i=0;i<n_pts;i++)
        {
        g[n_gno].p[workset2].data.ex[0][i]=((double)i)/(xspace*n_pts);//x-values in frequency-space
        g[n_gno].p[workset2].data.ex[1][i]=amp_correction*hypot(real_data[i], imag_data[i]);
        }
    for (int i=n_pts/2;i<n_pts;i++)//the second half of the x-values has to have the other sign
        g[n_gno].p[workset2].data.ex[0][i]=-g[n_gno].p[workset2].data.ex[0][n_pts-i-1];
    do_copyset(n_gno, workset2, n_gno, fft_original);
    ///order=n*20dB/Dekade
    ///--> 1.order = decrease by factor 10 at frequency*10
    ///--> 2.order = decrease by factor 100 at frequency*10
    ///--> n-th Order= decrease by factor 10^n at frequency*10
    ///LowPass-cutoff-function:
    ///V(f) = 1.0/sqrt( 1.0 + (f/f_cut)^(2.0*n) )
    //We always generate a low pass at the beginning; we use the x-values of workset2 (which is the fft-version of the original set)
    switch (realization)
    {
    default:
    case FILTER_BRICKWALL:
        generateLowPass_Brickwall(g[n_gno].p[workset2].data.ex[0],n_pts,f1,cut_r,cut_i);
        break;
    case FILTER_BUTTERWORTH:
        generateLowPass_Butterworth(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
        break;
    case FILTER_BUTTERWORTH_SIMPLE:
        generateLowPass_Butterworth_simple(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
        break;
    case FILTER_BESSEL:
        generateLowPass_Bessel(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
        break;
    case FILTER_CHEBYCHEV:
        generateLowPass_Chebychev(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,ripple,cut_r,cut_i);
        break;
    case FILTER_GAUSSIAN:
        //generateLowPass_Butterworth_simple(g[n_gno].p[workset2].data.ex[0],n_pts/2,f1,order1,cut_r,cut_i);
        generateLowPass_Gaussian(g[n_gno].p[workset2].data.ex[0],n_pts,f1,order1,cut_r,cut_i);
        //generateLowPass_Gaussian(double * f,int n,double f_cutoff,int order,double * cutoff_Function)
        break;
    }
    if (type==FILTER_BAND_PASS || type==FILTER_BAND_STOP)
    {//in this case we have to generate another cut-off-function for the second filter frequency
        //At first we always generate a band-pass-filter
        cut_r2=new double[n_pts];
        cut_i2=new double[n_pts];
        switch (realization)
        {
        case FILTER_BRICKWALL:
            generateLowPass_Brickwall(g[n_gno].p[workset2].data.ex[0],n_pts,f2,cut_r2,cut_i2);
            break;
        case FILTER_BUTTERWORTH:
            generateLowPass_Butterworth(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
            break;
        case FILTER_BUTTERWORTH_SIMPLE:
            generateLowPass_Butterworth_simple(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
            break;
        case FILTER_BESSEL:
            generateLowPass_Bessel(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
            break;
        case FILTER_CHEBYCHEV:
            generateLowPass_Chebychev(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,ripple,cut_r2,cut_i2);
            break;
        case FILTER_GAUSSIAN:
            generateLowPass_Gaussian(g[n_gno].p[workset2].data.ex[0],n_pts,f2,order2,cut_r2,cut_i2);
            break;
        }
        for(int i=0;i<n_pts;i++)//generate the whole cut-off from two low-pass-filters --> this generates a band-pass
        {
            cut_r[i]=(1.0-cut_r[i])*cut_r2[i];
            cut_i[i]=(1.0-cut_i[i])*cut_i2[i];
        }
        delete[] cut_r2;
        delete[] cut_i2;
    }
    for(int i=0;i<n_pts;i++)//fft-spectra symetrical --> fill the second half
    {
        cutoff_function[i]=hypot(cut_r[i],cut_i[i]);
    }
    for(int i=0;i<n_pts;i++)//workset4 gets the x-values of workset2...
        g[n_gno].p[workset4].data.ex[0][i]=g[n_gno].p[workset2].data.ex[0][i];
    switch (type)//...and workset4 gets the cut-off-function as y-values
    {
    default:
    case FILTER_LOW_PASS:
    case FILTER_BAND_PASS:
        for(int i=0;i<n_pts;i++)
            g[n_gno].p[workset4].data.ex[1][i]=cutoff_function[i];
        break;
    case FILTER_HIGH_PASS:
    case FILTER_BAND_STOP://for high-pass or band-stop the cutoff has to be inverted here
        for(int i=0;i<n_pts;i++)
        {
            cut_r[i]=1.0-cut_r[i];
            cut_i[i]=1.0-cut_i[i];
            cutoff_function[i]=1.0-cutoff_function[i];
            g[n_gno].p[workset4].data.ex[1][i]=cutoff_function[i];
        }
        break;
    }
    //multiply fft-coefficients by cutoff function
    if (abs==1)
    {
        for (int i=0;i<n_pts;i++)
        {
            real_data[i]*=amp_correction*cutoff_function[i]*factor;
            imag_data[i]*=amp_correction*cutoff_function[i]*factor;
        }
    }
    else
    {
        for (int i=0;i<n_pts;i++)
        {
            tmp_ko.real=real_data[i];
            tmp_ko.imag=imag_data[i];
            tmp_ko2.real=cut_r[i];
            tmp_ko2.imag=cut_i[i];
            tmp_ko=mult_komplex(tmp_ko,tmp_ko2);
            real_data[i]=amp_correction*tmp_ko.real*factor;
            imag_data[i]=amp_correction*tmp_ko.imag*factor;
        }
    }
    do_copyset(n_gno, workset4, n_gno, filtered_data);
    for (int i=0;i<n_pts;i++)
    {
        g[n_gno].p[filtered_data].data.ex[1][i]=hypot(real_data[i],imag_data[i]);//real_data of filtered coefficients
    }
    //do inverse-fft
    resno = fft_v6(real_data,imag_data,n_pts,nu,1);
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in forward fft").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
    //copy result to workset3
    for (int i=0;i<n_pts;i++)
    {
        g[n_gno].p[workset3].data.ex[1][i]=amp_correction*real_data[i];//-->workset3 now has the y-values of the back-transformed data and the extended x-values (in a power of 2)
    }
    //interpolate result to original X-values
    //delete worksets if necessary
    do_copyset(n_gno, workset2, n_gno, workset1);//save workset2 to workset1

    sprintf(fstr,"X=X/(%s)",formula);
    ReplaceDecimalSeparator(fstr);
    set_parser_setno(n_gno,workset3);
    resno = do_compute(n_gno, workset3, n_gno, workset2, NULL, fstr);//transform X-axis back to original scale --> resulting data present in workset2 but probably to many points

    xfree(mesh);
    mesh = getcol(o_gno, o_sno, DATA_X);//get original x-values
    resno = do_interp(n_gno, workset2, n_gno, workset0, mesh, setlen, 0, 0);//interpolate back to original set axis and store data in target-set
    if (resno != RETURN_SUCCESS)
    {
        errmsg(QObject::tr("Error in generation of interpolated set").toLocal8Bit().constData());
        error=1;
        goto end_single_filter;
    }
end_single_filter:
    killsetdata(n_gno,workset2);
    killsetdata(n_gno,workset3);
    killsetdata(n_gno,workset1);
    if (!debug)
    {
        killsetdata(n_gno,padded_set);
        killsetdata(n_gno,fft_original);
        killsetdata(n_gno,filtered_data);
        killsetdata(n_gno,workset4);
    }
    else//debug
    {
        //sprintf(dummy,"%d %d %d %d",padded_set,fft_original,workset4,filtered_data);
        //qDebug(dummy);
        strcpy(fstr,QObject::tr("Set restricted, extended or interpolated to power of 2").toLocal8Bit().constData());
        set_legend_string(n_gno,padded_set,fstr);
        setcomment(n_gno,padded_set,fstr);
        strcpy(fstr,QObject::tr("Fourier-transformation of original set").toLocal8Bit().constData());
        set_legend_string(n_gno,fft_original,fstr);
        setcomment(n_gno,fft_original,fstr);
        strcpy(fstr,QObject::tr("Cutoff/filter-function").toLocal8Bit().constData());
        set_legend_string(n_gno,workset4,fstr);
        setcomment(n_gno,workset4,fstr);
        strcpy(fstr,QObject::tr("filtered data vs. frequency").toLocal8Bit().constData());
        set_legend_string(n_gno,filtered_data,fstr);
        setcomment(n_gno,filtered_data,fstr);
    }
    copysetdata(n_gno, workset0, n_gno, n_sno);//copy data to destination
    setcomment(n_gno, n_sno, filter_name);
//qDebug() << "filter_name=" << filter_name;
    delete[] filter_name;
    if (workset0!=n_sno)
        killset(n_gno,workset0);
    XCFREE(rarray);
    if (real_data!=NULL)
    {
        delete[] real_data;
        delete[] imag_data;
        delete[] cutoff_function;
        delete[] cut_r;
        delete[] cut_i;
    }
    if (error==1)
    {
        return RETURN_FAILURE;
    }
    if (o_gno!=n_gno || o_sno!=n_sno) g[n_gno].p[n_sno].linepen.color=color;
    //appendTextToLegendString(n_gno,n_sno,QObject::tr("(filtered)"));
    return RETURN_SUCCESS;
}

int generate_x_mesh_from_formula(int gno,int sno,double start,double stop,int npts,char * formula,int type)
{
    int res;
    grarr * t;
    t = get_parser_arr_by_name(dollar_t);
    if (t == NULL)
    {
        t = define_parser_arr(dollar_t);
        if (t == NULL)
        {
            errmsg(QObject::tr("Internal error").toLocal8Bit().constData());
            return RETURN_FAILURE;
        }
    }
    if (t->length != 0)
    {
        xfree(t->data);
        t->length = 0;
    }
    t->data = allocate_mesh(start, stop, npts);
    if (t->data == NULL)
    {
        errmsg(QObject::tr("Internal error").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    t->length = npts;
    set_dataset_type(gno, sno, type);
    set_set_hidden(gno, sno, FALSE);
    if (setlength(gno, sno, npts) != RETURN_SUCCESS)
    {
        killset(gno, sno);
        XCFREE(t->data);
        t->length = 0;
        errmsg(QObject::tr("Internal error").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    set_parser_setno(gno, sno);
    char buf[32], *expr;
    /* preparing the expression */
    sprintf(buf, "GRAPH[%d].SET[%d].%s = ", gno, sno, dataset_colname(0));
    expr = copy_string(NULL, buf);
    expr = concat_strings(expr, formula);
    /* evaluate the expression */
    res = scanner(expr);
    xfree(expr);
    if (res != RETURN_SUCCESS)
    {
        killset(gno, sno);
        XCFREE(t->data);
        t->length = 0;
        errmsg(QObject::tr("Internal error").toLocal8Bit().constData());
        return RETURN_FAILURE;
    }
    XCFREE(t->data);
    t->length = 0;
    return RETURN_SUCCESS;
}

char * extract_single_parameter(char * command,char * parameter)//takes the command an extracts everything until the next separator is reached (like ; or }); returns the position of the separtor or the '\0'; parameter is copied in the parameter-array
{
int braket_counter=0;
int len=strlen(command);
int i;
for (i=0;i<len;i++)
{
    if (command[i]=='(') braket_counter++;
    else if (command[i]==')') braket_counter--;
    else if ((command[i]==',' || command[i]==';' || command[i]=='{' || command[i]=='}') && (braket_counter==0))
    {
    strncpy(parameter,command,i);
    parameter[i]='\0';
    break;
    }
}
if (i==len) parameter[0]='\0';
return command+i;
}

int containsSpecialCommand(char * com,char ** parameters)
{
    char ts2[MAX_STRING_LENGTH];
    char operation[MAX_STRING_LENGTH],operand[MAX_STRING_LENGTH];
    static char para[MAX_STRING_LENGTH];
    strncpy(ts2,com,16);
    ts2[16]='\0';
    if (strcmp(ts2,"#QTGRACE_SPECIAL") != 0) return SPECIAL_NONE;//no special command
    *parameters=para;
    //cout << "Contains Special Command? #" << com << "#" << endl;
    sscanf(com,"%s %s %s",operation,operand,para);
    //cout << "#"<< operation << "#" << operand << "#" << para << "#" << endl;
    if ( strcmp(operand,"FILTER_SET") == 0 )
        return SPECIAL_FILTER;
    else if ( strcmp(operand,"REGRESSION") == 0 )
        return SPECIAL_REGRESSION;
    else if ( strcmp(operand,"REMEMBER") == 0 )
        return SPECIAL_REMEMBER;
    else if ( strcmp(operand,"ADD") == 0 )
        return SPECIAL_ADD;
    else if ( strcmp(operand,"MINUS") == 0 )
        return SPECIAL_MINUS;
    else if ( strcmp(operand,"DIVIDE") == 0 )
        return SPECIAL_DIVIDE;
    else if ( strcmp(operand,"MULTIPLY") == 0 )
        return SPECIAL_MULTIPLY;
    else if ( strcmp(operand,"USE") == 0 )
        return SPECIAL_USE;
    else if ( strcmp(operand,"EXTRACT") == 0 )
        return SPECIAL_EXTRACT;
    else if ( strcmp(operand,"FORMULA") == 0 )
        return SPECIAL_FORMULA;
    else if ( strcmp(operand,"APPEND") == 0 )
        return SPECIAL_APPEND;
    else
        return SPECIAL_NONE;
}

int ParseExtractCommand(char * com,char * arg)
{
int brakets,endpos;
arg[0]=arg[1]=arg[2]='\0';
//qDebug() << "ParseExtractCommand: com=#" << com << "#";
    if (strncmp(com,"MEDIAN",6)==0)
    {
        brakets=1;
        endpos=strlen(com)-1;
        for (unsigned int i=7;i<strlen(com);i++)
        {
        if (com[i]=='(') brakets++;
        else if (com[i]==')') brakets--;
        if (brakets==0) endpos=i;
        }
        get_text_from_to(com,6,endpos,arg);
        /*arg[0]=toupper(com[7]);
        if (isdigit(com[8]))
        {
        arg[1]=com[8];
        }*/
    return FEATURE_Y_MEDIAN;//median (also used for 9 and other Y-values Y1-Y4)
    }
    else if (strncmp(com,"FREQUENCY",9)==0)
    {
    return FEATURE_FREQUENCY;//no arguments
    }
    else if (strncmp(com,"PERIOD",6)==0)
    {
    return FEATURE_PERIOD;//no arguments
    }
    else if (strncmp(com,"ZERO_CROSSING",13)==0)
    {
    return FEATURE_ZERO_CROSSING;//no arguments
    }
    else if (strncmp(com,"RISE_TIME",9)==0)
    {
    return FEATURE_RISE_TIME;//no arguments
    }
    else if (strncmp(com,"FALL_TIME",9)==0)
    {
    return FEATURE_FALL_TIME;//no arguments
    }
    else if (strncmp(com,"SLOPE",5)==0)
    {
    return FEATURE_SLOPE;//no arguments
    }
    else if (strncmp(com,"Y_INTERCEPTION",14)==0)
    {
    return FEATURE_Y_INTERCEPT;//no arguments
    }
    else if (strncmp(com,"SET_LENGTH",10)==0)
    {
    return FEATURE_SET_LENGTH;//no arguments
    }
    else if (strncmp(com,"HALF_MAX_WIDTH",14)==0)
    {
    return FEATURE_HALF_MAX_WIDTH;//no arguments
    }
    else if (strncmp(com,"BARYCENTER_X",12)==0)
    {
    return FEATURE_BARYCENTER_X;//no arguments
    }
    else if (strncmp(com,"BARYCENTER_Y",12)==0)
    {
    return FEATURE_BARYCENTER_Y;//no arguments
    }
    else if (strncmp(com,"Y_VALUE_CROSSING",16)==0)
    {
        strcpy(arg,com+17);
        for (int i=strlen(arg)-1;i>=0;i++)
        {
            if (arg[i]==')')
            {
            arg[i]='\0';
            break;
            }
        }
    return FEATURE_VALUE_CROSSING;
    }
    else if (strncmp(com,"X_VALUE_CROSSING",16)==0)
    {
        strcpy(arg,com+17);
        for (int i=strlen(arg)-1;i>=0;i++)
        {
            if (arg[i]==')')
            {
            arg[i]='\0';
            break;
            }
        }
    return FEATURE_VALUE_CROSSING2;
    }
return -1;
}

int ParseSpecialFormula(char * com,char * arg)
{
    (void)com;
    (void)arg;
return 0;
}

void ParseRegression(char * com,int & n_sets,int ** gnos,int ** snos,int & n_n_sets,int ** n_gnos,int ** n_snos,int & ideg,int & iresid,int & rno,int & invr,double & start,double & stop,int & points,int & rx,char * formula)
{//parses the commands after '#QTGRACE_SPECIAL REGRESSION '
    int index,i,j;
    //int counter;
    int len=strlen(com);
    //counter=0;
    //cout << "Parsing regression-command=#" << com << "#" << endl;
    double tmp_answer;
    char parameter[128];
    char * next_pos=extract_single_parameter(com,parameter);
    next_pos++;//we are now after the ','
    int retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) n_sets=(int)tmp_answer;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) n_n_sets=(int)tmp_answer;
    next_pos++;
    /// sscanf(com,"%d,%d",&n_sets,&n_n_sets);
//cout << "Einlesen: old_sets=" << n_sets << " new_sets=" << n_n_sets << endl;
    index=-1;
    (*gnos)=new int[1+n_sets];
    (*snos)=new int[1+n_sets];
    (*n_gnos)=new int[1+n_n_sets];
    (*n_snos)=new int[1+n_n_sets];
    for (i=0;i<len;i++)
    {
        if (com[i]=='{')
        {
            index=i+1;
            break;
        }
    }
    for (i=0;i<n_sets;i++)
    {
    next_pos=com+index;
        //cout << "A: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*gnos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "B: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*snos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "C: original: next_pos=" << next_pos << endl;
        //cout << "original: com-index=" << com+index << endl;
        /// sscanf(com+index,"%d,%d",(*gnos)+i,(*snos)+i);
        index=next_pos-com-1;
        for (j=0;j<len;j++)
        {
            if (com[j+index]==';' || com[j+index]=='}')
            {
                index+=j+1;
                break;
            }
        }
    }
    index++;
    next_pos=com+index;
    for (i=0;i<n_n_sets;i++)
    {
    next_pos=com+index;
        //cout << "A: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*n_gnos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "B: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*n_snos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "C: original: next_pos=" << next_pos << endl;
        //cout << "original: com-index=" << com+index << endl;
        //cout << "new: com-index=" << com+index << endl;
        /// sscanf(com+index,"%d,%d",(*n_gnos)+i,(*n_snos)+i);
        index=next_pos-com-1;
        for (j=0;j<len;j++)
        {
            if (com[j+index]==';' || com[j+index]=='}')
            {
                index+=j+1;
                break;
            }
        }
    }
    if (n_n_sets==0) index++;
    index++;
    next_pos=com+index;
/*cout << "source sets:" << endl;
for (i=0;i<n_sets;i++)
{
cout << "G" << (*gnos)[i] << ".S" << (*snos)[i] << endl;
}
cout << "target sets:" << endl;
for (i=0;i<n_n_sets;i++)
{
cout << "G" << (*n_gnos)[i] << ".S" << (*n_snos)[i] << endl;
}
cout << "Parameters:" << endl;*/
    //cout << "rest: com-index=" << com+index << endl;
    /// sscanf(com+index,"%d;%d;%d;%d;%d;%lf;%lf;%s",&ideg,&rno,&invr,&points,&rx,&start,&stop,formula);
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) ideg=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) rno=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) invr=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) points=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) rx=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) start=tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) stop=tmp_answer;
    next_pos++;
    sscanf(next_pos,"%s",formula);
/*cout << "ideg=" << ideg << endl;
cout << "rno=" << rno << endl;
cout << "invr=" << invr << endl;
cout << "points=" << points << endl;
cout << "rx=" << rx << endl;
cout << "start=" << start << endl;
cout << "stop=" << stop << endl;*/
    switch (rx)
    {
    case 0://fitted values
        iresid = 0;
        break;
    case 1://residuals
        iresid = 1;
        break;
    case 2://function
        iresid = 0;
        break;
    case 3://no new set for regression
        iresid = 2;
        break;
    }
    formula[strlen(formula)-1]='\0';
//cout << "formula=" << formula << endl;
}

void ParseFilterCommand(char * com,int & o_n_sets,int ** o_gnos,int ** o_snos,int & n_sets,int ** gnos,int ** snos,int & type,int & realization,double * limits,int * orders,char * x_formula,double & ripple,int & absolute,int & debug,int & point_extension,int & oversampling,int & rno,int & invr)
{//parses the commands after '#QTGRACE_SPECIAL FILTER_SET '
    int index,i,j;
    //int counter;
    int len=strlen(com);
    //counter=0;
    //cout << "Parsing filter-command=#" << com << "#" << endl;
    /// sscanf(com,"%d,%d",&o_n_sets,&n_sets);
n_sets=o_n_sets=-1;
    double tmp_answer;
    char parameter[128];
    char * next_pos=extract_single_parameter(com,parameter);
    next_pos++;//we are now after the ','

    int retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) o_n_sets=(int)tmp_answer;

//cout << "after first extract: com=#" << next_pos << "# parameter=#" << parameter << "# o_n_sets=" << o_n_sets << endl;

    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) n_sets=(int)tmp_answer;

//cout << "after second extract: com=#" << next_pos << "# parameter=#" << parameter << "# n_sets=" << n_sets << endl;

    index=-1;
    (*o_gnos)=new int[1+o_n_sets];
    (*o_snos)=new int[1+o_n_sets];
    (*gnos)=new int[1+n_sets];
    (*snos)=new int[1+n_sets];
    for (i=0;i<len;i++)
    {
        if (com[i]=='{')
        {
            index=i+1;
            break;
        }
    }
    for (i=0;i<o_n_sets;i++)
    {
    next_pos=com+index;
        //cout << "A: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*o_gnos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "B: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*o_snos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "C: original: next_pos=" << next_pos << endl;
        /// sscanf(com+index,"%d,%d",(*o_gnos)+i,(*o_snos)+i);
        index=next_pos-com-1;
        for (j=0;j<len;j++)
        {
            if (com[j+index]==';' || com[j+index]=='}')
            {
                index+=j+1;
                break;
            }
        }
    }
    index++;
    for (i=0;i<n_sets;i++)
    {
    next_pos=com+index;
        //cout << "A: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*gnos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "B: original: next_pos=" << next_pos << endl;
        next_pos=extract_single_parameter(next_pos,parameter);
        retval=std_evalexpr(parameter,&tmp_answer);
        if (retval==RETURN_SUCCESS) (*snos)[i]=(int)tmp_answer;
        next_pos++;
        //cout << "C: original: next_pos=" << next_pos << endl;
        //cout << "new: com-index=" << com+index << endl;
        /// sscanf(com+index,"%d,%d",(*gnos)+i,(*snos)+i);
        index=next_pos-com-1;
        for (j=0;j<len;j++)
        {
            if (com[j+index]==';' || com[j+index]=='}')
            {
                index+=j+1;
                break;
            }
        }
    }
    next_pos++;
    index++;
    //cout << "D: rest: next_pos=" << next_pos << endl;

    double d1=0.0,d2=0.0;
    int o1=1,o2=1;

    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) type=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) realization=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) o1=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) o2=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) absolute=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) debug=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) point_extension=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) oversampling=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) rno=(int)tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) invr=(int)tmp_answer;
    next_pos++;

    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) d1=tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) d2=tmp_answer;
    next_pos++;
    next_pos=extract_single_parameter(next_pos,parameter);
    retval=std_evalexpr(parameter,&tmp_answer);
    if (retval==RETURN_SUCCESS) ripple=tmp_answer;
    next_pos++;
    sscanf(next_pos,"%s",x_formula);

    /// sscanf(com+index,"%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%lf;%lf;%lf;%s",&type,&realization,&o1,&o2,&absolute,&debug,&point_extension,&oversampling,&rno,&invr,&d1,&d2,&ripple,x_formula);
    x_formula[strlen(x_formula)-1]='\0';

    //cout << "d1=" << d1 << " o1=" << o1 << endl;
    //cout << "d2=" << d2 << " o2=" << o2 << endl;

/*cout << "original sets:" << endl;
for (i=0;i<o_n_sets;i++)
{
cout << "G" << (*o_gnos)[i] << ".S" << (*o_snos)[i] << endl;
}
cout << "target sets:" << endl;
for (i=0;i<n_sets;i++)
{
cout << "G" << (*gnos)[i] << ".S" << (*snos)[i] << endl;
}
cout << "type= " << type << endl;
cout << "realization= " << realization << endl;
cout << "o1= " << o1 << endl;
cout << "o2= " << o2 << endl;
cout << "absolute= " << absolute << endl;
cout << "debug= " << debug << endl;
cout << "point_extension= " << point_extension << endl;
cout << "oversampling= " << oversampling << endl;
cout << "rno= " << rno << endl;
cout << "invr= " << invr << endl;
cout << "d1= " << d1 << endl;
cout << "d2= " << d2 << endl;
cout << "ripple= " << ripple << endl;
cout << "x_formula= #" << x_formula << "#" << endl;*/

    limits[0]=d1;
    limits[1]=d2;
    orders[0]=o1;
    orders[1]=o2;
}

TestDialog::TestDialog(QWidget * parent):QWidget(parent)
{
QString home=QString(user_home_dir)+QDir::separator();

layout=new QGridLayout();
layout->setMargin(STD_MARGIN);
layout->setSpacing(STD_SPACING);

int number=number_of_devices();
QString entr[32];
    for (int i=0;i<number;i++)
    {
    entr[i]=get_device_name(i);
    }
devices_item=new StdSelector(this,tr("Output format:"),number,entr);

cmdSetExportName=new QPushButton(tr("set_exportname_external()"),this);
cmdSetDocName=new QPushButton(tr("set_docname_external()"),this);
cmdhardcopy=new QPushButton(tr("do_hardcopy()"),this);
cmdLoad=new QPushButton(tr("load_project_file()"),this);
cmdImportSin=new QPushButton(tr("Import Sinus via readDataFromClient()"),this);
cmdArrangeGr=new QPushButton(tr("Arrange Graphs"),this);
cmdCreatePolar2=new QPushButton(tr("Create Polar Graph v2"),this);
lenFile=new stdLineEdit(this,tr("FileName="));
lenExport=new stdLineEdit(this,tr("ExportName="));
lenDoc=new stdLineEdit(this,tr("DocName="));

lenFile->setText(home+QString("project.agr"));
lenDoc->setText(home+QString("project2.agr"));
lenExport->setText(home+QString("project3.png"));
lenDPI=new stdLineEdit(this,tr("DPI="));
lenDPI->setText("72");
lenSizeX=new stdLineEdit(this,tr("Width="));
lenSizeX->setText("792");
lenSizeY=new stdLineEdit(this,tr("Height="));
lenSizeY->setText("612");

lenFormulaTest=new stdLineEdit(this,tr("Formula with id to replace:"));
lenFormulaTest->setText("y=a0+a1*sin(a2*x+a3);fit formula \"y=a0+a1*x+a2*x^2\";formula2 \"x=2*x;y=3*x\" set;y1=exp(x*y+y2)");
lblReplacements=new QLabel(QString(""),this);
lblReplacedFormula=new QLabel(QString(""),this);
cmdReplacements=new QPushButton(tr("Set Replacements"),this);
cmdExecute=new QPushButton(tr("Execute Formula"),this);

int line=0;
layout->addWidget(cmdImportSin,line++,1);
layout->addWidget(lenFile,line,0);
layout->addWidget(cmdLoad,line++,1);
layout->addWidget(lenDoc,line,0);
layout->addWidget(cmdSetDocName,line++,1);
layout->addWidget(lenExport,line,0);
layout->addWidget(cmdSetExportName,line++,1);
layout->addWidget(devices_item,line++,0);
layout->addWidget(lenSizeX,line,0);
layout->addWidget(lenSizeY,line++,1);
layout->addWidget(lenDPI,line,0);
layout->addWidget(cmdhardcopy,line++,1);
layout->addWidget(cmdArrangeGr,line++,1);
layout->addWidget(cmdCreatePolar2,line++,1);

layout->addWidget(lenFormulaTest,line++,0,1,2);
layout->addWidget(lblReplacements,line,0);
layout->addWidget(cmdReplacements,line++,1);
layout->addWidget(lblReplacedFormula,line,0);
layout->addWidget(cmdExecute,line++,1);

setLayout(layout);

connect(cmdLoad,SIGNAL(clicked()),SLOT(doLoad()));
connect(cmdSetDocName,SIGNAL(clicked()),SLOT(doDocname()));
connect(cmdSetExportName,SIGNAL(clicked()),SLOT(doExport()));
connect(cmdhardcopy,SIGNAL(clicked()),SLOT(doHardcopy()));
connect(cmdImportSin,SIGNAL(clicked()),SLOT(doImportSin()));
connect(cmdArrangeGr,SIGNAL(clicked()),SLOT(doArrange()));
connect(cmdCreatePolar2,SIGNAL(clicked()),SLOT(doCreatePolar2()));
connect(cmdReplacements,SIGNAL(clicked()),SLOT(doSetReplacements()));
connect(cmdExecute ,SIGNAL(clicked()),SLOT(doExecuteFormula()));
}

void TestDialog::doExport(void)
{
QString text=lenExport->text();
set_exportname_external(text.toLocal8Bit().constData());
}

void TestDialog::doDocname(void)
{
QString text=lenDoc->text();
set_docname_external(text.toLocal8Bit().constData());
}

void TestDialog::doHardcopy(void)
{
unsigned long w,h;
float dpi;
int dev_nr=devices_item->currentValue();
int sav_cur_file=curdevice;
int sav_hdevice=hdevice;
int sav_ptofile=get_ptofile();
set_ptofile(TRUE);

dpi=lenDPI->getDoubleValue();
w=lenSizeX->getIntValue();
h=lenSizeY->getIntValue();

Page_geometry pg,sav_pg;
sav_pg=get_page_geometry();
pg.dpi=dpi;
pg.height=h;
pg.width=w;

hdevice=dev_nr;
select_device(hdevice);
set_page_geometry(pg);

do_hardcopy();

hdevice=sav_hdevice;
select_device(sav_cur_file);
set_page_geometry(sav_pg);
set_ptofile(sav_ptofile);
mainWin->doDraw();
}

void TestDialog::doLoad(void)
{
QString text=lenFile->text();
int ret=load_project(text.toLocal8Bit().data());
    if (ret==RETURN_SUCCESS)
    QMessageBox::information(this,tr("Success"),tr("Project file loaded successfully."));
    else
    QMessageBox::information(this,tr("Failure"),tr("Failed to load project file. Sorry!"));
}

void TestDialog::doImportSin(void)
{
char * dataIn=new char[2048*64];
double x;
int offset=0;
for (int i=0;i<200;i++)
{
x=i/100.0;
sprintf(dataIn+offset,"%.5f %.5f\n",x,3.5*sin(2.0*3.1415927*x+0.2));
offset=strlen(dataIn);
}
//int ret=readDataFromClient(dataIn,LOAD_NXY,"Y=3.5*sin(2*PI*x+0.2)");
(void)readDataFromClient(dataIn,LOAD_NXY,"Y=3.5*sin(2*PI*x+0.2)");
delete[] dataIn;
mainWin->mainArea->completeRedraw();
}

void TestDialog::doArrange(void)
{
    int graphs[8];
    graphs[0]=0;
    graphs[1]=1;
    arrange_graphs(graphs, 2, 2, 1, 5, 1, 0.22, 0.08, 0.15, 0.15, 0.2, 0.2, FALSE, FALSE, TRUE, 0.0, 0.0);
    update_all();
}

void TestDialog::doCreatePolar2(void)
{
    //first: we just create a set for testing
int next_id=nextset(0);
(void)setlength(0,next_id,10);
g[0].p[next_id].data.ex[0][0]=-6.1515069e-18;
g[0].p[next_id].data.ex[1][0]=0.030733606;
g[0].p[next_id].data.ex[0][1]=0.6981317;
g[0].p[next_id].data.ex[1][1]=0.030733606;
g[0].p[next_id].data.ex[0][2]=1.3962634;
g[0].p[next_id].data.ex[1][2]=0.030733606;
g[0].p[next_id].data.ex[0][3]=2.0943951;
g[0].p[next_id].data.ex[1][3]=0.030733606;
g[0].p[next_id].data.ex[0][4]=2.7925268;
g[0].p[next_id].data.ex[1][4]=0.030733606;
g[0].p[next_id].data.ex[0][5]=-2.7925268;
g[0].p[next_id].data.ex[1][5]=0.030733606;
g[0].p[next_id].data.ex[0][6]=-2.0943951;
g[0].p[next_id].data.ex[1][6]=0.030544375;
g[0].p[next_id].data.ex[0][7]=-1.3962634;
g[0].p[next_id].data.ex[1][7]=0.030733606;
g[0].p[next_id].data.ex[0][8]=-0.6981317;
g[0].p[next_id].data.ex[1][8]=0.030733606;
g[0].p[next_id].data.ex[0][9]=-6.1515069e-18;
g[0].p[next_id].data.ex[1][9]=0.030733606;
    //second: set polar plot v2
set_graph_type(0,GRAPH_POLAR2);
    //third: set plot options (here arbitrary values: phi0=0.9 and roffset=12%)
set_parameters_polar_v2(0,0.9,0.12);
    //fourth: autoscale
autoscale_graph(0,AUTOSCALE_XY);
    //fifth: set nice graph settings
make_nice_polar_plot_v2(0);
    //redraw
mainWin->mainArea->completeRedraw();
}

void TestDialog::doSetReplacements(void)
{
g_lhs=g_rhs=s_lhs=s_rhs=-1;
bool ok;
g_lhs=QInputDialog::getInt(this,QString("Set Graph for LHS"),QString("Graph LHS"),0,0,100,1,&ok);
if (ok)
{
s_lhs=QInputDialog::getInt(this,QString("Set Set for LHS"),QString("Set LHS"),0,0,100,1,&ok);
    if (ok)
    {
    g_rhs=QInputDialog::getInt(this,QString("Set Graph for RHS"),QString("Graph RHS"),0,0,100,1,&ok);
        if (ok)
        {
        s_rhs=QInputDialog::getInt(this,QString("Set Set for RHS"),QString("Set RHS"),0,0,100,1,&ok);
            if (ok)
            {
            formula1.init_formula(lenFormulaTest->text());
            QString str_replacements;
            str_replacements=QString("G-LHS=") + QString::number(g_lhs) + QString(" S-LHS=") + QString::number(s_lhs) + QString(" G-RHS=") + QString::number(g_rhs) + QString(" S-RHS=") + QString::number(s_rhs);
            lblReplacements->setText(str_replacements);
            lblReplacedFormula->setText(QString(""));
            }
        }
    }
}
}

void TestDialog::doExecuteFormula(void)
{
int stdBut2=QMessageBox::question(this,tr("Replace?"),tr("Replace IDs?\nIf No, formula will just be completed (otherwise all ids will repaced)."),QMessageBox::Yes,QMessageBox::No);
int stdBut=QMessageBox::question(this,tr("Execute?"),tr("Execute the command?\nIf No, only the replaced formula will be shown."),QMessageBox::Yes,QMessageBox::No);
int return_value;
if (stdBut==QMessageBox::Yes)
{
    if (stdBut2==QMessageBox::Yes)
    lblReplacedFormula->setText(formula1.execute_formula(g_lhs,s_lhs,g_rhs,s_rhs,1,return_value));
    else
    lblReplacedFormula->setText(formula1.execute_formula(g_lhs,s_lhs,g_rhs,s_rhs,0,return_value));
    mainWin->mainArea->completeRedraw();
}
else
{
QString f;
    if (stdBut2==QMessageBox::Yes)
    formula1.return_replaced_formula(g_lhs,s_lhs,g_rhs,s_rhs,f);
    else
    formula1.return_completed_formula(g_lhs,s_lhs,g_rhs,s_rhs,f);
lblReplacedFormula->setText(f);
}
}

SetupWizard::SetupWizard(QWidget * parent):QDialog(parent)
{
    setWindowTitle(tr("QtGrace Setup Wizard"));
    setWindowIcon(QIcon(*GraceIcon));
page_number=0;
max_pages=7;
lblPicture=new QLabel(this);
title1=new QLabel(tr("Initialize default settings for QtGrace"),this);
title1->setAlignment(Qt::AlignCenter);
QFont fo1=title1->font();
fo1.setPixelSize(fo1.pixelSize()*1.5);
title1->setFont(fo1);
title2=new QLabel(this);
    for (int i=0;i<MAX_SETUP_OPTIONS;i++)
    {
    optOptions[i]=new QRadioButton(QString("Option ")+QString::number(i));
    chkOptions[i]=new QCheckBox(QString("Check ")+QString::number(i));
    ledOptions[i]=new stdLineEdit(this,QString("Line Edit ")+QString::number(i));
    }
title3=new QLabel(tr("\nPlease select the settings that suit you best:"),this);
grid=new QGridLayout;
grid->setSpacing(STD_SPACING);
grid->setMargin(STD_MARGIN);
cmdPrev=new QPushButton(tr("Previous"),this);
cmdNext=new QPushButton(tr("Next"),this);
cmdCancel=new QPushButton(tr("Cancel"),this);
connect(cmdPrev,SIGNAL(clicked()),SLOT(doPrev()));
connect(cmdNext,SIGNAL(clicked()),SLOT(doNext()));
connect(cmdCancel,SIGNAL(clicked()),SLOT(doCancel()));
int index=0,index2;
grid->addWidget(title1,index++,0,1,4);
grid->addWidget(title2,index,1,1,3);
grid->addWidget(lblPicture,index++,0,2+2*MAX_SETUP_OPTIONS,1);
grid->addWidget(title3,index++,1,1,3);
index2=index;
    for (int i=0;i<MAX_SETUP_OPTIONS;i++)
    grid->addWidget(optOptions[i],index++,1,1,3);
index=index2;
    for (int i=0;i<MAX_SETUP_OPTIONS;i++)
    grid->addWidget(chkOptions[i],index++,1,1,3);
index=index2;
    for (int i=0;i<MAX_SETUP_OPTIONS;i++)
    grid->addWidget(ledOptions[i],index++,1,1,3);
QWidget * empty=new QWidget(this);
grid->addWidget(empty,index++,1,1,1);
grid->setRowStretch(index-1,3);
grid->addWidget(cmdPrev,index,1,1,1);
grid->addWidget(cmdNext,index,2,1,1);
grid->addWidget(cmdCancel,index++,3,1,1);
setLayout(grid);
reinitPage();
cmdCancel->setDefault(true);
resize(LastSize_Form_SetupWizard);
}

SetupWizard::~SetupWizard()
{
LastSize_Form_SetupWizard=this->size();
}

void SetupWizard::closeEvent( QCloseEvent * event )
{
    int ret=QMessageBox::question(this,tr("Cancel Setup Wizard"),tr("Do you want to cancel the Setup-Wizard?\nIf 'yes', the default-values will be used for the settings."),QMessageBox::Yes|QMessageBox::No);
    if (ret==QMessageBox::No)
    {
    event->ignore();
    }
    else
    {
    event->accept();
    }
}

void SetupWizard::init(void)
{
    page_number=0;
    reinitPage();
}

void SetupWizard::doCancel(void)
{
    int ret=QMessageBox::question(this,tr("Cancel Setup Wizard"),tr("Do you want to cancel the Setup-Wizard?\nIf 'yes', the default-values will be used for the settings."),QMessageBox::Yes|QMessageBox::No);
    if (ret==QMessageBox::No) return;
    hide();
}

void SetupWizard::doPrev(void)
{
    page_number--;
    reinitPage();
}

void SetupWizard::doNext(void)
{
    if (page_number==max_pages)
    {
    doApplySettings();
    hide();
    }
    else
    {
    page_number++;
    reinitPage();
    }
}

void SetupWizard::reinitPage(void)
{
static QString * entries=new QString[MAX_SETUP_OPTIONS];
static QString * entries2=new QString[MAX_SETUP_OPTIONS];
static QString * entries3=new QString[MAX_SETUP_OPTIONS];

    if (page_number>=max_pages)
    {
    page_number=max_pages;
    cmdNext->setText(tr("Apply Settings"));
    }
    else if (page_number<0)
    {
    page_number=0;
    }
    else
    {
    cmdNext->setText(tr("Next"));
    }

    if (page_number==0) cmdPrev->setEnabled(false);
    else cmdPrev->setEnabled(true);
    /*if (page_number==max_pages) cmdNext->setEnabled(false);
    else cmdNext->setEnabled(true);*/

    title2->setText(QString("Page ")+QString::number(page_number));

    switch (page_number)
    {
    case 0:
        title2->setText(tr("\nWelcome to the setup-wizard for QtGrace.\n\nIt seems, that you start this version of QtGrace for the first time.\nThis dialog shows you a few of the new features of QtGrace\nand helps you to select the default settings you like.\n\nIf you want to change the settings later,\nyou can find all settings in the 'Preferences'-dialog."));
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 1:
        title2->setText(tr("\nQtGrace offers an Undo/Redo-function.\nIf you do anything (e.g. changing set appearance, killing sets, transform a set)\nand find out that you did something wrong this function lets you reverse the operation.\n(This should work for most operations.) You find the list of reversable operations via the menu Edit->UndoList.\nIn the list-dialog you can also activate and deactivate the Undo-function.\nMost undo-list entries can also be used to generate script commands\n(do several operations, select them in the list and\nthe associated commands are transfered to the 'Commands'-dialog to be used as a script)."));
        entries[0]=tr("Activate Undo-function (useful to reverse a wrong operation)");
        entries[1]=tr("Deactivate Undo-function (if you work with very large sets the undo needs a lot of memory)");
        setNumberOfOptions(2,entries,0,entries2,0,entries3);
        break;
    case 2:
        title2->setText(tr("\nQtGrace shows existing sets in lists where they can be selected for operations.\nSometimes it is hard to find a specific set among a lot of sets.\nQtGrace offers several options to distinguish between the sets (apart from the set-ID)."));
        entries2[0]=tr("Show set icons (show a small icon in the list according the set appearance)");
        entries2[1]=tr("Show set comments");
        entries2[2]=tr("Show set legends");
        entries2[3]=tr("Show hidden sets (display sets that are currently not visible in a graph)");
        entries2[4]=tr("Show data-less sets (displays sets that have 0 datapoints which result from killing sets)");
        setNumberOfOptions(0,entries,5,entries2,0,entries3);
        break;
    case 3:
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 4:
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 5:
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 6:
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    case 7:
        title2->setText(tr("\nYou have set the most notable options now.\n\nIf you want to apply them to QtGrace please press the 'Apply Settings'-button below.\n\nAll settings are stored in an ini-file and will we applied every time you open QtGrace."));
        setNumberOfOptions(0,entries,0,entries2,0,entries3);
        break;
    }
}

void SetupWizard::setNumberOfOptions(int nr, QString * optentries,int nr2, QString * chkentries,int nr3, QString * ledentries)
{
    for (int i=0;i<nr;i++)
    {
    optOptions[i]->setVisible(true);
    optOptions[i]->setText(optentries[i]);
    }
    for (int i=nr;i<MAX_SETUP_OPTIONS;i++)
    {
    optOptions[i]->setVisible(false);
    }

    for (int i=0;i<nr2;i++)
    {
    chkOptions[i]->setVisible(true);
    chkOptions[i]->setText(chkentries[i]);
    }
    for (int i=nr2;i<MAX_SETUP_OPTIONS;i++)
    {
    chkOptions[i]->setVisible(false);
    }

    for (int i=0;i<nr3;i++)
    {
    ledOptions[i]->setVisible(true);
    ledOptions[i]->lblText->setText(ledentries[i]);
    }
    for (int i=nr3;i<MAX_SETUP_OPTIONS;i++)
    {
    ledOptions[i]->setVisible(false);
    }

    if (nr==0 && nr2==0)
    {
    title3->setVisible(false);
    }
    else
    {
    title3->setVisible(true);
    }
}

void SetupWizard::doApplySettings(void)
{
QMessageBox::information(this,tr("Setup Wizard finished"),tr("The setup is complete now. Your selected settings will be saved as default.\nYou can change them later via the 'Preferences'-dialog.\nYou can also summon this wizard again in the 'Miscellaneous'-tab there."));
/// here the settings should be applied to the defaults
}

//new setup-wizard
WizardIntroPage::WizardIntroPage(QWidget *parent):QWizardPage(parent)
{
setTitle(QObject::tr("Welcome"));
QLabel * label = new QLabel(QObject::tr("Welcome to the setup-wizard of QtGrace.\n\nIt seems, that you start this version of QtGrace for the first time.\nThis dialog shows you a few of the new features of QtGrace\nand helps you to select the default settings you like.\n\nIf you want to change the settings later,\nyou can find all settings in the 'Preferences'-dialog.\n\nBy clicking Cancel you may skip this Wizard for now,\nbut if you like to summon this Wizard again at a later time\nplease use the appropriate button in Preferences\\Miscellaneous."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
layout->addWidget(label);
setLayout(layout);
}

WizardUndoPage::WizardUndoPage(QWidget *parent):QWizardPage(parent)
{
setTitle(QObject::tr("Undo / Redo - function (01 / 19)"));
QLabel * label = new QLabel(QObject::tr("QtGrace has an option to undo most of the operations (like deleting sets).\nIn order to do so open Edit->UndoList.\n\nDo you want to activate the Undo-function?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nIf Undo is activated the state before and after most operations is saved internally. Via the UndoList you may select to undo an operation or redo it again later. If you undo an operation the state before the operation is restored. If undo has already been done another undo will restore the state after the operation.\nIf you select more than one operation for undo the 'Undo'- and 'Redo'-buttons do the same think, but in different orders: Undo goes from the last operation upwards, Redo from the first operation downwards. If only one operation is to be made undone both do the same.\n\nGernerally having Undo active is a good thing, but if you are working with very large sets this function uses a lot of memory. When working with large data sets especially on 32-bit systems this means, that QtGrace will crash as soon as around 1.5GB of memory is used. In this case you may prefer to deactivate Undo (temporarily).\nPlease set your initial preference here. This setting will be used for the current session and every time QtGrace is started.\n\nIf you have to activate or deactivate Undo later open\nEdit->UndoList or Preferences->QtGrace-Behavior. In the preferences the initial setting for Undo when QtGrace is started is separated from the current setting."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (activate undo)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (deactivate undo)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("undoActive", radYes);
    if (undo_active==TRUE)
    radYes->setChecked(true);
    else
    radNo->setChecked(true);
}

WizardImmediateUpdatePage::WizardImmediateUpdatePage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Immediate Updates (02 / 19)"));
QLabel * label = new QLabel(QObject::tr("In the original XmGrace / Grace the user has to press the 'Apply'-button to apply changes made in the GUI to the sets and graphs in a project.\nQtGrace has an option to apply every change in settings as soon as they are made in the GUI without the need of having to press 'Apply'. In the case of texts you have to press 'Return' or 'Enter' to accept text-changes and complete the editing.\n\nDo you want to activate the Immediate Updates function?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther information:\n\nIf Undo is activated this may result in many additional steps in the UndoList if for example a slider is used. On the other hand this behavior resembles the behavior of other graphical user interfaces of modern programs and can be very convenient."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (automatically apply all changes)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (make changes only after 'Apply' is pressed)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("ImmUpdateActive", radYes);
    if (immediateUpdate==true)
    radYes->setChecked(true);
    else
    radNo->setChecked(true);
}

WizardDecSepPage::WizardDecSepPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Decimal Separator & Encoding (03 / 19)"));
QLabel * label = new QLabel(QObject::tr("QtGrace allows you to use '.' or ',' as decimal separator. \n\nFor the text (especially with the QtFonts) you may use non-ascii-characters. To save these non-ascii-characters in a project file a special encoding has to be used (the Grace-project format is usually ascii-text). \n\nPlease select your preferences:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nDecimal separator:\nInternally '.' is used, for all GUI-inputs and the displays the selected separator is used. For data-import via drag-and-drop the number of '.' and ',' is counted and a suggestion made about what separator should be used for import accordingly. For data export the default separator of the operating system is used.\n\nEncoding:\nYou have to select the encoding that suits your characters best (UTF-8 is recommended). If you load files with non-ascii-characters in Grace, this will not work. Also note, that the encoding set for the text has to be present on the system to be able to load the text properly. In case the encoding of a project file differs from the current encoding a warning is displayed. This can sometimes be anoying and can be switched off."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
QLabel * label2 = new QLabel(QObject::tr("Decimal separator to use:"));
QLabel * label3 = new QLabel(QObject::tr("File text encoding:"));
QComboBox * cmbDecSep=new QComboBox(this);
cmbDecSep->addItem(QString("."));
cmbDecSep->addItem(QString(","));
QComboBox * cmbEncoding=new QComboBox(this);
    for (int i=0;i<avcod.length();i++)
    cmbEncoding->addItem(avcod.at(i));
QCheckBox * chkWarningEncodingChange=new QCheckBox(QObject::tr("Display warning on encoding change"),this);
layout->addWidget(label,0,0,1,2);
layout->addWidget(label2,1,0,1,1);
layout->addWidget(cmbDecSep,1,1,1,1);
layout->addWidget(label3,2,0,1,1);
layout->addWidget(cmbEncoding,2,1,1,1);
layout->addWidget(chkWarningEncodingChange,3,0,1,2);
layout->addWidget(explanation,4,0,1,2);
setLayout(layout);
    if (warn_on_encoding_change)
    chkWarningEncodingChange->setChecked(true);
    else
    chkWarningEncodingChange->setChecked(false);
    if (DecimalPointToUse=='.')
    cmbDecSep->setCurrentIndex(0);
    else
    cmbDecSep->setCurrentIndex(1);
int index=0;
for (int i=0;i<avcod.length();i++)
{
    if (FileCodec==QTextCodec::codecForName(avcod.at(i)))
    {
    index=i;
    break;
    }
}
cmbEncoding->setCurrentIndex(index);
registerField("DecimalSeparator",cmbDecSep);
registerField("FileEncoding",cmbEncoding);
registerField("WarnOnEncodingChange",chkWarningEncodingChange);
}

WizardLatexPage::WizardLatexPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("LaTeX-Support (04 / 19)"));
QLabel * label = new QLabel(QObject::tr("For a more convenient input of formulas in text labels QtGrace is able to accept simple LaTeX-commands.\n\nDo you want to activate the LaTeX-support?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nThis is done via a simple LaTeX-to-Grace-font-commands-translator. It is NOT a full LaTeX interpreter. To use the LaTeX-commands put them inside double '$'-characters like '$$\\alpha$$'. The offsets for the character glyphs have been optimized for the use with T1-fonts and may produce results that may not look perfect in the case of QtFont (see next page).\n\nIf you enter text containing LaTeX-commands in the GUI and want to fine-tune the resulting glyph commands click on the label left of the input-line where the commands have been entered. This will toggle between LaTeX-mode and Grace-input-mode. For example '$$\\alpha$$' is translated to '\\xa\\f{}'. If you edit the input in Grace-input-mode and press Enter the fine-tuned input will replace the LaTeX-command because a revers translation is not possible."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (simple LaTeX-commands are accepted)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (only Grace-font-commands are accepted - LaTeX-commands are not translated)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("LatexActive", radYes);
if (activateLaTeXsupport==true)
radYes->setChecked(true);
else
radNo->setChecked(true);
}

WizardQtFontsPage::WizardQtFontsPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("QtFonts (05 / 19)"));
QLabel * label = new QLabel(QObject::tr("The T1-fonts used in Grace / XmGrace mostly contain the ascii-characters and a few special characters. Only with special additions other characters can theoretically be used. In QtGrace you can also use characters from any other font you have installed on your system.\n\nDo you want to activate the QtFonts?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nThis breaks the compatibility with the original Grace, but allows the usage of for example chinese characters. If QtFonts are activated the fonts are still accessed via numbers like in the original Grace and the first fonts are the same as in Grace / XmGrace. To add additional special fonts (on a project-specific basis) you have to click on the 'Font'-button left of every font-selector and select any font you like from the font-dialog (please note that the font size selected in the font-dialog is ignored). Please note that the font you want to use has to be present on any system you load the project file on. The T1-fonts are a guaranteed part of the QtGrace-/Grace-/XmGrace-installation.\n\nContrary to the T1-font every Qt-font contains the greek letters and special mathematical characters - but the placing in the character table is different. In order to use the symbol-font like in Grace the symbol font for the Qt-fonts has to be set as special. With this option the T1-characters of the symbol font are translated to their positions in the UTF-8-encoding. If the symbol font is not to be treated as special it is harder to access greek letters, but greek-letters can be displaed in any font (that has glyphs for them) in the same way."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (use Qt-fonts instead of T1-fonts)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (only Grace-T1-fonts are used)"),this);
QCheckBox * chkSpecial=new QCheckBox(QObject::tr("Symbol-font is special"));
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(chkSpecial);
layout->addWidget(explanation);
setLayout(layout);
registerField("QtFontsActive", radYes);
registerField("SymbolFontSpecial", chkSpecial);
if (useQtFonts==true)
radYes->setChecked(true);
else
radNo->setChecked(true);
chkSpecial->setChecked(symbol_font_is_special);
}

WizardMouseWheelPage::WizardMouseWheelPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Usage of the Mouse Wheel (06 / 19)"));
QLabel * label = new QLabel(QObject::tr("If you want to zoom in with the mouse-wheel activate zooming and place the cursor at the position at which you want to zoom in and rotate the mouse wheel away from you. Rotation towards you will zoom out.\n\nYou may also use the mouse-wheel to resize different items in a plot.\n\nPlease select your preferences for the usage of the mouse-wheel:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nYou can increase or decrease the font sizes or the size of objects like boxes or lines. To change the font size of axis-tick-labels you have to use the mouse-wheel on the axis itself (not the axis-tick-labels); on all other texts using the mouse-wheel directly on the text changes the font size."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QCheckBox * chkZoom=new QCheckBox(QObject::tr("Use mouse-wheel for zooming in and out of the graph"),this);
QCheckBox * chkSizeChange =new QCheckBox(QObject::tr("Use mouse-wheel to change font sizes and object sizes"),this);
layout->addWidget(label);
layout->addWidget(chkZoom);
layout->addWidget(chkSizeChange);
layout->addWidget(explanation);
setLayout(layout);
registerField("MouseWheelZoom", chkZoom);
registerField("MouseWheelSize", chkSizeChange);
    if (allow_wheel_zoom)
    chkZoom->setChecked(true);
    else
    chkZoom->setChecked(false);
    if (allow_wheel_changes)
    chkSizeChange->setChecked(true);
    else
    chkSizeChange->setChecked(false);
}

WizardTextEditPage::WizardTextEditPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Edit Text in Main Drawing Area (07 / 19)"));
QLabel * label = new QLabel(QObject::tr("In Grace / XmGrace to edit labels you have to open separate dialogs and press apply.\nIn QtGrace it is possible to directly enter and edit text in the main drawing area. \n\nDo you want to activate the Inline-Editing?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nIf this option is activated just double-click on a text (like graph-title or -subtitle, set-legend, axis-label, custom-tick-label or text-annotation) and type your text. To accept your changes press 'Enter'/'Return'. To reject changes press 'Esc' or click outside the text.\n\nIf this inline-editing function is activated double click does not summon some of the dialogs any more but they can still be accessed via the Plot-menu or if you hold the CTRL-button while double clicking."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (Edit text entries in main drawing area)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (text can only be edited via the dialogs like in Grace / XmGrace)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("TextEditInMain", radYes);
if (inline_editing==true)
radYes->setChecked(true);
else
radNo->setChecked(true);
}

WizardContextMenuPage::WizardContextMenuPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Context Menu in Main Drawing Area (08 / 19)"));
QLabel * label = new QLabel(QObject::tr("QtGrace offers the option to summon a context menu for a set in the main drawing area by right-clicking on one of the points in a set. \n\nDo you want to activate the context menu?"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nThis menu is the same as in the set-lists. You can use it to change the appearance of a set or hide it and you may also do the data-set-operations (like sort)."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
QRadioButton * radYes=new QRadioButton(QObject::tr("Yes (summon context menu for sets via a right-click)"),this);
QRadioButton * radNo =new QRadioButton(QObject::tr("No  (no context menu in main drawing area - context menus only in set-lists)"),this);
layout->addWidget(label);
layout->addWidget(radYes);
layout->addWidget(radNo);
layout->addWidget(explanation);
setLayout(layout);
registerField("ContextMenuInMain", radYes);
    if (context_menu_in_main==true)
    radYes->setChecked(true);
    else
    radNo->setChecked(true);
}

WizardHighlightPage::WizardHighlightPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Set Highlighting (09 / 19)"));
QLabel * label = new QLabel(QObject::tr("In QtGrace sets or graphs can be highlighted for better identifying one set among lots of set.\n\nPlease select your preferences for the highlighting:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nTo highlight something select it in a list and press 'h'. To stop the highlighting select something outside the list (list loses focus) or press 'h' again. There is also an option to automatically stop highlighting after a specified amount of time. All highlights are done in dashed lines with an increased linewidth in a predefined color. The highlighted sets or graphs blink. You may also set, that every time you change the selection in a list the new selection is to be highlighted automatically.\n\nThe drawback of the hightlighting is, that it can be very cpu-intensive if you have large sets - especially if you also highlight the errorbars and symbols. QtGrace will react very slowly then. Keep this in mind if you consider activating auto-highlighting."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
QComboBox * cmbHighlightTime = new QComboBox(this);
QString entr[6];
entr[0]=tr("No limit");
entr[1]=QString("1 s");
entr[2]=QString("2 s");
entr[3]=QString("3 s");
entr[4]=QString("4 s");
entr[5]=QString("5 s");
    for (int i=0;i<6;i++)
    cmbHighlightTime->addItem(entr[i]);
QLabel * label2 = new QLabel(QObject::tr("Maximum time for highlight:"));
QLabel * label3 = new QLabel(QObject::tr("Highlight-color:"));
QComboBox * colSel = new QComboBox(this);
    for (unsigned int i=0;i<number_of_colors();i++)
    colSel->addItem(QString(get_colorname(i)));
QCheckBox * chkAutoHighlight = new QCheckBox(tr("Auto-highlight new selection\n(every time a new set or graph is selected the new selection is highlighted)"),this);
QCheckBox * chkHighlighErrorBars = new QCheckBox(tr("Highlight error bars and symbols\n(only lines are highlighted if not activated)"),this);
layout->addWidget(label,0,0,1,2);
layout->addWidget(label2,1,0,1,1);
layout->addWidget(cmbHighlightTime,1,1,1,1);
layout->addWidget(label3,2,0,1,1);
layout->addWidget(colSel,2,1,1,1);
layout->addWidget(chkAutoHighlight,3,0,1,2);
layout->addWidget(chkHighlighErrorBars,4,0,1,2);
layout->addWidget(explanation,5,0,1,2);
setLayout(layout);
registerField("HighlightColor", colSel);
registerField("HighlightTime", cmbHighlightTime);
registerField("AutoHighlight", chkAutoHighlight);
registerField("HighlightErrorBars", chkHighlighErrorBars);
    if (highlight_errorbars)
    chkHighlighErrorBars->setChecked(true);
    else
    chkHighlighErrorBars->setChecked(false);
    if (chkAutoHighlight)
    chkAutoHighlight->setChecked(true);
    else
    chkAutoHighlight->setChecked(false);
colSel->setCurrentIndex(highlight_color);
cmbHighlightTime->setCurrentIndex(highlight_time);
}

WizardAutoscalePage::WizardAutoscalePage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Extended autoscale options (10 / 19)"));
QLabel * label = new QLabel(QObject::tr("Grace / XmGrace ignore error bars for autoscaling and may position set points on the borders of a graph. QtGrace lets you choose to consider the errorbars for the autoscaling. You can also set a fraction of the range of X- and Y-axis around the borders of the graph that will stay empty after autoscaling.\n\nPlease set your preferences for the autoscaling:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nConcidering the errorbars for autoscaling makes sure the errorbars do not extend outside the graphs viewing area. Forcing a border around the data-points and errorbars to stay empty may give a more conveniant look to a graph. Please note: These settings only affect the autoscaling - you can still set any X- or Y-range for the axes manually."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
QCheckBox * chkErrorBarsForAutoscale = new QCheckBox(tr("Take error bars into account for autoscaling"),this);
QLabel * label2 = new QLabel(QObject::tr("Minimal offset from the borders as fraction of the axis-range:"));
QDoubleSpinBox * spnAutoScaleRange = new QDoubleSpinBox(this);
spnAutoScaleRange->setRange(0.0,0.5);
spnAutoScaleRange->setDecimals(3);
spnAutoScaleRange->setSingleStep(0.01);
layout->addWidget(label,0,0,1,2);
layout->addWidget(chkErrorBarsForAutoscale,1,0,1,2);
layout->addWidget(label2,2,0,1,1);
layout->addWidget(spnAutoScaleRange,2,1,1,1);
layout->addWidget(explanation,3,0,1,2);
setLayout(layout);
registerField("AutoscaleIncludingErrorBars", chkErrorBarsForAutoscale);
registerField("AutoscaleBorderOffset",spnAutoScaleRange);
    if (useErrorbarsInAutoscale)
    chkErrorBarsForAutoscale->setChecked(true);
    else
    chkErrorBarsForAutoscale->setChecked(false);
spnAutoScaleRange->setValue(minAutoscaleBorderOffset);
}

WizardListIconsPage::WizardListIconsPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Additional Icons in Lists (11 / 19)"));
QLabel * label = new QLabel(QObject::tr("QtGrace allows the display of icons in some lists or on some buttons to better illustrate the purpose of the options.\n\nPlease select your prefered setting:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nThis setting is global for every dialog and is mainly meant for the color-selectors or the symbol-type.\nThe additional icons also affect the buttons in the Drawing-Objects-Dialog."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
int nr=3;
QString * entries=new QString[3];
entries[0]=tr("No Icons");
entries[1]=tr("Icons and text");
entries[2]=tr("Just icons (no text)");
StdSelector * selIcons=new StdSelector(this,QObject::tr("Icons on buttons and in lists:"),nr,entries);
layout->addWidget(label,0,0,1,1);
layout->addWidget(selIcons,1,0,1,1);
layout->addWidget(explanation,2,0,1,1);
setLayout(layout);
delete[] entries;
selIcons->setCurrentValue(icon_preferences);
registerField("IconPreferences",selIcons->cmbSelect);
}

WizardUniListSettingsPage::WizardUniListSettingsPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Display settings for Set-Lists (12 / 19)"));
QLabel * label = new QLabel(QObject::tr("In QtGrace the set-lists can display additional informations about data sets apart from the set-ID.\n\nSelect what to show:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nUsually a set is denoted by the set-ID like G1.S5 (set number 5 in graph number 1).\nThe list can as well display comment or legend for every set (the comment contains in most cases the origin of a data set - like the file it has been loaded from).\nThe list can also display icons showing a simplified representation of the set appearance (which can be very handy indeed).\n\nA list usually displays visible and hidden sets showing (+) for visible and (-) for invisible sets. To match a list with what is shown in the main drawing area just deactivate the \"Hidden\"-option (invisble sets are inaccessible then apart from the \"Explorer\"-dialog).\n\nUsually sets without data-points are not shown in the lists but after deleting a set the appearance-settings are retained if \"kill-data\" is used. If new data is imported the new data is stored in the next free set-ID (i.e. the next set-ID that has no data in it or a new ID). If you want to edit the set appearance before loading data you have to activate \"Show data-less sets\" (but this can sometimes be confusing as well)."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
QCheckBox * chkShowDataLess=new QCheckBox(tr("Data-less sets"),this);
QCheckBox * chkShowHidden=new QCheckBox(tr("Hidden sets"),this);
QCheckBox * chkShowComment=new QCheckBox(tr("Set comments"),this);
QCheckBox * chkShowLegend=new QCheckBox(tr("Set legends"),this);
QCheckBox * chkShowIcons=new QCheckBox(tr("Icons"),this);
layout->addWidget(label,0,0,1,2);
layout->addWidget(chkShowIcons,1,0,1,1);
layout->addWidget(chkShowHidden,1,1,1,1);
layout->addWidget(chkShowComment,2,0,1,1);
layout->addWidget(chkShowLegend,2,1,1,1);
layout->addWidget(chkShowDataLess,3,0,1,1);
layout->addWidget(explanation,4,0,1,2);
chkShowDataLess->setChecked(DefaultSetListShowDataless);
chkShowHidden->setChecked(DefaultSetListShowHidden);
chkShowComment->setChecked(DefaultSetListShowComments);
chkShowLegend->setChecked(DefaultSetListShowLegends);
chkShowIcons->setChecked(DefaultSetListShowIcons);

registerField("ListDataLess",chkShowDataLess);
registerField("ListHidden",chkShowHidden);
registerField("ListComment",chkShowComment);
registerField("ListLegend",chkShowLegend);
registerField("ListIcons",chkShowIcons);

setLayout(layout);
}

WizardLibFFTW3Page::WizardLibFFTW3Page(QWidget * parent):QWizardPage(parent)
{
    check_external_lib_usability();
setTitle(QObject::tr("FFTW3-library (13 / 19)"));
QString labeltext=QObject::tr("The FFTW3-library can be used in QtGrace for more efficient fourier-transformations.");
QString labeltext2=QObject::tr("FFTW3-library usable.");

#ifdef USE_STATIC_EXT_LIB_FFTW3
labeltext+=QObject::tr("\n\nThe FFTW3-library has been linked to your build of QtGrace statically and is therefore always available.");
labeltext+=QObject::tr("\n\nYou just have to choose whether you want to use it (or not).");
#else
labeltext+=QObject::tr("\n\nIf you have the FFTW3-library on your system and want to use it for all fourier-transformations you have to tell QtGrace the location of the library and activate it.");
labeltext2=QObject::tr("FFTW3-library NOT usable.");
#endif

/*have_fftw3
path_to_fftw3_lib*/

QLabel * label = new QLabel(labeltext);
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nInternally QtGrace uses a simple Fast-Fourier-algorithm for fourier transformations of sets with a number of points that is a power of 2. For other sets a discrete fourier transformation is used that is very slow."));
lblUsable = new QLabel(labeltext2);
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,2);

ledLibraryPath=new stdLineEdit(this,QObject::tr("Library path:"));
ledLibraryPath->setText(path_to_fftw3_lib.fileName());
QPushButton * cmdBrowse=new QPushButton(QObject::tr("Browse"),this);
connect(cmdBrowse,SIGNAL(clicked()),SLOT(doBrowse()));

layout->addWidget(ledLibraryPath,1,0,1,1);
layout->addWidget(cmdBrowse,1,1,1,1);

QCheckBox * chkUseFFTW3=new QCheckBox(QObject::tr("Use FFTW3 for fourier-transformations"),this);
chkUseFFTW3->setChecked(use_fftw3);
layout->addWidget(lblUsable,2,0,1,2);
layout->addWidget(chkUseFFTW3,3,0,1,2);
registerField("UseFFTW3",chkUseFFTW3);
registerField("LibFFTW3Path",ledLibraryPath->lenText);

#ifdef USE_STATIC_EXT_LIB_FFTW3
ledLibraryPath->hide();
cmdBrowse->hide();
#else
bool usability=is_fftw3_lib_usable(ledLibraryPath->text());
    if (usability)
    {
    labeltext2=QObject::tr("FFTW3-library usable.");
    }
    else
    {
    labeltext2=QObject::tr("FFTW3-library NOT usable!");
    }
lblUsable->setText(labeltext2);
#endif
layout->addWidget(explanation,4,0,1,2);
setLayout(layout);
}

void WizardLibFFTW3Page::doBrowse(void)
{
QString suffix;
QString labeltext2=QObject::tr("FFTW3-library usable.");
#ifdef WINDOWS_SYSTEM
    suffix=QString("*.dll");
#endif
#ifdef MAC_SYSTEM
    suffix=QString("*.dylib");
#else
    #ifdef LINUX_SYSTEM
    suffix=QString("*.so");
    #endif
#endif
QString fileName = QFileDialog::getOpenFileName(this, QObject::tr("Select FFTW3-library file"),
                                                ledLibraryPath->text(),
                                                QObject::tr("Dynamic library (")+suffix+QString(")"));
    if (!fileName.isEmpty())
    {
    //qDebug() << "New File: " << fileName;
    bool usability=is_fftw3_lib_usable(fileName);
        if (usability==true)
        {
        ledLibraryPath->setText(fileName);
        labeltext2=QObject::tr("FFTW3-library usable.");
        }
        else
        {
        QMessageBox::warning(this,tr("Invalid file"),tr("The file you selected does not seem to contain a compatible version of the FFTW3-library."));
            if (is_fftw3_lib_usable(ledLibraryPath->text())==true)
            labeltext2=QObject::tr("FFTW3-library usable.");
            else
            labeltext2=QObject::tr("FFTW3-library NOT usable!");
        }
    lblUsable->setText(labeltext2);
    }
    //qDebug() << "Browse fftw3";
}

WizardLibHaruPage::WizardLibHaruPage(QWidget * parent):QWizardPage(parent)
{
    check_external_lib_usability();
setTitle(QObject::tr("Haru-pdf-library (14 / 19)"));
QString labeltext=QObject::tr("Grace / XmGrace can also use an external pdf-library. ");
QString labeltext2=QObject::tr("Haru-PDF-library usable.");

#ifdef USE_STATIC_EXT_LIB_HARU
labeltext+=QObject::tr("\n\nThe Haru-PDF-library has been linked to your build of QtGrace statically and is therefore always available.");
labeltext+=QObject::tr("\n\nYou just have to choose whether you want to use it (or not).");
#else
labeltext+=QObject::tr("\n\nIf you have the Haru-PDF-library on your system, you may use it in QtGrace.");
labeltext+=QObject::tr("\n\nIf you want to use it you have to tell QtGrace the location of the library and activate it.");
labeltext2=QObject::tr("Haru-PDF-library NOT usable.");
#endif
/*have_libHaru
path_to_libharu;*/

QLabel * label = new QLabel(labeltext);
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nFor the export of the project you can by default use formats like PNG, JPG or Postscript. Unfortunately the pdf-library used by XmGrace is not completely free for use in every case. Therefore QtGrace can use the Haru-PDF-library to export as pdf-files instead.\n\nTo actually export something as pdf you also have to choose PDF(Haru) as the output-format in the export-setup-dialog.\n\nPlease note, that there is also an internal pdf-export-function available that utilizes the pdf-export-capability of the Qt-library. If you use QtFonts and a Qt-version of at least 5.3 the internal pdf-export should produce nice pdf-files. On previous Qt-versions the pdf-files just contain a screenshot of the project (i.e. low quality). If Qt-fonts are not used, the Qt-PDF-export is unable to export text (yet). Sorry. Therefore without QtFonts or with a Qt-version lower than 5.3 the Haru-pdf-library is the best option for pdf-export. If you use QtFonts, the Haru-pdf-library will not be able to export text (sorry).\n\nSummary: If you are not using QtFonts you probably want the Haru-PDF-library to export pdf-files."));
lblUsable = new QLabel(labeltext2);
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,2);

ledLibraryPath=new stdLineEdit(this,QObject::tr("Library path:"));
ledLibraryPath->setText(path_to_libharu.fileName());
QPushButton * cmdBrowse=new QPushButton(QObject::tr("Browse"),this);
connect(cmdBrowse,SIGNAL(clicked()),SLOT(doBrowse()));

layout->addWidget(ledLibraryPath,1,0,1,1);
layout->addWidget(cmdBrowse,1,1,1,1);

QCheckBox * chkUseLibHaru=new QCheckBox(QObject::tr("Enable the Haru-PDF-library for PDF-export"),this);
chkUseLibHaru->setChecked(use_libHaru);
layout->addWidget(lblUsable,2,0,1,2);
layout->addWidget(chkUseLibHaru,3,0,1,2);
registerField("UseLibHaru",chkUseLibHaru);
registerField("LibHaruPath",ledLibraryPath->lenText);

#ifdef USE_STATIC_EXT_LIB_HARU
ledLibraryPath->hide();
cmdBrowse->hide();
#else
bool usability=is_Haru_lib_usable(ledLibraryPath->text());
    if (usability)
    {
    labeltext2=QObject::tr("Haru-PDF-library usable.");
    }
    else
    {
    labeltext2=QObject::tr("Haru-PDF-library NOT usable!");
    }
lblUsable->setText(labeltext2);
#endif
layout->addWidget(explanation,4,0,1,2);
setLayout(layout);
}

void WizardLibHaruPage::doBrowse(void)
{
QString suffix;
QString labeltext2=QObject::tr("Haru-PDF-library usable.");
#ifdef WINDOWS_SYSTEM
    suffix=QString("*.dll");
#endif
#ifdef MAC_SYSTEM
    suffix=QString("*.dylib");
#else
    #ifdef LINUX_SYSTEM
    suffix=QString("*.so");
    #endif
#endif
QString fileName = QFileDialog::getOpenFileName(this, QObject::tr("Select HaruPDF-library file"),
                                                    ledLibraryPath->text(),
                                                    QObject::tr("Dynamic library (")+suffix+QString(")"));
    if (!fileName.isEmpty())
    {
    //qDebug() << "New File: " << fileName;
    bool usability=is_Haru_lib_usable(fileName);
        if (usability==true)
        {
        ledLibraryPath->setText(fileName);
        labeltext2=QObject::tr("Haru-PDF-library usable.");
        }
        else
        {
        QMessageBox::warning(this,tr("Invalid file"),tr("The file you selected does not seem to contain a compatible version of the Haru-PDF-library."));
            if (is_Haru_lib_usable(ledLibraryPath->text()))
            labeltext2=QObject::tr("Haru-PDF-library usable.");
            else
            labeltext2=QObject::tr("Haru-PDF-library NOT usable!");
        }
    lblUsable->setText(labeltext2);
    }
    //qDebug() << "Browse haru";
}

bool WizardLibHaruPage::validatePage()
{
outPage->initializePage();
return true;
}

WizardToolBarPage::WizardToolBarPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Tool bar contents (15 / 19)"));
QLabel * label = new QLabel(QObject::tr("The contents of the tool-bar on the left hand side of the main window are extended in QtGrace in comparison with Grace / XmGrace.\n\nChoose what should be displayed in the tool-bar:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nNot every one might need every button regularely. Therefore the contents of the tool-bar can be adjusted.\nThe following options activate or deactivate buttons or groups of buttons according to specific purposes.\nThe \"Pan\"-button allows you to click and drag the viewing area (i.e. shift the axis ranges up and down).\nThe \"Move\"-button allows you to click and move most things in the viewing area (like graph- or axis-labels, legends or objects). You can also click-and-drag the viewing area like with the \"Pan\"-button. Be aware, that althought the \"Move\"-button can do everything the \"Pan\"-button can and more, the \"Pan\"-button is saver in its use! The \"Move\"-button can change the positioning of labels from auto to specified without you noticing (if you click on the labels while \"Move\" is active - keep this in mind).\nThe graph-list is used to select more than one graph for simultaneous zooming and shifting of the contents.\n\nThe export button prints the current projects contents in a file as set in the export-setup-dialog. If nothing is set explicitly the file name is the same as the project file name with a different suffix according to the currently set export format.\nThe new icons are just a different / more colorful representation of the icons on the move- and zoom-buttons."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;

int index=3;
QString entries[3];
entries[0]=tr("Hide button");
entries[1]=tr("Show button");
entries[2]=tr("Always on");

QCheckBox * chkNewIcons=new QCheckBox(tr("Use new icons"),this);
QCheckBox * chkShowNavi=new QCheckBox(tr("Show navigation buttons"),this);
QCheckBox * chkShowGraph=new QCheckBox(tr("Show graph list"),this);
QCheckBox * chkShowSpecZoom=new QCheckBox(tr("Show special zoom buttons"),this);
//QCheckBox * chkShowViewp=new QCheckBox(tr("Show viewport stack"),this);
QCheckBox * chkShowPageZoom=new QCheckBox(tr("Show page zoom"),this);
QCheckBox * chkShowPrintB=new QCheckBox(tr("Show print button"),this);
QCheckBox * chkShowExportP=new QCheckBox(tr("Show export button"),this);

StdSelector * selPanB=new StdSelector(this,tr("Pan:"),index,entries);
StdSelector * selMoveB=new StdSelector(this,tr("Move:"),index,entries);

/*QCheckBox * chkShowPanB=new QComboBox(tr("Show pan button"),this);
QCheckBox * chkShowPickB=new QCheckBox(tr("Show move button"),this);*/

QCheckBox * chkShowUndoRedo=new QCheckBox(tr("Show Undo/Redo buttons"),this);

layout->addWidget(label,0,0,1,2);
layout->addWidget(chkNewIcons,1,0,1,1);
layout->addWidget(chkShowNavi,1,1,1,1);
layout->addWidget(chkShowGraph,2,0,1,1);
layout->addWidget(chkShowSpecZoom,2,1,1,1);
//layout->addWidget(chkShowViewp,3,0,1,1);
layout->addWidget(chkShowPageZoom,3,1,1,1);
layout->addWidget(chkShowPrintB,4,0,1,1);
layout->addWidget(chkShowExportP,4,1,1,1);
/*layout->addWidget(chkShowPanB,5,0,1,1);
layout->addWidget(chkShowPickB,5,1,1,1);*/
layout->addWidget(selPanB,5,0,1,1);
layout->addWidget(selMoveB,5,1,1,1);
layout->addWidget(chkShowUndoRedo,3,0,1,1);//was 6,0,1,1
layout->addWidget(explanation,6,0,1,2);
chkNewIcons->setChecked(use_new_icons);
chkShowNavi->setChecked(show_Navi_B);
chkShowGraph->setChecked(show_Graph_List);
chkShowSpecZoom->setChecked(show_special_Zoom);
//chkShowViewp->setChecked(show_Viewport_Stack);
chkShowPageZoom->setChecked(show_Page_Zoom);
chkShowPrintB->setChecked(show_Print_B);
chkShowExportP->setChecked(show_Export_B);
selPanB->setCurrentIndex(show_PanButton);
selMoveB->setCurrentIndex(show_PickButton);
/*chkShowPanB->setChecked(show_PanButton);
chkShowPickB->setChecked(show_PickButton);*/
chkShowUndoRedo->setChecked(show_UndoRedo_B);

registerField("ToolsNewIcons",chkNewIcons);
registerField("ToolsNavi",chkShowNavi);
registerField("ToolsGraph",chkShowGraph);
registerField("ToolsSpecZoom",chkShowSpecZoom);
//registerField("ToolsViewportStack",chkShowViewp);
registerField("ToolsPageZoom",chkShowPageZoom);
registerField("ToolsPrint",chkShowPrintB);
registerField("ToolsExport",chkShowExportP);
/*registerField("ToolsPan",chkShowPanB);
registerField("ToolsPick",chkShowPickB);*/
registerField("ToolsPan",selPanB->cmbSelect);
registerField("ToolsPick",selMoveB->cmbSelect);
registerField("ToolsUndo",chkShowUndoRedo);

setLayout(layout);

}

WizardToolBarPage2::WizardToolBarPage2(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Viewport-Stack (16 / 19)"));
QLabel * label = new QLabel(QObject::tr("In Grace/XmGrace the user has an option to store different viewports (that means different settings for X- and Y-axis representing different zoom stages).\n\nChoose how the viewport-stack should be accessed:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nIn Grace/XmGrace these viewports are numbered and organized in a stack that can be accessed via the tool bar (Push/Pop). The user may cycle through all viewports in the stack. The accessability is a bit limited and therefore QtGrace offers extended control.\n\nIn QtGrace you may name every viewport in the stack and randomly access any of the entries in the stack and also rearrange the order of the stack. You may cycle the stack in both directions."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;

int index=3;
QString entries[3];
entries[0]=tr("Hide controls");
entries[1]=tr("Simple controls (Grace/XmGrace)");
entries[2]=tr("Complete list (QtGace)");
StdSelector * selShowViewp=new StdSelector(this,tr("Viewport:"),index,entries);

layout->addWidget(label,0,0,1,2);
layout->addWidget(selShowViewp,1,0,1,1);
layout->addWidget(explanation,2,0,1,2);
selShowViewp->setCurrentIndex(show_Viewport_Stack);

registerField("ToolsViewportStack",selShowViewp->cmbSelect);
setLayout(layout);
}

WizardStartUpPage::WizardStartUpPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Start up file (17 / 19)"));
QLabel * label = new QLabel(QObject::tr("In Grace / XmGrace the file Default.agr in the bin-folder is loaded on startup and when 'New' is pressed. QtGrace now offers to use any Grace-project file in any folder on startup.\n\nPlease select a default startup file:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nYou may also choose to store the file-path relative to the QtGrace-executable-file or absolute.\n\nThe default-path for startup-files is now the templates-subfolder in the QtGrace-directory."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,2);
lenAbsoluteFile=new stdLineEdit(this,QObject::tr("Absolute startup file path:"));

cmdBrowse=new QPushButton(QObject::tr("Browse"),this);
connect(cmdBrowse,SIGNAL(clicked()),SLOT(doBrowse()));
layout->addWidget(lenAbsoluteFile,1,0,1,1);
layout->addWidget(cmdBrowse,1,1,1,1);

radAbsolute=new QRadioButton(QObject::tr("Store file path absolute"),this);
radRelative=new QRadioButton(QObject::tr("Store file path relative to the QtGrace executable file"),this);
connect(radAbsolute,SIGNAL(toggled(bool)),SLOT(changeSaving(bool)));

layout->addWidget(radAbsolute,2,0,1,2);
layout->addWidget(radRelative,3,0,1,2);
QLabel * lblLabel=new QLabel(QObject::tr("The following path-information will be stored:"),this);
lblResult=new QLabel(QObject::tr(""),this);

layout->addWidget(lblLabel,4,0,1,2);
layout->addWidget(lblResult,5,0,1,2);
layout->addWidget(explanation,6,0,1,2);
registerField("DefaultStartupFilePath",lblResult);

char dummy[1024];
QFileInfo fi1(default_grace_file);
    if (fi1.isAbsolute()==true)
    {
    strcpy(dummy,default_grace_file);
    }
    else
    {
    sprintf(dummy,"%s/%s",qt_grace_templates_dir,default_grace_file);
    }
lenAbsoluteFile->setText(dummy);//default_grace_file);
    if (fi1.isAbsolute()==true)
    {
    radAbsolute->setChecked(true);
    }
    else
    {
    radRelative->setChecked(true);
    }
changeSaving(radAbsolute->isChecked());

setLayout(layout);
}

void WizardStartUpPage::doBrowse(void)
{
QString fileName = QFileDialog::getOpenFileName(this, QObject::tr("Select default project file"),
                                                lenAbsoluteFile->text(),
                                                QObject::tr("QtGrace Project file (*.agr)"));
    if (!fileName.isEmpty())
    {
    //qDebug() << "New File";
    lenAbsoluteFile->setText(fileName);
    changeSaving(radAbsolute->isChecked());
    }
    /*else
    {
    qDebug() << "No File selected";
    }*/
}

void WizardStartUpPage::changeSaving(bool t)
{
//qDebug() << "Change=" << t;
    if (t)//absolute
    {
    lblResult->setText(lenAbsoluteFile->text());
    }
    else
    {
    QFileInfo fi(lenAbsoluteFile->text());
    QString templ_dir=QString(qt_grace_templates_dir);
    QDir fi1(templ_dir);
    lblResult->setText(fi1.relativeFilePath(fi.absoluteFilePath()));
    }
}

WizardOutputPage::WizardOutputPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Default Output Format (18 / 19)"));
QLabel * label = new QLabel(QObject::tr("Please choose a file format to save pictures / hardcopies by default:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nQtGrace is able to export directly into files of different formats. If you load a project file the extension for the export is automatically set according to the export format and if you click on the Export button an outputfile is automatically produced with the same name as the project file but with a different suffix.\n\nThe output format is used as it has been set in the export-setup-dialog. When QtGrace is opened the output-format will be set to a default format that can be set here.\n\nIf you select 'Last selection' the output format that was set when QtGrace is closed will be used as default when QtGrace is opened again."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,1);

int nr=number_of_devices();
QString * entr=new QString[32+nr];
int * i_entr=new int[32+nr];

int useHaru=field("UseLibHaru").toInt();
if (have_libHaru==FALSE) useHaru=FALSE;

entr[0]=QObject::tr("Last selection");
i_entr[0]=-1;
for (int i=0;i<nr;i++)
{
    if ((i!=DEVICE_SCREEN && i!=DEVICE_PDF_HARU) || (i==DEVICE_PDF_HARU && useHaru==TRUE))
    {
    entr[i]=get_device_name(i);
    i_entr[i]=i;
    }
}
devices_item=new StdSelector(this,tr("Please select the default output format:"),nr,entr);
devices_item->setValues(i_entr);
delete[] i_entr;
delete[] entr;
layout->addWidget(devices_item,1,0,1,1);
layout->addWidget(explanation,2,0,1,2);
devices_item->setCurrentIndex(default_Print_Device);
registerField("DefaultOutputFormat",devices_item->cmbSelect);
setLayout(layout);
}

void WizardOutputPage::initializePage()
{
    int nr=number_of_devices(),counter;
    QString * entr=new QString[32+nr];
    int * i_entr=new int[32+nr];

    int useHaru=field("UseLibHaru").toInt();
    if (have_libHaru==FALSE) useHaru=FALSE;

    entr[0]=QObject::tr("Last selection");
    i_entr[0]=-1;
    counter=1;
    for (int i=0;i<nr;i++)
    {
        if ((i!=DEVICE_SCREEN && i!=DEVICE_PDF_HARU) || (i==DEVICE_PDF_HARU && useHaru==TRUE))
        {
        entr[i]=get_device_name(i);
        i_entr[i]=i;
        counter++;
        }
    }
devices_item->setNewEntries(counter,entr,i_entr);
devices_item->setCurrentIndex(default_Print_Device);
}

void WizardOutputPage::cleanupPage()
{
devices_item->cmbSelect->clear();
}

WizardBehaviorPage::WizardBehaviorPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("General Behavior (19 / 19)"));
QLabel * label = new QLabel(QObject::tr("You may choose between different behaviors of the general interface. You can choose to use QtGrace like XmGrace or you can choose a more modern behavior:"));
QLabel * explanation = new QLabel(QObject::tr("----------------------------------------\nFurther explanation:\n\nWhen closing QtGrace while there are still unsaved changes the same question as in Grace / XmGrace is displayed (\"Exit loosing unsaved changes\" --> 'yes' means just close without saving).\nThis question may not be easily understandable for the beginner.\nTherefore the text of the question can be changed (\"Contents changed. Save?\" --> 'discard' / 'Don't save' means closing without saving, 'abort' means not closing).\n\nThe behavior of QtGrace also implies to open the default file dialog for saving and loading some of the files instead of the cumbersome file-dialog of Grace / XmGrace. Generally you may also open the default file dialog of the operating system from inside the Grace-file-dialog via the folder-button on the right hand side of the dialog. Regardsless of what you select here, you may also open the other type of file-dialog by holding down the CTRL-key while choosing Load/Save."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
explanation->setAlignment(Qt::AlignJustify);
explanation->setWordWrap(true);
QGridLayout * layout = new QGridLayout;
layout->addWidget(label,0,0,1,1);
int nr=2;
QString * entries=new QString[2];
entries[0]=tr("Grace / XmGrace");
entries[1]=tr("QtGrace");
StdSelector * selIcons=new StdSelector(this,tr("General behavior like:"),nr,entries);
selIcons->setCurrentIndex(general_behavior);
registerField("GeneralBehavior",selIcons->cmbSelect);
delete[] entries;
layout->addWidget(selIcons,1,0,1,1);
layout->addWidget(explanation,2,0,1,1);
setLayout(layout);
}

WizardFinishPage::WizardFinishPage(QWidget * parent):QWizardPage(parent)
{
setTitle(QObject::tr("Setup finished!"));
QLabel * label = new QLabel(QObject::tr("The setup of QtGrace has been finished. If you accept/finish this Wizard-Dialog your choices will be used as the preferences for QtGrace and will be stored in an ini-file when QtGrace is closed regularely.\n\nIf you want to reactivate this Setup-Wizard go to Preferences->Miscellaneous.\n\nAll settings in this Wizard-Dialog can also be altered via the Preferences-Dialog.\n\nHave fun using QtGrace."));
label->setAlignment(Qt::AlignJustify);
label->setWordWrap(true);
QVBoxLayout * layout = new QVBoxLayout;
layout->addWidget(label);
setLayout(layout);
}

InitQtGraceWizard::InitQtGraceWizard(QWidget * parent):QWizard(parent)
{
setWindowTitle(tr("Setup Wizard"));
setOption(QWizard::IndependentPages,true);
addPage(new WizardIntroPage);//0
addPage(new WizardUndoPage);//1
addPage(new WizardImmediateUpdatePage);//2
addPage(new WizardDecSepPage);//3
addPage(new WizardLatexPage);//4
addPage(new WizardQtFontsPage);//5
addPage(new WizardMouseWheelPage);//6
addPage(new WizardTextEditPage);//7
addPage(new WizardContextMenuPage);//8
addPage(new WizardHighlightPage);//9
addPage(new WizardAutoscalePage);//10
addPage(new WizardListIconsPage);//11
addPage(new WizardUniListSettingsPage);//12
addPage(new WizardLibFFTW3Page);//13
WizardLibHaruPage * lharu=new WizardLibHaruPage();
addPage(lharu);//14
addPage(new WizardToolBarPage);//15
addPage(new WizardToolBarPage2);//16
startuppage=new WizardStartUpPage();
addPage(startuppage);//17
WizardOutputPage * outpage=new WizardOutputPage();
addPage(outpage);//18
lharu->outPage=outpage;
addPage(new WizardBehaviorPage);//19
addPage(new WizardFinishPage);//20(End)
connect(this,SIGNAL(currentIdChanged(int)),this,SLOT(PageChanged(int)));
setOption(QWizard::NoCancelButton,false);
setMinimumSize(800,600);
resize(LastSize_Form_InitWizard);
}

InitQtGraceWizard::~InitQtGraceWizard()
{
    LastSize_Form_InitWizard=this->size();
}

void InitQtGraceWizard::initAllPages(void)
{
//setField("undoActive", !undo_active);
//setField("ImmUpdateActive", immediateUpdate);
}

void InitQtGraceWizard::setGlobalsToWizardValues(void)
{
start_with_undo_active=undo_active=field("undoActive").toInt();
immediateUpdate=field("ImmUpdateActive").toBool();
activateLaTeXsupport=field("LatexActive").toBool();
useQtFonts=field("QtFontsActive").toBool();
symbol_font_is_special=field("SymbolFontSpecial").toBool();

inline_editing=field("TextEditInMain").toInt();
context_menu_in_main=field("ContextMenuInMain").toInt();

auto_highlight=field("AutoHighlight").toInt();
highlight_errorbars=field("HighlightErrorBars").toInt();
highlight_color=field("HighlightColor").toInt();
highlight_time=field("HighlightTime").toInt();

useErrorbarsInAutoscale=field("AutoscaleIncludingErrorBars").toInt();
minAutoscaleBorderOffset=field("AutoscaleBorderOffset").toDouble();

allow_wheel_zoom=field("MouseWheelZoom").toInt();
allow_wheel_changes=field("MouseWheelSize").toInt();

icon_preferences=field("IconPreferences").toInt();

use_new_icons=field("ToolsNewIcons").toInt();
show_Navi_B=field("ToolsNavi").toInt();
show_Graph_List=field("ToolsGraph").toInt();
show_special_Zoom=field("ToolsSpecZoom").toInt();
show_Viewport_Stack=field("ToolsViewportStack").toInt();
show_Page_Zoom=field("ToolsPageZoom").toInt();
show_Print_B=field("ToolsPrint").toInt();
show_Export_B=field("ToolsExport").toInt();
show_PanButton=field("ToolsPan").toInt();
show_PickButton=field("ToolsPick").toInt();
show_UndoRedo_B=field("ToolsUndo").toInt();

DefaultSetListShowDataless=field("ListDataLess").toInt();
DefaultSetListShowHidden=field("ListHidden").toInt();
DefaultSetListShowComments=field("ListComment").toInt();
DefaultSetListShowLegends=field("ListLegend").toInt();
DefaultSetListShowIcons=field("ListIcons").toInt();

general_behavior=field("GeneralBehavior").toInt();

use_libHaru=field("UseLibHaru").toInt();
use_fftw3=field("UseFFTW3").toInt();

path_to_fftw3_lib.setFileName(field("LibFFTW3Path").toString());
path_to_libharu.setFileName(field("LibHaruPath").toString());

default_Print_Device=field("DefaultOutputFormat").toInt();

warn_on_encoding_change=field("WarnOnEncodingChange").toInt();
int dc=field("DecimalSeparator").toInt();
if (dc==0) DecimalPointToUse='.';
else DecimalPointToUse=',';
dc=field("FileEncoding").toInt();
FileCodec=QTextCodec::codecForName(avcod.at(dc));

strcpy(default_grace_file,startuppage->lblResult->text().toLocal8Bit().constData());
//strcpy(default_grace_file,field("DefaultStartupFilePath").toString().toLocal8Bit().constData());
}

void InitQtGraceWizard::PageChanged(int p)
{
(void)p;
int id=currentId();
//qDebug() << "id=" << id;
    switch (id)
    {
    case 0:
        break;
    case 1:
        //setField("undoActive", undo_active);
        break;
    case 2:
        //setField("ImmUpdateActive", immediateUpdate);
        break;
    case 3:
        break;
    default:
        break;
    }
}

void InitQtGraceWizard::done(int result)
{
//qDebug() << "Result=" << result;
    if (result)
    {
    setGlobalsToWizardValues();
    update_all();
    }
    else
    {
    QMessageBox::information(this,tr("Close Setup-Wizard"),tr("You are about to close the setup-wizard.\n\nYour choices will NOT be transferred to the settings.\n\nIf you want to change any settings later please go to the Preferences-dialog.\nYou may also summon this setup-dialog again via the Miscellaneous-tab therein."));
    }
QWizard::done(result);
}

void InitQtGraceWizard::closeEvent(QCloseEvent * e)
{
    e->accept();
//qDebug() << "cancel";
    done(0);
}

graphicTestWidget::graphicTestWidget(QWidget * parent):QWidget(parent)
{
setWindowTitle(QString("GraphicsTestWidget"));
resize(550,420);

lbltest=new QLabel(this);

lenEdit=new QLineEdit(QString("Text"),0);
lenEdit->setFrame(false);

//lenEdit->setAlignment(Qt::AlignHCenter | Qt::AlignVCenter);
lenEdit->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);

g_view=new QGraphicsView(this);
g_scene=new QGraphicsScene(this);
g_proxy = g_scene->addWidget(lenEdit);
g_view->setScene(g_scene);

transpPalette=this->palette();
transpPalette.setColor(QPalette::Base,Qt::transparent);//for testing
transpPalette.setColor(QPalette::AlternateBase,Qt::transparent);
transpPalette.setColor(QPalette::Window,Qt::transparent);
transpPalette.setColor(QPalette::Button,Qt::transparent);
transpPalette.setColor(QPalette::Text,Qt::black);
//transpPalette.setColor(QPalette::Base,Qt::green);
g_scene->setPalette(transpPalette);
g_view->setPalette(transpPalette);
//transpPalette.setColor(QPalette::Base,Qt::yellow);
transpPalette.setColor(QPalette::Base,Qt::transparent);
lenEdit->setPalette(transpPalette);
//transpPalette.setColor(QPalette::Base,Qt::green);
//g_proxy->setPalette(transpPalette);
//transpPalette.setColor(QPalette::Base,Qt::yellow);
//this->setPalette(transpPalette);

//g_scene->setSceneRect(0,0,540,340);
//g_view->setGeometry(this->rect());
g_view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
g_view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

lenEdit->resize(620,25);
g_proxy->setPos(00.0,00.0);
g_view->centerOn(g_proxy);
g_view->hide();
g_view->setFocus();
g_proxy->setFocus();
lenEdit->setFocus(Qt::MouseFocusReason);

points[0].setX(100);//Position von oben links aus
points[0].setY(100);
points[1].setX(200);
points[1].setY(220);
points[2].setX(340);
points[2].setY(230);

QPixmap * pix=new QPixmap(500,300);
QPen pen;
QPainter * paint=new QPainter(pix);
pen=paint->pen();
pen.setWidth(1);//3
paint->setPen(pen);
paint->setBrush(Qt::white);
paint->drawRect(0,0,500-1,300-1);//-3
    for (int i=0;i<3;i++)
    paint->drawPoint(points[i]);
/*paint->drawPoint(100,100);
paint->drawPoint(200,220);
paint->drawPoint(340,230);*/
paint->end();

lbltest->setPixmap(*pix);
lbltest->setGeometry(0,0,500,300);

lblTitles[4]=new QLabel(tr("FontSize:"),this);
spnKoords[3]=new QSpinBox(this);
lblTitles[4]->setGeometry(0*120,300,120,30);
spnKoords[3]->setGeometry(1*120,300,120,30);

lblTitles[0]=new QLabel(tr("Rotation:"),this);
lblTitles[1]=new QLabel(tr("x_shift:"),this);
lblTitles[2]=new QLabel(tr("y_shift:"),this);
lblTitles[3]=new QLabel(tr("Alignment:"),this);
    for (int i=0;i<4;i++)
    {
    lblTitles[i]->setGeometry(i*120,330,120,30);
    }
spnKoords[0]=new QSpinBox(this);
spnKoords[1]=new QSpinBox(this);
spnKoords[2]=new QSpinBox(this);
for (int i=0;i<4;i++)
spnKoords[i]->setRange(-100,100);
spnKoords[0]->setValue(0);
spnKoords[1]->setValue(14);
spnKoords[2]->setValue(-2);
spnKoords[3]->setValue(12);

    for (int i=0;i<3;i++)
    {
    spnKoords[i]->setGeometry(i*120,360,120,30);
    }

cmbAlign=new QComboBox(this);
cmbAlign->setGeometry(3*120,360,120,30);
cmbAlign->addItem(tr("Left"));
cmbAlign->addItem(tr("Center"));
cmbAlign->addItem(tr("Right"));

push1=new QPushButton(tr("Show"),this);
push2=new QPushButton(tr("Reposition"),this);
push1->setGeometry(0,390,100,25);
push2->setGeometry(120,390,100,25);

connect(push1,SIGNAL(clicked()),SLOT(doPush1()));
connect(push2,SIGNAL(clicked()),SLOT(doPush2()));

for (int i=0;i<4;i++)
{
connect(spnKoords[i],SIGNAL(valueChanged(int)),SLOT(value_changed(int)));
}

ppoint=0;
}

void graphicTestWidget::doPush1(void)
{
//qDebug() << "Push 1";
    g_view->setGeometry(lbltest->rect());
    g_scene->setSceneRect(lbltest->rect());
    g_view->show();
    g_view->centerOn(g_proxy);
//qDebug() << lenEdit->pos();
    lenEdit->setText("Ag_Test_Text_New_gA");
position_text(points[ppoint].x(),points[ppoint].y());
}

void graphicTestWidget::doPush2(void)
{
//qDebug() << "Push 2";
    ppoint++;
    if (ppoint>=3) ppoint=0;
//position_text(points[ppoint].x(),points[ppoint].y());
doPush1();
}

void graphicTestWidget::value_changed(int i)
{
(void)i;
doPush1();
}

void graphicTestWidget::position_text(int xp,int yp)
{
//double rot=QInputDialog::getDouble(this,QString("Test"),QString("Rotation(degrees)="));
    int x_shift,y_shift,rot;
    double sa;//=sin(rot*M_PI/180.0);
    double ca;//=cos(rot*M_PI/180.0);
    double tmp1,tmp2;

#ifdef MAC_SYSTEM
    #if QT_VERSION >= 0x050000
    x_shift=0;
    y_shift=-1;
    #else
    x_shift=14;
    y_shift=-2;
    #endif
#endif
#ifdef WINDOWS_SYSTEM
    x_shift=2;
    y_shift=0;
#endif
#ifdef LINUX_SYSTEM
    x_shift=2;
    y_shift=0;
#endif

rot=spnKoords[0]->value();
x_shift=spnKoords[1]->value();
y_shift=spnKoords[2]->value();

switch (spnKoords[3]->value())
{
case 0://left
lenEdit->setAlignment(Qt::AlignVCenter | Qt::AlignLeft);
break;
case 1://center
lenEdit->setAlignment(Qt::AlignVCenter | Qt::AlignHCenter);
break;
case 2://right
lenEdit->setAlignment(Qt::AlignVCenter | Qt::AlignRight);
break;
}

QFont f1=lenEdit->font();
f1.setPixelSize(spnKoords[3]->value());
lenEdit->setFont(f1);
lenEdit->resize(lbltest->width(),f1.pixelSize()*2);

QRect rec=lenEdit->style()->itemTextRect(lenEdit->fontMetrics(),lenEdit->rect(),lenEdit->alignment(),true,lenEdit->text());
//qDebug() << "rec.x=" << rec.x() << " y=" << rec.y() << " w=" << rec.width() << " h=" << rec.height() << " baseline=" << baseline;
x_shift+=rec.x();
y_shift+=(lenEdit->height()-rec.height())/2+rec.height()-lenEdit->fontMetrics().descent();

/*
QPoint rec2=lenEdit->mapToParent(QPoint(rec.x(),rec.y()));
QPointF rec3=g_proxy->mapToParent(QPoint(rec2.x(),rec2.y()));
qDebug() << "rec2=" << rec2 << " rec3=" << rec3;
rec=lenEdit->style()->itemTextRect(lenEdit->fontMetrics(),QRect(0,0,10,10),lenEdit->alignment(),true,lenEdit->text());
qDebug() << "rec.x=" << rec.x() << " y=" << rec.y() << " w=" << rec.width() << " h=" << rec.height() << " baseline=" << baseline;
*/

/*
qDebug() << "proxy  =" << g_proxy->rect();
qDebug() << "lenEdit=" << lenEdit->rect();
qDebug() << "frameGeometry=" << lenEdit->frameGeometry();
qDebug() << "Geometry=" << lenEdit->geometry();
qDebug() << "frameSize=" << lenEdit->frameSize();
*/

g_proxy->resetTransform();
g_proxy->setRotation(-rot);
//g_proxy->moveBy(xp-g_proxy->x(),yp-g_proxy->y());

sa=sin(rot*M_PI/180.0);
ca=cos(rot*M_PI/180.0);

tmp1=ca*x_shift+sa*y_shift;
tmp2=-sa*x_shift+ca*y_shift;

x_shift=rint_2(tmp1);
y_shift=rint_2(tmp2);

//qDebug() << "x_shift=" << x_shift << " y_shift=" << y_shift;
g_proxy->moveBy(xp-g_proxy->x()-x_shift,yp-g_proxy->y()-y_shift);
}

frmGroupTestWidget::frmGroupTestWidget(QWidget * parent):QWidget(parent)
{
    grp_1=new QGroupBox(tr("Group 1"),this);
    layout1=new QGridLayout();
    layout1->setMargin(STD_MARGIN);
    layout1->setSpacing(STD_SPACING);
        for (int i=0;i<4;i++)
        {
        lbltest1[i]=new QLabel(tr("1: Test ")+QString::number(i),this);
        lentest1[i]=new QLineEdit(QString(""),this);
        layout1->addWidget(lbltest1[i],i,0);
        layout1->addWidget(lentest1[i],i,1);
        layout1->setRowStretch(i,1);
        }
        layout1->setRowStretch(4,10);
    grp_1->setLayout(layout1);

    grp_2=new QGroupBox(tr("Group 2"),this);
    layout2=new QGridLayout();
    layout2->setMargin(STD_MARGIN);
    layout2->setSpacing(STD_SPACING);
    layout2->setRowStretch(0,1);
    //nix
    grp_2->setLayout(layout2);

    grp_3=new QGroupBox(tr("Group 3"),this);
    layout3=new QGridLayout();
    layout3->setMargin(STD_MARGIN);
    layout3->setSpacing(STD_SPACING);
        for (int i=0;i<4;i++)
        {
        lbltest3[i]=new QLabel(tr("3: Test ")+QString::number(i),this);
        lentest3[i]=new QLineEdit(QString(""),this);
        layout3->addWidget(lbltest3[i],i,0);
        layout3->addWidget(lentest3[i],i,1);
        layout3->setRowStretch(i,1);
        }
        layout3->setRowStretch(4,10);
    grp_3->setLayout(layout3);

    grp_4=new QGroupBox(tr("Group 4"),this);
    layout4=new QGridLayout();
    layout4->setMargin(STD_MARGIN);
    layout4->setSpacing(STD_SPACING);
        for (int i=0;i<4;i++)
        {
        lbltest4[i]=new QLabel(tr("4: Test ")+QString::number(i),this);
        lentest4[i]=new QLineEdit(QString(""),this);
        layout4->addWidget(lbltest4[i],i,0);
        layout4->addWidget(lentest4[i],i,1);
        layout4->setRowStretch(i,1);
        }
        layout4->setRowStretch(4,10);
    grp_4->setLayout(layout4);

layout=new QVBoxLayout();
push=new QPushButton(tr("Push"),this);
connect(push,SIGNAL(clicked()),SLOT(doClick()));
layout->addWidget(grp_1);
layout->addWidget(grp_2);
layout->addWidget(grp_3);
layout->addWidget(grp_4);
layout->addWidget(push);
layout->addStretch(10);
this->setLayout(layout);
delta=0;
}

void frmGroupTestWidget::doClick(void)
{
    if (lbltest3[0]->isVisible())
    {
        delta=this->height()-push->height()-push->y();
        for (int i=0;i<4;i++)
        {
        lbltest3[i]->setVisible(false);
        lentest3[i]->setVisible(false);
        }
        qApp->processEvents();
        delta-=this->height()-push->height()-push->y();
        qDebug() << "delta=" << delta;
        this->resize(this->width(),this->height()+delta);
    }
    else
    {
        for (int i=0;i<4;i++)
        {
        lbltest3[i]->setVisible(true);
        lentest3[i]->setVisible(true);
        }
        //this->resize(this->width(),this->height()-delta);
        qApp->processEvents();
    }
}


